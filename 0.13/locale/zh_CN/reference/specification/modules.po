msgid ""
msgstr ""
"Project-Id-Version: PRQL language book\n"
"POT-Creation-Date: 2026-01-10T16:14:11Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/reference/spec/modules.md:1
msgid "Modules"
msgstr ""

#: src/reference/spec/modules.md:3
msgid ""
"\\[!WARNING\\] The `module` facility is in discussion. This page documents "
"our understanding of the way the final PRQL compiler will likely work. The "
"PRQL compiler currently uses these techniques to compile the `std`, `date`, "
"`text`, and `math` modules into the language."
msgstr ""

#: src/reference/spec/modules.md:8
msgid ""
"However, at this time (Spring 2024), the `module` facility does not work "
"within a PRQL query itself. That is, a `module` statement in a query cannot "
"import files from the local file system."
msgstr ""

#: src/reference/spec/modules.md:12
msgid "Design goals for **modules**:"
msgstr ""

#: src/reference/spec/modules.md:14
msgid "Allow importing declarations from other files."
msgstr ""

#: src/reference/spec/modules.md:16
msgid "Have namespaces for things like `std`."
msgstr ""

#: src/reference/spec/modules.md:18
msgid "Have a hierarchical structure so we can represent files in directories."
msgstr ""

#: src/reference/spec/modules.md:20
msgid "Have an unambiguous module structure within a project."
msgstr ""

#: src/reference/spec/modules.md:22
msgid "Definition"
msgstr ""

#: src/reference/spec/modules.md:24
msgid ""
"A module is a namespace that contains declarations. A module is itself a "
"declaration, which means that it can contain nested child modules."
msgstr ""

#: src/reference/spec/modules.md:27
msgid ""
"This means that modules form a [tree graph](https://en.wikipedia.org/wiki/"
"Tree_(graph_theory)), which we call \"the module structure\"."
msgstr ""

#: src/reference/spec/modules.md:31
msgid ""
"For the sake of this document, we will express the module structure with "
"`module` keyword and a code block encased in curly braces:"
msgstr ""

#: src/reference/spec/modules.md:44
msgid ""
"The syntax `module name { ...decls... }` is not part of PRQL language, with "
"the objection that it is unnecessary as it only adds more ways of defining "
"modules. If a significant upside of this syntax is found, it may be added in "
"the future."
msgstr ""

#: src/reference/spec/modules.md:49
msgid "Name resolution"
msgstr ""

#: src/reference/spec/modules.md:51
msgid ""
"Any declarations within a module can be referenced from the outside of the "
"module:"
msgstr ""

#: src/reference/spec/modules.md:63
msgid "Identifiers are resolved relative to current module."
msgstr ""

#: src/reference/spec/modules.md:76
msgid ""
"If an identifier cannot be resolved relative to the current module, it tries "
"to resolve relative to the parent module. This is repeated, stepping up the "
"module hierarchy until a match is found or root of the module structure is "
"reached."
msgstr ""

#: src/reference/spec/modules.md:96
msgid "Main var declaration"
msgstr ""

#: src/reference/spec/modules.md:98
msgid ""
"The final variable declaration in a module can omit the leading `let main =` "
"and acquire an implicit name main."
msgstr ""

#: src/reference/spec/modules.md:111
msgid ""
"When a module is referenced as a value, the `main` variable is used instead. "
"This is especially useful when referring to a module which is to be compiled "
"to RQ (and later SQL)."
msgstr ""

#: src/reference/spec/modules.md:120
msgid "File importing"
msgstr ""

#: src/reference/spec/modules.md:122 src/reference/spec/modules.md:274
msgid ""
"\\[!WARNING\\] The examples below do **not** work. At this time (Spring "
"2024), the `module` facility does not work within a PRQL query itself. That "
"is, a `module` statement in a query cannot import files from the local file "
"system."
msgstr ""

#: src/reference/spec/modules.md:126
msgid ""
"To include PRQL source code from other files, we can use the following "
"syntax:"
msgstr ""

#: src/reference/spec/modules.md:132
msgid ""
"This loads either `./my_playlists.prql` (a leaf module) or `./my_playlists/"
"_my_playlists.prql` (a directory module) and uses its contents as module "
"`my_playlists`. If none or both of the files are present, a compilation "
"error is raised."
msgstr ""

#: src/reference/spec/modules.md:137
msgid ""
"Only directory modules can contain module declarations. If a leaf module "
"contains a module declaration, a compilation error is raised, suggesting the "
"leaf module to be converted into a directory module. This is a step toward "
"any module structure having a single \"normalized\" representation in the "
"file system. Such normalization is desired because it restrains the possible "
"file system layouts to a comprehensible and predictable layout, while not "
"sacrificing any functionality."
msgstr ""

#: src/reference/spec/modules.md:145
msgid ""
"Described importing rules don't achieve this \"single normalized "
"representation\" in full, since any leaf modules could be replaced by a "
"directory module with zero submodules, without any semantic changes. "
"Restricting directory modules to have at least one sub-module would not "
"improve approachability enough to justify adding this restriction."
msgstr ""

#: src/reference/spec/modules.md:151
msgid ""
"For example, the following module structure is annotated with files names in "
"which the modules would reside:"
msgstr ""

#: src/reference/spec/modules.md:177
msgid ""
"If module `my_project.sales` wants to add a submodule `util`, it has to be "
"converted to a directory modules. This means that it has to be moved to "
"`sales/_sales.prql`. The new module would reside in `sales/util.prql`."
msgstr ""

#: src/reference/spec/modules.md:181
msgid ""
"The annotated layout is not the only possible layout for this module "
"structure, since any of the modules `sales`, `year_2023` or `year_2024` "
"could be converted into a directory module with zero sub-modules."
msgstr ""

#: src/reference/spec/modules.md:185
msgid ""
"Point 4 of design goals means that each declaration within a project has a "
"single fully-qualified name within this project. This is ensured by strict "
"rules regarding importing files and the fact that the module structure is a "
"tree."
msgstr ""

#: src/reference/spec/modules.md:189
msgid "Declaration order"
msgstr ""

#: src/reference/spec/modules.md:191
msgid ""
"The order of declarations in a module holds no semantic value, except the "
"\"last `main` variable\"."
msgstr ""

#: src/reference/spec/modules.md:194
msgid "References between modules can be cyclic."
msgstr ""

#: src/reference/spec/modules.md:206
msgid "References between variable declarations cannot be cyclic."
msgstr ""

#: src/reference/spec/modules.md:222
msgid "Compiler interface"
msgstr ""

#: src/reference/spec/modules.md:224
msgid "`prqlc` provides two interfaces for compiling files."
msgstr ""

#: src/reference/spec/modules.md:226
msgid "**Multi-file interface** requires three arguments:"
msgstr ""

#: src/reference/spec/modules.md:228
msgid ""
"path to the file containing the module which is the root of the module "
"structure,"
msgstr ""

#: src/reference/spec/modules.md:230
msgid ""
"identifier of the pipeline that should be compiled to RQ (this can also be "
"an identifier of a module that has a `main` pipeline) and,"
msgstr ""

#: src/reference/spec/modules.md:232
msgid "a \"file loader\", which can load files on-demand."
msgstr ""

#: src/reference/spec/modules.md:234
msgid ""
"The path to the root module can be automatically detected by searching for `."
"prql` files starting with `_` in the current working directory."
msgstr ""

#: src/reference/spec/modules.md:237
msgid "Example prqlc usage:"
msgstr ""

#: src/reference/spec/modules.md:244
msgid ""
"**Single-file interface** requires a single argument; the PRQL source. Any "
"attempts to load modules in this mode result in compilation errors. This "
"interface is needed, for example, when integrating the compiler with a "
"database connector (i.e. JDBC) where no other files can be loaded."
msgstr ""

#: src/reference/spec/modules.md:249
msgid "Built-in module structure"
msgstr ""

#: src/reference/spec/modules.md:251
msgid "As noted above, this facility is in discussion."
msgstr ""

#: src/reference/spec/modules.md:272
msgid "Example"
msgstr ""

#: src/reference/spec/modules.md:278
msgid ""
"This is an example project, where each of code block is a separate file."
msgstr ""

#: src/reference/spec/modules.md:333
msgid "Sources:"
msgstr ""

#: src/reference/spec/modules.md:335
msgid ""
"[Notes On Module System](https://matklad.github.io/2021/11/27/notes-on-"
"module-system.html), by @matklad."
msgstr ""
