msgid ""
msgstr ""
"Project-Id-Version: PRQL language book\n"
"POT-Creation-Date: 2026-01-10T16:14:11Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/reference/stdlib/index.md:1
msgid "Standard library"
msgstr ""

#: src/reference/stdlib/index.md:3
msgid ""
"The standard library currently contains commonly used functions that are "
"used in SQL. It's not yet as broad as we'd like, and we're very open to "
"expanding it."
msgstr ""

#: src/reference/stdlib/index.md:6
msgid ""
"Currently s-strings are an escape-hatch for any function that isn't in our "
"standard library. If we find ourselves using them for something frequently, "
"raise an issue and we'll add it to the stdlib."
msgstr ""

#: src/reference/stdlib/index.md:10
msgid ""
"Here's the source of the current [PRQL `std`](https://github.com/PRQL/prql/"
"blob/main/prqlc/prqlc/src/semantic/std.prql):"
msgstr ""

#: src/reference/stdlib/index.md:13
msgid ""
"\\[!NOTE\\] PRQL 0.9.0 has started supporting different DB implementations "
"for standard library functions. The source is the [`std.sql`](https://github."
"com/PRQL/prql/blob/main/prqlc/prqlc/src/sql/std.sql.prql)."
msgstr ""

#: src/reference/stdlib/index.md:17
msgid ""
"````prql no-eval\n"
"# The PRQL standard library defines the following functions and transforms.\n"
"# The definitions are whitespace insensitive, and have this form:\n"
"#\n"
"# ```\n"
"# let my_func = param1 param2 ...  -> <return_type> body_expr\n"
"# ```\n"
"#\n"
"# Where:\n"
"#   * `my_func` is the name of the function\n"
"#   * `param1` is the first parameter optionally followed by a type in "
"\"< ... >\"\n"
"#   * `param2` etc. follow the same pattern as param1\n"
"#   * `<return_type>` is the type of result wrapped in \"< ... >\"\n"
"#   * `body_expr` defines the function body that creates the result.\n"
"#     It can be PRQL code or `internal ...` to indicate internal compiler "
"code.\n"
"\n"
"# Operators\n"
"\n"
"let mul = left right -> internal std.mul\n"
"let div_i = left right -> internal std.div_i\n"
"let div_f = left right -> internal std.div_f\n"
"let mod = left right -> internal std.mod\n"
"let add = left right -> internal std.add\n"
"let sub = left right -> internal std.sub\n"
"let eq = left right -> <bool> internal std.eq\n"
"let ne = left right -> <bool> internal std.ne\n"
"let gt = left right -> <bool> internal std.gt\n"
"let lt = left right -> <bool> internal std.lt\n"
"let gte = left right -> <bool> internal std.gte\n"
"let lte = left right -> <bool> internal std.lte\n"
"let and = left<bool> right<bool> -> <bool> internal std.and\n"
"let or = left<bool> right<bool> -> <bool> internal std.or\n"
"let coalesce = left right -> internal std.coalesce\n"
"let regex_search = text pattern -> <bool> internal std.regex_search\n"
"\n"
"let neg = expr -> internal std.neg\n"
"let not = expr<bool> -> <bool> internal std.not\n"
"\n"
"# Types\n"
"\n"
"## Type primitives\n"
"type int = int\n"
"type float = float\n"
"type bool = bool\n"
"type text = text\n"
"type date = date\n"
"type time = time\n"
"type timestamp = timestamp\n"
"type `func` = func\n"
"\n"
"## Generic array\n"
"type array = []\n"
"\n"
"## Generic relation\n"
"type relation = [{..}]\n"
"\n"
"## Range\n"
"type range = {start = *, end = *}\n"
"\n"
"## Transform\n"
"type transform = func relation -> relation\n"
"\n"
"# Functions\n"
"\n"
"## Relational transforms\n"
"let from = func\n"
"  `default_db.source` <relation>\n"
"  -> <relation> source\n"
"\n"
"let select = func\n"
"  columns\n"
"  tbl <relation>\n"
"  -> <relation> internal select\n"
"\n"
"let filter = func\n"
"  condition <bool>\n"
"  tbl <relation>\n"
"  -> <relation> internal filter\n"
"\n"
"let derive = func\n"
"  columns\n"
"  tbl <relation>\n"
"  -> <relation> internal derive\n"
"\n"
"let aggregate = func\n"
"  columns\n"
"  tbl <relation>\n"
"  -> <relation> internal aggregate\n"
"\n"
"let sort = func\n"
"  by\n"
"  tbl <relation>\n"
"  -> <relation> internal sort\n"
"\n"
"let take = func\n"
"  expr\n"
"  tbl <relation>\n"
"  -> <relation> internal take\n"
"\n"
"let join = func\n"
"  `default_db.with` <relation>\n"
"  condition <bool>\n"
"  `noresolve.side`:inner\n"
"  tbl <relation>\n"
"  -> <relation> internal join\n"
"\n"
"let group = func\n"
"  by\n"
"  pipeline <transform>\n"
"  tbl <relation>\n"
"  -> <relation> internal group\n"
"\n"
"let window = func\n"
"  rows:0..-1\n"
"  range:0..-1\n"
"  expanding <bool>:false\n"
"  rolling <int>:0\n"
"  pipeline <transform>\n"
"  tbl <relation>\n"
"  -> <relation> internal window\n"
"\n"
"let append = `default_db.bottom`<relation> top<relation> -> <relation> "
"internal append\n"
"let intersect = `default_db.bottom`<relation> top<relation> -> <relation> (\n"
"  t = top\n"
"  join (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b.*)))\n"
"  select t.*\n"
")\n"
"let remove = `default_db.bottom`<relation> top<relation> -> <relation> (\n"
"  t = top\n"
"  join side:left (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b."
"*)))\n"
"  filter (tuple_every (tuple_map _is_null b.*))\n"
"  select t.*\n"
")\n"
"let loop = func\n"
"  pipeline <transform>\n"
"  top <relation>\n"
"  -> <relation> internal loop\n"
"\n"
"## Aggregate functions\n"
"# These return either a scalar when used within `aggregate`, or a column "
"when used anywhere else.\n"
"\n"
"let min = column <array> -> internal std.min\n"
"\n"
"let max = column <array> -> internal std.max\n"
"\n"
"let sum = column <array> -> internal std.sum\n"
"\n"
"let average = column <array> -> internal std.average\n"
"\n"
"let stddev = column <array> -> internal std.stddev\n"
"\n"
"let all = column <array> -> <bool> internal std.all\n"
"\n"
"let any = column <array> -> <bool> internal std.any\n"
"\n"
"let concat_array = column <array> -> <text> internal std.concat_array\n"
"\n"
"# Counts number of items in the column.\n"
"# Note that the count will include null values.\n"
"let count = column <array> -> <int> internal count\n"
"\n"
"# Deprecated in favour of filtering input to the [std.count] function (not "
"yet implemented).\n"
"@{deprecated}\n"
"let count_distinct = column <array> -> internal std.count_distinct\n"
"\n"
"## Window functions\n"
"let lag =   offset <int>    column <array> -> internal std.lag\n"
"let lead =  offset <int>    column <array> -> internal std.lead\n"
"let first      = column <array> -> internal std.first\n"
"let last       = column <array> -> internal std.last\n"
"let rank       = column <array> -> internal std.rank\n"
"let rank_dense = column <array> -> internal std.rank_dense\n"
"let row_number = column <array> -> internal row_number\n"
"\n"
"# Mathematical functions\n"
"module math {\n"
"  let abs = column -> internal std.math.abs\n"
"  let floor = column -> <int> internal std.math.floor\n"
"  let ceil = column -> <int> internal std.math.ceil\n"
"  let pi = -> <float> internal std.math.pi\n"
"  let exp = column -> internal std.math.exp\n"
"  let ln = column -> internal std.math.ln\n"
"  let log10 = column -> internal std.math.log10\n"
"  let log = func base column -> internal std.math.log\n"
"  let sqrt = column -> internal std.math.sqrt\n"
"  let degrees = column -> internal std.math.degrees\n"
"  let radians = column -> internal std.math.radians\n"
"  let cos = column -> internal std.math.cos\n"
"  let acos = column -> internal std.math.acos\n"
"  let sin = column -> internal std.math.sin\n"
"  let asin = column -> internal std.math.asin\n"
"  let tan = column -> internal std.math.tan\n"
"  let atan = column -> internal std.math.atan\n"
"  let pow = exponent column -> internal std.math.pow\n"
"  let round = n_digits column -> internal std.math.round\n"
"}\n"
"\n"
"## Misc functions\n"
"let as = `noresolve.type` column -> internal std.as\n"
"let in = pattern value -> <bool> internal in\n"
"\n"
"## Tuple functions\n"
"let tuple_every = func list -> <bool> internal tuple_every\n"
"let tuple_map = func fn <func> list -> internal tuple_map\n"
"let tuple_zip = func a b -> internal tuple_zip\n"
"let _eq = func a -> internal _eq\n"
"let _is_null = func a -> _param.a == null\n"
"\n"
"## Misc\n"
"let from_text = input<text> `noresolve.format`:csv -> <relation> internal "
"from_text\n"
"\n"
"## Text functions\n"
"module text {\n"
"  let lower = column -> <text> internal std.text.lower\n"
"  let upper = column -> <text> internal std.text.upper\n"
"  let ltrim = column -> <text> internal std.text.ltrim\n"
"  let rtrim = column -> <text> internal std.text.rtrim\n"
"  let trim = column -> <text> internal std.text.trim\n"
"  let length = column -> <int> internal std.text.length\n"
"  let extract = offset<int> length<int> column -> <text> internal std.text."
"extract\n"
"  let replace = pattern<text> replacement<text> column -> <text> internal "
"std.text.replace\n"
"  let starts_with = prefix<text> column -> <bool> internal std.text."
"starts_with\n"
"  let contains = substr<text> column -> <bool> internal std.text.contains\n"
"  let ends_with = suffix<text> column -> <bool> internal std.text.ends_with\n"
"}\n"
"\n"
"## Date functions\n"
"module date {\n"
"  let to_text = format<text> column -> <text> internal std.date.to_text\n"
"}\n"
"\n"
"## File-reading functions, primarily for DuckDB\n"
"let read_parquet = func\n"
"  source <text>\n"
"  binary_as_string <bool>:false\n"
"  file_row_number <bool>:false\n"
"  hive_partitioning <bool>:null\n"
"  union_by_name <bool>:false\n"
"  -> <relation> internal std.read_parquet\n"
"let read_csv = source<text> -> <relation> internal std.read_csv\n"
"let read_json = source<text> -> <relation> internal std.read_json\n"
"\n"
"\n"
"## PRQL compiler functions\n"
"module `prql` {\n"
"  let version = -> <text> internal prql_version\n"
"}\n"
"\n"
"# Deprecated, will be removed in 0.12.0\n"
"let prql_version = -> <text> internal prql_version\n"
"````"
msgstr ""

#: src/reference/stdlib/index.md:269
msgid "And a couple of examples:"
msgstr ""

#: src/reference/stdlib/index.md:271
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = (salary + payroll_tax | as int),\n"
"  gross_salary_rounded = (gross_salary | math.round 0),\n"
"  time = s\"NOW()\",  # an s-string, given no `now` function exists in PRQL\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:280
msgid "Example of different implementations of division and integer division:"
msgstr ""

#: src/reference/stdlib/index.md:282
msgid ""
"```prql\n"
"prql target:sql.sqlite\n"
"\n"
"from [{x = 13, y = 5}]\n"
"select {\n"
"  quotient = x / y,\n"
"  int_quotient = x // y,\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:292
msgid ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from [{x = 13, y = 5}]\n"
"select {\n"
"  quotient = x / y,\n"
"  int_quotient = x // y,\n"
"}\n"
"```"
msgstr ""
