<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PRQL language book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="Modern language for transforming data ‚Äî a simple, powerful, pipelined SQL replacement">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="comparison-table.css">
        <link rel="stylesheet" href="mdbook-admonish.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PRQL language book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/PRQL/prql" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="prql-language-book"><a class="header" href="#prql-language-book">PRQL language book</a></h1>
<p><strong>P</strong>ipelined <strong>R</strong>elational <strong>Q</strong>uery <strong>L</strong>anguage, pronounced ‚ÄúPrequel‚Äù.</p>
<p>PRQL is a modern language for transforming data ‚Äî a simple, powerful, pipelined SQL replacement. Like SQL, it‚Äôs readable, explicit and declarative. Unlike SQL, it forms a logical pipeline of transformations, and supports abstractions such as variables and functions. It can be used with any database that uses SQL, since it compiles to SQL.</p>
<p>This book serves as a tutorial and reference guide on the language and the broader project. It currently has three sections, navigated by links on the left:</p>
<ul>
<li><strong>Tutorial</strong> ‚Äî A friendly &amp; accessible guide for learning PRQL. It has a gradual increase of difficulty and requires only basic understanding of programming languages. Knowledge of SQL is beneficial, because of many comparisons to SQL, but not required.</li>
<li><strong>Reference</strong> ‚Äî In-depth information about the PRQL language. Includes justifications for language design decisions and formal specifications for parts of the language.</li>
<li><strong>Project</strong> ‚Äî¬†General information about the project, tooling and development.</li>
</ul>
<hr />
<p>To lead with a couple of examples, with a comparison to SQL: the language can be as simple as:</p>
<div class="comparison">
<div>
<h4 id="prql"><a class="header" href="#prql">PRQL</a></h4>
<pre><code class="language-prql">from tracks
filter artist == "Bob Marley"                 # Each line transforms the previous result
aggregate {                                   # `aggregate` reduces each column to a value
  plays    = sum plays,
  longest  = max length,
  shortest = min length,                      # Trailing commas are allowed
}
</code></pre>
</div>
<div>
<h4 id="sql"><a class="header" href="#sql">SQL</a></h4>
<pre><code class="language-sql">SELECT
  COALESCE(SUM(plays), 0) AS plays,
  MAX(length) AS longest,
  MIN(length) AS shortest
FROM
  tracks
WHERE
  artist = 'Bob Marley'

</code></pre>
</div>
</div>
<p>‚Ä¶and here‚Äôs a fuller example:</p>
<div class="comparison">
<div>
<h4 id="prql-1"><a class="header" href="#prql-1">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter start_date &gt; @2021-01-01               # Clear date syntax
derive {                                      # `derive` adds columns / variables
  gross_salary = salary + (tax ?? 0),         # Terse coalesce
  gross_cost = gross_salary + benefits_cost,  # Variables can use other variables
}
filter gross_cost &gt; 0
group {title, country} (                      # `group` runs a pipeline over each group
  aggregate {                                 # `aggregate` reduces each group to a value
    average gross_salary,
    sum_gross_cost = sum gross_cost,          # `=` sets a column name
  }
)
filter sum_gross_cost &gt; 100_000               # `filter` replaces both of SQL's `WHERE` &amp; `HAVING`
derive id = f"{title}_{country}"              # F-strings like Python
derive country_code = s"LEFT(country, 2)"     # S-strings allow using SQL as an escape hatch
sort {sum_gross_cost, -country}               # `-country` means descending order
take 1..20                                    # Range expressions (also valid here as `take 20`)
</code></pre>
</div>
<div>
<h4 id="sql-1"><a class="header" href="#sql-1">SQL</a></h4>
<pre><code class="language-sql">WITH table_1 AS (
  SELECT
    title,
    country,
    salary + COALESCE(tax, 0) + benefits_cost AS _expr_1,
    salary + COALESCE(tax, 0) AS _expr_2
  FROM
    employees
  WHERE
    start_date &gt; DATE '2021-01-01'
),
table_0 AS (
  SELECT
    title,
    country,
    AVG(_expr_2) AS _expr_0,
    COALESCE(SUM(_expr_1), 0) AS sum_gross_cost
  FROM
    table_1
  WHERE
    _expr_1 &gt; 0
  GROUP BY
    title,
    country
)
SELECT
  title,
  country,
  _expr_0,
  sum_gross_cost,
  CONCAT(title, '_', country) AS id,
  LEFT(country, 2) AS country_code
FROM
  table_0
WHERE
  sum_gross_cost &gt; 100000
ORDER BY
  sum_gross_cost,
  country DESC
LIMIT
  20

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relations"><a class="header" href="#relations">Relations</a></h1>
<p>PRQL is designed on top of <em>relational algebra</em>, which is the established data model used by modern SQL databases. A <em>relation</em> has a rigid mathematical definition, which can be simplified to ‚Äúa table of data‚Äù. For example, the <code>invoices</code> table from the Chinook database (<a href="https://github.com/lerocha/chinook-database">https://github.com/lerocha/chinook-database</a>) looks like this:</p>
<div class="table-wrapper"><table><thead><tr><th>invoice_id</th><th>customer_id</th><th>billing_city</th><th style="text-align: center"><em>other columns</em></th><th>total</th></tr></thead><tbody>
<tr><td>1</td><td>2</td><td>Stuttgart</td><td style="text-align: center">‚Ä¶</td><td>1.98</td></tr>
<tr><td>2</td><td>4</td><td>Oslo</td><td style="text-align: center">‚Ä¶</td><td>3.96</td></tr>
<tr><td>3</td><td>8</td><td>Brussels</td><td style="text-align: center">‚Ä¶</td><td>5.94</td></tr>
<tr><td>4</td><td>14</td><td>Edmonton</td><td style="text-align: center">‚Ä¶</td><td>8.91</td></tr>
<tr><td>5</td><td>23</td><td>Boston</td><td style="text-align: center">‚Ä¶</td><td>13.86</td></tr>
<tr><td>6</td><td>37</td><td>Frankfurt</td><td style="text-align: center">‚Ä¶</td><td>0.99</td></tr>
</tbody></table>
</div>
<p>A relation is composed of rows. Each row in a relation contains a value for each of the relation‚Äôs columns. Each column in a relation has an unique name and a designated data type. The table above is a relation, and has columns named <code>invoice_id</code>and <code>customer_id</code> each with a data type of ‚Äúinteger number‚Äù, a <code>billing_city</code> column with a data type of ‚Äútext‚Äù, several other columns, and a <code>total</code> column that contains floating-point numbers.</p>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>The main purpose of PRQL is to build queries that combine and transform data from relations such as the <code>invoices</code> table above. Here is the most basic query:</p>
<pre><code class="language-prql no-eval">from invoices
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="tutorial/relations.html#admonition-note"></a>
</div>
<div>
<p>Try each of these examples here in the <a href="https://prql-lang.org/playground/">Playground.</a> Enter the query on the left-hand side, and click <strong>output.arrow</strong> in the right-hand side to see the result.</p>
</div>
</div>
<p>The result of the query above is not terribly interesting, it‚Äôs just the same relation as before.</p>
<h3 id="select-transform"><a class="header" href="#select-transform"><code>select</code> transform</a></h3>
<p>The <code>select</code> function picks the columns to pass through based on a list and discards all others. Formally, that list is a <em>tuple</em> of comma-separated expressions wrapped in <code>{ ... }</code>.</p>
<p>Suppose we only need the <code>order_id</code> and <code>total</code> columns. Use <code>select</code> to choose the columns to pass through. <em>(Try it in the <a href="https://prql-lang.org/playground/">Playground.</a>)</em></p>
<pre><code class="language-prql no-eval">from invoices
select { order_id, total }
</code></pre>
<p>We can write the items in the tuple on one or several lines: trailing commas are ignored. In addition, we can assign any of the expressions to a <em>variable</em> that becomes the name of the resulting column in the SQL output.</p>
<pre><code class="language-prql no-eval">from invoices
select {
  OrderID = invoice_id,
  Total = total,
}
</code></pre>
<p>This is the same query as above, rewritten on multiple lines, and assigning <code>OrderID</code> and <code>Total</code> names to the columns.</p>
<p>Once we <code>select</code> certain columns, subsequent transforms will have access only to those columns named in the tuple.</p>
<h3 id="derive-transform"><a class="header" href="#derive-transform"><code>derive</code> transform</a></h3>
<p>To add columns to a relation, we can use <code>derive</code> function. Let‚Äôs define a new column for Value Added Tax, set at 19% of the invoice total.</p>
<pre><code class="language-prql no-eval">from invoices
derive { VAT = total * 0.19 }
</code></pre>
<!-- todo: make sure that the new column is unnamed -->
<p>The value of the new column can be a constant (such as a number or a string), or can be computed from the value of an existing column. Note that the value of the new column is assigned the name <code>VAT</code>.</p>
<h3 id="join-transform"><a class="header" href="#join-transform"><code>join</code> transform</a></h3>
<p>The <code>join</code> transform also adds columns to the relation by combining the rows from two relations ‚Äúside by side‚Äù. To determine which rows from each relation should be joined, <code>join</code> has match criteria, written in <code>( ... )</code>.</p>
<pre><code class="language-prql no-eval">from invoices
join customers ( ==customer_id )
</code></pre>
<p>This example ‚Äúconnects‚Äù the customer information from the <code>customers</code> relation with the information from the <code>invoices</code> relation, using identical values of the <code>customer_id</code> column from each relation to match the rows.</p>
<p>It is frequently useful to assign an alias to both relations being joined together so that each relation‚Äôs columns can be referred to uniquely.</p>
<pre><code class="language-prql no-eval">from inv=invoices
join cust=customers ( ==customer_id )
</code></pre>
<p>In the example above, the alias <code>inv</code> represents the <code>invoices</code> relation and <code>cust</code> represents the <code>customers</code> relation. It then becomes possible to refer to <code>inv.billing_city</code> and <code>cust.last_name</code> unambiguously.</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>PRQL manipulates relations (tables) of data. The <code>derive</code>, <code>select</code>, and <code>join</code> transforms change the number of columns in a table. The first two never affect the number of rows in a table. <code>join</code> may change the number of rows, depending on the variation chosen.</p>
<p>This final example combines the above into a single query. It illustrates <em>a pipeline</em> - the fundamental basis of PRQL. We simply add new lines (transforms) at the end of the query. Each transform modifies the relation produced by the statement above to produce the desired result.</p>
<pre><code class="language-prql no-eval">from inv=invoices
join cust=customers (==customer_id)
derive { VAT = inv.total * 0.19 }
select {
  OrderID = inv.invoice_id,
  CustomerName = cust.last_name,
  Total = inv.total,
  VAT,
}
</code></pre>
<!-- PRQL uses the data from... _Where does our data come from? Do we use some canonical version?_ -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="filtering-rows"><a class="header" href="#filtering-rows">Filtering rows</a></h1>
<p>In the previous page we learned how <code>select</code>, <code>derive</code>, and <code>join</code> change the columns of a table.</p>
<p>Now we will explore how to manipulate the rows of a table using <code>filter</code> and <code>take</code>.</p>
<h3 id="filter-transform"><a class="header" href="#filter-transform"><code>filter</code> transform</a></h3>
<p>The <code>filter</code> transform picks rows to pass through based on their values:</p>
<pre><code class="language-prql no-eval">from invoices
filter billing_city == "Berlin"
</code></pre>
<p>The resulting table contains all the rows that came from Berlin.</p>
<p>PRQL converts the single <code>filter</code> transform to use the appropriate SQL <code>WHERE</code> or <code>HAVING</code> command, depending on where it appears in the pipeline.</p>
<h3 id="take-transform"><a class="header" href="#take-transform"><code>take</code> transform</a></h3>
<p>The <code>take</code> transform picks rows to pass through based on their position within the table. The set of rows picked can be specified in two ways:</p>
<ul>
<li>a plain number <code>x</code>, which will pick the first <code>x</code> rows, or</li>
<li>an inclusive range of rows <code>start..end</code>.</li>
</ul>
<pre><code class="language-prql no-eval">from invoices
take 4
</code></pre>
<pre><code class="language-prql no-eval">from invoices
take 4..7
</code></pre>
<p>Of course, it is possible combine all these transforms into a single pipeline:</p>
<pre><code class="language-prql no-eval">from invoices

# retain only rows for orders from Berlin
filter billing_city == "Berlin"

# skip first 10 rows and take the next 10
take 11..20

# take only first 3 rows of *that* result
take 3
</code></pre>
<p>We did something a bit odd at the end: first we took rows <code>11..20</code> and then took the first 3 rows from that result.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="tutorial/filtering.html#admonition-note"></a>
</div>
<div>
<p>Note that a single transform <code>take 11..13</code> would have produced the same SQL. The example serves an example of how PRQL allows fast data exploration by ‚Äústacking‚Äù transforms in the pipeline, reducing the cognitive burden of how a new transform with the previous query.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregation"><a class="header" href="#aggregation">Aggregation</a></h1>
<p>A key feature of analytics is reducing many values down to some summary. This act is called ‚Äúaggregation‚Äù and always includes a function ‚Äî for example, <code>average</code> or <code>sum</code> ‚Äî that reduces values in the table to a single row.</p>
<h3 id="aggregate-transform"><a class="header" href="#aggregate-transform"><code>aggregate</code> transform</a></h3>
<p>The <code>aggregate</code> transform takes a tuple to create one or more new columns that ‚Äúdistill down‚Äù data from all the rows.</p>
<pre><code class="language-prql no-eval">from invoices
aggregate { sum_of_orders = sum total }
</code></pre>
<p>The query above computes the sum of the <code>total</code> column of all rows of the <code>invoices</code> table to produce a single value.</p>
<p><code>aggregate</code> can produce multiple summaries at once when one or more aggregation expressions are contained in a tuple. <code>aggregate</code> discards all columns that are not present in the tuple.</p>
<pre><code class="language-prql no-eval">from invoices
aggregate {
    num_orders = count this,
    sum_of_orders = sum total,
}
</code></pre>
<p>In the example above, the result is a single row with two columns. The <code>count</code> function displays the number of rows in the table that was passed in; the <code>sum</code> function adds up the values of the <code>total</code> column of all rows.</p>
<h2 id="grouping"><a class="header" href="#grouping">Grouping</a></h2>
<p>Suppose we want to produce summaries of invoices <em>for each city</em> in the table. We could create a query for each city, and aggregate its rows:</p>
<pre><code class="language-prql no-eval">from albums
filter billing_city == "Oslo"
aggregate { sum_of_orders = sum total }
</code></pre>
<p>But we would need to do it for each city: <code>London</code>, <code>Frankfurt</code>, etc. Of course this is repetitive (and boring) and error prone (because we would need to type each <code>billing_city</code> by hand). Moreover, we would need to create a list of each <code>billing_city</code> before we started.</p>
<h3 id="group-transform"><a class="header" href="#group-transform"><code>group</code> transform</a></h3>
<p>The <code>group</code> transform separates the table into groups (say, those having the same city) using information that‚Äôs already in the table. It then applies a transform to each group, and combines the results back together:</p>
<pre><code class="language-prql no-eval">from invoices
group billing_city (
    aggregate {
        num_orders = count this,
        sum_of_orders = sum total,
    }
)
</code></pre>
<p>Those familiar with SQL have probably noticed that we just decoupled aggregation from grouping.</p>
<p>Although these operations are connected in SQL, PRQL makes it straightforward to use <code>group</code> and <code>aggregate</code> separate from each other, while combining with other transform functions, such as:</p>
<pre><code class="language-prql no-eval">from invoices
group billing_city (
    take 2
)
</code></pre>
<p>This code collects the first two rows for each city‚Äôs <code>group</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<p>A summary of PRQL syntax:</p>
<!-- markdownlint-disable MD033 ‚Äî the `|` characters need to be escaped, and surrounded with tags rather than backticks   -->
<!-- I can't seem to get "Quoted identifies" to work without a space between the backticks. VS Code will preview ` `` ` correctly, but not mdbook -->
<!-- TODO: assigns links to select, aliases to join, potentially we should have explicit sections for them?  -->
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Usage</th><th>Example</th></tr></thead><tbody>
<tr><td><code>|</code></td><td><a href="reference/syntax/./function-calls.html">Pipelines</a></td><td><code>from employees | select first_name</code></td></tr>
<tr><td><code>=</code></td><td><a href="reference/syntax/../declarations/variables.html">Assigns</a></td><td><code>from e = employees</code> <br> <code>derive total = (sum salary)</code></td></tr>
<tr><td><code>:</code></td><td><a href="reference/syntax/../declarations/functions.html">Named args &amp; parameters</a></td><td><code>interp low:0 1600 sat_score</code></td></tr>
<tr><td><code>{}</code></td><td><a href="reference/syntax/./tuples.html">Tuples</a></td><td><code>{id, false, total = 3}</code></td></tr>
<tr><td><code>[]</code></td><td><a href="reference/syntax/./arrays.html">Arrays</a></td><td><code>[1, 4, 3, 4]</code></td></tr>
<tr><td><code>!</code>,<code>&amp;&amp;</code>,<code>==</code>,<code>+</code></td><td><a href="reference/syntax/./operators.html">Operators</a></td><td><code>filter a == b + c || d &gt;= e</code></td></tr>
<tr><td><code>()</code></td><td><a href="reference/syntax/./operators.html#parentheses">Parentheses</a></td><td><code>derive celsius = (fht - 32) / 1.8</code></td></tr>
<tr><td><code>\</code></td><td><a href="reference/syntax/./operators.html#wrapping-lines">Line wrap</a></td><td><code>1 + 2 + 3 +</code><br><code>\ 4 + 5</code></td></tr>
<tr><td><code>1</code>,<code>100_000</code>,<code>5e10</code></td><td><a href="reference/syntax/./literals.html#numbers">Numbers</a></td><td><code>derive { huge = 5e10 * 10_000 }</code></td></tr>
<tr><td><code>''</code>,<code>""</code></td><td><a href="reference/syntax/./literals.html#strings">Strings</a></td><td><code>derive name = 'Mary'</code></td></tr>
<tr><td><code>true</code>,<code>false</code></td><td><a href="reference/syntax/./literals.html#booleans">Booleans</a></td><td><code>derive { Col1 = true }</code></td></tr>
<tr><td><code>null</code></td><td><a href="reference/syntax/./literals.html#null">Null</a></td><td><code>filter ( name != null )</code></td></tr>
<tr><td><code>@</code></td><td><a href="reference/syntax/./literals.html#date-and-time">Dates &amp; times</a></td><td><code>@2021-01-01</code></td></tr>
<tr><td><code>` `</code></td><td><a href="reference/syntax/./keywords.html#quoting">Quoted identifiers</a></td><td><code>select `first name` </code></td></tr>
<tr><td><code>#</code></td><td><a href="reference/syntax/./comments.html">Comments</a></td><td><code># A comment</code></td></tr>
<tr><td><code>==</code></td><td><a href="reference/syntax/../stdlib/transforms/join.html#self-equality-operator">Self-equality in <code>join</code></a></td><td><code>join s=salaries (==id)</code></td></tr>
<tr><td><code>-&gt;</code></td><td><a href="reference/syntax/../declarations/functions.html">Function definitions</a></td><td><code>let add = a b -&gt; a + b</code></td></tr>
<tr><td><code>=&gt;</code></td><td><a href="reference/syntax/./case.html">Case statement</a></td><td><code>case [a==1 =&gt; c, a==2 =&gt; d]</code></td></tr>
<tr><td><code>+</code>,<code>-</code></td><td><a href="reference/syntax/../stdlib/transforms/sort.html">Sort order</a></td><td><code>sort {-amount, +date}</code></td></tr>
<tr><td><code>??</code></td><td><a href="reference/syntax/./operators.html#coalesce">Coalesce</a></td><td><code>amount ?? 0</code></td></tr>
</tbody></table>
</div><!-- markdownlint-enable MD033 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="literals"><a class="header" href="#literals">Literals</a></h1>
<p>A literal is a constant value expression, with special syntax rules for each data type.</p>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p>Number literals can contain number characters as well as a period, underscores and char <code>e</code>.</p>
<p>If a number literal contains a dot or character <code>e</code>, it is treated as floating point number (or just <em>float</em>), otherwise it is treated as integer number.</p>
<p>Character <code>e</code> denotes <a href="https://en.wikipedia.org/wiki/Scientific_notation">‚Äúscientific notation‚Äù</a>, where the number after <code>e</code> is the exponent in 10-base.</p>
<p>Underscores are ignored, so they can be placed at arbitrary positions, but it is advised to use them as thousand separators.</p>
<p>Integers can, alternatively, be expressed using hexadecimal, octal or binary notation using these prefixes respectively: <code>0x</code>, <code>0o</code> or <code>0b</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-2"><a class="header" href="#prql-2">PRQL</a></h4>
<pre><code class="language-prql">from numbers
select {
    small = 1.000_000_1,
    big = 5_000_000,
    huge = 5e9,
    binary = 0x0011,
    hex = 0x80,
    octal = 0o777,
}
</code></pre>
</div>
<div>
<h4 id="sql-2"><a class="header" href="#sql-2">SQL</a></h4>
<pre><code class="language-sql">SELECT
  1.0000001 AS small,
  5000000 AS big,
  5000000000.0 AS huge,
  17 AS binary,
  128 AS hex,
  511 AS octal
FROM
  numbers

</code></pre>
</div>
</div>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>PRQL supports string literals and several other formats of strings. See the <a href="reference/syntax/./strings.html">Strings</a> page for more information.</p>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>Boolean values can be expressed with <code>true</code> or <code>false</code> keyword.</p>
<h2 id="null"><a class="header" href="#null">Null</a></h2>
<p>The null value can be expressed with <code>null</code> keyword. See also the discussion of how <a href="reference/syntax/../spec/null.html">PRQL handles nulls</a>.</p>
<h2 id="date-and-time"><a class="header" href="#date-and-time">Date and time</a></h2>
<p>Date and time literals are expressed with character <code>@</code>, followed by a string that encodes the date &amp; time.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/literals.html#admonition-note"></a>
</div>
<div>
<p>PRQL‚Äôs notation is designed to be less verbose than SQL‚Äôs <code>TIMESTAMP '2004-10-19 10:23:54'</code> and more explicit than SQL‚Äôs implicit option that just uses a string <code>'2004-10-19 10:23:54'</code>.</p>
</div>
</div>
<h3 id="dates"><a class="header" href="#dates">Dates</a></h3>
<p>Dates are represented by <code>@{yyyy-mm-dd}</code> ‚Äî a <code>@</code> followed by the date format.</p>
<div class="comparison">
<div>
<h4 id="prql-3"><a class="header" href="#prql-3">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive age_at_year_end = (@2022-12-31 - dob)
</code></pre>
</div>
<div>
<h4 id="sql-3"><a class="header" href="#sql-3">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  DATE '2022-12-31' - dob AS age_at_year_end
FROM
  employees

</code></pre>
</div>
</div>
<h3 id="times"><a class="header" href="#times">Times</a></h3>
<p>Times are represented by <code>@{HH:mm:ss.SSS¬±Z}</code> with any parts not supplied defaulting to zero. This includes the timezone, which is represented by <code>+HH:mm</code>, <code>-HH:mm</code> or <code>Z</code>. This is consistent with the ISO8601 time format.</p>
<div class="comparison">
<div>
<h4 id="prql-4"><a class="header" href="#prql-4">PRQL</a></h4>
<pre><code class="language-prql">from orders
derive should_have_shipped_today = (order_time &lt; @08:30)
</code></pre>
</div>
<div>
<h4 id="sql-4"><a class="header" href="#sql-4">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  order_time &lt; TIME '08:30' AS should_have_shipped_today
FROM
  orders

</code></pre>
</div>
</div>
<h3 id="timestamps"><a class="header" href="#timestamps">Timestamps</a></h3>
<p>Timestamps are represented by <code>@{yyyy-mm-ddTHH:mm:ss.SSS¬±Z}</code> / <code>@{date}T{time}</code>, with any time parts not supplied being rounded to zero, including the timezone, which is represented by <code>+HH:mm</code>, <code>-HH:mm</code> or <code>Z</code> (<code>:</code> is optional). This is¬†<code>@</code> followed by the ISO8601 datetime format, which uses <code>T</code> to separate date &amp; time.</p>
<div class="comparison">
<div>
<h4 id="prql-5"><a class="header" href="#prql-5">PRQL</a></h4>
<pre><code class="language-prql">from commits
derive first_prql_commit = @2020-01-01T13:19:55-08:00
derive first_prql_commit_utc = @2020-01-02T21:19:55Z
</code></pre>
</div>
<div>
<h4 id="sql-5"><a class="header" href="#sql-5">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  TIMESTAMP '2020-01-01T13:19:55-0800' AS first_prql_commit,
  TIMESTAMP '2020-01-02T21:19:55Z' AS first_prql_commit_utc
FROM
  commits

</code></pre>
</div>
</div>
<h3 id="durations"><a class="header" href="#durations">Durations</a></h3>
<p>Durations are represented by <code>{N}{periods}</code>, such as <code>2years</code> or <code>10minutes</code>, without a space.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/literals.html#admonition-note-1"></a>
</div>
<div>
<p>These aren‚Äôt the same as ISO8601, because we evaluated <code>P3Y6M4DT12H30M5S</code> to be difficult to understand, but we could support a simplified form if there‚Äôs demand for it. We don‚Äôt currently support compound expressions, for example <code>2years10months</code>, but most DBs will allow <code>2years + 10months</code>. Please raise an issue if this is inconvenient.</p>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-6"><a class="header" href="#prql-6">PRQL</a></h4>
<pre><code class="language-prql">from projects
derive first_check_in = start + 10days
</code></pre>
</div>
<div>
<h4 id="sql-6"><a class="header" href="#sql-6">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  "start" + INTERVAL 10 DAY AS first_check_in
FROM
  projects

</code></pre>
</div>
</div>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>Here‚Äôs a larger list of date and time examples:</p>
<ul>
<li><code>@20221231</code> is invalid ‚Äî it must contain full punctuation (<code>-</code> and <code>:</code>),</li>
<li><code>@2022-12-31</code> is a date</li>
<li><code>@2022-12</code> or <code>@2022</code> are invalid ‚Äî SQL can‚Äôt express a month, only a date</li>
<li><code>@16:54:32.123456</code> is a time</li>
<li><code>@16:54:32</code>, <code>@16:54</code>, <code>@16</code> are all allowed, expressing <code>@16:54:32.000000</code>, <code>@16:54:00.000000</code>, <code>@16:00:00.000000</code> respectively</li>
<li><code>@2022-12-31T16:54:32.123456</code> is a timestamp without timezone</li>
<li><code>@2022-12-31T16:54:32.123456Z</code> is a timestamp in UTC</li>
<li><code>@2022-12-31T16:54+02</code> is timestamp in UTC+2</li>
<li><code>@2022-12-31T16:54+02:00</code> and <code>@2022-12-31T16:54+02</code> are datetimes in UTC+2</li>
<li><code>@16:54+02</code> is invalid ‚Äî time is always local, so it cannot have a timezone</li>
<li><code>@2022-12-31+02</code> is invalid ‚Äî date is always local, so it cannot have a timezone</li>
</ul>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/literals.html#admonition-note-2"></a>
</div>
<div>
<p>Currently prqlc does not parse or validate any of the datetime strings and will pass them to the database engine without adjustment. This might be refined in the future to aid in compatibility across databases. We‚Äôll always support the canonical <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO8601</a> format described above.</p>
</div>
</div>
<h3 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h3>
<p>Datetimes (as a distinct datatype from the timestamps) are supported by some databases (e.g. MySql, BigQuery). With the addition of type casts, these could be represented by a timestamp cast to a datetime:</p>
<pre><code class="language-prql no-eval">derive pi_day = @2017-03-14T15:09:26.535898&lt;datetime&gt;
</code></pre>
<p>These are some examples we can then add:</p>
<ul>
<li><code>@2022-12-31T16:54&lt;datetime&gt;</code> is datetime without timezone</li>
<li><code>@2022-12-31&lt;datetime&gt;</code> is forbidden ‚Äî datetime must specify time</li>
<li><code>@16:54&lt;datetime&gt;</code> is forbidden ‚Äî datetime must specify date</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings-1"><a class="header" href="#strings-1">Strings</a></h1>
<p>String literals can use any matching odd number of either single or double quotes:</p>
<div class="comparison">
<div>
<h4 id="prql-7"><a class="header" href="#prql-7">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive {
  single        =   'hello world',
  double        =   "hello world",
  double_triple = """hello world""",
}
</code></pre>
</div>
<div>
<h4 id="sql-7"><a class="header" href="#sql-7">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  'hello world' AS single,
  'hello world' AS double,
  'hello world' AS double_triple
FROM
  artists

</code></pre>
</div>
</div>
<h2 id="quoting-and-escape-characters"><a class="header" href="#quoting-and-escape-characters">Quoting and escape characters</a></h2>
<p>To quote a string containing quote characters, use the ‚Äúother‚Äù type of quote, or use the escape character <code>\</code>, or use more quotes.</p>
<div class="comparison">
<div>
<h4 id="prql-8"><a class="header" href="#prql-8">PRQL</a></h4>
<pre><code class="language-prql">from artists
select {
  other   = '"hello world"',
  escaped = "\"hello world\"",
  triple  = """I said "hello world"!""",
}
</code></pre>
</div>
<div>
<h4 id="sql-8"><a class="header" href="#sql-8">SQL</a></h4>
<pre><code class="language-sql">SELECT
  '"hello world"' AS other,
  '"hello world"' AS escaped,
  'I said "hello world"!' AS triple
FROM
  artists

</code></pre>
</div>
</div>
<p>Strings can contain any escape character sequences defined by the <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">JSON standard</a>.</p>
<div class="comparison">
<div>
<h4 id="prql-9"><a class="header" href="#prql-9">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive escapes = "\tXYZ\n \\ "                            # tab (\t), "XYZ", newline (\n), " ", \, " "
derive world = "\u{0048}\u{0065}\u{006C}\u{006C}\u{006F}" # "Hello"
derive hex = "\x48\x65\x6C\x6C\x6F"                       # "Hello"
derive turtle = "\u{01F422}"                              # "üê¢"
</code></pre>
</div>
<div>
<h4 id="sql-9"><a class="header" href="#sql-9">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  '	XYZ
 \ ' AS escapes,
  'Hello' AS world,
  'Hello' AS hex,
  'üê¢' AS turtle
FROM
  artists

</code></pre>
</div>
</div>
<h2 id="other-string-formats"><a class="header" href="#other-string-formats">Other string formats</a></h2>
<ul>
<li><a href="reference/syntax/./f-strings.html"><strong>F-strings</strong></a> - Build up a new string from a set of columns or values.</li>
<li><a href="reference/syntax/./r-strings.html"><strong>R-strings</strong></a> - Include the raw characters of the string without any form of escaping.</li>
<li><a href="reference/syntax/./s-strings.html"><strong>S-strings</strong></a> - Insert SQL statements directly into the query. Use when PRQL doesn‚Äôt have an equivalent facility.</li>
</ul>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/strings.html#admonition-warning"></a>
</div>
<div>
<p>Currently PRQL allows multiline strings with either a single character or multiple character quotes. This may change for strings using a single character quote in future versions.</p>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/strings.html#admonition-note"></a>
</div>
<div>
<p>These escape rules specify how PRQL interprets escape characters when compiling strings to SQL, not necessarily how the database will interpret the string. Dialects interpret escape characters differently, and PRQL doesn‚Äôt currently account for these differences. Please open issues with any difficulties in the current implementation.</p>
</div>
</div>
<h2 id="escape-sequences"><a class="header" href="#escape-sequences">Escape sequences</a></h2>
<p>Unless an <code>r</code> prefix is present, escape sequences in string literals are interpreted according to rules similar to those used by Standard C. The recognized escape sequences are:</p>
<div class="table-wrapper"><table><thead><tr><th>Escape Sequence</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>\\</code></td><td>Backslash ()</td></tr>
<tr><td><code>\'</code></td><td>Single quote (‚Äô)</td></tr>
<tr><td><code>\"</code></td><td>Double quote (‚Äú)</td></tr>
<tr><td><code>\b</code></td><td>Backspace</td></tr>
<tr><td><code>\f</code></td><td>Formfeed</td></tr>
<tr><td><code>\n</code></td><td>ASCII Linefeed (LF)</td></tr>
<tr><td><code>\r</code></td><td>ASCII Carriage Return (CR)</td></tr>
<tr><td><code>\t</code></td><td>ASCII Horizontal Tab (TAB)</td></tr>
<tr><td><code>\xhh</code></td><td>Character with hex value hh</td></tr>
<tr><td><code>\u{xxxx}</code></td><td>Character with hex value xxxx</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="f-strings"><a class="header" href="#f-strings">F-strings</a></h1>
<p>F-strings are a readable approach to building new strings from existing strings &amp; variables.</p>
<div class="comparison">
<div>
<h4 id="prql-10"><a class="header" href="#prql-10">PRQL</a></h4>
<pre><code class="language-prql">from employees
select full_name = f"{first_name} {last_name}"
</code></pre>
</div>
<div>
<h4 id="sql-10"><a class="header" href="#sql-10">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS full_name
FROM
  employees

</code></pre>
</div>
</div>
<p>This can be much easier to read for longer strings, relative to the SQL approach:</p>
<div class="comparison">
<div>
<h4 id="prql-11"><a class="header" href="#prql-11">PRQL</a></h4>
<pre><code class="language-prql">from web
select url = f"http{tls}://www.{domain}.{tld}/{page}"
</code></pre>
</div>
<div>
<h4 id="sql-11"><a class="header" href="#sql-11">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(
    'http',
    tls,
    '://www.',
    domain,
    '.',
    tld,
    '/',
    page
  ) AS url
FROM
  web

</code></pre>
</div>
</div>
<p>Note that currently interpolations can only contain plain variable names and not whole expressions like Python, so this won‚Äôt work:</p>
<div class="comparison">
<div>
<h4 id="prql-12"><a class="header" href="#prql-12">PRQL</a></h4>
<pre><code class="language-prql">from tracks
select length_str = f"{length_seconds / 60} minutes"
</code></pre>
</div>
<div>
<h4 id="error"><a class="header" href="#error">Error</a></h4>
<pre><code class="hljs language-undefined">Error:
   ‚ï≠‚îÄ[:2:38]
   ‚îÇ
 2 ‚îÇ select length_str = f&quot;{length_seconds / 60} minutes&quot;
   ‚îÇ                                      ‚î¨
   ‚îÇ                                      ‚ï∞‚îÄ‚îÄ interpolated string expected one of &quot;.&quot;, &quot;:&quot; or &quot;}&quot;, but found &quot; &quot;
‚îÄ‚îÄ‚îÄ‚ïØ
</code></pre>
</div>
</div>
<h2 id="roadmap-1"><a class="header" href="#roadmap-1">Roadmap</a></h2>
<p>In the future, f-strings may incorporate string formatting such as datetimes, numbers, and padding. If there‚Äôs a feature that would be helpful, please <a href="https://github.com/PRQL/prql/issues/new/">post an issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="r-strings"><a class="header" href="#r-strings">R-strings</a></h1>
<p>R-strings handle escape characters without special treatment:</p>
<div class="comparison">
<div>
<h4 id="prql-13"><a class="header" href="#prql-13">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive normal_string =  "\\\t"   #  two characters - \ and tab (\t)
derive raw_string    = r"\\\t"   # four characters - \, \, \, and t
</code></pre>
</div>
<div>
<h4 id="sql-12"><a class="header" href="#sql-12">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  '\	' AS normal_string,
  '\\\t' AS raw_string
FROM
  artists

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="s-strings"><a class="header" href="#s-strings">S-strings</a></h1>
<p>An s-string inserts SQL directly, as an escape hatch when there‚Äôs something that PRQL doesn‚Äôt yet implement. For example, there‚Äôs a <code>version()</code> function in PostgreSQL that returns the PostgreSQL version, so if we want to use that, we use an s-string:</p>
<div class="comparison">
<div>
<h4 id="prql-14"><a class="header" href="#prql-14">PRQL</a></h4>
<pre><code class="language-prql">from my_table
select db_version = s"version()"
</code></pre>
</div>
<div>
<h4 id="sql-13"><a class="header" href="#sql-13">SQL</a></h4>
<pre><code class="language-sql">SELECT
  version() AS db_version
FROM
  my_table

</code></pre>
</div>
</div>
<p>Embed a column name in an s-string using braces. For example, PRQL‚Äôs standard library defines the <code>average</code> function as:</p>
<pre><code class="language-prql no-eval">let average = column -&gt; s"AVG({column})"
</code></pre>
<p>So this compiles using the function:</p>
<div class="comparison">
<div>
<h4 id="prql-15"><a class="header" href="#prql-15">PRQL</a></h4>
<pre><code class="language-prql">from employees
aggregate {average salary}
</code></pre>
</div>
<div>
<h4 id="sql-14"><a class="header" href="#sql-14">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary)
FROM
  employees

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/s-strings.html#admonition-note"></a>
</div>
<div>
<p>Because S-string contents are SQL, double-quotes (<code>"</code>) will denote a <em>column name</em>. To avoid that, use single-quotes (<code>'</code>) around the SQL string, and adjust the quotes of the S-string. For example, instead of <code>s'CONCAT("hello", "world")'</code> use <code>s"CONCAT('hello', 'world')"</code></p>
</div>
</div>
<p>Here‚Äôs an example of a more involved use of an s-string:</p>
<div class="comparison">
<div>
<h4 id="prql-16"><a class="header" href="#prql-16">PRQL</a></h4>
<pre><code class="language-prql">from de=dept_emp
join s=salaries side:left (s.emp_no == de.emp_no &amp;&amp; s"""
  ({s.from_date}, {s.to_date})
  OVERLAPS
  ({de.from_date}, {de.to_date})
""")
</code></pre>
</div>
<div>
<h4 id="sql-15"><a class="header" href="#sql-15">SQL</a></h4>
<pre><code class="language-sql">SELECT
  de.*,
  s.*
FROM
  dept_emp AS de
  LEFT JOIN salaries AS s ON s.emp_no = de.emp_no
  AND (s.from_date, s.to_date) OVERLAPS (de.from_date, de.to_date)

</code></pre>
</div>
</div>
<p>For those who have used Python, s-strings are similar to Python‚Äôs f-strings, but the result is SQL code, rather than a string literal. For example, a Python f-string of <code>f"average({col})"</code> would produce <code>"average(salary)"</code>, with quotes; while in PRQL, <code>s"average({col})"</code> produces <code>average(salary)</code>, without quotes.</p>
<p>Note that interpolations can only contain plain variable names and not whole expression like Python.</p>
<p>We can also use s-strings to produce a full table:</p>
<div class="comparison">
<div>
<h4 id="prql-17"><a class="header" href="#prql-17">PRQL</a></h4>
<pre><code class="language-prql">from s"SELECT DISTINCT ON first_name, id, age FROM employees ORDER BY age ASC"
join s = s"SELECT * FROM salaries" (==id)
</code></pre>
</div>
<div>
<h4 id="sql-16"><a class="header" href="#sql-16">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    DISTINCT ON first_name,
    id,
    age
  FROM
    employees
  ORDER BY
    age ASC
),
table_1 AS (
  SELECT
    *
  FROM
    salaries
)
SELECT
  table_0.*,
  table_1.*
FROM
  table_0
  JOIN table_1 ON table_0.id = table_1.id

</code></pre>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/s-strings.html#admonition-note-1"></a>
</div>
<div>
<p>S-strings in user code are intended as an escape hatch for an unimplemented feature. If we often need s-strings to express something, that‚Äôs a sign we should implement it in PRQL or PRQL‚Äôs stdlib. If you often require an s-string, <a href="https://github.com/PRQL/prql/issues/new/choose">submit an issue with your use case</a>.</p>
</div>
</div>
<h2 id="braces"><a class="header" href="#braces">Braces</a></h2>
<p>To output braces from an s-string, use double braces:</p>
<div class="comparison">
<div>
<h4 id="prql-18"><a class="header" href="#prql-18">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  has_valid_title = s"regexp_contains(title, '([a-z0-9]*-){{2,}}')"
}
</code></pre>
</div>
<div>
<h4 id="sql-17"><a class="header" href="#sql-17">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  regexp_contains(title, '([a-z0-9]*-){2,}') AS has_valid_title
FROM
  employees

</code></pre>
</div>
</div>
<h2 id="precedence-within-s-strings"><a class="header" href="#precedence-within-s-strings">Precedence within s-strings</a></h2>
<p>Variables in s-strings are inserted into the SQL source as-is, which means we may get surprising behavior when the variable has multiple terms and the s-string isn‚Äôt parenthesized.</p>
<p>In this toy example, the expression <code>salary + benefits / 365</code> gets precedence wrong. The generated SQL code is as if we had written <code>salary + (benefits / 365)</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-19"><a class="header" href="#prql-19">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = salary + benefits,
  daily_rate = s"{gross_salary} / 365"
}
</code></pre>
</div>
<div>
<h4 id="sql-18"><a class="header" href="#sql-18">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + benefits AS gross_salary,
  salary + benefits / 365 AS daily_rate
FROM
  employees

</code></pre>
</div>
</div>
<p>Instead, the numerator <code>{gross_salary}</code> must be encased in parentheses:</p>
<div class="comparison">
<div>
<h4 id="prql-20"><a class="header" href="#prql-20">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = salary + benefits,
  daily_rate = s"({gross_salary}) / 365"
}
</code></pre>
</div>
<div>
<h4 id="sql-19"><a class="header" href="#sql-19">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + benefits AS gross_salary,
  (salary + benefits) / 365 AS daily_rate
FROM
  employees

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>Tuple is a container type, composed of multiple fields. Each field can have a different type. Number of fields and their types must be known at compile time.</p>
<p>Tuple is represented by <code>{}</code>. It can span multiple lines. Fields can be assigned a name. Fields are separated by commas, trailing trailing comma is optional.</p>
<pre><code class="language-prql no-eval">let var1 = {x = 1, y = 2}

let var2 = {           # Span multiple lines
  a = x,
  b = y                # Optional trailing comma
}

let var3 = {
  c,                   # Individual item
  d = b,               # Assignment
}
</code></pre>
<p>Tuples are the type of a table row, which means that they are expected by many transforms. Most transforms can also take a single field, which will be converted into a tuple. These are equivalent:</p>
<div class="comparison">
<div>
<h4 id="prql-21"><a class="header" href="#prql-21">PRQL</a></h4>
<pre><code class="language-prql">from employees
select {first_name}
</code></pre>
</div>
<div>
<h4 id="sql-20"><a class="header" href="#sql-20">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-22"><a class="header" href="#prql-22">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-21"><a class="header" href="#sql-21">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/tuples.html#admonition-note"></a>
</div>
<div>
<p>Prior to <code>0.9.0</code>, tuples were previously named Lists, and represented with <code>[]</code> syntax. There may still be references to the old naming.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>Array is a container type, composed of multiple items. All items must be of the same type. Number of fields can be vary.</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/arrays.html#admonition-warning"></a>
</div>
<div>
<p>This page is a stub.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers--keywords"><a class="header" href="#identifiers--keywords">Identifiers &amp; keywords</a></h1>
<p>Identifiers can contain alphanumeric characters and <code>_</code> and must not start with a number. They can be chained together with the <code>.</code> indirection operator, used to retrieve a tuple from a field or a variable from a module.</p>
<pre><code class="language-prql no-eval">hello

_h3llo

hello.world
</code></pre>
<h2 id="this--that"><a class="header" href="#this--that"><code>this</code> &amp; <code>that</code></a></h2>
<p><code>this</code> refers to the current relation:</p>
<div class="comparison">
<div>
<h4 id="prql-23"><a class="header" href="#prql-23">PRQL</a></h4>
<pre><code class="language-prql">from invoices
aggregate (
    count this
)
</code></pre>
</div>
<div>
<h4 id="sql-22"><a class="header" href="#sql-22">SQL</a></h4>
<pre><code class="language-sql">SELECT
  COUNT(*)
FROM
  invoices

</code></pre>
</div>
</div>
<p>Within a <a href="reference/syntax/../stdlib/transforms/join.html"><code>join</code></a>, <code>that</code> refers to the other table:</p>
<div class="comparison">
<div>
<h4 id="prql-24"><a class="header" href="#prql-24">PRQL</a></h4>
<pre><code class="language-prql">from invoices
join tracks (this.track_id==that.id)
</code></pre>
</div>
<div>
<h4 id="sql-23"><a class="header" href="#sql-23">SQL</a></h4>
<pre><code class="language-sql">SELECT
  invoices.*,
  tracks.*
FROM
  invoices
  JOIN tracks ON invoices.track_id = tracks.id

</code></pre>
</div>
</div>
<p><code>this</code> can also be used to remove any column ambiguity. For example, currently using a bare <code>time</code> as a column name will fail, because it‚Äôs also a type:</p>
<div class="comparison">
<div>
<h4 id="prql-25"><a class="header" href="#prql-25">PRQL</a></h4>
<pre><code class="language-prql">from invoices
derive t = time
</code></pre>
</div>
<div>
<h4 id="error-1"><a class="header" href="#error-1">Error</a></h4>
<pre><code class="hljs language-undefined">Error:
   ‚ï≠‚îÄ[:2:12]
   ‚îÇ
 2 ‚îÇ derive t = time
   ‚îÇ            ‚îÄ‚îÄ‚î¨‚îÄ
   ‚îÇ              ‚ï∞‚îÄ‚îÄ‚îÄ expected a value, but found a type
‚îÄ‚îÄ‚îÄ‚ïØ
</code></pre>
</div>
</div>
<p>But with <code>this.time</code>, we can remove the ambiguity:</p>
<div class="comparison">
<div>
<h4 id="prql-26"><a class="header" href="#prql-26">PRQL</a></h4>
<pre><code class="language-prql">from invoices
derive t = this.time
</code></pre>
</div>
<div>
<h4 id="sql-24"><a class="header" href="#sql-24">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  time AS t
FROM
  invoices

</code></pre>
</div>
</div>
<h2 id="quoting"><a class="header" href="#quoting">Quoting</a></h2>
<p>To use characters that would be otherwise invalid, identifiers can be surrounded by with backticks.</p>
<p>When compiling to SQL, these identifiers will use dialect-specific quotes and quoting rules.</p>
<div class="comparison">
<div>
<h4 id="prql-27"><a class="header" href="#prql-27">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mysql
from employees
select `first name`
</code></pre>
</div>
<div>
<h4 id="sql-25"><a class="header" href="#sql-25">SQL</a></h4>
<pre><code class="language-sql">SELECT
  `first name`
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-28"><a class="header" href="#prql-28">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.postgres
from employees
select `first name`
</code></pre>
</div>
<div>
<h4 id="sql-26"><a class="header" href="#sql-26">SQL</a></h4>
<pre><code class="language-sql">SELECT
  "first name"
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-29"><a class="header" href="#prql-29">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.bigquery

from `project-foo.dataset.table`
join `project-bar.dataset.table` (==col_bax)
</code></pre>
</div>
<div>
<h4 id="sql-27"><a class="header" href="#sql-27">SQL</a></h4>
<pre><code class="language-sql">SELECT
  `project-foo.dataset.table`.*,
  `project-bar.dataset.table`.*
FROM
  `project-foo.dataset.table`
  JOIN `project-bar.dataset.table` ON `project-foo.dataset.table`.col_bax = `project-bar.dataset.table`.col_bax

</code></pre>
</div>
</div>
<h2 id="schemas--database-names"><a class="header" href="#schemas--database-names">Schemas &amp; database names</a></h2>
<p>Identifiers of database tables can be prefixed with schema and databases names.</p>
<div class="comparison">
<div>
<h4 id="prql-30"><a class="header" href="#prql-30">PRQL</a></h4>
<pre><code class="language-prql">from my_database.chinook.albums
</code></pre>
</div>
<div>
<h4 id="sql-28"><a class="header" href="#sql-28">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  my_database.chinook.albums

</code></pre>
</div>
</div>
<p>Note that all of following identifiers will be treated as separate table definitions: <code>tracks</code>, <code>public.tracks</code>, <code>my_database.public.tracks</code>.</p>
<h2 id="keywords"><a class="header" href="#keywords">Keywords</a></h2>
<p>PRQL uses following keywords:</p>
<ul>
<li><strong><code>prql</code></strong> - query header <a href="reference/syntax/../../project/target.html"><em>more‚Ä¶</em></a></li>
<li><strong><code>let</code></strong> - variable definition <a href="reference/syntax/../declarations/variables.html"><em>more‚Ä¶</em></a></li>
<li><strong><code>into</code></strong> - variable definition <a href="reference/syntax/../declarations/variables.html"><em>more‚Ä¶</em></a></li>
<li><strong><code>case</code></strong> - flow control <a href="reference/syntax/../syntax/case.html"><em>more‚Ä¶</em></a></li>
<li><strong><code>type</code></strong> - type declaration</li>
<li><strong><code>func</code></strong> - explicit function declaration <a href="reference/syntax/../declarations/functions.html"><em>more‚Ä¶</em></a></li>
<li><strong><code>module</code></strong> - used internally</li>
<li><strong><code>internal</code></strong> - used internally</li>
<li><strong><code>true</code></strong> - boolean <a href="reference/syntax/./literals.html#booleans"><em>more‚Ä¶</em></a></li>
<li><strong><code>false</code></strong> - boolean <a href="reference/syntax/./literals.html#booleans"><em>more‚Ä¶</em></a></li>
<li><strong><code>null</code></strong> - NULL <a href="reference/syntax/./literals.html#null"><em>more‚Ä¶</em></a></li>
</ul>
<p>Keywords can be used as identifiers (of columns or variables) when encased in backticks: <code>`case`</code>.</p>
<p>Transforms are normal functions within the <code>std</code> namespace, not keywords. That is, <code>std.from</code> is the same function as <code>from</code>. In the example below, the resulting query is the same as without the <code>std.</code> namespace:</p>
<div class="comparison">
<div>
<h4 id="prql-31"><a class="header" href="#prql-31">PRQL</a></h4>
<pre><code class="language-prql">std.from my_table
std.select {from = my_table.a, take = my_table.b}
std.take 3
</code></pre>
</div>
<div>
<h4 id="sql-29"><a class="header" href="#sql-29">SQL</a></h4>
<pre><code class="language-sql">SELECT
  a AS "from",
  b AS take
FROM
  my_table
LIMIT
  3

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-calls"><a class="header" href="#function-calls">Function calls</a></h1>
<h2 id="simple"><a class="header" href="#simple">Simple</a></h2>
<p>A distinction between PRQL and most other programming languages is the function call syntax. It consists of the function name followed by arguments separated by whitespace.</p>
<pre><code class="language-prql no-eval">function_name arg1 arg2 arg3
</code></pre>
<p>If one of the arguments is also a function call, it must be encased in parentheses, so we know where arguments of inner function end and the arguments of outer function start.</p>
<pre><code class="language-prql no-eval">outer_func arg_1 (inner_func arg_a, arg_b) arg_2
</code></pre>
<p>The function name must refer to a function variable, which has either <a href="reference/syntax/../declarations/functions.html">been declared</a> in the <a href="reference/syntax/../stdlib/">standard library</a> or some other module.</p>
<p>Function calls can also specify named parameters using <code>:</code> notation:</p>
<pre><code class="language-prql no-eval">function_name arg1 named_param:arg2 arg3
</code></pre>
<h2 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h2>
<p>There is a alternative way of calling functions: using a pipeline. Regardless of whether the pipeline is delimited by pipe symbol <code>|</code> or a new line, the pipeline is equivalent to applying each of functions as the last argument of the next function.</p>
<pre><code class="language-prql no-eval">a | foo 3 | bar 'hello' 'world' | baz
</code></pre>
<p>‚Ä¶ is equivalent to ‚Ä¶</p>
<pre><code class="language-prql no-eval">baz (bar 'hello' 'world' (foo 3 a))
</code></pre>
<!--
TODO: this should be a part of the tutorial


As you may have noticed, transforms are regular functions too!

```prql
from employees
filter age > 50
sort name
```

... is equivalent to ...

```prql
from employees | filter age > 50 | sort name
```

... is equivalent to ...

```prql
filter age > 50 (from employees) | sort name
```

... is equivalent to ...

```prql
sort name (filter age > 50 (from employees))
```

As you can see, the first example with pipeline notation is much easier to
comprehend, compared to the last one with the regular function call notation.
This is why it is recommended to use pipelines for nested function calls that
are 3 or more levels deep.

-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipes"><a class="header" href="#pipes">Pipes</a></h1>
<p>Pipes are the connection between <a href="reference/syntax/../stdlib/transforms/">transforms</a> that make up a pipeline. The relation produced by a transform before the pipe is used as the input for the transform following the pipe. A pipe can be represented with either a line break or a pipe character (<code>|</code>).</p>
<p>For example, here the <code>filter</code> transform operates on the result of <code>from employees</code> (which is just the <code>employees</code> table), and the <code>select</code> transform operates on the result of the <code>filter</code> transform.</p>
<div class="comparison">
<div>
<h4 id="prql-32"><a class="header" href="#prql-32">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter department == "Product"
select {first_name, last_name}
</code></pre>
</div>
<div>
<h4 id="sql-30"><a class="header" href="#sql-30">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees
WHERE
  department = 'Product'

</code></pre>
</div>
</div>
<p>In the place of a line break, it‚Äôs also possible to use the <code>|</code> character to pipe results between transforms, such that this is equivalent:</p>
<div class="comparison">
<div>
<h4 id="prql-33"><a class="header" href="#prql-33">PRQL</a></h4>
<pre><code class="language-prql">from employees | filter department == "Product" | select {first_name, last_name}
</code></pre>
</div>
<div>
<h4 id="sql-31"><a class="header" href="#sql-31">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees
WHERE
  department = 'Product'

</code></pre>
</div>
</div>
<h2 id="cest-ne-pas-un-pipe"><a class="header" href="#cest-ne-pas-un-pipe">‚ÄúC‚Äôest ne pas un pipe‚Äù</a></h2>
<p>In almost all situations, a line break acts as a pipe. But there are a few cases where a line break doesn‚Äôt act as a pipe.</p>
<ul>
<li>before or after tuple items</li>
<li>before or after list items</li>
<li>before a new statement, which starts with <code>let</code> or <code>from</code> (or <code>func</code>)</li>
<li>within a <a href="reference/syntax/./operators.html#wrapping-lines">line wrap</a></li>
</ul>
<p>For example:</p>
<div class="comparison">
<div>
<h4 id="prql-34"><a class="header" href="#prql-34">PRQL</a></h4>
<pre><code class="language-prql">[
  {a=2}      # No pipe from line break before &amp; after this list item
]
derive {
  c = 2 * a, # No pipe from line break before &amp; after this tuple item
}
</code></pre>
</div>
<div>
<h4 id="sql-32"><a class="header" href="#sql-32">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    2 AS a
)
SELECT
  a,
  2 * a AS c
FROM
  table_0

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-35"><a class="header" href="#prql-35">PRQL</a></h4>
<pre><code class="language-prql">let b =
  \ 3        # No pipe from line break within this line wrap

# No pipe from line break before this `from` statement

from y
derive a = b
</code></pre>
</div>
<div>
<h4 id="sql-33"><a class="header" href="#sql-33">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  3 AS a
FROM
  y

</code></pre>
</div>
</div>
<h2 id="inner-transforms"><a class="header" href="#inner-transforms">Inner Transforms</a></h2>
<!-- TODO: I don't think this really fits here -->
<p>Parentheses are also used for transforms (such as <code>group</code> and <code>window</code>) that pass their result to an ‚Äúinner transform‚Äù. The example below applies the <code>aggregate</code> pipeline to each group of unique <code>title</code> and <code>country</code> values:</p>
<div class="comparison">
<div>
<h4 id="prql-36"><a class="header" href="#prql-36">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {title, country} (
  aggregate {
    average salary,
    ct = count salary,
  }
)
</code></pre>
</div>
<div>
<h4 id="sql-34"><a class="header" href="#sql-34">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>Expressions can be composed from <em>function calls</em> and <em>operations</em>, such as <code>2 + 3</code> or <code>((1 + x) * -y)</code>. In the example below, note the use of expressions to calculate the alias <code>circumference</code> and in the <code>filter</code> transform.</p>
<div class="comparison">
<div>
<h4 id="prql-37"><a class="header" href="#prql-37">PRQL</a></h4>
<pre><code class="language-prql">from foo
select {
  circumference = diameter * 3.14159,
  color,
}
filter circumference &gt; 10 &amp;&amp; color != "red"
</code></pre>
</div>
<div>
<h4 id="sql-35"><a class="header" href="#sql-35">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    diameter * 3.14159 AS circumference,
    color
  FROM
    foo
)
SELECT
  circumference,
  color
FROM
  table_0
WHERE
  circumference &gt; 10
  AND color &lt;&gt; 'red'

</code></pre>
</div>
</div>
<h2 id="operator-precedence"><a class="header" href="#operator-precedence">Operator precedence</a></h2>
<p>This table shows operator precedence. Use parentheses <code>()</code> to prioritize operations and for function calls (see the discussion below.)</p>
<!-- markdownlint-disable MD033 ‚Äî the `|` characters need to be escaped, and surrounded with tags rather than backticks   -->
<p>|          Group | Operators                   | Precedence | Associativity | | ‚Äî‚Äî‚Äî‚Äì‚Äì: | ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî | :‚Äì‚Äì‚Äì‚Äì: | :‚Äî‚Äî‚Äî‚Äì: | ‚Äî | ‚Äî | |    parentheses | <code>()</code>                        |     0      |   see below   | | identifier dot | <code>.</code>                         |     1      |               | |          unary | <code>-</code> <code>+</code> <code>!</code> <code>==</code>            |     2      |               | |          range | <code>..</code>                        |     3      |               | |           <!-- | pow                         |    `**`    |       4       |     | --> | |            mul | <code>*</code> <code>/</code> <code>//</code> <code>%</code>            |     5      | left-to-right | |            add | <code>+</code> <code>-</code>                     |     6      | left-to-right | |        compare | <code>==</code> <code>!=</code> <code>&lt;=</code> <code>&gt;=</code> <code>&lt;</code> <code>&gt;</code> |     7      | left-to-right | |       coalesce | <code>??</code>                        |     8      | left-to-right | |            and | <code>&amp;&amp;</code>                        |     9      | left-to-right | |             or | <code>||</code>           |     10     | left-to-right | |  function call |                             |     11     |               |</p>
<h2 id="division-and-integer-division"><a class="header" href="#division-and-integer-division">Division and integer division</a></h2>
<p>The <code>/</code> operator performs division that always returns a float value, while the <code>//</code> operator does integer division (truncated division) that always returns an integer value.</p>
<div class="comparison">
<div>
<h4 id="prql-38"><a class="header" href="#prql-38">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.sqlite

from [
  {a = 5, b = 2},
  {a = 5, b = -2},
]
select {
  div_out = a / b,
  int_div_out = a // b,
}
</code></pre>
</div>
<div>
<h4 id="sql-36"><a class="header" href="#sql-36">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    5 AS a,
    2 AS b
  UNION
  ALL
  SELECT
    5 AS a,
    -2 AS b
)
SELECT
  (a * 1.0 / b) AS div_out,
  ROUND(ABS(a / b) - 0.5) * SIGN(a) * SIGN(b) AS int_div_out
FROM
  table_0

</code></pre>
</div>
</div>
<h2 id="coalesce"><a class="header" href="#coalesce">Coalesce</a></h2>
<p>We can coalesce values with an <code>??</code> operator. Coalescing takes either the first value or, if that value is null, the second value.</p>
<div class="comparison">
<div>
<h4 id="prql-39"><a class="header" href="#prql-39">PRQL</a></h4>
<pre><code class="language-prql">from orders
derive amount ?? 0
</code></pre>
</div>
<div>
<h4 id="sql-37"><a class="header" href="#sql-37">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  COALESCE(amount, 0)
FROM
  orders

</code></pre>
</div>
</div>
<h2 id="regex-expressions"><a class="header" href="#regex-expressions">Regex expressions</a></h2>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/operators.html#admonition-note"></a>
</div>
<div>
<p>This is currently experimental</p>
</div>
</div>
<p>To perform a case-sensitive regex search, use the <code>~=</code> operator. This generally compiles to <code>REGEXP</code>, though differs by dialect. A regex search means that to match an exact value, the start and end need to be anchored with <code>^foo$</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-40"><a class="header" href="#prql-40">PRQL</a></h4>
<pre><code class="language-prql">from tracks
filter (name ~= "Love")
</code></pre>
</div>
<div>
<h4 id="sql-38"><a class="header" href="#sql-38">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP(name, 'Love')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-41"><a class="header" href="#prql-41">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.duckdb

from artists
filter (name ~= "Love.*You")
</code></pre>
</div>
<div>
<h4 id="sql-39"><a class="header" href="#sql-39">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  artists
WHERE
  REGEXP_MATCHES(name, 'Love.*You')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-42"><a class="header" href="#prql-42">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.bigquery

from tracks
filter (name ~= "\\bLove\\b")
</code></pre>
</div>
<div>
<h4 id="sql-40"><a class="header" href="#sql-40">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP_CONTAINS(name, '\bLove\b')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-43"><a class="header" href="#prql-43">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.postgres

from tracks
filter (name ~= "\\(I Can't Help\\) Falling")
</code></pre>
</div>
<div>
<h4 id="sql-41"><a class="header" href="#sql-41">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  name ~ '\(I Can''t Help\) Falling'

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-44"><a class="header" href="#prql-44">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mysql

from tracks
filter (name ~= "With You")
</code></pre>
</div>
<div>
<h4 id="sql-42"><a class="header" href="#sql-42">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP_LIKE(name, 'With You', 'c')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-45"><a class="header" href="#prql-45">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.sqlite

from tracks
filter (name ~= "But Why Isn't Your Syntax More Similar\\?")
</code></pre>
</div>
<div>
<h4 id="sql-43"><a class="header" href="#sql-43">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  name REGEXP 'But Why Isn''t Your Syntax More Similar\?'

</code></pre>
</div>
</div>
<h2 id="parentheses"><a class="header" href="#parentheses">Parentheses</a></h2>
<p>PRQL uses parentheses <code>()</code> for several purposes:</p>
<ul>
<li>
<p>Parentheses group operands to control the order of evaluation, for example: <code>((1 + x) * y)</code></p>
</li>
<li>
<p>Parentheses delimit a minus sign of a function argument, for example: <code>add (-1) (-3)</code></p>
</li>
<li>
<p>Parentheses delimit nested function calls that contain a pipe, either the <code>|</code> symbol or a new line. ‚ÄúNested‚Äù means within a transform; i.e. not just the main pipeline, for example: <code>(column-name | in 0..20)</code></p>
</li>
<li>
<p>Parentheses wrap a function call that is part of a larger expression, for example: <code>math.round 0 (sum distance)</code></p>
</li>
</ul>
<p>Parentheses are <em>not</em> required for expressions that do not contain function calls, for example: <code>foo + bar</code>.</p>
<p>Here‚Äôs a set of examples of these rules:</p>
<div class="comparison">
<div>
<h4 id="prql-46"><a class="header" href="#prql-46">PRQL</a></h4>
<pre><code class="language-prql">from employees
# Requires parentheses, because it contains a pipe
derive is_proximate = (distance | in 0..20)
# Requires parentheses, because it's a function call
derive total_distance = (sum distance)
# `??` doesn't require parentheses, as it's not a function call
derive min_capped_distance = (min distance ?? 5)
# No parentheses needed, because no function call
derive travel_time = distance / 40
# No inner parentheses needed around `1+1` because no function call
derive distance_rounded_2_dp = (math.round 1+1 distance)
derive {
  # Requires parentheses, because it contains a pipe
  is_far = (distance | in 100..),
  # The left value of the range requires parentheses,
  # because of the minus sign
  is_negative = (distance | in (-100..0)),
  # ...this is equivalent
  is_negative = (distance | in (-100)..0),
  # _Technically_, this doesn't require parentheses, because it's
  # the RHS of an assignment in a tuple
  # (this is especially confusing)
  average_distance = average distance,
}
# Requires parentheses because of the minus sign
sort (-distance)
# A tuple is fine too
sort {-distance}
</code></pre>
</div>
<div>
<h4 id="sql-44"><a class="header" href="#sql-44">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  distance BETWEEN 0 AND 20 AS is_proximate,
  SUM(distance) OVER () AS total_distance,
  MIN(COALESCE(distance, 5)) OVER () AS min_capped_distance,
  distance / 40 AS travel_time,
  ROUND(distance, 1 + 1) AS distance_rounded_2_dp,
  distance &gt;= 100 AS is_far,
  distance BETWEEN -100 AND 0,
  distance BETWEEN -100 AND 0 AS is_negative,
  AVG(distance) OVER () AS average_distance
FROM
  employees
ORDER BY
  distance DESC

</code></pre>
</div>
</div>
<p>For example, the snippet below produces an error because the <code>sum</code> function call is not in a tuple.</p>
<div class="comparison">
<div>
<h4 id="prql-47"><a class="header" href="#prql-47">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive total_distance = sum distance
</code></pre>
</div>
<div>
<h4 id="error-2"><a class="header" href="#error-2">Error</a></h4>
<pre><code class="hljs language-undefined">Error:
   ‚ï≠‚îÄ[:2:29]
   ‚îÇ
 2 ‚îÇ derive total_distance = sum distance
   ‚îÇ                             ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ
   ‚îÇ                                 ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Unknown name `distance`
‚îÄ‚îÄ‚îÄ‚ïØ
</code></pre>
</div>
</div>
<p>‚Ä¶while with parentheses, it works at expected:</p>
<div class="comparison">
<div>
<h4 id="prql-48"><a class="header" href="#prql-48">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive other_distance = (sum distance)
</code></pre>
</div>
<div>
<h4 id="sql-45"><a class="header" href="#sql-45">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  SUM(distance) OVER () AS other_distance
FROM
  employees

</code></pre>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/operators.html#admonition-note-1"></a>
</div>
<div>
<p>We‚Äôre continuing to think whether these rules can be more intuitive. We‚Äôre also planning to make the error messages much better, so the compiler can help out.</p>
</div>
</div>
<h2 id="wrapping-lines"><a class="header" href="#wrapping-lines">Wrapping lines</a></h2>
<p>Line breaks in PRQL have semantic meaning, so to wrap a single logical line into multiple physical lines, we can use <code>\</code> at the beginning of subsequent physical lines:</p>
<div class="comparison">
<div>
<h4 id="prql-49"><a class="header" href="#prql-49">PRQL</a></h4>
<pre><code class="language-prql">from artists
select is_europe =
\ country == "DE"
\ || country == "FR"
\ || country == "ES"
</code></pre>
</div>
<div>
<h4 id="sql-46"><a class="header" href="#sql-46">SQL</a></h4>
<pre><code class="language-sql">SELECT
  country = 'DE'
  OR country = 'FR'
  OR country = 'ES' AS is_europe
FROM
  artists

</code></pre>
</div>
</div>
<p>Wrapping will ‚Äújump over‚Äù empty lines or lines with comments. For example, the <code>select</code> here is only one logical line:</p>
<div class="comparison">
<div>
<h4 id="prql-50"><a class="header" href="#prql-50">PRQL</a></h4>
<pre><code class="language-prql">from tracks
# This would be a really long line without being able to split it:
select listening_time_years = (spotify_plays + apple_music_plays + pandora_plays)
# We can toggle between lines when developing:
# \ * length_seconds
\ * length_s
#   min  hour day  year
\ / 60 / 60 / 24 / 365
</code></pre>
</div>
<div>
<h4 id="sql-47"><a class="header" href="#sql-47">SQL</a></h4>
<pre><code class="language-sql">SELECT
  (
    spotify_plays + apple_music_plays + pandora_plays
  ) * length_s / 60 / 60 / 24 / 365 AS listening_time_years
FROM
  tracks

</code></pre>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/operators.html#admonition-info"></a>
</div>
<div>
<p>Note that PRQL differs from most languages, which use a <code>\</code> at the <em>end</em> of the preceding line. Because PRQL aims to be friendly for data exploration, we want to make it possible to comment out any line, including the final line, without breaking the query. This requires all lines after the first to be structured similarly, and for the character to be at the start of each following line.</p>
</div>
</div>
<p>See <a href="reference/syntax/./pipes.html">Pipes</a> for more details on line breaks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case"><a class="header" href="#case">Case</a></h1>
<p>Search for the first condition that evaluates to <code>true</code> and return its associated value. If none of the conditions match, <code>null</code> is returned.</p>
<div class="comparison">
<div>
<h4 id="prql-51"><a class="header" href="#prql-51">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive distance = case [
  city == "Calgary" =&gt; 0,
  city == "Edmonton" =&gt; 300,
]
</code></pre>
</div>
<div>
<h4 id="sql-48"><a class="header" href="#sql-48">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  CASE
    WHEN city = 'Calgary' THEN 0
    WHEN city = 'Edmonton' THEN 300
    ELSE NULL
  END AS distance
FROM
  employees

</code></pre>
</div>
</div>
<p>To set a default, a <code>true</code> condition can be used:</p>
<div class="comparison">
<div>
<h4 id="prql-52"><a class="header" href="#prql-52">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive distance = case [
  city == "Calgary" =&gt; 0,
  city == "Edmonton" =&gt; 300,
  true =&gt; "Unknown",
]
</code></pre>
</div>
<div>
<h4 id="sql-49"><a class="header" href="#sql-49">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  CASE
    WHEN city = 'Calgary' THEN 0
    WHEN city = 'Edmonton' THEN 300
    ELSE 'Unknown'
  END AS distance
FROM
  employees

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ranges"><a class="header" href="#ranges">Ranges</a></h1>
<p>Range <code>start..end</code> represents as set of values between <code>start</code> and <code>end</code>, inclusive (greater of equal to <code>start</code> and less than or equal to <code>end</code>).</p>
<p>To express a range that is open on one side, either <code>start</code> or <code>end</code> can be omitted.</p>
<p>Ranges can be used in filters with the <code>in</code> function, with any type of literal, including dates:</p>
<div class="comparison">
<div>
<h4 id="prql-53"><a class="header" href="#prql-53">PRQL</a></h4>
<pre><code class="language-prql">from events
filter (created_at | in @1776-07-04..@1787-09-17)
filter (magnitude | in 50..100)
derive is_northern = (latitude | in 0..)
</code></pre>
</div>
<div>
<h4 id="sql-50"><a class="header" href="#sql-50">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  latitude &gt;= 0 AS is_northern
FROM
  events
WHERE
  created_at BETWEEN DATE '1776-07-04' AND DATE '1787-09-17'
  AND magnitude BETWEEN 50 AND 100

</code></pre>
</div>
</div>
<p>Ranges can also be used in <code>take</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-54"><a class="header" href="#prql-54">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort {-value, created_at}
take 101..110
</code></pre>
</div>
<div>
<h4 id="sql-51"><a class="header" href="#sql-51">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  orders
ORDER BY
  value DESC,
  created_at
LIMIT
  10 OFFSET 100

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/ranges.html#admonition-note"></a>
</div>
<div>
<p>Half-open ranges are generally less intuitive to read than a simple <code>&gt;=</code> or <code>&lt;=</code> operator.</p>
</div>
</div>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li><a href="reference/syntax/../stdlib/transforms/take.html">take transform</a></li>
</ul>
<h2 id="roadmap-2"><a class="header" href="#roadmap-2">Roadmap</a></h2>
<p>We‚Äôd like to use ranges for other types, such as whether an object is in an array or list literal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>Character <code>#</code> denotes a comment until the end of the line.</p>
<div class="comparison">
<div>
<h4 id="prql-55"><a class="header" href="#prql-55">PRQL</a></h4>
<pre><code class="language-prql">from employees  # Comment 1
# Comment 2
aggregate {average salary}
</code></pre>
</div>
<div>
<h4 id="sql-52"><a class="header" href="#sql-52">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary)
FROM
  employees

</code></pre>
</div>
</div>
<p>There‚Äôs no distinct multiline comment syntax.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameters"><a class="header" href="#parameters">Parameters</a></h1>
<p>Parameter is a placeholder for a value provided after the compilation of the query.</p>
<p>It uses the following syntax: <code>$id</code>, where <code>id</code> is an arbitrary alpha numeric string.</p>
<p>Most database engines only support numeric positional parameter ids (i.e <code>$3</code>).</p>
<div class="comparison">
<div>
<h4 id="prql-56"><a class="header" href="#prql-56">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter id == $1
</code></pre>
</div>
<div>
<h4 id="sql-53"><a class="header" href="#sql-53">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  id = $1

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="importing-data"><a class="header" href="#importing-data">Importing data</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from"><a class="header" href="#from">From</a></h1>
<p>Specifies a data source.</p>
<div class="comparison">
<div>
<h4 id="prql-57"><a class="header" href="#prql-57">PRQL</a></h4>
<pre><code class="language-prql">from artists
</code></pre>
</div>
<div>
<h4 id="sql-54"><a class="header" href="#sql-54">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  artists

</code></pre>
</div>
</div>
<p>To introduce an alias, use an assign expression:</p>
<div class="comparison">
<div>
<h4 id="prql-58"><a class="header" href="#prql-58">PRQL</a></h4>
<pre><code class="language-prql">from e = employees
select e.first_name
</code></pre>
</div>
<div>
<h4 id="sql-55"><a class="header" href="#sql-55">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees AS e

</code></pre>
</div>
</div>
<p>Table names containing spaces or special characters <a href="reference/data/../syntax/keywords.html#quoting">need to be contained within backticks</a>:</p>
<div class="comparison">
<div>
<h4 id="prql-59"><a class="header" href="#prql-59">PRQL</a></h4>
<pre><code class="language-prql">from `artist tracks`
</code></pre>
</div>
<div>
<h4 id="sql-56"><a class="header" href="#sql-56">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  "artist tracks"

</code></pre>
</div>
</div>
<p><code>default_db.tablename</code> can be used if the table name matches a function from the standard library.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/data/from.html#admonition-note"></a>
</div>
<div>
<p>We realize this is an awkward workaround. Track &amp; üëç <a href="https://github.com/PRQL/prql/issues/3271">#3271</a> for resolving this.</p>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-60"><a class="header" href="#prql-60">PRQL</a></h4>
<pre><code class="language-prql">default_db.group  # in place of `from group`
take 1
</code></pre>
</div>
<div>
<h4 id="sql-57"><a class="header" href="#sql-57">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  "group"
LIMIT
  1

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-files"><a class="header" href="#reading-files">Reading files</a></h1>
<p>There are a couple of functions mainly designed for DuckDB to read from files:</p>
<div class="comparison">
<div>
<h4 id="prql-61"><a class="header" href="#prql-61">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.duckdb

from (read_parquet "artists.parquet")
join (read_csv "albums.csv") (==track_id)
</code></pre>
</div>
<div>
<h4 id="sql-58"><a class="header" href="#sql-58">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *
  FROM
    read_parquet('artists.parquet')
),
table_1 AS (
  SELECT
    *
  FROM
    read_csv_auto('albums.csv')
)
SELECT
  table_0.*,
  table_1.*
FROM
  table_0
  JOIN table_1 ON table_0.track_id = table_1.track_id

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/data/read-files.html#admonition-note"></a>
</div>
<div>
<p>These don‚Äôt currently have all the DuckDB options. If those would be helpful, please log an issue and it‚Äôs a fairly easy addition.</p>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="reference/data/read-files.html#admonition-info"></a>
</div>
<div>
<p>We may be able to reduce the boilerplate <code>WITH table_x AS SELECT * FROM...</code> in future versions.</p>
</div>
</div>
<p>When specifying file names directly in the <code>FROM</code> clause without using functions, which is allowed in DuckDB, enclose the file names in backticks <code>``</code> as follows:</p>
<div class="comparison">
<div>
<h4 id="prql-62"><a class="header" href="#prql-62">PRQL</a></h4>
<pre><code class="language-prql">from `artists.parquet`
</code></pre>
</div>
<div>
<h4 id="sql-59"><a class="header" href="#sql-59">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  "artists.parquet"

</code></pre>
</div>
</div>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See also</a></h2>
<ul>
<li><a href="reference/data/../../project/target.html">Target and Version</a></li>
<li><a href="reference/data/./relation-literals.html">Ad-hoc data</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-create-ad-hoc-relations"><a class="header" href="#how-do-i-create-ad-hoc-relations">How do I: create ad-hoc relations?</a></h1>
<p>It‚Äôs often useful to make a small inline relation, for example when exploring how a database will evaluate an expression, or for a small lookup table. This can be quite verbose in SQL.</p>
<p>PRQL offers two approaches ‚Äî¬†array literals, and a <code>from_text</code> transform.</p>
<h2 id="array-literals"><a class="header" href="#array-literals">Array literals</a></h2>
<p>Because relations (aka a table) in PRQL are just arrays of tuples, they can be expressed with array and tuple syntax:</p>
<div class="comparison">
<div>
<h4 id="prql-63"><a class="header" href="#prql-63">PRQL</a></h4>
<pre><code class="language-prql">from [
  {a=5, b=false},
  {a=6, b=true},
]
filter b == true
select a
</code></pre>
</div>
<div>
<h4 id="sql-60"><a class="header" href="#sql-60">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    5 AS a,
    false AS b
  UNION
  ALL
  SELECT
    6 AS a,
    true AS b
)
SELECT
  a
FROM
  table_0
WHERE
  b = true

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-64"><a class="header" href="#prql-64">PRQL</a></h4>
<pre><code class="language-prql">let my_artists = [
  {artist="Miles Davis"},
  {artist="Marvin Gaye"},
  {artist="James Brown"},
]

from artists
join my_artists (==artist)
join albums (==artist_id)
select {artists.artist_id, albums.title}
</code></pre>
</div>
<div>
<h4 id="sql-61"><a class="header" href="#sql-61">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    'Miles Davis' AS artist
  UNION
  ALL
  SELECT
    'Marvin Gaye' AS artist
  UNION
  ALL
  SELECT
    'James Brown' AS artist
),
my_artists AS (
  SELECT
    artist
  FROM
    table_0
)
SELECT
  artists.artist_id,
  albums.title
FROM
  artists
  JOIN my_artists ON artists.artist = my_artists.artist
  JOIN albums ON artists.artist_id = albums.artist_id

</code></pre>
</div>
</div>
<h2 id="from_text"><a class="header" href="#from_text"><code>from_text</code></a></h2>
<p><code>from_text</code> takes a string in a common format, and converts it to table. It accepts a few formats:</p>
<ul>
<li>
<p><code>format:csv</code> parses CSV (default),</p>
</li>
<li>
<p><code>format:json</code> parses either:</p>
<ul>
<li>
<p>an array of objects each of which represents a row, or</p>
</li>
<li>
<p>an object with fields <code>columns</code> &amp; <code>data</code>, where <code>columns</code> take an array of column names and <code>data</code> takes an array of arrays.</p>
</li>
</ul>
</li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-65"><a class="header" href="#prql-65">PRQL</a></h4>
<pre><code class="language-prql">from_text """
a,b,c
1,2,3
4,5,6
"""
derive {
    d = b + c,
    answer = 20 * 2 + 2,
}
</code></pre>
</div>
<div>
<h4 id="sql-62"><a class="header" href="#sql-62">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    '1' AS a,
    '2' AS b,
    '3' AS c
  UNION
  ALL
  SELECT
    '4' AS a,
    '5' AS b,
    '6' AS c
)
SELECT
  a,
  b,
  c,
  b + c AS d,
  20 * 2 + 2 AS answer
FROM
  table_0

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-66"><a class="header" href="#prql-66">PRQL</a></h4>
<pre><code class="language-prql">from_text format:json """
[
    {"a": 1, "m": "5"},
    {"a": 4, "n": "6"}
]
"""
</code></pre>
</div>
<div>
<h4 id="sql-63"><a class="header" href="#sql-63">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    1 AS a,
    '5' AS m
  UNION
  ALL
  SELECT
    4 AS a,
    NULL AS m
)
SELECT
  a,
  m
FROM
  table_0

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-67"><a class="header" href="#prql-67">PRQL</a></h4>
<pre><code class="language-prql">from_text format:json """
{
    "columns": ["a", "b", "c"],
    "data": [
        [1, "x", false],
        [4, "y", null]
    ]
}
"""
</code></pre>
</div>
<div>
<h4 id="sql-64"><a class="header" href="#sql-64">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    1 AS a,
    'x' AS b,
    false AS c
  UNION
  ALL
  SELECT
    4 AS a,
    'y' AS b,
    NULL AS c
)
SELECT
  a,
  b,
  c
FROM
  table_0

</code></pre>
</div>
</div>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See also</a></h2>
<ul>
<li><a href="reference/data/./read-files.html">How do I: read files?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables--let--into"><a class="header" href="#variables--let--into">Variables ‚Äî <code>let</code> &amp; <code>into</code></a></h1>
<p>Variables assign a name ‚Äî¬†say <code>x</code> ‚Äî to an expression, like in most programming languages. The name can then be used in any expression, acting as a substitute for the expression <code>x</code>.</p>
<p>Syntactically, variables can take 3 forms.</p>
<ul>
<li>
<p><code>let</code> declares the name before the expression.</p>
<pre><code class="language-prql no-eval">let my_name = x
</code></pre>
</li>
<li>
<p><code>into</code> declares the name after the expression. This form is useful for quick pipeline splitting and conforms with the ‚Äúflow from top to bottom‚Äù rule of pipelines.</p>
<pre><code class="language-prql no-eval">x
into my_name
</code></pre>
</li>
<li>
<p>The final expression of a pipeline defaults to taking the name <code>main</code>.</p>
<pre><code class="language-prql no-eval">from x
</code></pre>
<p>‚Ä¶ is equivalent to:</p>
<pre><code class="language-prql no-eval">let main = x
</code></pre>
</li>
</ul>
<p>When compiling to SQL, relational variables are compiled to Common Table Expressions (or sub-queries in some cases).</p>
<div class="comparison">
<div>
<h4 id="prql-68"><a class="header" href="#prql-68">PRQL</a></h4>
<pre><code class="language-prql">let top_50 = (
  from employees
  sort salary
  take 50
  aggregate {total_salary = sum salary}
)

from top_50      # Starts a new pipeline
</code></pre>
</div>
<div>
<h4 id="sql-65"><a class="header" href="#sql-65">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    salary
  FROM
    employees
  ORDER BY
    salary
  LIMIT
    50
), top_50 AS (
  SELECT
    COALESCE(SUM(salary), 0) AS total_salary
  FROM
    table_0
)
SELECT
  total_salary
FROM
  top_50

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-69"><a class="header" href="#prql-69">PRQL</a></h4>
<pre><code class="language-prql">from employees
take 50
into first_50

from first_50
</code></pre>
</div>
<div>
<h4 id="sql-66"><a class="header" href="#sql-66">SQL</a></h4>
<pre><code class="language-sql">WITH first_50 AS (
  SELECT
    *
  FROM
    employees
  LIMIT
    50
)
SELECT
  *
FROM
  first_50

</code></pre>
</div>
</div>
<p>Variables can be assigned an s-string containing the whole SQL query <a href="reference/declarations/../syntax/s-strings.html">s-string</a>, enabling us to use features which PRQL doesn‚Äôt yet support.</p>
<div class="comparison">
<div>
<h4 id="prql-70"><a class="header" href="#prql-70">PRQL</a></h4>
<pre><code class="language-prql">let grouping = s"""
  SELECT SUM(a)
  FROM tbl
  GROUP BY
    GROUPING SETS
    ((b, c, d), (d), (b, d))
"""

from grouping
</code></pre>
</div>
<div>
<h4 id="sql-67"><a class="header" href="#sql-67">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    SUM(a)
  FROM
    tbl
  GROUP BY
    GROUPING SETS ((b, c, d), (d), (b, d))
)
SELECT
  *
FROM
  table_0

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<!--
TODOs:
- Examples are a bit artificial ‚Äî the interp is just "divide by 100" in one case!  -->
<p>Functions have two types of parameters:</p>
<ol>
<li>Positional parameters, which require an argument.</li>
<li>Named parameters, which optionally take an argument, otherwise using their default value.</li>
</ol>
<p>So this function is named <code>fahrenheit_to_celsius</code> and has one parameter <code>temp</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-71"><a class="header" href="#prql-71">PRQL</a></h4>
<pre><code class="language-prql">let fahrenheit_to_celsius = temp -&gt; (temp - 32) / 1.8

from cities
derive temp_c = (fahrenheit_to_celsius temp_f)
</code></pre>
</div>
<div>
<h4 id="sql-68"><a class="header" href="#sql-68">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (temp_f - 32) / 1.8 AS temp_c
FROM
  cities

</code></pre>
</div>
</div>
<p>This function is named <code>interp</code>, and has two positional parameters named <code>high</code> and <code>x</code>, and one named parameter named <code>low</code> which takes a default argument of <code>0</code>. It calculates the proportion of the distance that <code>x</code> is between <code>low</code> and <code>high</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-72"><a class="header" href="#prql-72">PRQL</a></h4>
<pre><code class="language-prql">let interp = low:0 high x -&gt; (x - low) / (high - low)

from students
derive {
  sat_proportion_1 = (interp 1600 sat_score),
  sat_proportion_2 = (interp low:0 1600 sat_score),
}
</code></pre>
</div>
<div>
<h4 id="sql-69"><a class="header" href="#sql-69">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_1,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_2
FROM
  students

</code></pre>
</div>
</div>
<h2 id="other-examples"><a class="header" href="#other-examples">Other examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-73"><a class="header" href="#prql-73">PRQL</a></h4>
<pre><code class="language-prql">let is_adult = col -&gt; col &gt;= 18
let writes_code = col -&gt; (col | in ["PRQL", "Rust"])
let square = col -&gt; (col | math.pow 2)
let starts_with_a = col -&gt; (col | text.lower | text.starts_with("a"))

from employees
select {
    first_name,
    last_name,
    hobby,
    adult = is_adult age,
    age_squared = square age,
}
filter ((starts_with_a last_name) &amp;&amp; (writes_code hobby))
</code></pre>
</div>
<div>
<h4 id="sql-70"><a class="header" href="#sql-70">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    first_name,
    last_name,
    hobby,
    age &gt;= 18 AS adult,
    POW(age, 2) AS age_squared
  FROM
    employees
)
SELECT
  first_name,
  last_name,
  hobby,
  adult,
  age_squared
FROM
  table_0
WHERE
  LOWER(last_name) LIKE CONCAT('a', '%')
  AND hobby IN ('PRQL', 'Rust')

</code></pre>
</div>
</div>
<h2 id="piping-values-into-functions"><a class="header" href="#piping-values-into-functions">Piping values into functions</a></h2>
<p>Consistent with the principles of PRQL, it‚Äôs possible to pipe values into functions, which makes composing many functions more readable. When piping a value into a function, the value is passed as an argument to the final positional parameter of the function. Here‚Äôs the same result as the examples above with an alternative construction:</p>
<div class="comparison">
<div>
<h4 id="prql-74"><a class="header" href="#prql-74">PRQL</a></h4>
<pre><code class="language-prql">let interp = low:0 high x -&gt; (x - low) / (high - low)

from students
derive {
  sat_proportion_1 = (sat_score | interp 1600),
  sat_proportion_2 = (sat_score | interp low:0 1600),
}
</code></pre>
</div>
<div>
<h4 id="sql-71"><a class="header" href="#sql-71">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_1,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_2
FROM
  students

</code></pre>
</div>
</div>
<p>and</p>
<div class="comparison">
<div>
<h4 id="prql-75"><a class="header" href="#prql-75">PRQL</a></h4>
<pre><code class="language-prql">let fahrenheit_to_celsius = temp -&gt; (temp - 32) / 1.8

from cities
derive temp_c = (temp_f | fahrenheit_to_celsius)
</code></pre>
</div>
<div>
<h4 id="sql-72"><a class="header" href="#sql-72">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (temp_f - 32) / 1.8 AS temp_c
FROM
  cities

</code></pre>
</div>
</div>
<p>We can combine a chain of functions, which makes logic more readable:</p>
<div class="comparison">
<div>
<h4 id="prql-76"><a class="header" href="#prql-76">PRQL</a></h4>
<pre><code class="language-prql">let fahrenheit_to_celsius = temp -&gt; (temp - 32) / 1.8
let interp = low:0 high x -&gt; (x - low) / (high - low)

from kettles
derive boiling_proportion = (temp_c | fahrenheit_to_celsius | interp 100)
</code></pre>
</div>
<div>
<h4 id="sql-73"><a class="header" href="#sql-73">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  ((temp_c - 32) / 1.8 - 0) / (100 - 0) AS boiling_proportion
FROM
  kettles

</code></pre>
</div>
</div>
<h3 id="late-binding"><a class="header" href="#late-binding">Late binding</a></h3>
<p>Functions can bind to any variable that is in scope when the function is executed. For example, here <code>cost_total</code> refers to the column that‚Äôs introduced in the <code>from</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-77"><a class="header" href="#prql-77">PRQL</a></h4>
<pre><code class="language-prql">let cost_share = cost -&gt; cost / cost_total

from costs
select {materials, labor, overhead, cost_total}
derive {
  materials_share = (cost_share materials),
  labor_share = (cost_share labor),
  overhead_share = (cost_share overhead),
}
</code></pre>
</div>
<div>
<h4 id="sql-74"><a class="header" href="#sql-74">SQL</a></h4>
<pre><code class="language-sql">SELECT
  materials,
  labor,
  overhead,
  cost_total,
  materials / cost_total AS materials_share,
  labor / cost_total AS labor_share,
  overhead / cost_total AS overhead_share
FROM
  costs

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard library</a></h1>
<p>The standard library currently contains commonly used functions that are used in SQL. It‚Äôs not yet as broad as we‚Äôd like, and we‚Äôre very open to expanding it.</p>
<p>Currently s-strings are an escape-hatch for any function that isn‚Äôt in our standard library. If we find ourselves using them for something frequently, raise an issue and we‚Äôll add it to the stdlib.</p>
<p>Here‚Äôs the source of the current <a href="https://github.com/PRQL/prql/blob/main/prqlc/prqlc/src/semantic/std.prql">PRQL <code>std</code></a>:</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/index.html#admonition-note"></a>
</div>
<div>
<p>PRQL 0.9.0 has started supporting different DB implementations for standard library functions. The source is the <a href="https://github.com/PRQL/prql/blob/main/prqlc/prqlc/src/sql/std.sql.prql"><code>std.sql</code></a>.</p>
</div>
</div>
<pre><code class="language-prql no-eval"># The PRQL standard library defines the following functions and transforms.
# The definitions are whitespace insensitive, and have this form:
#
# ```
# let my_func = param1 param2 ...  -&gt; &lt;return_type&gt; body_expr
# ```
#
# Where:
#   * `my_func` is the name of the function
#   * `param1` is the first parameter optionally followed by a type in "&lt; ... &gt;"
#   * `param2` etc. follow the same pattern as param1
#   * `&lt;return_type&gt;` is the type of result wrapped in "&lt; ... &gt;"
#   * `body_expr` defines the function body that creates the result.
#     It can be PRQL code or `internal ...` to indicate internal compiler code.

# Operators

let mul = left right -&gt; &lt;int || float&gt; internal std.mul
let div_i = left right -&gt; &lt;int || float&gt; internal std.div_i
let div_f = left right -&gt; &lt;int || float&gt; internal std.div_f
let mod = left right -&gt; &lt;int || float&gt; internal std.mod
let add = left right -&gt; &lt;int || float || timestamp || date&gt; internal std.add
let sub = left right -&gt; &lt;int || float || timestamp || date&gt; internal std.sub
let eq = left right -&gt; &lt;bool&gt; internal std.eq
let ne = left right -&gt; &lt;bool&gt; internal std.ne
let gt = left right -&gt; &lt;bool&gt; internal std.gt
let lt = left right -&gt; &lt;bool&gt; internal std.lt
let gte = left right -&gt; &lt;bool&gt; internal std.gte
let lte = left right -&gt; &lt;bool&gt; internal std.lte
let and = left&lt;bool&gt; right&lt;bool&gt; -&gt; &lt;bool&gt; internal std.and
let or = left&lt;bool&gt; right&lt;bool&gt; -&gt; &lt;bool&gt; internal std.or
let coalesce = left right -&gt; internal std.coalesce
let regex_search = text pattern -&gt; &lt;bool&gt; internal std.regex_search

let neg = expr&lt;int || float&gt; -&gt; &lt;int || float&gt; internal std.neg
let not = expr&lt;bool&gt; -&gt; &lt;bool&gt; internal std.not

# Types

## Type primitives
type int = int
type float = float
type bool = bool
type text = text
type date = date
type time = time
type timestamp = timestamp
type `func` = func
type anytype = anytype

## Generic array
# TODO: an array of anything, not just nulls
type array = [anytype]

## Scalar
type scalar = int || float || bool || text || date || time || timestamp || null
type tuple = {anytype..}

## Range
type range = {start = scalar, end = scalar}

## Relation (an array of tuples)
type relation = [tuple]

## Transform
type transform = func relation -&gt; relation

# Functions

## Relational transforms
let from = func
  `default_db.source` &lt;relation&gt;
  -&gt; &lt;relation&gt; source

let select = func
  columns &lt;anytype&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal select

let filter = func
  condition &lt;bool&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal filter

let derive = func
  columns &lt;anytype&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal derive

let aggregate = func
  columns &lt;anytype&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal aggregate

let sort = func
  by &lt;anytype&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal sort

let take = func
  expr &lt;anytype&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal take

let join = func
  `default_db.with` &lt;relation&gt;
  condition &lt;bool&gt;
  `noresolve.side`:inner
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal join

let group = func
  by&lt;scalar || tuple&gt;
  pipeline &lt;transform&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal group

let window = func
  rows:0..-1
  range:0..-1
  expanding &lt;bool&gt;:false
  rolling &lt;int&gt;:0
  pipeline &lt;transform&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal window

let append = `default_db.bottom`&lt;relation&gt; top&lt;relation&gt; -&gt; &lt;relation&gt; internal append
let intersect = `default_db.bottom`&lt;relation&gt; top&lt;relation&gt; -&gt; &lt;relation&gt; (
  t = top
  join (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b.*)))
  select t.*
)
let remove = `default_db.bottom`&lt;relation&gt; top&lt;relation&gt; -&gt; &lt;relation&gt; (
  t = top
  join side:left (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b.*)))
  filter (tuple_every (tuple_map _is_null b.*))
  select t.*
)
let loop = func
  pipeline &lt;transform&gt;
  top &lt;relation&gt;
  -&gt; &lt;relation&gt; internal loop

## Aggregate functions
# These return either a scalar when used within `aggregate`, or a column when used anywhere else.

let min = column &lt;array&gt; -&gt; &lt;int || float || null&gt; internal std.min

let max = column &lt;array&gt; -&gt; &lt;int || float || null&gt; internal std.max

let sum = column &lt;array&gt; -&gt; &lt;int || float&gt; internal std.sum

let average = column &lt;array&gt; -&gt; &lt;float || null&gt; internal std.average

let stddev = column &lt;array&gt; -&gt; &lt;float || null&gt; internal std.stddev

let all = column &lt;array&gt; -&gt; &lt;bool&gt; internal std.all

let any = column &lt;array&gt; -&gt; &lt;bool&gt; internal std.any

let concat_array = column &lt;array&gt; -&gt; &lt;text&gt; internal std.concat_array

# Counts number of items in the column.
# Note that the count will include null values.
let count = column&lt;array&gt; -&gt; &lt;int&gt; internal count

# Deprecated in favour of filterning input to the [std.count] function (not yet implemented).
@{deprecated}
let count_distinct = column &lt;array&gt; -&gt; internal std.count_distinct

## Window functions
let lag =   offset &lt;int&gt;    column &lt;array&gt; -&gt; internal std.lag
let lead =  offset &lt;int&gt;    column &lt;array&gt; -&gt; internal std.lead
let first      = column &lt;array&gt; -&gt; internal std.first
let last       = column &lt;array&gt; -&gt; internal std.last
let rank       = column &lt;array&gt; -&gt; internal std.rank
let rank_dense = column &lt;array&gt; -&gt; internal std.rank_dense
let row_number = column &lt;array&gt; -&gt; internal row_number

# Mathematical functions
module math {
  let abs = column -&gt; &lt;int || float&gt; internal std.math.abs
  let floor = column -&gt; &lt;int&gt; internal std.math.floor
  let ceil = column -&gt; &lt;int&gt; internal std.math.ceil
  let pi = -&gt; &lt;float&gt; internal std.math.pi
  let exp = column -&gt; &lt;int || float&gt; internal std.math.exp
  let ln = column -&gt; &lt;int || float&gt; internal std.math.ln
  let log10 = column -&gt; &lt;int || float&gt; internal std.math.log10
  let log = base&lt;int || float&gt; column -&gt; &lt;int || float&gt; internal std.math.log
  let sqrt = column -&gt; &lt;int || float&gt; internal std.math.sqrt
  let degrees = column -&gt; &lt;int || float&gt; internal std.math.degrees
  let radians = column -&gt; &lt;int || float&gt; internal std.math.radians
  let cos = column -&gt; &lt;int || float&gt; internal std.math.cos
  let acos = column -&gt; &lt;int || float&gt; internal std.math.acos
  let sin = column -&gt; &lt;int || float&gt; internal std.math.sin
  let asin = column -&gt; &lt;int || float&gt; internal std.math.asin
  let tan = column -&gt; &lt;int || float&gt; internal std.math.tan
  let atan = column -&gt; &lt;int || float&gt; internal std.math.atan
  let pow = exponent&lt;int || float&gt; column -&gt; &lt;int || float&gt; internal std.math.pow
  let round = n_digits column -&gt; &lt;scalar&gt; internal std.math.round
}

## Misc functions
let as = `noresolve.type` column -&gt; &lt;scalar&gt; internal std.as
let in = pattern value -&gt; &lt;bool&gt; internal in

## Tuple functions
let tuple_every = func list -&gt; &lt;bool&gt; internal tuple_every
let tuple_map = func fn &lt;func&gt; list -&gt; internal tuple_map
let tuple_zip = func a b -&gt; internal tuple_zip
let _eq = func a -&gt; internal _eq
let _is_null = func a -&gt; _param.a == null

## Misc
let from_text = input&lt;text&gt; `noresolve.format`:csv -&gt; &lt;relation&gt; internal from_text

## Text functions
module text {
  let lower = column -&gt; &lt;text&gt; internal std.text.lower
  let upper = column -&gt; &lt;text&gt; internal std.text.upper
  let ltrim = column -&gt; &lt;text&gt; internal std.text.ltrim
  let rtrim = column -&gt; &lt;text&gt; internal std.text.rtrim
  let trim = column -&gt; &lt;text&gt; internal std.text.trim
  let length = column -&gt; &lt;int&gt; internal std.text.length
  let extract = offset&lt;int&gt; length&lt;int&gt; column -&gt; &lt;text&gt; internal std.text.extract
  let replace = pattern&lt;text&gt; replacement&lt;text&gt; column -&gt; &lt;text&gt; internal std.text.replace
  let starts_with = prefix&lt;text&gt; column -&gt; &lt;bool&gt; internal std.text.starts_with
  let contains = substr&lt;text&gt; column -&gt; &lt;bool&gt; internal std.text.contains
  let ends_with = suffix&lt;text&gt; column -&gt; &lt;bool&gt; internal std.text.ends_with
}

## Date functions
module date {
  let to_text = format&lt;text&gt; column -&gt; &lt;text&gt; internal std.date.to_text
}

## File-reading functions, primarily for DuckDB
let read_parquet = source&lt;text&gt; -&gt; &lt;relation&gt; internal std.read_parquet
let read_csv = source&lt;text&gt; -&gt; &lt;relation&gt; internal std.read_csv


## PRQL compiler functions
module `prql` {
  let version = -&gt; &lt;text&gt; internal prql_version
}

# Deprecated, will be removed in 0.12.0
let prql_version = -&gt; &lt;text&gt; internal prql_version
</code></pre>
<p>And a couple of examples:</p>
<div class="comparison">
<div>
<h4 id="prql-78"><a class="header" href="#prql-78">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = (salary + payroll_tax | as int),
  gross_salary_rounded = (gross_salary | math.round 0),
  time = s"NOW()",  # an s-string, given no `now` function exists in PRQL
}
</code></pre>
</div>
<div>
<h4 id="sql-75"><a class="header" href="#sql-75">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  CAST(salary + payroll_tax AS int) AS gross_salary,
  ROUND(CAST(salary + payroll_tax AS int), 0) AS gross_salary_rounded,
  NOW() AS time
FROM
  employees

</code></pre>
</div>
</div>
<p>Example of different implementations of division and integer division:</p>
<div class="comparison">
<div>
<h4 id="prql-79"><a class="header" href="#prql-79">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.sqlite

from [{x = 13, y = 5}]
select {
  quotient = x / y,
  int_quotient = x // y,
}
</code></pre>
</div>
<div>
<h4 id="sql-76"><a class="header" href="#sql-76">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    13 AS x,
    5 AS y
)
SELECT
  (x * 1.0 / y) AS quotient,
  ROUND(ABS(x / y) - 0.5) * SIGN(x) * SIGN(y) AS int_quotient
FROM
  table_0

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-80"><a class="header" href="#prql-80">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mysql

from [{x = 13, y = 5}]
select {
  quotient = x / y,
  int_quotient = x // y,
}
</code></pre>
</div>
<div>
<h4 id="sql-77"><a class="header" href="#sql-77">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    13 AS x,
    5 AS y
)
SELECT
  (x / y) AS quotient,
  (x DIV y) AS int_quotient
FROM
  table_0

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transforms"><a class="header" href="#transforms">Transforms</a></h1>
<p>Transforms are functions that take a relation and produce a relation.</p>
<p>Usually they are chained together into a pipeline, which resembles an SQL query.</p>
<p>Transforms were designed with a focus on modularity, so each of them is fulfilling a specific purpose and has defined invariants (properties of the relation that are left unaffected). That‚Äôs often referred to as ‚Äúorthogonality‚Äù and its goal is to keep transform functions composable by minimizing interference of their effects. Additionally, it also keeps the number of transforms low.</p>
<p>For example, <code>select</code> and <code>derive</code> will not change the number of rows, while <code>filter</code> and <code>take</code> will not change the number of columns.</p>
<p>In SQL, we can see this lack of invariant when an aggregation function is used in the <code>SELECT</code> clause. Before, the number of rows was kept constant, but introduction of an aggregation function caused the whole statement to produce only one row (per group).</p>
<p>These are the currently available transforms:</p>
<div class="table-wrapper"><table><thead><tr><th>Transform</th><th>Purpose</th><th>SQL Equivalent</th></tr></thead><tbody>
<tr><td><code>derive</code></td><td><a href="reference/stdlib/transforms/./derive.html">Compute new columns</a></td><td><code>SELECT *, ... AS ...</code></td></tr>
<tr><td><code>select</code></td><td><a href="reference/stdlib/transforms/./select.html">Pick &amp; compute columns</a></td><td><code>SELECT ... AS ...</code></td></tr>
<tr><td><code>filter</code></td><td><a href="reference/stdlib/transforms/./filter.html">Pick rows based on their values</a></td><td><code>WHERE</code>, <code>HAVING</code>,<code>QUALIFY</code></td></tr>
<tr><td><code>sort</code></td><td><a href="reference/stdlib/transforms/./sort.html">Order rows based on the values of columns</a></td><td><code>ORDER BY</code></td></tr>
<tr><td><code>join</code></td><td><a href="reference/stdlib/transforms/./join.html">Add columns from another table, matching rows based on a condition</a></td><td><code>JOIN</code></td></tr>
<tr><td><code>take</code></td><td><a href="reference/stdlib/transforms/./take.html">Pick rows based on their position</a></td><td><code>TOP</code>, <code>LIMIT</code>, <code>OFFSET</code></td></tr>
<tr><td><code>group</code></td><td><a href="reference/stdlib/transforms/./group.html">Partition rows into groups and applies a pipeline to each of them</a></td><td><code>GROUP BY</code>, <code>PARTITION BY</code></td></tr>
<tr><td><code>aggregate</code></td><td><a href="reference/stdlib/transforms/./aggregate.html">Summarize many rows into one row</a></td><td><code>SELECT foo(...)</code></td></tr>
<tr><td><code>window</code></td><td><a href="reference/stdlib/transforms/./window.html">Apply a pipeline to overlapping segments of rows</a></td><td><code>OVER</code>, <code>ROWS</code>, <code>RANGE</code></td></tr>
<tr><td><code>loop</code></td><td><a href="reference/stdlib/transforms/./loop.html">Iteratively apply a function to a relation until it‚Äôs empty</a></td><td><code>WITH RECURSIVE ...</code></td></tr>
</tbody></table>
</div>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See also</a></h2>
<ul>
<li><a href="reference/stdlib/transforms/../../data/from.html"><code>from</code></a> ‚Äî¬†<code>from</code> is the main way of getting data into a pipeline (it‚Äôs not listed above since it‚Äôs not technically a transform, since it doesn‚Äôt receive an input).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregate"><a class="header" href="#aggregate">Aggregate</a></h1>
<p>Summarizes many rows into one row.</p>
<p>When applied:</p>
<ul>
<li>without <code>group</code>, it produces one row from the whole table,</li>
<li>within a <code>group</code> pipeline, it produces one row from each group.</li>
</ul>
<pre><code class="language-prql no-eval">aggregate {expression or assign operations}
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/aggregate.html#admonition-note"></a>
</div>
<div>
<p>Currently, all declared aggregation functions are <code>min</code>, <code>max</code>, <code>count</code>, <code>average</code>, <code>stddev</code>, <code>avg</code>, <code>sum</code> and <code>count_distinct</code>. We are in the process of filling out <a href="reference/stdlib/transforms/../">std lib</a>.</p>
</div>
</div>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-81"><a class="header" href="#prql-81">PRQL</a></h4>
<pre><code class="language-prql">from employees
aggregate {
  average salary,
  ct = count salary
}
</code></pre>
</div>
<div>
<h4 id="sql-78"><a class="header" href="#sql-78">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-82"><a class="header" href="#prql-82">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {title, country} (
  aggregate {
    average salary,
    ct = count salary,
  }
)
</code></pre>
</div>
<div>
<h4 id="sql-79"><a class="header" href="#sql-79">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country

</code></pre>
</div>
</div>
<h2 id="aggregate-is-required"><a class="header" href="#aggregate-is-required">Aggregate is required</a></h2>
<p>Unlike in SQL, using an aggregation function in <code>derive</code> or <code>select</code> (or any other transform except <code>aggregate</code>) will not trigger aggregation. By default, PRQL will interpret such attempts functions as window functions:</p>
<div class="comparison">
<div>
<h4 id="prql-83"><a class="header" href="#prql-83">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {avg_sal = average salary}
</code></pre>
</div>
<div>
<h4 id="sql-80"><a class="header" href="#sql-80">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  AVG(salary) OVER () AS avg_sal
FROM
  employees

</code></pre>
</div>
</div>
<p>This ensures that <code>derive</code> does not manipulate the number of rows, but only ever adds a column. For more information, see <a href="reference/stdlib/transforms/./window.html">window transform</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="append"><a class="header" href="#append">Append</a></h1>
<p>Concatenates two tables together.</p>
<p>Equivalent to <code>UNION ALL</code> in SQL. The number of rows is always the sum of the number of rows from the two input tables. To replicate <code>UNION DISTINCT</code>, see <a href="reference/stdlib/transforms/append.html#set-operations">set operations</a>.</p>
<div class="comparison">
<div>
<h4 id="prql-84"><a class="header" href="#prql-84">PRQL</a></h4>
<pre><code class="language-prql">from employees_1
append employees_2
</code></pre>
</div>
<div>
<h4 id="sql-81"><a class="header" href="#sql-81">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees_1
UNION
ALL
SELECT
  *
FROM
  employees_2

</code></pre>
</div>
</div>
<h2 id="remove"><a class="header" href="#remove">Remove</a></h2>
<blockquote>
<p><em>experimental</em></p>
</blockquote>
<p>Removes rows that appear in another relation, like <code>EXCEPT ALL</code>. Duplicate rows are removed one-for-one.</p>
<div class="comparison">
<div>
<h4 id="prql-85"><a class="header" href="#prql-85">PRQL</a></h4>
<pre><code class="language-prql">from employees_1
remove employees_2
</code></pre>
</div>
<div>
<h4 id="sql-82"><a class="header" href="#sql-82">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees_1 AS t
EXCEPT
  ALL
SELECT
  *
FROM
  employees_2 AS b

</code></pre>
</div>
</div>
<h2 id="intersection"><a class="header" href="#intersection">Intersection</a></h2>
<blockquote>
<p><em>experimental</em></p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-86"><a class="header" href="#prql-86">PRQL</a></h4>
<pre><code class="language-prql">from employees_1
intersect employees_2
</code></pre>
</div>
<div>
<h4 id="sql-83"><a class="header" href="#sql-83">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees_1 AS t
INTERSECT
ALL
SELECT
  *
FROM
  employees_2 AS b

</code></pre>
</div>
</div>
<h2 id="set-operations"><a class="header" href="#set-operations">Set operations</a></h2>
<blockquote>
<p><em>experimental</em></p>
</blockquote>
<p>To imitate set operations i.e. (<code>UNION</code>, <code>EXCEPT</code> and <code>INTERSECT</code>), you can use the following functions:</p>
<pre><code class="language-prql no-eval">let distinct = rel -&gt; (from t = _param.rel | group {t.*} (take 1))
let union = `default_db.bottom` top -&gt; (top | append bottom | distinct)
let except = `default_db.bottom` top -&gt; (top | distinct | remove bottom)
let intersect_distinct = `default_db.bottom` top -&gt; (top | intersect bottom | distinct)
</code></pre>
<p>Don‚Äôt mind the <code>default_db.</code> and <code>noop</code>, these are compiler implementation detail for now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive"><a class="header" href="#derive">Derive</a></h1>
<p>Computes one or more new columns.</p>
<pre><code class="language-prql no-eval">derive {
  name = expression,
  # or
  column,
}
</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-87"><a class="header" href="#prql-87">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive gross_salary = salary + payroll_tax
</code></pre>
</div>
<div>
<h4 id="sql-84"><a class="header" href="#sql-84">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + payroll_tax AS gross_salary
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-88"><a class="header" href="#prql-88">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = salary + payroll_tax,
  gross_cost = gross_salary + benefits_cost
}
</code></pre>
</div>
<div>
<h4 id="sql-85"><a class="header" href="#sql-85">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + payroll_tax AS gross_salary,
  salary + payroll_tax + benefits_cost AS gross_cost
FROM
  employees

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filter"><a class="header" href="#filter">Filter</a></h1>
<p>Picks rows based on their values.</p>
<pre><code class="language-prql no-eval">filter boolean_expression
</code></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-89"><a class="header" href="#prql-89">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter age &gt; 25
</code></pre>
</div>
<div>
<h4 id="sql-86"><a class="header" href="#sql-86">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  age &gt; 25

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-90"><a class="header" href="#prql-90">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter (age &gt; 25 || department != "IT")
</code></pre>
</div>
<div>
<h4 id="sql-87"><a class="header" href="#sql-87">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  age &gt; 25
  OR department &lt;&gt; 'IT'

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-91"><a class="header" href="#prql-91">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter (department | in ["IT", "HR"])
</code></pre>
</div>
<div>
<h4 id="sql-88"><a class="header" href="#sql-88">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  department IN ('IT', 'HR')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-92"><a class="header" href="#prql-92">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter (age | in 25..40)
</code></pre>
</div>
<div>
<h4 id="sql-89"><a class="header" href="#sql-89">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  age BETWEEN 25 AND 40

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="group"><a class="header" href="#group">Group</a></h1>
<p>Partitions the rows into groups and applies a pipeline to each of the groups.</p>
<pre><code class="language-prql no-eval">group {key_columns} (pipeline)
</code></pre>
<p>The partitioning of groups are determined by the <code>key_column</code>s (first argument).</p>
<p>The most conventional use of <code>group</code> is with <code>aggregate</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-93"><a class="header" href="#prql-93">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {title, country} (
  aggregate {
    average salary,
    ct = count salary
  }
)
</code></pre>
</div>
<div>
<h4 id="sql-90"><a class="header" href="#sql-90">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country

</code></pre>
</div>
</div>
<p>In concept, a transform in context of a <code>group</code> does the same transformation to the group as it would to the table ‚Äî for example finding the employee who joined first across the whole table:</p>
<div class="comparison">
<div>
<h4 id="prql-94"><a class="header" href="#prql-94">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort join_date
take 1
</code></pre>
</div>
<div>
<h4 id="sql-91"><a class="header" href="#sql-91">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  join_date
LIMIT
  1

</code></pre>
</div>
</div>
<p>To find the employee who joined first in each department, it‚Äôs exactly the same pipeline, but within a <code>group</code> expression:</p>
<div class="comparison">
<div>
<h4 id="prql-95"><a class="header" href="#prql-95">PRQL</a></h4>
<pre><code class="language-prql">from employees
group role (
  sort join_date  # taken from above
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-92"><a class="header" href="#sql-92">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    ROW_NUMBER() OVER (
      PARTITION BY role
      ORDER BY
        join_date
    ) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  _expr_0 &lt;= 1

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join"><a class="header" href="#join">Join</a></h1>
<p>Adds columns from another relation, matching rows based on a condition.</p>
<pre><code class="language-prql no-eval">join side:{inner|left|right|full} rel (condition)
</code></pre>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<ul>
<li><code>side</code> specifies which rows to include, defaulting to <code>inner</code>.</li>
<li><code>rel</code> - the relation to join with, possibly including an alias, e.g. <code>a=artists</code>.</li>
<li><code>condition</code> - the criteria on which to match the rows from the two relations. Theoretically, <code>join</code> will produce a cartesian product of the two input relations and then filter the result by the condition. It supports two additional features:
<ul>
<li><em>Names <a href="reference/stdlib/transforms/../../syntax/keywords.html#this--that"><code>this</code> &amp; <code>that</code></a></em>: Along name <code>this</code>, which refers to the first input relation, <code>condition</code> can use name <code>that</code>, which refers to the second input relation.</li>
<li><em>Self equality operator</em>: If the condition is an equality comparison between two columns with the same name (i.e. <code>(this.col == that.col)</code>), it can be expressed with only <code>(==col)</code>.</li>
</ul>
</li>
</ul>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-96"><a class="header" href="#prql-96">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:left positions (employees.id==positions.employee_id)
</code></pre>
</div>
<div>
<h4 id="sql-93"><a class="header" href="#sql-93">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*
FROM
  employees
  LEFT JOIN positions ON employees.id = positions.employee_id

</code></pre>
</div>
</div>
<hr />
<div class="comparison">
<div>
<h4 id="prql-97"><a class="header" href="#prql-97">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:left p=positions (employees.id==p.employee_id)
</code></pre>
</div>
<div>
<h4 id="sql-94"><a class="header" href="#sql-94">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  p.*
FROM
  employees
  LEFT JOIN positions AS p ON employees.id = p.employee_id

</code></pre>
</div>
</div>
<hr />
<div class="comparison">
<div>
<h4 id="prql-98"><a class="header" href="#prql-98">PRQL</a></h4>
<pre><code class="language-prql">from tracks
join side:left artists (
  # This adds a `country` condition, as an alternative to filtering
  artists.id==tracks.artist_id &amp;&amp; artists.country=='UK'
)
</code></pre>
</div>
<div>
<h4 id="sql-95"><a class="header" href="#sql-95">SQL</a></h4>
<pre><code class="language-sql">SELECT
  tracks.*,
  artists.*
FROM
  tracks
  LEFT JOIN artists ON artists.id = tracks.artist_id
  AND artists.country = 'UK'

</code></pre>
</div>
</div>
<hr />
<p>In SQL, CROSS JOIN is a join that returns each row from first relation matched with all rows from the second relation. To accomplish this, we can use condition <code>true</code>, which will return all rows of the cartesian product of the input relations:</p>
<pre><code>from shirts
join hats true
</code></pre>
<hr />
<p><a href="reference/stdlib/transforms/../../syntax/keywords.html#this--that"><code>this</code> &amp; <code>that</code></a> can be used to refer to the current &amp; other table respectively:</p>
<div class="comparison">
<div>
<h4 id="prql-99"><a class="header" href="#prql-99">PRQL</a></h4>
<pre><code class="language-prql">from tracks
join side:inner artists (
  this.id==that.artist_id
)
</code></pre>
</div>
<div>
<h4 id="sql-96"><a class="header" href="#sql-96">SQL</a></h4>
<pre><code class="language-sql">SELECT
  tracks.*,
  artists.*
FROM
  tracks
  JOIN artists ON tracks.id = artists.artist_id

</code></pre>
</div>
</div>
<hr />
<p>If the join conditions are of form <code>left.x == right.x</code>, we can use ‚Äúself equality operator‚Äù:</p>
<div class="comparison">
<div>
<h4 id="prql-100"><a class="header" href="#prql-100">PRQL</a></h4>
<pre><code class="language-prql">from employees
join positions (==emp_no)
</code></pre>
</div>
<div>
<h4 id="sql-97"><a class="header" href="#sql-97">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*
FROM
  employees
  JOIN positions ON employees.emp_no = positions.emp_no

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop"><a class="header" href="#loop">Loop</a></h1>
<blockquote>
<p><em>Experimental</em></p>
</blockquote>
<pre><code class="language-prql no-eval">loop {step_function} {initial_relation}
</code></pre>
<p>Iteratively applies <code>step</code> function to <code>initial</code> relation until the <code>step</code> returns an empty table. Returns a relation that contains rows of initial relation and all intermediate relations.</p>
<p>This behavior could be expressed with following pseudo-code:</p>
<pre><code class="language-python">def loop(step, initial):
    result = []
    current = initial
    while current is not empty:
        result = append(result, current)
        current = step(current)

    return result
</code></pre>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-101"><a class="header" href="#prql-101">PRQL</a></h4>
<pre><code class="language-prql">from [{n = 1}]
loop (
    filter n&lt;4
    select n = n+1
)

# returns [1, 2, 3, 4]
</code></pre>
</div>
<div>
<h4 id="sql-98"><a class="header" href="#sql-98">SQL</a></h4>
<pre><code class="language-sql">WITH RECURSIVE table_0 AS (
  SELECT
    1 AS n
),
table_1 AS (
  SELECT
    n
  FROM
    table_0
  UNION
  ALL
  SELECT
    n + 1
  FROM
    table_1
  WHERE
    n &lt; 4
)
SELECT
  n
FROM
  table_1 AS table_2

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/loop.html#admonition-note"></a>
</div>
<div>
<p>The behavior of <code>WITH RECURSIVE</code> may depend on the database configuration in MySQL. The compiler assumes the behavior described by the <a href="https://www.postgresql.org/docs/15/queries-with.html#QUERIES-WITH-RECURSIVE">Postgres documentation</a> and will not produce correct results for <a href="https://dev.mysql.com/doc/refman/8.0/en/with.html#common-table-expressions-recursive">alternative configurations of MySQL</a>.</p>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/loop.html#admonition-note-1"></a>
</div>
<div>
<p>Currently, <code>loop</code> may produce references to the recursive CTE in sub-queries, which is not supported by some database engines, e.g. SQLite. For now, we suggest step functions are kept simple enough to fit into a single SELECT statement.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">Select</a></h1>
<p>Picks and computes columns.</p>
<pre><code class="language-prql no-eval">select {
  name = expression,
  # or
  column,
}
# or
select !{column}
</code></pre>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-102"><a class="header" href="#prql-102">PRQL</a></h4>
<pre><code class="language-prql">from employees
select name = f"{first_name} {last_name}"
</code></pre>
</div>
<div>
<h4 id="sql-99"><a class="header" href="#sql-99">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS name
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-103"><a class="header" href="#prql-103">PRQL</a></h4>
<pre><code class="language-prql">from employees
select {
  name = f"{first_name} {last_name}",
  age_eoy = dob - @2022-12-31,
}
</code></pre>
</div>
<div>
<h4 id="sql-100"><a class="header" href="#sql-100">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS name,
  dob - DATE '2022-12-31' AS age_eoy
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-104"><a class="header" href="#prql-104">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-101"><a class="header" href="#sql-101">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-105"><a class="header" href="#prql-105">PRQL</a></h4>
<pre><code class="language-prql">from e=employees
select {e.first_name, e.last_name}
</code></pre>
</div>
<div>
<h4 id="sql-102"><a class="header" href="#sql-102">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees AS e

</code></pre>
</div>
</div>
<h3 id="excluding-columns"><a class="header" href="#excluding-columns">Excluding columns</a></h3>
<p>We can use <code>!</code> to exclude a list of columns. This can operate in two ways:</p>
<ul>
<li>We use <code>SELECT * EXCLUDE</code> / <code>SELECT * EXCEPT</code> for the columns supplied to <code>select !{}</code> in dialects which support it.</li>
<li>Otherwise, the columns must have been defined prior in the query (unless all of a table‚Äôs columns are excluded); for example in another <code>select</code> or a <code>group</code> transform. In this case, we evaluate and specify the columns that should be included in the output SQL.</li>
</ul>
<p>Some examples:</p>
<div class="comparison">
<div>
<h4 id="prql-106"><a class="header" href="#prql-106">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.bigquery
from tracks
select !{milliseconds, bytes}
</code></pre>
</div>
<div>
<h4 id="sql-103"><a class="header" href="#sql-103">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
EXCEPT
  (milliseconds, bytes)
FROM
  tracks

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-107"><a class="header" href="#prql-107">PRQL</a></h4>
<pre><code class="language-prql">from tracks
select {track_id, title, composer, bytes}
select !{title, composer}
</code></pre>
</div>
<div>
<h4 id="sql-104"><a class="header" href="#sql-104">SQL</a></h4>
<pre><code class="language-sql">SELECT
  track_id,
  bytes
FROM
  tracks

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-108"><a class="header" href="#prql-108">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive nick = name
select !{artists.*}
</code></pre>
</div>
<div>
<h4 id="sql-105"><a class="header" href="#sql-105">SQL</a></h4>
<pre><code class="language-sql">SELECT
  name AS nick
FROM
  artists

</code></pre>
</div>
</div>
<p>Note that <code>!</code> is also the <code>NOT</code> operator, so without the tuple it has a different meaning:</p>
<div class="comparison">
<div>
<h4 id="prql-109"><a class="header" href="#prql-109">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.bigquery
from tracks
select !is_compilation
</code></pre>
</div>
<div>
<h4 id="sql-106"><a class="header" href="#sql-106">SQL</a></h4>
<pre><code class="language-sql">SELECT
  NOT is_compilation
FROM
  tracks

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sort"><a class="header" href="#sort">Sort</a></h1>
<p>Order rows based on the values of one or more expressions (generally columns).</p>
<pre><code class="language-prql no-eval">sort {(+|-) column}
</code></pre>
<h2 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h2>
<ul>
<li>One expression or a tuple of expressions to sort by</li>
<li>Each expression can be prefixed with:
<ul>
<li><code>+</code>, for ascending order, the default</li>
<li><code>-</code>, for descending order</li>
</ul>
</li>
<li>When using prefixes, even a single expression needs to be in a tuple or parentheses. (Otherwise, <code>sort -foo</code> is parsed as a subtraction between <code>sort</code> and <code>foo</code>.)</li>
</ul>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-110"><a class="header" href="#prql-110">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort age
</code></pre>
</div>
<div>
<h4 id="sql-107"><a class="header" href="#sql-107">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-111"><a class="header" href="#prql-111">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort {-age}
</code></pre>
</div>
<div>
<h4 id="sql-108"><a class="header" href="#sql-108">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age DESC

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-112"><a class="header" href="#prql-112">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort {age, -tenure, +salary}
</code></pre>
</div>
<div>
<h4 id="sql-109"><a class="header" href="#sql-109">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age,
  tenure DESC,
  salary

</code></pre>
</div>
</div>
<p>We can also use expressions:</p>
<div class="comparison">
<div>
<h4 id="prql-113"><a class="header" href="#prql-113">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort {s"substr({first_name}, 2, 5)"}
</code></pre>
</div>
<div>
<h4 id="sql-110"><a class="header" href="#sql-110">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    substr(first_name, 2, 5) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
ORDER BY
  _expr_0

</code></pre>
</div>
</div>
<h2 id="ordering-guarantees"><a class="header" href="#ordering-guarantees">Ordering guarantees</a></h2>
<p>Ordering is persistent through a pipeline in PRQL. For example:</p>
<div class="comparison">
<div>
<h4 id="prql-114"><a class="header" href="#prql-114">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort tenure
join locations (==employee_id)
</code></pre>
</div>
<div>
<h4 id="sql-111"><a class="header" href="#sql-111">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  locations.*
FROM
  employees
  JOIN locations ON employees.employee_id = locations.employee_id
ORDER BY
  employees.tenure

</code></pre>
</div>
</div>
<p>Here, PRQL pushes the <code>sort</code> down the pipeline, compiling the <code>ORDER BY</code> to the <em>end</em> of the query. Consequently, most relation transforms retain the row order.</p>
<p>The explicit semantics are:</p>
<ul>
<li><code>sort</code> introduces a new order,</li>
<li><code>group</code> resets the order,</li>
<li><code>join</code> retains the order of the left relation,</li>
<li>database tables don‚Äôt have a known order.</li>
</ul>
<p>Comparatively, in SQL, relations possess no order, being orderable solely within the context of the query result, <code>LIMIT</code> statement, or window function. The lack of inherent order can result in an unexpected reshuffling of a previously ordered relation from a <code>JOIN</code> or windowing operation.</p>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/sort.html#admonition-info"></a>
</div>
<div>
<p>To be precise ‚Äî in PRQL, a relation is an <em>array of tuples</em> and not a set or a bag. The persistent nature of this order remains intact through sub-queries and intermediate table definitions.</p>
</div>
</div>
<p>For instance, an SQL query such as:</p>
<pre><code class="language-sql">WITH albums_sorted AS (
  SELECT *
  FROM albums
  ORDER BY title
)
SELECT *
FROM albums_sorted
JOIN artists USING (artist_id)
</code></pre>
<p>‚Ä¶doesn‚Äôt guarantee any row order (indeed ‚Äî even without the <code>JOIN</code>, the SQL standard doesn‚Äôt guarantee an order, although most implementations will respect it).</p>
<!-- We rolling this back. Waiting on the outcome of https://github.com/PRQL/prql/issues/2622 -->
<!-- ## Nulls

PRQL defaults to `NULLS LAST` when compiling to SQL. Because databases have
different defaults, the compiler emits this for all targets for which it's not a
default<sup><a name="to-footnote-1">[1](#footnote-1)</a></sup>.

The main benefit of this approach is that `take 42` will select non-null values
for both ascending and descending sorts, which is generally what is wanted.

There isn't currently a way to change this for a query, but if that would be
helpful, please raise an issue.

Note how DuckDB doesn't require a `NULLS LAST`, unlike the generic targets
above:

```prql
prql target:sql.duckdb

from artists
sort artist_id
take 42
```

```admonish info
Check out [DuckDB #7174](https://github.com/duckdb/duckdb/pull/7174) for a survey of various databases' implementations.
```
<p><hr/>


<a name="footnote-1">[1](#to-footnote-1)</a>: except for MSSQL, which doesn't support this<div style="break-before: page; page-break-before: always;"></div><h1 id="take"><a class="header" href="#take">Take</a></h1>
<p>Picks rows based on their position.</p>
<pre><code class="language-prql no-eval">take (n|range)
</code></pre>
<p>See <a href="reference/stdlib/transforms/../../syntax/ranges.html">Ranges</a> for more details on how ranges work.</p>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-115"><a class="header" href="#prql-115">PRQL</a></h4>
<pre><code class="language-prql">from employees
take 10
</code></pre>
</div>
<div>
<h4 id="sql-112"><a class="header" href="#sql-112">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
LIMIT
  10

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-116"><a class="header" href="#prql-116">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort {-value, created_at}
take 101..110
</code></pre>
</div>
<div>
<h4 id="sql-113"><a class="header" href="#sql-113">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  orders
ORDER BY
  value DESC,
  created_at
LIMIT
  10 OFFSET 100

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window"><a class="header" href="#window">Window</a></h1>
<p>Applies a pipeline to segments of rows, producing one output value for every input value.</p>
<pre><code class="language-prql no-eval">window rows:(range) range:(range) expanding:false rolling:0 (pipeline)
</code></pre>
<p>For each row, the segment over which the pipeline is applied is determined by one of:</p>
<ul>
<li><code>rows</code>, which takes a range of rows relative to the current row position.
<ul>
<li><code>0</code> references the current row.</li>
</ul>
</li>
<li><code>range</code>, which takes a range of values relative to current row value.</li>
</ul>
<p>The bounds of the range are inclusive. If a bound is omitted, the segment will extend until the edge of the table or group.</p>
<p>For ease of use, there are two flags that override <code>rows</code> or <code>range</code>:</p>
<ul>
<li><code>expanding:true</code> is an alias for <code>rows:..0</code>. A sum using this window is also known as ‚Äúcumulative sum‚Äù.</li>
<li><code>rolling:n</code> is an alias for <code>rows:(-n+1)..0</code>, where <code>n</code> is an integer. This will include <code>n</code> last values, including current row. An average using this window is also knows as a Simple Moving Average.</li>
</ul>
<p>Some examples:</p>
<div class="table-wrapper"><table><thead><tr><th>Expression</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>rows:0..2</code></td><td>current row plus two following</td></tr>
<tr><td><code>rows:-2..0</code></td><td>two preceding rows plus current row</td></tr>
<tr><td><code>rolling:3</code></td><td>(same as previous)</td></tr>
<tr><td><code>rows:-2..4</code></td><td>two preceding rows plus current row plus four following rows</td></tr>
<tr><td><code>rows:..0</code></td><td>all rows from the start of the table up to &amp; including current row</td></tr>
<tr><td><code>expanding:true</code></td><td>(same as previous)</td></tr>
<tr><td><code>rows:0..</code></td><td>current row and all following rows until the end of the table</td></tr>
<tr><td><code>rows:..</code></td><td>all rows, which same as not having window at all</td></tr>
</tbody></table>
</div>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<div class="comparison">
<div>
<h4 id="prql-117"><a class="header" href="#prql-117">PRQL</a></h4>
<pre><code class="language-prql">from employees
group employee_id (
  sort month
  window rolling:12 (
    derive {trail_12_m_comp = sum paycheck}
  )
)
</code></pre>
</div>
<div>
<h4 id="sql-114"><a class="header" href="#sql-114">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  SUM(paycheck) OVER (
    PARTITION BY employee_id
    ORDER BY
      month ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
  ) AS trail_12_m_comp
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-118"><a class="header" href="#prql-118">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort day
window rows:-3..3 (
  derive {centered_weekly_average = average value}
)
group {order_month} (
  sort day
  window expanding:true (
    derive {monthly_running_total = sum value}
  )
)
</code></pre>
</div>
<div>
<h4 id="sql-115"><a class="header" href="#sql-115">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  AVG(value) OVER (
    ORDER BY
      day ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING
  ) AS centered_weekly_average,
  SUM(value) OVER (
    PARTITION BY order_month
    ORDER BY
      day ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) AS monthly_running_total
FROM
  orders

</code></pre>
</div>
</div>
<p>Rows vs Range:</p>
<div class="comparison">
<div>
<h4 id="prql-119"><a class="header" href="#prql-119">PRQL</a></h4>
<pre><code class="language-prql">from [
  {time_id=1, value=15},
  {time_id=2, value=11},
  {time_id=3, value=16},
  {time_id=4, value=9},
  {time_id=7, value=20},
  {time_id=8, value=22},
]
window rows:-2..0 (
  sort time_id
  derive {sma3rows = average value}
)
window range:-2..0 (
  sort time_id
  derive {sma3range = average value}
)
</code></pre>
</div>
<div>
<h4 id="sql-116"><a class="header" href="#sql-116">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    1 AS time_id,
    15 AS value
  UNION
  ALL
  SELECT
    2 AS time_id,
    11 AS value
  UNION
  ALL
  SELECT
    3 AS time_id,
    16 AS value
  UNION
  ALL
  SELECT
    4 AS time_id,
    9 AS value
  UNION
  ALL
  SELECT
    7 AS time_id,
    20 AS value
  UNION
  ALL
  SELECT
    8 AS time_id,
    22 AS value
)
SELECT
  time_id,
  value,
  AVG(value) OVER (
    ORDER BY
      time_id ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
  ) AS sma3rows,
  AVG(value) OVER (
    ORDER BY
      time_id RANGE BETWEEN 2 PRECEDING AND CURRENT ROW
  ) AS sma3range
FROM
  table_0
ORDER BY
  time_id

</code></pre>
</div>
</div>
<div class="table-wrapper"><table><thead><tr><th>time_id</th><th>value</th><th>sma3rows</th><th>sma3range</th></tr></thead><tbody>
<tr><td>1</td><td>15</td><td>15</td><td>15</td></tr>
<tr><td>2</td><td>11</td><td>13</td><td>13</td></tr>
<tr><td>3</td><td>16</td><td>14</td><td>14</td></tr>
<tr><td>4</td><td>9</td><td>12</td><td>12</td></tr>
<tr><td>7</td><td>20</td><td>15</td><td>20</td></tr>
<tr><td>8</td><td>22</td><td>17</td><td>21</td></tr>
</tbody></table>
</div>
<p>We can see that rows having <code>time_id</code> of 5 and 6 are missing in example data; we can say there are gaps in our time series data.</p>
<p>When computing SMA 3 for the fifth row (<code>time_id==7</code>) then:</p>
<ul>
<li>‚Äúrows‚Äù will compute average on 3 rows (<code>time_id</code> in <code>3, 4, 7</code>)</li>
<li>‚Äúrange‚Äù will compute average on single row only (<code>time_id==7</code>)</li>
</ul>
<p>When computing SMA 3 for the sixth row (<code>time_id==8</code>) then:</p>
<ul>
<li>‚Äúrows‚Äù will compute average on 3 rows (<code>time_id</code> in <code>4, 7, 8</code>)</li>
<li>‚Äúrange‚Äù will compute average on 2 rows (<code>time_id</code> in <code>7, 8</code>)</li>
</ul>
<p>We can observe that ‚Äúrows‚Äù ignores the content of the <code>time_id</code>, only uses its order; we can say its window operates on physical rows. On the other hand ‚Äúrange‚Äù looks at the content of the <code>time_id</code> and based on the content decides how many rows fits into window; we can say window operates on logical rows.</p>
<h2 id="windowing-by-default"><a class="header" href="#windowing-by-default">Windowing by default</a></h2>
<p>If you use window functions without <code>window</code> transform, they will be applied to the whole table. Unlike in SQL, they will remain window functions and will not trigger aggregation.</p>
<div class="comparison">
<div>
<h4 id="prql-120"><a class="header" href="#prql-120">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort age
derive {rnk = rank age}
</code></pre>
</div>
<div>
<h4 id="sql-117"><a class="header" href="#sql-117">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  RANK() OVER (
    ORDER BY
      age
  ) AS rnk
FROM
  employees
ORDER BY
  age

</code></pre>
</div>
</div>
<p>You can also only apply <code>group</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-121"><a class="header" href="#prql-121">PRQL</a></h4>
<pre><code class="language-prql">from employees
group department (
  sort age
  derive {rnk = rank age}
)
</code></pre>
</div>
<div>
<h4 id="sql-118"><a class="header" href="#sql-118">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  RANK() OVER (
    PARTITION BY department
    ORDER BY
      age
  ) AS rnk
FROM
  employees

</code></pre>
</div>
</div>
<h2 id="window-functions-as-first-class-citizens"><a class="header" href="#window-functions-as-first-class-citizens">Window functions as first class citizens</a></h2>
<p>There are no limitations on where windowed expressions can be used:</p>
<div class="comparison">
<div>
<h4 id="prql-122"><a class="header" href="#prql-122">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter salary &lt; (average salary)
</code></pre>
</div>
<div>
<h4 id="sql-119"><a class="header" href="#sql-119">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    AVG(salary) OVER () AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  salary &lt; _expr_0

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="date-functions"><a class="header" href="#date-functions">Date functions</a></h1>
<p>These are all the functions defined in the <code>date</code> module:</p>
<h3 id="to_text"><a class="header" href="#to_text"><code>to_text</code></a></h3>
<p>Converts a date into a text.<br />
Since there are many possible date representations, <code>to_text</code> takes a <code>format</code> parameter that describes thanks to <a href="reference/stdlib/date.html#date--time-format-specifiers">specifiers</a> how the date or timestamp should be structured.</p>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/date.html#admonition-info"></a>
</div>
<div>
<p>Since all RDBMS have different ways to format dates and times, PRQL <strong>requires an explicit dialect</strong> to be specified</p>
</div>
</div>
<div id="admonition-info-1" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-1-title">
<div class="admonition-title">
<div id="admonition-info-1-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/date.html#admonition-info-1"></a>
</div>
<div>
<p>For now the supported DBs are: Clickhouse, DuckDB, MySQL, MSSQL and Postgres.</p>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-123"><a class="header" href="#prql-123">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.duckdb

from invoices
select {
  invoice_date | date.to_text "%d/%m/%Y"
}
</code></pre>
</div>
<div>
<h4 id="sql-120"><a class="header" href="#sql-120">SQL</a></h4>
<pre><code class="language-sql">SELECT
  strftime(invoice_date, '%d/%m/%Y')
FROM
  invoices

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-124"><a class="header" href="#prql-124">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.postgres

from invoices
select {
  invoice_date | date.to_text "%d/%m/%Y"
}
</code></pre>
</div>
<div>
<h4 id="sql-121"><a class="header" href="#sql-121">SQL</a></h4>
<pre><code class="language-sql">SELECT
  TO_CHAR(invoice_date, 'DD/MM/YYYY')
FROM
  invoices

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-125"><a class="header" href="#prql-125">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mysql

from invoices
select {
  invoice_date | date.to_text "%d/%m/%Y"
}
</code></pre>
</div>
<div>
<h4 id="sql-122"><a class="header" href="#sql-122">SQL</a></h4>
<pre><code class="language-sql">SELECT
  DATE_FORMAT(invoice_date, '%d/%m/%Y')
FROM
  invoices

</code></pre>
</div>
</div>
<h3 id="date--time-format-specifiers"><a class="header" href="#date--time-format-specifiers">Date &amp; time format specifiers</a></h3>
<p>PRQL specifiers for date and time formatting is a subset of specifiers used by <a href="https://docs.rs/chrono/latest/chrono/format/strftime/index.html"><code>chrono</code></a>.</p>
<p>Here is the list of the specifiers currently supported:</p>
<div class="table-wrapper"><table><thead><tr><th>Spec.</th><th>Example</th><th>Description</th></tr></thead><tbody>
<tr><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td><strong>DATE SPECIFIERS:</strong></td></tr>
<tr><td><code>%Y</code></td><td><code>2001</code></td><td>Year number, zero-padded to 4 digits</td></tr>
<tr><td><code>%y</code></td><td><code>01</code></td><td>Year number, zero-padded to 2 digits</td></tr>
<tr><td><code>%m</code></td><td><code>07</code></td><td>Month number (01‚Äì12), zero-padded to 2 digits</td></tr>
<tr><td><code>%-m</code></td><td><code>7</code></td><td>Month number (1-12)</td></tr>
<tr><td><code>%b</code></td><td><code>Jul</code></td><td>Abbreviated month name. Always 3 letters.</td></tr>
<tr><td><code>%B</code></td><td><code>July</code></td><td>Full month name</td></tr>
<tr><td><code>%d</code></td><td><code>08</code></td><td>Day number (01-31), zero-padded to 2 digits</td></tr>
<tr><td><code>%-d</code></td><td><code> 8</code></td><td>Day number (1-31)</td></tr>
<tr><td><code>%a</code></td><td><code>Sun</code></td><td>Abbreviated weekday name. Always 3 letters</td></tr>
<tr><td><code>%A</code></td><td><code>Sunday</code></td><td>Full weekday name</td></tr>
<tr><td><code>%D</code></td><td><code>07/08/01</code></td><td>Month-day-year format. Same as <code>%m/%d/%y</code></td></tr>
<tr><td><code>%x</code></td><td><code>07/08/01</code></td><td>Locale‚Äôs date representation</td></tr>
<tr><td><code>%F</code></td><td><code>2001-07-08</code></td><td>Year-month-day format (ISO 8601). Same as <code>%Y-%m-%d</code></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td><strong>TIME SPECIFIERS:</strong></td></tr>
<tr><td><code>%H</code></td><td><code>00</code></td><td>Hour number (00-23)</td></tr>
<tr><td><code>%k</code></td><td><code> 0</code></td><td>Same as <code>%H</code> but space-padded. Same as <code>%_H</code>.</td></tr>
<tr><td><code>%I</code></td><td><code>12</code></td><td>Hour number in 12-hour clocks (01‚Äì12), zero-padded to 2 digits.</td></tr>
<tr><td><code>%p</code></td><td><code>AM</code></td><td><code>AM</code> or <code>PM</code> in 12-hour clocks.</td></tr>
<tr><td><code>%M</code></td><td><code>34</code></td><td>Minute number (00-59), zero-padded to 2 digits.</td></tr>
<tr><td><code>%S</code></td><td><code>60</code></td><td>Second number (00-59), zero-padded to 2 digits.</td></tr>
<tr><td><code>%f</code></td><td><code>264900</code></td><td>Number of microseconds<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> since last whole second</td></tr>
<tr><td><code>%R</code></td><td><code>00:34</code></td><td>Hour-minute format. Same as <code>%H:%M</code>.</td></tr>
<tr><td><code>%T</code></td><td><code>00:34:60</code></td><td>Hour-minute-second format. Same as <code>%H:%M:%S</code>.</td></tr>
<tr><td><code>%X</code></td><td><code>00:34:60</code></td><td>Locale‚Äôs time representation (e.g., 23:13:48).</td></tr>
<tr><td><code>%r</code></td><td><code>12:34:60 AM</code></td><td>Locale‚Äôs 12 hour clock time. (e.g., 11:11:04 PM)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td><strong>DATE &amp; TIME SPECIFIERS:</strong></td></tr>
<tr><td><code>%+</code></td><td><code>2001-07-08T00:34:60.026490Z</code></td><td>ISO 8601 / RFC 3339 date &amp; time format.</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td><strong>SPECIAL SPECIFIERS:</strong></td></tr>
<tr><td><code>%t</code></td><td></td><td>Literal tab (<code>\t</code>).</td></tr>
<tr><td><code>%n</code></td><td></td><td>Literal newline (<code>\n</code>).</td></tr>
<tr><td><code>%%</code></td><td></td><td>Literal percent sign.</td></tr>
</tbody></table>
</div><hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>This is different from chrono, for which <code>%f</code> represents nanoseconds <a href="#fr-1-1">‚Ü©</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="mathematical-functions"><a class="header" href="#mathematical-functions">Mathematical functions</a></h1>
<p>These are all the functions defined in the <code>math</code> module:</p>
<div class="table-wrapper"><table><thead><tr><th>function</th><th>parameters</th><th>description</th></tr></thead><tbody>
<tr><td>abs</td><td><code>col</code></td><td>Absolute value of <code>col</code></td></tr>
<tr><td>acos</td><td><code>col</code></td><td>Arccosine of <code>col</code></td></tr>
<tr><td>asin</td><td><code>col</code></td><td>Arcsine of <code>col</code></td></tr>
<tr><td>atan</td><td><code>col</code></td><td>Arctangent of <code>col</code></td></tr>
<tr><td>ceil</td><td><code>col</code></td><td>Rounds the number up of <code>col</code></td></tr>
<tr><td>cos</td><td><code>col</code></td><td>Cosine of <code>col</code></td></tr>
<tr><td>degrees</td><td><code>col</code></td><td>Converts radians to degrees</td></tr>
<tr><td>exp</td><td><code>col</code></td><td>Exponential of <code>col</code></td></tr>
<tr><td>floor</td><td><code>col</code></td><td>Rounds the number down</td></tr>
<tr><td>ln</td><td><code>col</code></td><td>Natural logarithm of <code>col</code></td></tr>
<tr><td>log</td><td><code>b</code> <code>col</code></td><td><code>b</code>-log of <code>col</code></td></tr>
<tr><td>log10</td><td><code>col</code></td><td>10-log of <code>col</code></td></tr>
<tr><td>pi</td><td></td><td>The constant œÄ</td></tr>
<tr><td>pow</td><td><code>b</code> <code>col</code></td><td>Computes <code>col</code> to the power <code>b</code></td></tr>
<tr><td>radians</td><td><code>col</code></td><td>Converts degrees to radians</td></tr>
<tr><td>round</td><td><code>n</code> <code>col</code></td><td>Rounds <code>col</code> to <code>n</code> decimal places</td></tr>
<tr><td>sin</td><td><code>col</code></td><td>Sin of <code>col</code></td></tr>
<tr><td>sqrt</td><td><code>col</code></td><td>Square root of <code>col</code></td></tr>
<tr><td>tan</td><td><code>col</code></td><td>Tangent of <code>col</code></td></tr>
</tbody></table>
</div>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<div class="comparison">
<div>
<h4 id="prql-126"><a class="header" href="#prql-126">PRQL</a></h4>
<pre><code class="language-prql">from employees
select {
  age_squared = age | math.pow 2
}
</code></pre>
</div>
<div>
<h4 id="sql-123"><a class="header" href="#sql-123">SQL</a></h4>
<pre><code class="language-sql">SELECT
  POW(age, 2) AS age_squared
FROM
  employees

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-functions"><a class="header" href="#text-functions">Text functions</a></h1>
<p>These are all the functions defined in the <code>text</code> module:</p>
<div class="table-wrapper"><table><thead><tr><th>function</th><th>parameters</th><th>description</th></tr></thead><tbody>
<tr><td>contains</td><td><code>sub</code> <code>col</code></td><td>Returns true if <code>col</code> contains <code>sub</code></td></tr>
<tr><td>ends_with</td><td><code>sub</code> <code>col</code></td><td>Returns true if <code>col</code> ends with <code>sub</code></td></tr>
<tr><td>extract</td><td><code>idx</code> <code>len</code> <code>col</code></td><td>Extracts a substring at the index <code>idx</code> (starting at 1) with the length <code>len</code></td></tr>
<tr><td>length</td><td><code>col</code></td><td>Returns the number of characters in <code>col</code></td></tr>
<tr><td>lower</td><td><code>col</code></td><td>Converts <code>col</code> to lower case</td></tr>
<tr><td>ltrim</td><td><code>col</code></td><td>Removes all the whitespaces from the left side of <code>col</code></td></tr>
<tr><td>replace</td><td><code>before</code> <code>after</code> <code>col</code></td><td>Replaces any occurrences of <code>before</code> with <code>after</code> in <code>col</code></td></tr>
<tr><td>rtrim</td><td><code>col</code></td><td>Removes all the whitespaces from the right side of <code>col</code></td></tr>
<tr><td>starts_with</td><td><code>sub</code> <code>col</code></td><td>Returns true if <code>col</code> starts with <code>sub</code></td></tr>
<tr><td>trim</td><td><code>col</code></td><td>Removes all the whitespaces from both sides of <code>col</code></td></tr>
<tr><td>upper</td><td><code>col</code></td><td>Converts <code>col</code> to upper case</td></tr>
</tbody></table>
</div>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<div class="comparison">
<div>
<h4 id="prql-127"><a class="header" href="#prql-127">PRQL</a></h4>
<pre><code class="language-prql">from employees
select {
  last_name | text.lower | text.starts_with("a"),
  title | text.replace "manager" "chief"
}
</code></pre>
</div>
<div>
<h4 id="sql-124"><a class="header" href="#sql-124">SQL</a></h4>
<pre><code class="language-sql">SELECT
  LOWER(last_name) LIKE CONCAT('a', '%'),
  REPLACE(title, 'manager', 'chief')
FROM
  employees

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-remove-duplicates"><a class="header" href="#how-do-i-remove-duplicates">How do I: remove duplicates?</a></h1>
<p>PRQL doesn‚Äôt have a specific <code>distinct</code> keyword. Instead duplicate tuples in a relation can be removed by using <code>group</code> and <code>take 1</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-128"><a class="header" href="#prql-128">PRQL</a></h4>
<pre><code class="language-prql">from employees
select department
group employees.* (
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-125"><a class="header" href="#sql-125">SQL</a></h4>
<pre><code class="language-sql">SELECT
  DISTINCT department
FROM
  employees

</code></pre>
</div>
</div>
<p>This also works with a wildcard:</p>
<div class="comparison">
<div>
<h4 id="prql-129"><a class="header" href="#prql-129">PRQL</a></h4>
<pre><code class="language-prql">from employees
group employees.* (take 1)
</code></pre>
</div>
<div>
<h4 id="sql-126"><a class="header" href="#sql-126">SQL</a></h4>
<pre><code class="language-sql">SELECT
  DISTINCT *
FROM
  employees

</code></pre>
</div>
</div>
<h2 id="remove-duplicates-from-each-group"><a class="header" href="#remove-duplicates-from-each-group">Remove duplicates from each group?</a></h2>
<p>To <a href="https://stackoverflow.com/questions/3800551/select-first-row-in-each-group-by-group">select a single row from each group</a> <code>group</code> can be combined with <code>sort</code> and <code>take</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-130"><a class="header" href="#prql-130">PRQL</a></h4>
<pre><code class="language-prql"># youngest employee from each department
from employees
group department (
  sort age
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-127"><a class="header" href="#sql-127">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    ROW_NUMBER() OVER (
      PARTITION BY department
      ORDER BY
        age
    ) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  _expr_0 &lt;= 1

</code></pre>
</div>
</div>
<p>Note that we can‚Äôt always compile to <code>DISTINCT</code>; when the columns in the <code>group</code> aren‚Äôt all the available columns, we need to use a window function:</p>
<div class="comparison">
<div>
<h4 id="prql-131"><a class="header" href="#prql-131">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {first_name, last_name} (take 1)
</code></pre>
</div>
<div>
<h4 id="sql-128"><a class="header" href="#sql-128">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    ROW_NUMBER() OVER (PARTITION BY first_name, last_name) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  _expr_0 &lt;= 1

</code></pre>
</div>
</div>
<!-- TODO: uncomment when the bug is fixed -->
<!-- When compiling to Postgres or DuckDB dialect, such queries will be compiled to
`DISTINCT ON`, which is
[the most performant option](https://stackoverflow.com/a/7630564).

```prql
prql target:sql.postgres

from employees
group department (
  sort age
  take 1
)
``` -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="specification"><a class="header" href="#specification">Specification</a></h1>
<p>This chapter explains PRQL‚Äôs semantics: how expressions are interpreted and their meaning. It‚Äôs intended for advanced users and compiler contributors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-handling"><a class="header" href="#null-handling">Null handling</a></h1>
<p>SQL has an unconventional way of handling <code>NULL</code> values, since it treats them as unknown values. As a result, in SQL:</p>
<ul>
<li><code>NULL</code> is not a value indicating a missing entry, but a placeholder for anything possible,</li>
<li><code>NULL = NULL</code> evaluates to <code>NULL</code>, since one cannot know if one unknown is equal to another unknown,</li>
<li><code>NULL &lt;&gt; NULL</code> evaluates to <code>NULL</code>, using same logic,</li>
<li>to check if a value is <code>NULL</code>, SQL introduces <code>IS NULL</code> and <code>IS NOT NULL</code> operators,</li>
<li><code>DISTINCT column</code> may return multiple <code>NULL</code> values.</li>
</ul>
<p>For more information, check out the <a href="https://www.postgresql.org/docs/current/functions-comparison.html">Postgres documentation</a>.</p>
<p>PRQL, on the other hand, treats <code>null</code> as a value, which means that:</p>
<ul>
<li><code>null == null</code> evaluates to <code>true</code>,</li>
<li><code>null != null</code> evaluates to <code>false</code>,</li>
<li>distinct column cannot contain multiple <code>null</code> values.</li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-132"><a class="header" href="#prql-132">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter first_name == null
filter null != last_name
</code></pre>
</div>
<div>
<h4 id="sql-129"><a class="header" href="#sql-129">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  first_name IS NULL
  AND last_name IS NOT NULL

</code></pre>
</div>
</div>
<p>Note that PRQL doesn‚Äôt change how <code>NULL</code> is compared between columns, for example in joins. (PRQL compiles to SQL and so can‚Äôt change the behavior of the database).</p>
<p>For more context or to provide feedback check out the discussion on <a href="https://github.com/PRQL/prql/issues/99">issue #99</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="name-resolution"><a class="header" href="#name-resolution">Name resolution</a></h1>
<p>Because PRQL primarily handles relational data, it has specialized scoping rules for referencing columns.</p>
<h2 id="scopes"><a class="header" href="#scopes">Scopes</a></h2>
<p>In PRQL‚Äôs compiler, a scope is the collection of all names one can reference from a specific point in the program.</p>
<p>In PRQL, names in the scope are composed from namespace and variable name which are separated by a dot, similar to SQL. Namespaces can contain many dots, but variable names cannot.</p>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>Example</p>
</div>
<a class="admonition-anchor-link" href="reference/spec/name-resolution.html#admonition-example"></a>
</div>
<div>
<p>Name <code>my_table.some_column</code> is a variable <code>some_column</code> from namespace <code>my_table</code>.</p>
<p>Name <code>foo.bar.baz</code> is a variable <code>baz</code> from namespace <code>foo.bar</code>.</p>
</div>
</div>
<p>When processing a query, a scope is maintained and updated for each point in the query.</p>
<p>It start with only namespace <code>std</code>, which is the standard library. It contains common functions like <code>sum</code> or <code>count</code>, along with all transform functions such as <code>derive</code> and <code>group</code>.</p>
<p>In pipelines (or rather in transform functions), scope is also injected with namespaces of tables which may have been referenced with <code>from</code> or <code>join</code> transforms. These namespaces contain simply all the columns of the table and possibly a wildcard variable, which matches any variable (see the algorithm below). Within transforms, there is also a special namespace that does not have a name. It is called a <em>‚Äúframe‚Äù</em> and it contains columns of the current table the transform is operating on.</p>
<h2 id="resolving"><a class="header" href="#resolving">Resolving</a></h2>
<p>For each ident we want to resolve, we search the scope‚Äôs items in order. One of three things can happen:</p>
<ul>
<li>
<p>Scope contains an exact match, e.g. a name that matches in namespace and the variable name.</p>
</li>
<li>
<p>Scope does not contain an exact match, but the ident did not specify a namespace, so we can match a namespace that contains a <code>*</code> wildcard. If there‚Äôs a single namespace, the matched namespace is also updated to contain this new variable name.</p>
</li>
<li>
<p>Otherwise, the nothing is matched and an error is raised.</p>
</li>
</ul>
<h2 id="translating-to-sql"><a class="header" href="#translating-to-sql">Translating to SQL</a></h2>
<p>When translating into an SQL statement which references only one table, there is no need to reference column names with table prefix.</p>
<div class="comparison">
<div>
<h4 id="prql-133"><a class="header" href="#prql-133">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-130"><a class="header" href="#sql-130">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<p>But when there are multiple tables and we don‚Äôt have complete knowledge of all table columns, a column without a prefix (i.e. <code>first_name</code>) may actually reside in multiple tables. Because of this, we have to use table prefixes for all column names.</p>
<div class="comparison">
<div>
<h4 id="prql-134"><a class="header" href="#prql-134">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {first_name, dept_id}
join d=departments (==dept_id)
select {first_name, d.title}
</code></pre>
</div>
<div>
<h4 id="sql-131"><a class="header" href="#sql-131">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.first_name,
  d.title
FROM
  employees
  JOIN departments AS d ON employees.dept_id = d.dept_id

</code></pre>
</div>
</div>
<p>As you can see, <code>employees.first_name</code> now needs table prefix, to prevent conflicts with potential column with the same name in <code>departments</code> table. Similarly, <code>d.title</code> needs the table prefix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/spec/modules.html#admonition-warning"></a>
</div>
<div>
<p>The <code>module</code> facility is in discussion. This page documents our understanding of the way the final PRQL compiler will likely work. The PRQL compiler currently uses these techniques to compile the <code>std</code>, <code>date</code>, <code>text</code>, and <code>math</code> modules into the language.</p>
<p>However, at this time (Spring 2024), the <code>module</code> facility does not work within a PRQL query itself. That is, a <code>module</code> statement in a query cannot import files from the local file system.</p>
</div>
</div>
<p>Design goals for <strong>modules</strong>:</p>
<ol>
<li>
<p>Allow importing declarations from other files.</p>
</li>
<li>
<p>Have namespaces for things like <code>std</code>.</p>
</li>
<li>
<p>Have a hierarchical structure so we can represent files in directories.</p>
</li>
<li>
<p>Have an unambiguous module structure within a project.</p>
</li>
</ol>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>A module is a namespace that contains declarations. A module is itself a declaration, which means that it can contain nested child modules.</p>
<p>This means that modules form a <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">tree graph</a>, which we call ‚Äúthe module structure‚Äù.</p>
<p>For the sake of this document, we will express the module structure with <code>module</code> keyword and a code block encased in curly braces:</p>
<pre><code>module my_playlists {
    let bangers = ... # a declaration

    module soundtracks {
        let movie_albums = ... # another declaration
    }
}
</code></pre>
<blockquote>
<p>The syntax <code>module name { ...decls... }</code> is not part of PRQL language, with the objection that it is unnecessary as it only adds more ways of defining modules. If a significant upside of this syntax is found, it may be added in the future.</p>
</blockquote>
<h2 id="name-resolution-1"><a class="header" href="#name-resolution-1">Name resolution</a></h2>
<p>Any declarations within a module can be referenced from the outside of the module:</p>
<pre><code class="language-prql no-eval"># using module structure declared above
module my_playlists

let great_tracks = my_playlists.bangers

let movie_scores = my_playlists.soundtracks.movie_albums
</code></pre>
<p>Identifiers are resolved relative to current module.</p>
<pre><code class="language-prql no-eval">module my_playlists {
    module soundtracks {
        let movie_albums = (from albums | filter id == 3)
    }

    from soundtracks.movie_albums
}
from my_playlists.soundtracks.movie_albums
</code></pre>
<p>If an identifier cannot be resolved relative to the current module, it tries to resolve relative to the parent module. This is repeated, stepping up the module hierarchy until a match is found or root of the module structure is reached.</p>
<pre><code class="language-prql no-eval">module my_playlists {
    let decl_1 = ...

    module soundtracks {
        let decl_2 = ...
    }

    module upbeat_rock {
        let decl_3 = ...

        from decl_1 | join soundtracks.decl2 | join decl_3
    }
}
</code></pre>
<h2 id="main-var-declaration"><a class="header" href="#main-var-declaration">Main var declaration</a></h2>
<p>The final variable declaration in a module can omit the leading <code>let main =</code> and acquire an implicit name main.</p>
<pre><code>module my_playlists {
    let bangers = (from tracks | take 10)

    from playlists | take 10
}

let album_titles = my_playlists.main
</code></pre>
<p>When a module is referenced as a value, the <code>main</code> variable is used instead. This is especially useful when referring to a module which is to be compiled to RQ (and later SQL).</p>
<pre><code># last line from previous example could thus be shortened to:
let album_titles = my_playlists
</code></pre>
<h2 id="file-importing"><a class="header" href="#file-importing">File importing</a></h2>
<div id="admonition-warning-1" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-1-title">
<div class="admonition-title">
<div id="admonition-warning-1-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/spec/modules.html#admonition-warning-1"></a>
</div>
<div>
<p>The examples below do <strong>not</strong> work. At this time (Spring 2024), the <code>module</code> facility does not work within a PRQL query itself. That is, a <code>module</code> statement in a query cannot import files from the local file system.</p>
</div>
</div>
<p>To include PRQL source code from other files, we can use the following syntax:</p>
<pre><code>module my_playlists
</code></pre>
<p>This loads either <code>./my_playlists.prql</code> (a leaf module) or <code>./my_playlists/_my_playlists.prql</code> (a directory module) and uses its contents as module <code>my_playlists</code>. If none or both of the files are present, a compilation error is raised.</p>
<p>Only directory modules can contain module declarations. If a leaf module contains a module declaration, a compilation error is raised, suggesting the leaf module to be converted into a directory module. This is a step toward any module structure having a single ‚Äúnormalized‚Äù representation in the file system. Such normalization is desired because it restrains the possible file system layouts to a comprehensible and predictable layout, while not sacrificing any functionality.</p>
<p>Described importing rules don‚Äôt achieve this ‚Äúsingle normalized representation‚Äù in full, since any leaf modules could be replaced by a directory module with zero submodules, without any semantic changes. Restricting directory modules to have at least one sub-module would not improve approachability enough to justify adding this restriction.</p>
<p>For example, the following module structure is annotated with files names in which the modules would reside:</p>
<pre><code class="language-prql no-eval">
module my_project {
    # _my_project.prql

    module sales {
        # sales.prql
    }

    module projections {
        # projections/_projections.prql

        module year_2023 {
            # projections/year_2023.prql
        }

        module year_2024 {
            # projections/year_2024.prql
        }
    }
}
</code></pre>
<p>If module <code>my_project.sales</code> wants to add a submodule <code>util</code>, it has to be converted to a directory modules. This means that it has to be moved to <code>sales/_sales.prql</code>. The new module would reside in <code>sales/util.prql</code>.</p>
<p>The annotated layout is not the only possible layout for this module structure, since any of the modules <code>sales</code>, <code>year_2023</code> or <code>year_2024</code> could be converted into a directory module with zero sub-modules.</p>
<p>Point 4 of design goals means that each declaration within a project has a single fully-qualified name within this project. This is ensured by strict rules regarding importing files and the fact that the module structure is a tree.</p>
<h2 id="declaration-order"><a class="header" href="#declaration-order">Declaration order</a></h2>
<p>The order of declarations in a module holds no semantic value, except the ‚Äúlast <code>main</code> variable‚Äù.</p>
<p>References between modules can be cyclic.</p>
<pre><code>module mod_a {
    let decl_a_1 = ...
    let decl_a_2 = (from mod_b.decl_b | take 10)
}
module mod_b {
    let decl_b = (from mod_a.decl_a | take 10)
}
</code></pre>
<p>References between variable declarations cannot be cyclic.</p>
<pre><code>let decl_a = (from decl_b)
let decl_b = (from decl_a) # error: cyclic reference
</code></pre>
<pre><code>module mod_a {
    let decl_a = (from mod_b.decl_b)
}
module mod_b {
    let decl_b = (from mod_a.decl_a) # error: cyclic reference
}
</code></pre>
<h2 id="compiler-interface"><a class="header" href="#compiler-interface">Compiler interface</a></h2>
<p><code>prqlc</code> provides two interfaces for compiling files.</p>
<p><strong>Multi-file interface</strong> requires three arguments:</p>
<ul>
<li>path to the file containing the module which is the root of the module structure,</li>
<li>identifier of the pipeline that should be compiled to RQ (this can also be an identifier of a module that has a <code>main</code> pipeline) and,</li>
<li>a ‚Äúfile loader‚Äù, which can load files on-demand.</li>
</ul>
<p>The path to the root module can be automatically detected by searching for <code>.prql</code> files starting with <code>_</code> in the current working directory.</p>
<p>Example prqlc usage:</p>
<pre><code>$ prqlc compile _project.prql sales.projections.orders_2024
$ prqlc compile sales.projections.orders_2024
</code></pre>
<p><strong>Single-file interface</strong> requires a single argument; the PRQL source. Any attempts to load modules in this mode result in compilation errors. This interface is needed, for example, when integrating the compiler with a database connector (i.e. JDBC) where no other files can be loaded.</p>
<h2 id="built-in-module-structure"><a class="header" href="#built-in-module-structure">Built-in module structure</a></h2>
<blockquote>
<p>As noted above, this facility is in discussion.</p>
</blockquote>
<pre><code># root module of every project
module project {
	module std {
		let sum = a -&gt; ...
		let mean = a -&gt; ...
	}

	module default_db {
		# all inferred tables and defined CTEs
	}

	let main = (
		from t = tracks
		select [track_id, title]
	)
}
</code></pre>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<div id="admonition-warning-2" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-2-title">
<div class="admonition-title">
<div id="admonition-warning-2-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/spec/modules.html#admonition-warning-2"></a>
</div>
<div>
<p>The examples below do <strong>not</strong> work. At this time (Spring 2024), the <code>module</code> facility does not work within a PRQL query itself. That is, a <code>module</code> statement in a query cannot import files from the local file system.</p>
</div>
</div>
<p>This is an example project, where each of code block is a separate file.</p>
<pre><code># _project.prql

module employees
module sales
module util
</code></pre>
<pre><code># employees.prql

let employees = (...)

let salaries = (...)

let departments = (...)
</code></pre>
<pre><code># sales/_sales.prql

module orders
module projections

let revenue_by_source = (...)
</code></pre>
<pre><code># sales/orders.prql

let current_year = (...)

let archived = (...)

let by_employee = (from orders | join employees.employees ...)
</code></pre>
<pre><code># sales/projections.prql

let orders_2023 = (from orders.current_year | append orders.archived)

let orders_2024 = (...)
</code></pre>
<pre><code># util.prql

let pretty_print_num = col -&gt; (...)
</code></pre>
<hr />
<p>Sources:</p>
<ul>
<li><a href="https://matklad.github.io/2021/11/27/notes-on-module-system.html">Notes On Module System</a>, by @matklad.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system"><a class="header" href="#type-system">Type system</a></h1>
<blockquote>
<p>Status: under development</p>
</blockquote>
<blockquote>
<p>The type system determines the allowed values of a term.</p>
</blockquote>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>Each of the SQL DBMSs has their own type system. Thanks to the SQL standard, they are very similar, but have key differences regardless. For example, SQLite does not have a type for date or time or timestamps, but it has functions for handling date and time that take ISO 8601 strings or integers that represent Unix timestamps. So it does support most of what is possible to do with dates in other dialects, even though it stores data with a different physical layout and uses different functions to achieve that.</p>
<p>PRQL‚Äôs task is to define it‚Äôs own description of <em>data formats</em>, just as how it already defines common <em>data transformations</em>.</p>
<p>This is done in two steps:</p>
<ol>
<li>
<p>Define PRQL‚Äôs Type System (PTS), following principles we think a relational language should have (and not fixate on what existing SQL DBMSs have).</p>
</li>
<li>
<p>Define a mapping between SQL Type System (STS) and PTS, for each of the DBMSs. Ideally we‚Äôd want that to be a bijection, so each type in PTS would be represented by a single type in STS and vice-versa. Unfortunately this is not entirely possible, as shown below.</p>
</li>
</ol>
<p>In practical terms, we want for a user to be able to:</p>
<ul>
<li>
<p>‚Ä¶ express types of their database with PRQL (map their STS into PTS). In some cases, we can allow to say ‚Äúyour database is not representable with PRQL, change it or use only a subset of it‚Äù. An example of what we don‚Äôt want to support are arrays with arbitrary indexes in Postgres (i.e. 2-based index for arrays).</p>
<p>This task of mapping to PTS could be automated by LSP server, by introspecting user‚Äôs SQL database and generating PRQL source.</p>
</li>
<li>
<p>‚Ä¶ express their SQL queries in PRQL. Again, using mapping from STS to PTS, one should be able to express any SQL operation in PRQL.</p>
<p>For example, translate MSSQL <code>DATEDIFF</code> to subtraction operator <code>-</code> in PRQL.</p>
<p>For now, this mapping is manual, but should be documented and may be automated.</p>
</li>
<li>
<p>‚Ä¶ use any PRQL feature in their database. Here we are mapping from PTS into an arbitrary STS.</p>
<p>For example, translate PRQL‚Äôs datetime operations to use TEXT in SQLite.</p>
<p>As of now, prqlc already does a good job of automatically doing this mapping.</p>
</li>
</ul>
<p>Example of the mapping between PTS and two STSs:</p>
<div class="table-wrapper"><table><thead><tr><th>PTS</th><th>STS Postgres</th><th>STS SQLite</th></tr></thead><tbody>
<tr><td>int32</td><td>integer</td><td>INTEGER</td></tr>
<tr><td>int64</td><td>bigint</td><td>INTEGER</td></tr>
<tr><td>timestamp</td><td>timestamp</td><td>TEXT</td></tr>
</tbody></table>
</div>
<h2 id="principles"><a class="header" href="#principles">Principles</a></h2>
<p><strong>Algebraic types</strong> - have a way of expressing sum and product types. In Rust, sum would be an enum and product would be tuple or a struct. In SQL, product would be a row, since it can contain different types, all at once. Sum would be harder to express, see (this post)[https://www.parsonsmatt.org/2019/03/19/sum_types_in_sql.html ].</p>
<p>The value proposition here is that algebraic types give a lot modeling flexibility, all while being conceptually simple.</p>
<p><strong>Composable</strong> - as with transformation, we‚Äôd want types to compose together.</p>
<p>Using Python, JavaScript, C++ or Rust, one could define many different data structures that would correspond to our idea of ‚Äúrelation‚Äù. Most of them would be an object/struct that has column names and types and then a generic array of arrays for rows.</p>
<p>PRQL‚Äôs type system should also be able to express relations as composed from primitive types, but have only one idiomatic way of doing so.</p>
<p>In practice, this means that builtin types include only primitives (int, text, bool, float), tuple (for product), enum (for sum) and array (for repeating). An SQL row translates to a tuple, and a relation translates to an array of tuples.</p>
<p>Composability also leads to a minimal type system, which does not differentiate between tuples, objects and structs. A single product type is enough.</p>
<p><strong>No subtyping</strong> - avoid super types and inheritance.</p>
<p>Subtyping is a natural extension to a type system, where a type can be a super type of some other type. This is base mechanism for Object Oriented Programming, but is also present in most dynamically types languages. For example, a type <code>number</code> might be super type of <code>int</code> and <code>float</code>.</p>
<p>PTS does not have subtyping, because it requires dynamic dispatch and because it adds unnecessary complexity to generic type arguments.</p>
<p>Dynamic dispatch, is a mechanism that would be able, for example, to call appropriate <code>to_string</code> function for each element of an array of <code>number</code>. This array contains both elements of type <code>int</code> and type <code>float</code>, with different <code>to_string</code> implementations.</p>
<!--
> This segment was part of initial type system proposal.
> I still do believe it would be useful and possible to implement,
> but it should be updated to latest TS changes.

**Type constraints** - constrain a type with a predicate. For example, have a
type of `int64`s that are equal or greater than 10. Postgres
[does support this](https://news.ycombinator.com/item?id=34835063). The primary
value of using constrained types would not be validation (as it is used in
linked article), but when matching the type.

Say, for example, that we have a pipeline like this:

```
derive color = switch [x => 'red', true => 'green']
derive is_red = switch [color == 'red' => true, color == 'green' => false]
```

It should be possible to infer that `color` is of type `text`, but only when
equal to `'red'` or `'green'`. This means that the second switch covers all
possible cases and `is_red` cannot be `null`.
-->
<h2 id="definition-1"><a class="header" href="#definition-1">Definition</a></h2>
<blockquote>
<p>For any undefined terms used in this section, refer to set theory and mathematical definitions in general.</p>
</blockquote>
<p>A ‚Äútype of a variable‚Äù is a ‚Äúset of all possible values of that variable‚Äù.</p>
<h3 id="primitives"><a class="header" href="#primitives">Primitives</a></h3>
<p>At the moment of writing, PRQL defines following primitive types: <code>int</code>, <code>float</code>, <code>bool</code>, <code>text</code>, <code>date</code>, <code>time</code> and <code>timestamp</code>. New primitive types will be added in the future and some of existing types might be split into smaller subsets (see section ‚ÄúSplitting primitives‚Äù).</p>
<h3 id="tuples-1"><a class="header" href="#tuples-1">Tuples</a></h3>
<p>Tuple type is a product type.</p>
<p>It contains n ordered fields, where n is known at compile-time. Each field has a type itself and an optional name. Fields are not necessarily of the same type.</p>
<p>In other languages, similar constructs are named record, struct, tuple, named tuple or (data)class.</p>
<pre><code>type my_row = {id = int, bool, name = str}
</code></pre>
<h3 id="arrays-1"><a class="header" href="#arrays-1">Arrays</a></h3>
<p>Array is a container type that contains n ordered fields, where n is not known at compile-time. All fields are of the same type and cannot be named.</p>
<pre><code>type array_of_int = [int]
</code></pre>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<pre><code>type floor_signature = func float -&gt; int
</code></pre>
<h3 id="union"><a class="header" href="#union">Union</a></h3>
<pre><code>type status = (
  paid = () ||
  unpaid = float ||
  {reason = text, cancelled_at = timestamp} ||
)
</code></pre>
<p>This is ‚Äúa sum type‚Äù.</p>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type annotations</a></h2>
<p>Variable annotations and function parameters may specify type annotations:</p>
<pre><code>let a &lt;t&gt; = x
</code></pre>
<p>The value of <code>x</code> (and thus <code>a</code>) must be an element of <code>t</code>.</p>
<pre><code>let my_func = func x &lt;t&gt; -&gt; y
</code></pre>
<p>The value of argument supplied to <code>x</code> must be an element of <code>t</code>.</p>
<pre><code>let my_func = func x -&gt; &lt;t&gt; y
</code></pre>
<p>The value of function body <code>y</code> must be an element of <code>t</code>.</p>
<h2 id="physical-layout"><a class="header" href="#physical-layout">Physical layout</a></h2>
<p><em>Logical type</em> is user-facing the notion of a type that is the building block of the type system.</p>
<p><em>Physical layout</em> is the underlying memory layout of the data represented by a variable.</p>
<p>In many programming languages, physical layout of a logical type is dependent on the target platform. Similarly, physical layout of a PRQL logical type is dependent on representation of that type in the target STS.</p>
<pre><code>PTS logical type  ---&gt;  STS logical type  ---&gt; STS physical layout
</code></pre>
<p>Note that not all STS types do not have a single physical layout. Postgres has a logical (pseudo)type <code>anyelement</code>, which is a super type of any data type. It can be used as a function parameter type, but does not have a single physical layout so it cannot be used in a column declaration.</p>
<p>For now, PRQL does not define physical layouts of any type. It is not needed since PRQL is not used for DDL (see section ‚ÄúSplitting primitives‚Äù) or does not support raw access to underlying memory.</p>
<p>As a consequence, results of a PRQL query cannot be robustly compared across DBMSs, since the physical layout of the result will vary.</p>
<p>In the future, PRQL may define a common physical layout of types, probably using Apache Arrow.</p>
<h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<pre><code>type my_relation = [{
	id = int,
	title = text,
	age = int
}]

type invoices = [{
    invoice_id = int64,
    issued_at = timestamp,
    labels = [text]

    #[repr(json)]
    items = [{
        article_id = int64,
        count = int16 where x -&gt; x &gt;= 1,
    }],
    paid_by_user_id = (int64 || null),
}]
</code></pre>
<h2 id="appendix"><a class="header" href="#appendix">Appendix</a></h2>
<h3 id="splitting-primitives"><a class="header" href="#splitting-primitives">Splitting primitives</a></h3>
<p>This document mentions <code>int32</code> and <code>int64</code> as distinct types, but there is no need for that in the initial implementation. The built-in <code>int</code> can associate with all operations on integers and translate PRQL to valid SQL regardless of the size of the integer. Later, <code>int</code> cam be replaced by <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>.</p>
<p>The general rule for ‚Äúwhen to make a distinction between types‚Äù would be ‚Äúas soon as the types carry different information and we find an operation that would be expressed differently‚Äù. In this example, that would require some operation on <code>int32</code> to have different syntax than same operation over <code>int64</code>.</p>
<p>We can have such relaxed rule because PRQL is not aiming to be a Data Definition Language and does not have to bother with exact physical layout of types.</p>
<h3 id="type-representations"><a class="header" href="#type-representations">Type representations</a></h3>
<p>There are cases where a PTS type has multiple possible and valid representations in some STSs.</p>
<p>For such cases, we‚Äôd want to support the use of alternative representations for storing data, but also application of any function that is defined for the original type.</p>
<p>Using SQLite as an example again, users may have some temporal data stored as INTEGER unix timestamp and some as TEXT that contains ISO 8601 without timezone. From the user‚Äôs perspective, both of these types are <code>timestamp</code>s and should be declared as such. But when compiling operations over these types to SQL, the compiler should consider their different representations in STS. For example a difference between two timestamps <code>timestamp - timestamp</code> can be translated to a normal int subtraction for INTEGER repr, but must apply SQLite‚Äôs function <code>unixepoch</code> when dealing with TEXT repr.</p>
<p>Table declarations should therefore support annotations that give hints about which representation is used:</p>
<pre><code>table foo {
    #[repr(text)]
    created_at: timestamp,
}
</code></pre>
<p>A similar example is an ‚Äúarray of strings type‚Äù in PTS that could be represented by a <code>text[]</code> (if DBMS supports arrays) or <code>json</code> or it‚Äôs variant <code>jsonb</code> in Postgres. Again, the representation would affect operators: in Postgres, arrays would be accessed with <code>my_array[1]</code> and json arrays would use <code>my_json_array -&gt; 1</code>. This example may not be applicable, if we decide that we want a separate JSON type in PST.</p>
<h3 id="rq-functions-targets-and-reprs"><a class="header" href="#rq-functions-targets-and-reprs">RQ functions, targets and reprs</a></h3>
<blockquote>
<p>This part is talks about technical implementations, not the language itself</p>
</blockquote>
<h4 id="idea"><a class="header" href="#idea">Idea</a></h4>
<p>RQ contains a single node kind for expressing operations and functions: BuiltInFunction (may be renamed in the future).</p>
<p>It is a bottleneck that we can leverage when trying to affect how an operator or a function interacts with different type representations on different targets.</p>
<p>Idea is to implement the BuiltInFunction multiple times and annotate it with it intended target and parameter representation. Then we can teach the compiler to pick the appropriate function implementation that suit current repr and compilation target.</p>
<h4 id="specifics"><a class="header" href="#specifics">Specifics</a></h4>
<p>RQ specification is an interface that contains functions, identified by name (i.e. <code>std.int8.add</code>). These functions have typed parameters and a return value. If an RQ function call does not match the function declaration in number or in types of the parameters, this is considered an invalid RQ AST.</p>
<p>We provide multiple implementations for each RQ function. They are annotated with a target (i.e. <code>#[target(sql.sqlite)]</code>) and have their params annotated with type reprs (i.e. <code>#[repr(int)]</code>).</p>
<pre><code># using a made-up syntax

#[target(sql.sqlite)]
func std.int8.add
    #[repr(int8)] x
    #[repr(int8)] y
    -&gt; s"{x} + {y}"
</code></pre>
<p>Each RQ type has one canonical repr that serves as the reference implementation for other reprs and indicates the amount of contained data (i.e. 1 bit, 8 bits, 64 bits).</p>
<h4 id="example-4"><a class="header" href="#example-4">Example</a></h4>
<p>Let‚Äôs say for example, that we‚Äôd want to support 8bit integer arithmetic, and that we‚Äôd want the result of <code>127 + 1</code> to be <code>-128</code> (ideally we‚Äôd handle this better, but bear with me for the sake of the example). Because some RDBMSs don‚Äôt support 8bit numbers and do all their integer computation with 64bit numbers (SQLite), we need to implement an alternative type representation for that target.</p>
<p>The logical type <code>int8</code> could have the following two reprs:</p>
<ul>
<li>canonical <code>repr_int8</code> that contains 8 bits in two‚Äôs complement, covering integer values in range -128 to 127 (inclusive),</li>
<li><code>repr_int64</code> that contains 64 bits of data, but is using only the values that are also covered by <code>repr_int8</code>.</li>
</ul>
<p>Now we‚Äôd implement function <code>std.int8.add</code> for each of the reprs. Let‚Äôs assume that the <code>int8</code> implementation is straightforward and that databases don‚Äôt just change the data type when a number overflows. The impl for <code>int64</code> requires a CASE statement that checks if the value would overflow and subtact 256 in that case.</p>
<p>The goal here is that the results of the two impls are equivalent. To validate that, we also need a way to convert between the reprs, or another <code>to_string</code> function, implemented for both reprs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-changelog"><a class="header" href="#prql-changelog">PRQL Changelog</a></h1>
<h2 id="0122--2024-06-10"><a class="header" href="#0122--2024-06-10">0.12.2 ‚Äî 2024-06-10</a></h2>
<p>0.12.2 is a very small release which renames <code>prql-js</code> to <code>prqlc-js</code> to match our standard naming scheme. Within node the package is imported as <code>prqlc</code>.</p>
<p>It also fixes a mistake in the <code>prqlc-python</code> release pipeline.</p>
<h2 id="0121--2024-06-09"><a class="header" href="#0121--2024-06-09">0.12.1 ‚Äî¬†2024-06-09</a></h2>
<p>0.12.1 is a tiny hotfix release which fixes how intra-prql crate dependencies were specified.</p>
<h2 id="0120--2024-06-08"><a class="header" href="#0120--2024-06-08">0.12.0 ‚Äî 2024-06-08</a></h2>
<p>0.12.0 contains a few months of smaller features. Our focus has been on rewriting the resolver, an effort that is still ongoing.</p>
<p>It has 239 commits from 12 contributors. Selected changes (most are not listed here, possibly we should be more conscientious about adding them‚Ä¶):</p>
<p><strong>Features</strong>:</p>
<ul>
<li>Add <code>prqlc lex</code> command to the CLI (@max-sixty)</li>
<li>Add <code>prqlc debug lineage</code> command to the CLI, creating an expression lineage graph from a query (@kgutwin, #4533)</li>
<li>Initial implementation of an experimental documentation generator that generates Markdown documentation from <code>.prql</code> files. (@vanillajonathan, #4152).</li>
<li>Join‚Äôs <code>side</code> parameter can take a reference that resolves to a literal (note: this is an experimental feature which may change in the future) (@kgutwin, #4499)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Support expressions on left hand side of <code>std.in</code> operator. (@kgutwin, #4498)</li>
<li>Prevent panic for <code>from {}</code> and <code>std</code> (@m-span, #4538)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>The <code>browser</code> dist files are now built with <code>wasm-pack</code>‚Äôs <code>web</code> target. As a result, they should be usable as ES Modules, through JS CDNs, and for example with Observable Framework (@srenatus, #4274).</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li>The syntax highlighter package for Sublime Text is now <a href="https://packagecontrol.io/packages/PRQL">published</a> (@vanillajonathan).</li>
<li>The <a href="https://marketplace.visualstudio.com/items?itemName=emmanuelbeziat.vscode-great-icons">VSCode Great Icons</a> icon pack extension shows a database icon for <code>.prql</code> files. (@EmmanuelBeziat)</li>
<li><a href="https://github.com/XAMPPRocky/tokei">Tokei</a>, a source lines of code counter now has support for <code>.prql</code> files. (@vanillajonathan)</li>
<li>Add syntax highlight file for the <a href="https://micro-editor.github.io/">micro</a> text editor. (@vanillajonathan)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@srenatus, with #4274</li>
<li>@jacquayj, with #4332</li>
<li>@pdelewski, with #4337</li>
<li>@m-span, with #4422</li>
<li>@kgutwin, with #4498</li>
</ul>
<h2 id="0114--2024-02-25"><a class="header" href="#0114--2024-02-25">0.11.4 ‚Äî 2024-02-25</a></h2>
<p>0.11.4 is a hotfix release, fixing a CI issue that caused the CLI binaries to be built without the <code>cli</code> feature.</p>
<h2 id="0113--2024-02-10"><a class="header" href="#0113--2024-02-10">0.11.3 ‚Äî 2024-02-10</a></h2>
<p>0.11.3 is a very small release, mostly a rename of the Python bindings.</p>
<p>The release has 13 commits from 4 contributors.</p>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>As part of making our names more consistent, the Python bindings are renamed. <code>prql-python</code> becomes a package published and importable as <code>prqlc</code>. The internal Rust crate is named <code>prqlc-python</code>.</li>
</ul>
<h2 id="0112--2024-02-07"><a class="header" href="#0112--2024-02-07">0.11.2 ‚Äî 2024-02-07</a></h2>
<p>0.11.2 contains lots of internal changes, lots of syntax highlighting, and the beginning of <code>lutra</code>, a query runner.</p>
<p>This release has 122 commits from 9 contributors. Selected changes:</p>
<p><strong>Features</strong>:</p>
<ul>
<li>Initial implementation of <code>lutra</code>, a query runner. (@aljazerzen, #4182, #4174, #4134)</li>
<li><code>prqlc fmt</code> works on projects with multiple files. (@max-sixty, #4028)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Reduce stack memory usage (@aljazerzen, #4103)</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li>Add syntax highlight file for GtkSourceView. (@vanillajonathan, #4062)</li>
<li>Add syntax highlight file for CotEditor. (@vanillajonathan)</li>
<li>Add syntax highlight file for Sublime Text. (@vanillajonathan, #4127)</li>
<li><a href="https://github.com/flosse/sloc">sloc</a>, a source lines of code counter now has support for <code>.prql</code> files. (@vanillajonathan)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li><code>prql-compiler</code> has been renamed to <code>prqlc</code>, and we‚Äôve established a more consistent naming scheme. The existing crate will still be published, re-exporting <code>prqlc</code>, so no dependencies will break. A future version will add a deprecation warning.</li>
<li>The <code>prqlc-clib</code> crate was renamed to <code>prqlc-c</code>, and associated artifacts were renamed. We‚Äôre trying to make names consistent (ideally for the final time!), and have a plan to rename some other bindings. (@max-sixty, #4077)</li>
<li>Add lots of whitespace items to the lexer, in preparation for the completion of <code>prqlc fmt</code> (@max-sixty, #4109, #4105)</li>
<li>Table declarations (@aljazerzen, #4126)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@kaspermarstal, with #4124</li>
</ul>
<h2 id="0111--2023-12-26"><a class="header" href="#0111--2023-12-26">0.11.1 ‚Äî 2023-12-26</a></h2>
<p>0.11.1 fixes a couple of small bugs; it comes a few days after 0.11.</p>
<p>This release has 16 commits from 6 contributors. Selected changes:</p>
<p><strong>Features</strong>:</p>
<ul>
<li>Infer the type of array literals to be the union of types of its items. (@aljazerzen, #3989)</li>
<li><code>prql</code> module is added and the <code>prql_version</code> function is renamed to the <code>prql.version</code> function. The old <code>prql_version</code> function is deprecated and will be removed in the future release. (@eitsupi, #4006)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Do not compile to <code>DISTINCT ON</code> when <code>take n</code> is used with <code>group</code> for the targets <code>clickhouse</code>, <code>duckdb</code> and <code>postgres</code>. (@PrettyWood, #3988)</li>
<li>Fix <code>take</code> n rows for <code>mssql</code> dialect by switching from TOP to FETCH (@PrettyWood, #3994)</li>
</ul>
<h2 id="0110--2023-12-19"><a class="header" href="#0110--2023-12-19">0.11.0 ‚Äî 2023-12-19</a></h2>
<p>0.11.0 introduces new <code>date</code>, <code>text</code> &amp; <code>math</code> modules with lots of standard functions, including a new <code>date.to_text</code> function. It contains a few bugs fixes, and lots of internal improvements to the compiler.</p>
<p>This release has 119 commits from 9 contributors. Selected changes:</p>
<p><strong>Language</strong>:</p>
<ul>
<li><em>Breaking</em>: <code>group</code>‚Äôs <code>by</code> columns are now excluded from the partition. (#3490)</li>
<li><em>Breaking</em>: <code>round</code> is now in the <code>math</code> module and needs to be called via <code>math.round</code>. (#3928)</li>
<li><em>Breaking</em>: <code>lower</code> and <code>upper</code> are now in the <code>text</code> module and need to be called via <code>text.lower</code> and <code>text.upper</code>. (#3913, #3973)</li>
</ul>
<p><strong>Features</strong>:</p>
<ul>
<li>The <code>std.in</code> function now supports a list of values (@PrettyWood, #3883)</li>
<li>Most standard mathematical functions are now supported: <code>abs</code>, <code>floor</code>, <code>ceil</code>, <code>pi</code>, <code>exp</code>, <code>ln</code>, <code>log10</code>, <code>log</code>, <code>sqrt</code>, <code>degrees</code>, <code>radians</code>, <code>cos</code>, <code>acos</code>, <code>sin</code>, <code>asin</code>, <code>tan</code>, <code>atan</code>, <code>pow</code> and <code>round</code>.<br />
Those functions are in the <code>math</code> module (@PrettyWood, #3909, #3916 &amp; 3928)</li>
<li>Most standard string functions are now supported: <code>ltrim</code>, <code>rtrim</code>, <code>trim</code>, <code>length</code>, <code>extract</code>, <code>replace</code>. Utility functions <code>starts_with</code>, <code>contains</code> and <code>ends_with</code> are also available.<br />
Those functions are in the <code>text</code> module (@PrettyWood, #3913, #3973)</li>
<li>Formatting a date to a text is now available for Clickhouse, DuckDB, MySQL, MSSQL and Postgres. A new <code>date</code> module has been added with the <code>to_text</code> function (@PrettyWood, #3951, #3954 &amp; #3955)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Fix an issue with arithmetic precedence (@max-sixty, #3846)</li>
<li><code>+</code> and <code>-</code> can be used after a cast (@PrettyWood, #3923)</li>
<li>The <a href="https://lezer.codemirror.net/">Lezer</a> grammar had plenty of improvements and fixes. (@vanillajonathan)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>The Playground now uses <a href="https://vitejs.dev/">Vite</a>. (@vanillajonathan)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>Bump <code>prql-compiler</code>‚Äôs MSRV to 1.70.0 (@eitsupi, #3876)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@PrettyWood, with #3883</li>
</ul>
<h2 id="0101--2023-11-14"><a class="header" href="#0101--2023-11-14">0.10.1 ‚Äî 2023-11-14</a></h2>
<p>0.10.1 is a small release containing some internal fixes of the compiler.</p>
<p>This release has 36 commits from 7 contributors. Selected changes:</p>
<p><strong>Features</strong>:</p>
<ul>
<li>The <code>std.sql.read_csv</code> function and the <code>std.sql.read_parquet</code> function supports the <code>sql.glaredb</code> target. (@eitsupi, #3749)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Fix the bug of compiling to <code>DISTINCT ON</code> when <code>take 1</code> is used with <code>group by</code> for the targets <code>sql.clickhouse</code>, <code>sql.duckdb</code> and <code>sql.postgres</code>. (@aljazerzen, #3792)</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li>Enable integration tests for GlareDB. (@eitsupi, #3749)</li>
<li><a href="https://github.com/trapd00r/LS_COLORS">trapd00r/LS_COLORS</a>, a collection of LS_COLORS definitions colorizes <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://github.com/sharkdp/vivid">vivid</a>, a themeable LS_COLORS generator colorizes <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://github.com/athityakumar/colorls">colorls</a>, displays <code>.prql</code> files with a database icon. (@vanillajonathan)</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=mightbesimon.emoji-icons">Emoji File Icons</a>, a VS Code extension displays <code>.prql</code> files with a database emoji icon. (@vanillajonathan)</li>
<li><a href="https://eza.rocks/">eza</a>, a modern ls replacement colorizes <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://github.com/lsd-rs/lsd">lsd</a>, next gen ls command displays <code>.prql</code> files with a database icon. (@vanillajonathan)</li>
</ul>
<h2 id="0100--2023-10-26"><a class="header" href="#0100--2023-10-26">0.10.0 ‚Äî 2023-10-26</a></h2>
<p>0.10.0 contains lots of small improvements, including support for new types of literal notation, support for <code>read_*</code> functions in more dialects, playground improvements, and a better Lezer grammar (which we‚Äôre planning on using for a Jupyter extension).</p>
<p>This release has 155 commits from 9 contributors. Selected changes:</p>
<p><strong>Language</strong>:</p>
<ul>
<li><em>Breaking:</em> Case syntax now uses brackets <code>[]</code> rather than braces <code>{}</code>. To convert previous PRQL queries to this new syntax simply change <code>case { ... }</code> to <code>case [ ... ]</code>. (@AaronMoat, #3517)</li>
</ul>
<p><strong>Features</strong>:</p>
<ul>
<li><em>Breaking</em>: The <code>std.sql.read_csv</code> function is now compiled to <code>read_csv</code> by default. Please set the target <code>sql.duckdb</code> to use the DuckDB‚Äôs <code>read_csv_auto</code> function as previously. (@eitsupi, #3599)</li>
<li><em>Breaking</em>: The <code>std.every</code> function is renamed to <code>std.all</code> (@aljazerzen, #3703)</li>
<li>The <code>std.sql.read_csv</code> function and the <code>std.sql.read_parquet</code> function supports the <code>sql.clickhouse</code> target. (@eitsupi, #1533)</li>
<li>Add <code>std.prql_version</code> function to return PRQL version (@hulxv, #3533)</li>
<li>A new type <code>anytype</code> is added. (@aljazerzen, #3703)</li>
<li>Add support for hex escape sequences in strings. Example <code>"Hello \x51"</code>. (@vanillajonathan, #3568)</li>
<li>Add support for long Unicode escape sequences. Example <code>"Hello \u{01F422}"</code>. (@vanillajonathan, #3569)</li>
<li>Add support for binary numerical notation. Example <code>filter status == 0b1111000011110000</code>. (@vanillajonathan, #3661)</li>
<li>Add support for hexadecimal numerical notation. Example <code>filter status == 0xff</code>. (@vanillajonathan, #3654)</li>
<li>Add support for octal numerical notation. Example <code>filter status == 0o777</code>. (@vanillajonathan, #3672)</li>
<li>New compile target <code>sql.glaredb</code> for <a href="https://docs.glaredb.com/">GlareDB</a> and integration tests for it (However, there is a bug in the test and it is currently not running). (@universalmind303, @scsmithr, @eitsupi, #3669)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>
<p>Allow cmd-/ (Mac) or ctrl-/ (Windows) to toggle comments in the playground editor (@AaronMoat, #3522)</p>
</li>
<li>
<p>Limit maximum height of the playground editor‚Äôs error panel to avoid taking over whole screen (@AaronMoat, #3524)</p>
</li>
<li>
<p>The playground now uses <a href="https://vitejs.dev/">Vite</a> (@vanillajonathan).</p>
</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li>Add a CLI command <code>prqlc collect</code> to collect a project‚Äôs modules into a single file (@aljazerzen, #3739)</li>
<li>Add a CLI command <code>prqlc debug expand-pl</code> to parse &amp; and expand into PL without resolving (@aljazerzen, #3739)</li>
<li>Bump <code>prqlc</code>‚Äôs MSRV to 1.70.0 (@eitsupi, #3521)</li>
<li><a href="https://pygments.org/">Pygments</a>, a syntax highlighting library now has syntax highlighting for PRQL. (@vanillajonathan, #3564)</li>
<li><a href="https://github.com/alecthomas/chroma">chroma</a>, a syntax highlighting library written in Go and used by the static website generator <a href="https://gohugo.io/">Hugo</a>. (@vanillajonathan, #3597)</li>
<li><a href="https://github.com/boyter/scc">scc</a>, a source lines of code counter now has support for <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://github.com/JoaoDanielRufino/gcloc">gcloc</a> a source lines of code counter now has support for <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://github.com/AlDanial/cloc">cloc</a> a source lines of code counter now has support for <code>.prql</code> files. (@AlDanial)</li>
<li><a href="https://github.com/hhatto/gocloc">gocloc</a> a source lines of code counter now has support for <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=quarto.quarto">The Quarto VS Code extension</a> supports editing PRQL code blocks (<a href="https://prql-lang.org/book/project/bindings/r.html"><code>prqlr</code></a> is required to render Quarto Markdown with PRQL code blocks). (@jjallaire)</li>
</ul>
<p><strong>Internal</strong>:</p>
<ul>
<li>Rename some of the internal crates, and refactored their paths in the repo. (@aljazerzen, #3683).</li>
<li>Add a <code>justfile</code> for developers who prefer that above our <code>Taskfile.yaml</code> (@aljazerzen, #3681)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@hulxv, with #3533</li>
<li>@AaronMoat, with #3522</li>
<li>@jangorecki, with #3634</li>
</ul>
<h2 id="095--2023-09-16"><a class="header" href="#095--2023-09-16">0.9.5 ‚Äî 2023-09-16</a></h2>
<p>0.9.5 adds a line-wrapping character, fixes a few bugs, and improves our CI. The release has 77 commits from 8 contributors. Selected changes are below.</p>
<p>Look out for some conference talks coming up over the next few weeks, including <a href="https://qconsf.com/presentation/oct2023/prql-simple-powerful-pipelined-sql-replacement">QCon SF on Oct 2</a> and <a href="https://www.data2day.de/veranstaltung-21353-0-prql-a-modern-language-for-data-transformation.html">date2day on Oct 12</a>.</p>
<p><strong>Language</strong>:</p>
<ul>
<li>
<p>A new line-wrapping character, for lines that are long and we want to break up into multiple physical lines. This is slightly different from from many languages ‚Äî¬†it‚Äôs on the subsequent line:</p>
<pre><code class="language-prql no-eval">from artists
select is_europe =
\ country == "DE"
\ || country == "FR"
\ || country == "ES"
</code></pre>
<p>This allows for easily commenting out physical lines while maintaining a correct logical line; for example:</p>
<pre><code class="language-diff">from artists
select is_europe =
\ country == "DE"
\ || country == "FR"
\ || country == "FR"
-\ || country == "ES"
+#\ || country == "ES"
</code></pre>
<p>(@max-sixty, #3408)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>
<p>Fix stack overflow on very long queries in Windows debug builds (@max-sixty, #2908)</p>
</li>
<li>
<p>Fix panic when unresolved lineage appears in group or window (@davidot, #3266)</p>
</li>
<li>
<p>Fix a corner-case in handling precedence, and remove unneeded parentheses in some outputs (@max-sixty, #3472)</p>
</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Compiler panics are now printed to the console (@max-sixty, #3446)</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li><a href="https://ace.c9.io/">Ace</a>, the JavaScript code editor now has syntax highlighting for PRQL. (@vanillajonathan, #3493)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>Simplify &amp; speed up lexer (@max-sixty, #3426, #3418)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@davidot, with #3450</li>
</ul>
<h2 id="094--2023-08-24"><a class="header" href="#094--2023-08-24">0.9.4 ‚Äî¬†2023-08-24</a></h2>
<p>0.9.4 is a small release with some improvements and bug fixes in the compiler and <code>prqlc</code>. And, the documentation and CI are continually being improved.</p>
<p>This release has 110 commits from 9 contributors. Selected changes:</p>
<p><strong>Features</strong>:</p>
<ul>
<li>Strings can be delimited with any odd number of quote characters. The logic for lexing quotes is now simpler and slightly faster. Escapes in single-quote-delimited strings escape single-quotes rather than double-quotes. (@max-sixty, #3274)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>S-strings within double braces now parse correctly (@max-sixty, #3265)</li>
</ul>
<p><strong>Documentation</strong>:</p>
<ul>
<li>New docs for strings (@max-sixty, #3281)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Improve syntax highlighting for numbers in the book &amp; website (@max-sixty, #3261)</li>
<li>Add ClickHouse integration to docs (@max-sixty, #3251)</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li><code>prqlc</code> no longer displays a prompt when piping a query into its stdin (@max-sixty, #3248).</li>
<li>Add a minimal example for use <code>prql-lib</code> with Zig (@vanillajonathan, #3372)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>
<p>Overhaul our CI to run a cohesive set of tests depending on the specific changes in the PR, and elide all others. This cuts CI latency to less than three minutes for most changes, and enables GitHub‚Äôs auto-merge to wait for all relevant tests. It also reduces the CI time on merging to main, by moving some tests to only run on specific path changes or on our nightly run.</p>
<p>We now have one label we can add to PRs to run more tests ‚Äî¬†<code>pr-nightly</code>. (@max-sixty, #3317 &amp; others).</p>
</li>
<li>
<p>Auto-merge PRs for backports or pre-commit updates (@max-sixty, #3246)</p>
</li>
<li>
<p>Add a workflow to create an issue when the scheduled nightly workflow fails (@max-sixty, #3304)</p>
</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@FinnRG, with #3292</li>
<li>@sitiom, with #3353</li>
</ul>
<h2 id="093--2023-08-02"><a class="header" href="#093--2023-08-02">0.9.3 ‚Äî¬†2023-08-02</a></h2>
<p>0.9.3 is a small release, with mostly documentation, internal, and CI changes.</p>
<p>This release has 85 commits from 10 contributors.</p>
<p>We‚Äôd like to welcome @not-my-profile as someone who has helped with lots of internal refactoring in the past couple of weeks.</p>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@vthriller, with #3171</li>
<li>@postmeback, with #3216</li>
</ul>
<h2 id="092--2023-07-25"><a class="header" href="#092--2023-07-25">0.9.2 ‚Äî 2023-07-25</a></h2>
<p>0.9.2 is a hotfix release to fix an issue in the 0.9.0 &amp; 0.9.1 release pipelines.</p>
<h2 id="091--2023-07-25"><a class="header" href="#091--2023-07-25">0.9.1 ‚Äî 2023-07-25</a></h2>
<p>0.9.1 is a hotfix release to fix an issue in the 0.9.0 release pipeline.</p>
<h2 id="090--2023-07-24"><a class="header" href="#090--2023-07-24">0.9.0 ‚Äî 2023-07-24</a></h2>
<p>0.9.0 is probably PRQL‚Äôs biggest ever release. We have dialect-specific standard-libraries, a regex operator, an initial implementation of multiple-file projects &amp; modules, lots of bug fixes, and many many internal changes.</p>
<p>We‚Äôve made a few backward incompatible syntax changes. Most queries will work with a simple find/replace; see below for details.</p>
<p>The release has 421 commits from 12 contributors.</p>
<p>A small selection of the changes:</p>
<p><strong>Language</strong>:</p>
<ul>
<li>
<p>The major breaking change is a new syntax for lists, which have been renamed to <em>tuples</em>, and are now represented with braces <code>{}</code> rather than brackets <code>[]</code>.</p>
<p>To convert previous PRQL queries to this new syntax simply change <code>[ ... ]</code> to <code>{ ... }</code>.</p>
<p>We made the syntax change to incorporate arrays. Almost every major language uses <code>[]</code> for arrays. We are adopting that convention ‚Äî arrays use <code>[]</code>, tuples will use <code>{}</code>. (Though we recognize that <code>{}</code> for tuples is also rare (Hi, Erlang!), but didn‚Äôt want to further load parentheses with meaning.)</p>
<p>Arrays are conceptually similar to columns ‚Äî their elements have a single type. Array syntax can‚Äôt contain assignments.</p>
<p>As part of this, we‚Äôve also formalized tuples as containing both individual items (<code>select {foo, baz}</code>), and assignments (<code>select {foo=bar, baz=fuz}</code>).</p>
</li>
<li>
<p>Some significant changes regarding SQL dialects:</p>
<ul>
<li>Operators and functions can be defined on per-dialect basis. (@aljazerzen, #2681)</li>
<li><em>Breaking</em>: The <code>sql.duckdb</code> target supports DuckDB 0.8 (@eitsupi, #2810).</li>
<li><em>Breaking</em>: The <code>sql.hive</code> target is removed (@eitsupi, #2837).</li>
</ul>
</li>
<li>
<p>New arithmetic operators. These compile to different function or operator depending on the target.</p>
<ul>
<li>
<p><em>Breaking</em>: Operator <code>/</code> now always performs floating division (@aljazerzen, #2684). See the <a href="https://prql-lang.org/book/reference/syntax/operators.html#division-and-integer-division">Division docs</a> for details.</p>
</li>
<li>
<p>Truncated integer division operator <code>//</code> (@aljazerzen, #2684). See the <a href="https://prql-lang.org/book/reference/syntax/operators.html#division-and-integer-division">Division docs</a> for details.</p>
</li>
<li>
<p>Regex search operator <code>~=</code> (@max-sixty, #2458). An example:</p>
<pre><code class="language-prql no-eval">from tracks
filter (name ~= "Love")
</code></pre>
<p>‚Ä¶compiles to;</p>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP(name, 'Love')
</code></pre>
<p>‚Ä¶though the exact form differs by dialect; see the <a href="https://prql-lang.org/book/reference/syntax/operators.html#regex">Regex docs</a> for more details.</p>
</li>
</ul>
</li>
<li>
<p>New aggregation functions: <code>every</code>, <code>any</code>, <code>average</code>, and <code>concat_array</code>. <em>Breaking:</em> Remove <code>avg</code> in favor of <code>average</code>.</p>
</li>
<li>
<p><em>Breaking:</em> We‚Äôve changed our function declaration syntax to match other declarations. Functions were one of the first language constructs in PRQL, and since then we‚Äôve added normal declarations there‚Äôs no compelling reason for functions to be different.</p>
<pre><code class="language-prql no-eval">let add = a b -&gt; a + b
</code></pre>
<p>Previously, this was:</p>
<pre><code class="language-prql no-eval">func add a b -&gt; a + b
</code></pre>
</li>
<li>
<p>Experimental modules, which allow importing declarations from other files. Docs are forthcoming.</p>
</li>
<li>
<p>Relation literals create a relation (a ‚Äútable‚Äù) as an <em>array</em> of <em>tuples</em>. This example demonstrates the new syntax for arrays <code>[]</code> and tuples <code>{}</code>. (@aljazerzen, #2605)</p>
<pre><code class="language-prql no-eval">from [{a=5, b=false}, {a=6, b=true}]
filter b == true
select a
</code></pre>
</li>
<li>
<p><code>this</code> can be used to refer to the current pipeline, for situations where plain column name would be ambiguous:</p>
<pre><code class="language-prql no-eval">from x
derive sum = my_column
select this.sum   # does not conflict with `std.sum`
</code></pre>
<p>Within a <code>join</code> transform, there is also a reference to the right relation: <code>that</code>.</p>
</li>
<li>
<p><em>Breaking:</em> functions <code>count</code>, <code>rank</code> and <code>row_number</code> now require an argument of the array to operate on. In most cases you can directly replace <code>count</code> with <code>count this</code>. The <code>non_null</code> argument of <code>count</code> has been removed.</p>
</li>
</ul>
<p><strong>Features</strong>:</p>
<ul>
<li>
<p>We‚Äôve changed how we handle colors.</p>
<p><code>Options::color</code> is deprecated and has no effect. Code which consumes <code>prql_compiler::compile</code> should instead accept the output with colors and use a library such as <code>anstream</code> to handle the presentation of colors. To ensure minimal disruption, <code>prql_compiler</code> will currently strip color codes when a standard environment variable such as <code>CLI_COLOR=0</code> is set or when it detects <code>stderr</code> is not a TTY.</p>
<p>We now use the <a href="https://github.com/rust-cli/anstyle"><code>anstream</code></a> library in <code>prqlc</code> &amp; <code>prql-compiler</code>.</p>
<p>(@max-sixty, #2773)</p>
</li>
<li>
<p><code>prqlc</code> can now show backtraces when the standard backtrace env var (<code>RUST_BACKTRACE</code>) is active. (@max-sixty, #2751)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Numbers expressed with scientific notation ‚Äî¬†<code>1e9</code> ‚Äî are now handled correctly by the compiler (@max-sixty, #2865).</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li>prql-python now provides type hints (@philpep, #2912)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>
<p>Annotations in PRQL. These have limited support but are currently used to specify binding strengths. They‚Äôre modeled after Rust‚Äôs annotations, but with <code>@</code> syntax, more similar to traditional decorators. (#2729)</p>
<pre><code class="language-prql no-eval">@{binding_strength=11}
let mod = l r -&gt; s"{l} % {r}"
</code></pre>
</li>
<li>
<p>Remove BigQuery‚Äôs special handling of quoted identifiers, now that our module system handles its semantics (@max-sixty, #2609).</p>
</li>
<li>
<p>ClickHouse is tested in CI (@eitsupi, #2815).</p>
</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@maxmcd, with #2533</li>
<li>@khoa165, with #2876</li>
<li>@philpep, with #2912</li>
<li>@not-my-profile, with #2971</li>
</ul>
<h2 id="081--2023-04-29"><a class="header" href="#081--2023-04-29">0.8.1 ‚Äî 2023-04-29</a></h2>
<p>0.8.1 is a small release with a new <code>list-targets</code> command in <code>prqlc</code>, some documentation improvements, and some internal improvements.</p>
<p>This release has 41 commits from 8 contributors.</p>
<p>From the broader perspective of the project, we‚Äôre increasing the relative prioritization of it being easy for folks to actually use PRQL ‚Äî either with existing tools, or a tool we‚Äôd build. We‚Äôll be thinking about &amp; discussing the best way to do that over the next few weeks.</p>
<h2 id="080--2023-04-14"><a class="header" href="#080--2023-04-14">0.8.0 ‚Äî 2023-04-14</a></h2>
<p>0.8.0 renames the <code>and</code> &amp; <code>or</code> operators to <code>&amp;&amp;</code> &amp; <code>||</code> respectively, reorganizes the Syntax section in the book, and introduces <code>read_parquet</code> &amp; <code>read_csv</code> functions for reading files with DuckDB.</p>
<p>This release has 38 commits from 8 contributors. Selected changes:</p>
<p><strong>Features</strong>:</p>
<ul>
<li>
<p>Rename <code>and</code> to <code>&amp;&amp;</code> and <code>or</code> to <code>||</code>. Operators which are symbols are now consistently infix, while ‚Äúwords‚Äù are now consistently functions (@aljazerzen, #2422).</p>
</li>
<li>
<p>New functions <code>read_parquet</code> and <code>read_csv</code>, which mirror the DuckDB functions, instructing the database to read from files (@max-sixty, #2409).</p>
</li>
</ul>
<h2 id="071--2023-04-03"><a class="header" href="#071--2023-04-03">0.7.1 ‚Äî 2023-04-03</a></h2>
<p>0.7.1 is a hotfix release to fix <code>prql-js</code>‚Äôs <code>npm install</code> behavior when being installed as a dependency.</p>
<p>This release has 17 commits from 4 contributors.</p>
<h2 id="070--2023-04-01"><a class="header" href="#070--2023-04-01">0.7.0 ‚Äî 2023-04-01</a></h2>
<p>0.7.0 is a fairly small release in terms of new features, with lots of internal improvements, such as integration tests with a whole range of DBs, a blog post on Pi day, RFCs for a type system, and more robust language bindings.</p>
<p>There‚Äôs a very small breaking change to the Rust API, hence the minor version bump.</p>
<p>Here‚Äôs our April 2023 Update, from our <a href="https://github.com/PRQL/prql/blob/main/README.md">Readme</a>:</p>
<blockquote>
<h3 id="april-2023-update"><a class="header" href="#april-2023-update">April 2023 update</a></h3>
<p>PRQL is being actively developed by a growing community. It‚Äôs ready to use by the intrepid, either as part of one of our supported extensions, or within your own tools, using one of our supported language bindings.</p>
<p>PRQL still has some minor bugs and some missing features, and probably is only ready to be rolled out to non-technical teams for fairly simple queries.</p>
<p>Here‚Äôs our current <a href="https://prql-lang.org/roadmap/">Roadmap</a> and our <a href="https://github.com/PRQL/prql/milestones">Milestones.</a></p>
<p>Our immediate focus for the code is on:</p>
<ul>
<li>Building out the next few big features, including <a href="https://github.com/PRQL/prql/pull/1964">types</a> and <a href="https://github.com/PRQL/prql/pull/2129">modules</a>.</li>
<li>Ensuring our supported features feel extremely robust; resolving any <a href="https://github.com/PRQL/prql/issues?q=is%3Aissue+is%3Aopen+label%3Abug+label%3Apriority">priority bugs</a>.</li>
</ul>
<p>We‚Äôre also spending time thinking about:</p>
<ul>
<li>Making it really easy to start using PRQL. We‚Äôre doing that by building integrations with tools that folks already use; for example our VS Code extension &amp; Jupyter integration. If there are tools you‚Äôre familiar with that you think would be open to integrating with PRQL, please let us know in an issue.</li>
<li>Making it easier to contribute to the compiler. We have a wide group of contributors to the project, but contributions to the compiler itself are quite concentrated. We‚Äôre keen to expand this; <a href="https://github.com/PRQL/prql/issues/1840">#1840</a> for feedback.</li>
</ul>
</blockquote>
<hr />
<p>The release has 131 commits from 10 contributors. Particular credit goes to to @eitsupi &amp; @jelenkee, who have made significant contributions, and @vanillajonathan, whose prolific contribution include our growing language bindings.</p>
<p>A small selection of the changes:</p>
<p><strong>Features</strong>:</p>
<ul>
<li><code>prqlc compile</code> adds <code>--color</code> &amp; <code>--include-signature-comment</code> options. (@max-sixty, #2267)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Added the PRQL snippets from the book to the <a href="https://prql-lang.org/playground/">Playground</a> (@jelenkee, #2197)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li><em>Breaking</em>: The <code>compile</code> function‚Äôs <code>Options</code> now includes a <code>color</code> member, which determines whether error messages use ANSI color codes. This is technically a breaking change to the API. (@max-sixty, #2251)</li>
<li>The <code>Error</code> struct now exposes the <code>MessageKind</code> enum. (@vanillajonathan, #2307)</li>
<li>Integration tests run in CI with DuckDB, SQLite, PostgreSQL, MySQL and SQL Server (@jelenkee, #2286)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@k-nut, with #2294</li>
</ul>
<h2 id="061--2023-03-12"><a class="header" href="#061--2023-03-12">0.6.1 ‚Äî 2023-03-12</a></h2>
<p>0.6.1 is a small release containing an internal refactoring and improved bindings for C, PHP &amp; .NET.</p>
<p>This release has 54 commits from 6 contributors. Selected changes:</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>No longer incorrectly compile to <code>DISTINCT</code> when a <code>take 1</code> refers to a different set of columns than are in the <code>group</code>. (@max-sixty, with thanks to @cottrell, #2109)</li>
<li>The version specification of the dependency Chumsky was bumped from <code>0.9.0</code> to <code>0.9.2</code>. <code>0.9.0</code> has a bug that causes an infinite loop. (@eitsupi, #2110)</li>
</ul>
<p><strong>Documentation</strong>:</p>
<ul>
<li>Add a policy for which bindings are supported / unsupported / nascent. See <a href="https://prql-lang.org/book/project/bindings/index.html">https://prql-lang.org/book/project/bindings/index.html</a> for more details (@max-sixty, #2062) (@max-sixty, #2062)</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li>[prql-lib] Added C++ header file. (@vanillajonathan, #2126)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>Many of the items that were in the root of the repo have been aggregated into <code>web</code> &amp; <code>bindings</code>, simplifying the repo‚Äôs structure. There‚Äôs also <code>grammars</code> &amp; <code>packages</code> (@max-sixty, #2135, #2117, #2121).</li>
</ul>
<h2 id="060--2023-03-08"><a class="header" href="#060--2023-03-08">0.6.0 ‚Äî 2023-03-08</a></h2>
<p>0.6.0 introduces a rewritten parser, giving us the ability to dramatically improve error messages, renames <code>switch</code> to <code>case</code> and includes lots of minor improvements and fixes. It also introduces <code>loop</code>, which compiles to <code>WITH RECURSIVE</code>, as a highly experimental feature.</p>
<p>There are a few cases of breaking changes, including switching <code>switch</code> to <code>case</code>, in case that‚Äôs confusing. There are also some minor parsing changes outlined below.</p>
<p>This release has 108 commits from 11 contributors. Selected changes:</p>
<p><strong>Features</strong>:</p>
<ul>
<li>
<p>Add a (highly experimental) <code>loop</code> language feature, which translates to <code>WITH RECURSIVE</code>. We expect changes and refinements in upcoming releases. (#1642, @aljazerzen)</p>
</li>
<li>
<p>Rename the experimental <code>switch</code> function to <code>case</code> given it more closely matches the traditional semantics of <code>case</code>. (@max-sixty, #2036)</p>
</li>
<li>
<p>Change the <code>case</code> syntax to use <code>=&gt;</code> instead of <code>-&gt;</code> to distinguish it from function syntax.</p>
</li>
<li>
<p>Convert parser from pest to Chumsky (@aljazerzen, #1818)</p>
<ul>
<li>Improved error messages, and the potential to make even better in the future. Many of these improvements come from error recovery.</li>
<li>String escapes (<code>\n \t</code>).</li>
<li>Raw strings that don‚Äôt escape backslashes.</li>
<li>String interpolations can only contain identifiers and not any expression.</li>
<li>Operator associativity has been changed from right-to-left to left-to-right to be more similar to other conventional languages.</li>
<li><code>and</code> now has a higher precedence than <code>or</code> (of same reason as the previous point).</li>
<li>Dates, times and timestamps have stricter parsing rules.</li>
<li><code>let</code>, <code>func</code>, <code>prql</code>, <code>case</code> are now treated as keywords.</li>
<li>Float literals without fraction part are not allowed anymore (<code>1.</code>).</li>
</ul>
</li>
<li>
<p>Add a <code>--format</code> option to <code>prqlc parse</code> which can return the AST in YAML (@max-sixty, #1962)</p>
</li>
<li>
<p>Add a new subcommand <code>prqlc jinja</code>. (@aljazerzen, #1722)</p>
</li>
<li>
<p><em>Breaking</em>: prql-compiler no longer passes text containing <code>{{</code> &amp; <code>}}</code> through to the output. (@aljazerzen, #1722)</p>
<p>For example, the following PRQL query</p>
<pre><code class="language-prql no-eval">from {{foo}}
</code></pre>
<p>was compiled to the following SQL previously, but now it raises an error.</p>
<pre><code class="language-sql">SELECT
  *
FROM
  {{ foo }}
</code></pre>
<p>This pass-through feature existed for integration with dbt.</p>
<p>We‚Äôre again considering how to best integrate with dbt, and this change is based on the idea that the jinja macro should run before the PRQL compiler.</p>
<p>If you‚Äôre interested in dbt integration, subscribe or üëç to <a href="https://github.com/dbt-labs/dbt-core/pull/5982">https://github.com/dbt-labs/dbt-core/pull/5982</a>.</p>
</li>
<li>
<p>A new compile target <code>"sql.any"</code>. When <code>"sql.any"</code> is used as the target of the compile function‚Äôs option, the target contained in the query header will be used. (@aljazerzen, #1995)</p>
</li>
<li>
<p>Support for SQL parameters with similar syntax (#1957, @aljazerzen)</p>
</li>
<li>
<p>Allow <code>:</code> to be elided in timezones, such as <code>0800</code> in <code>@2020-01-01T13:19:55-0800</code> (@max-sixty, #1991).</p>
</li>
<li>
<p>Add <code>std.upper</code> and <code>std.lower</code> functions for changing string casing (@Jelenkee, #2019).</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li><code>prqlc compile</code> returns a non-zero exit code for invalid queries. (@max-sixty, #1924)</li>
<li>Identifiers can contain any alphabetic unicode characters (@max-sixty, #2003)</li>
</ul>
<p><strong>Documentation</strong>:</p>
<ul>
<li>Operator precedence (@aljazerzen, #1818)</li>
<li>Error messages for invalid queries are displayed in the book (@max-sixty, #2015)</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li>[prql-php] Added PHP bindings. (@vanillajonathan, #1860)</li>
<li>[prql-dotnet] Added .NET bindings. (@vanillajonathan, #1917)</li>
<li>[prql-lib] Added C header file. (@vanillajonathan, #1879)</li>
<li>Added a workflow building a <code>.deb</code> on each release. (Note that it‚Äôs not yet published on each release). (@vanillajonathan, #1883)</li>
<li>Added a workflow building a <code>.rpm</code> on each release. (Note that it‚Äôs not yet published on each release). (@vanillajonathan, #1918)</li>
<li>Added a workflow building a Snap package on each release. (@vanillajonathan, #1881)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>Test that the output of our nascent autoformatter can be successfully compiled into SQL. Failing examples are now clearly labeled. (@max-sixty, #2016)</li>
<li>Definition files have been added to configure <a href="https://containers.dev/">Dev Containers</a> for Rust development environment. (@eitsupi, #1893, #2025, #2028)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@linux-china, with #1971</li>
<li>@Jelenkee, with #2019</li>
</ul>
<h2 id="052--2023-02-18"><a class="header" href="#052--2023-02-18">0.5.2 ‚Äî 2023-02-18</a></h2>
<p>0.5.2 is a tiny release to fix an build issue in yesterday‚Äôs <code>prql-js</code> 0.5.1 release.</p>
<p>This release has 7 commits from 2 contributors.</p>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@matthias-Q, with #1873</li>
</ul>
<h2 id="051--2023-02-17"><a class="header" href="#051--2023-02-17">0.5.1 ‚Äî 2023-02-17</a></h2>
<p>0.5.1 contains a few fixes, and another change to how bindings handle default target / dialects.</p>
<p>This release has 53 commits from 7 contributors. Selected changes:</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Delegate dividing literal integers to the DB. Previously integer division was executed during PRQL compilation, which could be confusing given that behavior is different across DBs. Other arithmetic operations are still executed during compilation. (@max-sixty, #1747)</li>
</ul>
<p><strong>Documentation</strong>:</p>
<ul>
<li>Add docs on the <code>from_text</code> transform (@max-sixty, #1756)</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li>[prql-js] Default compile target changed from <code>Sql(Generic)</code> to <code>Sql(None)</code>. (@eitsupi, #1856)</li>
<li>[prql-python] Compilation options can now be specified from Python. (@eitsupi, #1807)</li>
<li>[prql-python] Default compile target changed from <code>Sql(Generic)</code> to <code>Sql(None)</code>. (@eitsupi, #1861)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@vanillajonathan, with #1766</li>
</ul>
<h2 id="050--2023-02-08"><a class="header" href="#050--2023-02-08">0.5.0 ‚Äî 2023-02-08</a></h2>
<p>0.5.0 contains a few fixes, some improvements to bindings, lots of docs improvements, and some work on forthcoming features. It contains one breaking change in the compiler‚Äôs <code>Options</code> interface.</p>
<p>This release has 74 commits from 12 contributors. Selected changes:</p>
<p><strong>Features</strong>:</p>
<ul>
<li>
<p>Change public API to use target instead of dialect in preparation for feature work (@aljazerzen, #1684)</p>
</li>
<li>
<p><code>prqlc watch</code> command which watches filesystem for changes and compiles .prql files to .sql (@aljazerzen, #1708)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Support double brackets in s-strings which aren‚Äôt symmetric (@max-sixty, #1650)</li>
<li>Support Postgres‚Äôs Interval syntax (@max-sixty, #1649)</li>
<li>Fixed tests for <code>prql-elixir</code> with macOS (@kasvith, #1707)</li>
</ul>
<p><strong>Documentation</strong>:</p>
<ul>
<li>Add a documentation test for prql-compiler, update prql-compiler README, and include the README in the prql book section for Rust bindings. The code examples in the README are included and tested as doctests in the prql-compiler (@nkicg6, #1679)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>Add tests for all PRQL website examples to prql-python to ensure compiled results match expected SQL (@nkicg6, #1719)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@ruslandoga, with #1628</li>
<li>@RalfNorthman, with #1632</li>
<li>@nicot, with #1662</li>
</ul>
<h2 id="042--2023-01-25"><a class="header" href="#042--2023-01-25">0.4.2 ‚Äî 2023-01-25</a></h2>
<p><strong>Features</strong>:</p>
<ul>
<li>
<p>New <code>from_text format-arg string-arg</code> function that supports JSON and CSV formats. <em>format-arg</em> can be <code>format:csv</code> or <code>format:json</code>. <em>string-arg</em> can be a string in any format. (@aljazerzen &amp; @snth, #1514)</p>
<pre><code class="language-prql no-eval">from_text format:csv """
a,b,c
1,2,3
4,5,6
"""
</code></pre>
<pre><code class="language-prql no-eval">from_text format:json '''
    [{"a": 1, "b": "x", "c": false }, {"a": 4, "b": "y", "c": null }]
'''
</code></pre>
<pre><code class="language-prql no-eval">from_text format:json '''{
    "columns": ["a", "b", "c"],
    "data": [
        [1, "x", false],
        [4, "y", null]
    ]
}'''
</code></pre>
<p>For now, the argument is limited to string constants.</p>
</li>
</ul>
<p><strong>Fixes</strong></p>
<ul>
<li>Export constructor for SQLCompileOptions (@bcho, #1621)</li>
<li>Remove backticks in count_distinct (@aljazerzen, #1611)</li>
</ul>
<p><strong>New Contributors</strong></p>
<ul>
<li>@1Kinoti, with #1596</li>
<li>@veenaamb, with #1614</li>
</ul>
<h2 id="041--2023-01-18"><a class="header" href="#041--2023-01-18">0.4.1 ‚Äî 2023-01-18</a></h2>
<p>0.4.1 comes a few days after 0.4.0, with a couple of features and the release of <code>prqlc</code>, the CLI crate.</p>
<p>0.4.1 has 35 commits from 6 contributors.</p>
<p><strong>Features</strong>:</p>
<ul>
<li>
<p>Inferred column names include the relation name (@aljazerzen, #1550):</p>
<pre><code class="language-prql no-eval">from albums
select title # name used to be inferred as title only
select albums.title # so using albums was not possible here
</code></pre>
</li>
<li>
<p>Quoted identifiers such as <code>dir/*.parquet</code> are passed through to SQL. (@max-sixty, #1516).</p>
</li>
<li>
<p>The CLI is installed with <code>cargo install prqlc</code>. The binary was renamed in 0.4.0 but required an additional <code>--features</code> flag, which has been removed in favor of this new crate (@max-sixty &amp; @aljazerzen, #1549).</p>
</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@fool1280, with #1554</li>
<li>@nkicg6, with #1567</li>
</ul>
<h2 id="040--2023-01-15"><a class="header" href="#040--2023-01-15">0.4.0 ‚Äî 2023-01-15</a></h2>
<p>0.4.0 brings lots of new features including <code>case</code>, <code>select ![]</code> and numbers with underscores. We have initial (unpublished) bindings to Elixir. And there‚Äôs the usual improvements to fixes &amp; documentation (only a minority are listed below in this release).</p>
<p>0.4.0 also has some breaking changes: <code>table</code> is <code>let</code>, <code>dialect</code> is renamed to <code>target</code>, and the compiler‚Äôs API has changed. Full details below.</p>
<p><strong>Features</strong>:</p>
<ul>
<li>
<p>Defining a temporary table is now expressed as <code>let</code> rather than <code>table</code> (@aljazerzen, #1315). See the <a href="https://prql-lang.org/book/reference/declarations/variables.html">tables docs</a> for details.</p>
</li>
<li>
<p><em>Experimental:</em> The <a href="https://prql-lang.org/book/reference/syntax/case.html"><code>case</code></a> function sets a variable to a value based on one of several expressions (@aljazerzen, #1278).</p>
<pre><code class="language-prql no-eval">derive var = case [
  score &lt;= 10 -&gt; "low",
  score &lt;= 30 -&gt; "medium",
  score &lt;= 70 -&gt; "high",
  true -&gt; "very high",
]
</code></pre>
<p>‚Ä¶compiles to:</p>
<pre><code class="language-sql">SELECT
  *,
  CASE
    WHEN score &lt;= 10 THEN 'low'
    WHEN score &lt;= 30 THEN 'medium'
    WHEN score &lt;= 70 THEN 'high'
    ELSE 'very high'
  END AS var
FROM
  bar
</code></pre>
<p>Check out the <a href="https://prql-lang.org/book/reference/syntax/case.html"><code>case</code> docs</a> for more details.</p>
</li>
<li>
<p><em>Experimental:</em> Columns can be excluded by name with <code>select</code> (@aljazerzen, #1329)</p>
<pre><code class="language-prql no-eval">from albums
select ![title, composer]
</code></pre>
</li>
<li>
<p><em>Experimental:</em> <code>append</code> transform, equivalent to <code>UNION ALL</code> in SQL. (@aljazerzen, #894)</p>
<pre><code class="language-prql no-eval">from employees
append managers
</code></pre>
<p>Check out the <a href="https://prql-lang.org/book/reference/stdlib/transforms/append.html"><code>append</code> docs</a> for more details.</p>
</li>
<li>
<p>Numbers can contain underscores, which can make reading long numbers easier (@max-sixty, #1467):</p>
<pre><code class="language-prql no-eval">from numbers
select {
    small = 1.000_000_1,
    big = 5_000_000,
}
</code></pre>
</li>
<li>
<p>The SQL output contains a comment with the PRQL compiler version (@aljazerzen, #1322)</p>
</li>
<li>
<p><code>dialect</code> is renamed to <code>target</code>, and its values are prefixed with <code>sql.</code> (@max-sixty, #1388); for example:</p>
<pre><code class="language-prql no-eval">prql target:sql.bigquery  # previously was `dialect:bigquery`

from employees
</code></pre>
<p>This gives us the flexibility to target other languages than SQL in the long term.</p>
</li>
<li>
<p>Tables definitions can contain a bare s-string (@max-sixty, #1422), which enables us to include a full CTE of SQL, for example:</p>
<pre><code class="language-prql no-eval">let grouping = s"""
  SELECT SUM(a)
  FROM tbl
  GROUP BY
    GROUPING SETS
    ((b, c, d), (d), (b, d))
"""
</code></pre>
</li>
<li>
<p>Ranges supplied to <code>in</code> can be half-open (@aljazerzen, #1330).</p>
</li>
<li>
<p>The crate‚Äôs external API has changed to allow for compiling to intermediate representation. This also affects bindings. See <a href="https://docs.rs/prql-compiler/latest/prql_compiler/"><code>prql-compiler</code> docs</a> for more details.</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<p>[This release, the changelog only contains a subset of fixes]</p>
<ul>
<li>Allow interpolations in table s-strings (@aljazerzen, #1337)</li>
</ul>
<p><strong>Documentation</strong>:</p>
<p>[This release, the changelog only contains a subset of documentation improvements]</p>
<ul>
<li>Add docs on aliases in <a href="https://prql-lang.org/book/reference/stdlib/transforms/select.html">Select</a></li>
<li>Add JS template literal and multiline example (@BCsabaEngine, #1432)</li>
<li>JS template literal and multiline example (@BCsabaEngine, #1432)</li>
<li>Improve prql-compiler docs &amp; examples (@aljazerzen, #1515)</li>
<li>Fix string highlighting in book (@max-sixty, #1264)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>The playground allows querying some sample data. As before, the result updates on every keystroke. (@aljazerzen, #1305)</li>
</ul>
<p><strong>Integrations</strong>:</p>
<p>[This release, the changelog only contains a subset of integration improvements]</p>
<ul>
<li>Added Elixir integration exposing PRQL functions as NIFs (#1500, @kasvith)</li>
<li>Exposed Elixir flavor with exceptions (#1513, @kasvith)</li>
<li>Rename <code>prql-compiler</code> binary to <code>prqlc</code> (@aljazerzen #1515)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<p>[This release, the changelog only contains a subset of internal changes]</p>
<ul>
<li>Add parsing for negative select (@max-sixty, #1317)</li>
<li>Allow for additional builtin functions (@aljazerzen, #1325)</li>
<li>Add an automated check for typos (@max-sixty, #1421)</li>
<li>Add tasks for running playground &amp; book (@max-sixty, #1265)</li>
<li>Add tasks for running tests on every file change (@max-sixty, #1380)</li>
</ul>
<p><strong>New contributors</strong>:</p>
<ul>
<li>@EArazli, with #1359</li>
<li>@boramalper, with #1362</li>
<li>@allurefx, with #1377</li>
<li>@bcho, with #1375</li>
<li>@JettChenT, with #1385</li>
<li>@BlurrechDev, with #1411</li>
<li>@BCsabaEngine, with #1432</li>
<li>@kasvith, with #1500</li>
</ul>
<h2 id="031---2022-12-03"><a class="header" href="#031---2022-12-03">0.3.1 - 2022-12-03</a></h2>
<p>0.3.1 brings a couple of small improvements and fixes.</p>
<p><strong>Features</strong>:</p>
<ul>
<li>
<p>Support for using s-strings for <code>from</code> (#1197, @aljazerzen)</p>
<pre><code class="language-prql no-eval">from s"SELECT * FROM employees WHERE foo &gt; 5"
</code></pre>
</li>
<li>
<p>Helpful error message when referencing a table in an s-string (#1203, @aljazerzen)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Multiple columns with same name created (#1211, @aljazerzen)</li>
<li>Renaming via select breaks preceding sorting (#1204, @aljazerzen)</li>
<li>Same column gets selected multiple times (#1186, @mklopets)</li>
</ul>
<p><strong>Internal</strong>:</p>
<ul>
<li>Update Github Actions and Workflows to current version numbers (and avoid using Node 12)</li>
</ul>
<h2 id="030--2022-11-29"><a class="header" href="#030--2022-11-29">0.3.0 ‚Äî 2022-11-29</a></h2>
<p>üéâ 0.3.0 is the biggest ever change in PRQL‚Äôs compiler, rewriting much of the internals: the compiler now has a semantic understanding of expressions, including resolving names &amp; building a DAG of column lineage üéâ.</p>
<p>While the immediate changes to the language are modest ‚Äî¬†some long-running bugs are fixed ‚Äî this unlocks the development of many of the project‚Äôs long-term priorities, such as type-checking &amp; auto-complete. And it simplifies the building of our next language features, such as match-case expressions, unions &amp; table expressions.</p>
<p>@aljazerzen has (mostly single-handedly) done this work over the past few months. The project owes him immense appreciation.</p>
<p><strong>Breaking changes</strong>:</p>
<p>We‚Äôve had to make some modest breaking changes for 0.3:</p>
<ul>
<li>
<p><em>Pipelines must start with <code>from</code></em>. For example, a pipeline with only <code>derive foo = 5</code>, with no <code>from</code> transform, is no longer valid. Depending on demand for this feature, it would be possible to add this back.</p>
</li>
<li>
<p><em>Shared column names now require <code>==</code> in a join</em>. The existing approach is ambiguous to the compiler ‚Äî <code>id</code> in the following example could be a boolean column.</p>
<pre><code class="language-diff">from employees
-join positions [id]
+join positions [==id]
</code></pre>
</li>
<li>
<p><em>Table references containing periods must be surrounded by backticks</em>. For example, when referencing a schema name:</p>
<pre><code class="language-diff">-from public.sometable
+from `public.sometable`
</code></pre>
</li>
</ul>
<p><strong>Features</strong>:</p>
<ul>
<li>Change self equality op to <code>==</code> (#1176, @aljazerzen)</li>
<li>Add logging (@aljazerzen)</li>
<li>Add clickhouse dialect (#1090, @max-sixty)</li>
<li>Allow namespaces &amp; tables to contain <code>.</code> (#1079, @aljazerzen)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Deduplicate column appearing in <code>SELECT</code> multiple times (#1186, @aljazerzen)</li>
<li>Fix uppercase table names (#1184, @aljazerzen)</li>
<li>Omit table name when only one ident in SELECT (#1094, @aljazerzen)</li>
</ul>
<p><strong>Documentation</strong>:</p>
<ul>
<li>Add chapter on semantics‚Äô internals (@aljazerzen, #1028)</li>
<li>Add note about nesting variables in s-strings (@max-sixty, #1163)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>Flatten group and window (#1120, @aljazerzen)</li>
<li>Split ast into expr and stmt (@aljazerzen)</li>
<li>Refactor associativity (#1156, @aljazerzen)</li>
<li>Rename Ident constructor to <code>from_name</code> (#1084, @aljazerzen)</li>
<li>Refactor rq folding (#1177, @aljazerzen)</li>
<li>Add tests for reported bugs fixes in semantic (#1174, @aljazerzen)</li>
<li>Bump duckdb from 0.5.0 to 0.6.0 (#1132)</li>
<li>Bump once_cell from 1.15.0 to 1.16.0 (#1101)</li>
<li>Bump pest from 2.4.0 to 2.5.0 (#1161)</li>
<li>Bump pest_derive from 2.4.0 to 2.5.0 (#1179)</li>
<li>Bump sqlparser from 0.25.0 to 0.27.0 (#1131)</li>
<li>Bump trash from 2.1.5 to 3.0.0 (#1178)</li>
</ul>
<h2 id="0211--2022-11-20"><a class="header" href="#0211--2022-11-20">0.2.11 ‚Äî 2022-11-20</a></h2>
<p>0.2.11 contains a few helpful fixes.</p>
<p>Work continues on our <code>semantic</code> refactor ‚Äî look out for 0.3.0 soon! Many thanks to @aljazerzen for his continued contributions to this.</p>
<p>Note: 0.2.10 was skipped due to this maintainer‚Äôs inability to read his own docs on bumping versions‚Ä¶</p>
<p><strong>Features</strong>:</p>
<ul>
<li>Detect when compiler version is behind query version (@MarinPostma, #1058)</li>
<li>Add <code>__version__</code> to prql-python package (@max-sixty, #1034)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Fix nesting of expressions with equal binding strength and left associativity, such as <code>a - (b - c)</code> (@max-sixty, #1136)</li>
<li>Retain floats without significant digits as floats (@max-sixty, #1141)</li>
</ul>
<p><strong>Documentation</strong>:</p>
<ul>
<li>Add documentation of <code>prqlr</code> bindings (@eitsupi, #1091)</li>
<li>Add a ‚ÄòWhy PRQL‚Äô section to the website (@max-sixty, #1098)</li>
<li>Add @snth to core-devs (@max-sixty, #1050)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>Use workspace versioning (@max-sixty, #1065)</li>
</ul>
<h2 id="029--2022-10-14"><a class="header" href="#029--2022-10-14">0.2.9 ‚Äî 2022-10-14</a></h2>
<p>0.2.9 is a small release containing a bug fix for empty strings.</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Fix parsing of empty strings (@aljazerzen, #1024)</li>
</ul>
<h2 id="028--2022-10-10"><a class="header" href="#028--2022-10-10">0.2.8 ‚Äî 2022-10-10</a></h2>
<p>0.2.8 is another modest release with some fixes, doc improvements, bindings improvements, and lots of internal changes. Note that one of the fixes causes the behavior of <code>round</code> and <code>cast</code> to change slightly ‚Äî though it‚Äôs handled as a fix rather than a breaking change in semantic versioning.</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>
<p>Change order of the <code>round</code> &amp; <code>cast</code> function parameters to have the column last; for example <code>round 2 foo_col</code> / <code>cast int foo</code>. This is consistent with other functions, and makes piping possible:</p>
<pre><code class="language-prql no-eval">derive [
  gross_salary = (salary + payroll_tax | as int),
  gross_salary_rounded = (gross_salary | round 0),
]
</code></pre>
</li>
</ul>
<p><strong>Documentation</strong>:</p>
<ul>
<li>Split <code>DEVELOPMENT.md</code> from <code>CONTRIBUTING.md</code> (@richb-hanover, #1010)</li>
<li>Make s-strings more prominent in website intro (@max-sixty, #982)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Add GitHub star count to website (@max-sixty, #990)</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li>Expose a shortened error message, in particular for the VS Code extension (@aljazerzen, #1005)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>Specify 1.60.0 as minimum Rust version (@max-sixty, #1011)</li>
<li>Remove old <code>wee-alloc</code> code (@max-sixty, #1013)</li>
<li>Upgrade clap to version 4 (@aj-bagwell, #1004)</li>
<li>Improve book-building script in Taskfile (@max-sixty, #989)</li>
<li>Publish website using an artifact rather than a long-lived branch (@max-sixty, #1009)</li>
</ul>
<h2 id="027--2022-09-17"><a class="header" href="#027--2022-09-17">0.2.7 ‚Äî 2022-09-17</a></h2>
<p>0.2.7 is a fairly modest release, six weeks after 0.2.6. We have some more significant features, including a <code>union</code> operator and an overhaul of our type system, as open PRs which will follow in future releases.</p>
<p>We also have new features in the <a href="https://github.com/PRQL/prql-code">VS Code extension</a>, courtesy of @jiripospisil, including a live output panel.</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li><code>range_of_ranges</code> checks the Range end is smaller than its start (@shuozeli, #946)</li>
</ul>
<p><strong>Documentation</strong>:</p>
<ul>
<li>Improve various docs (@max-sixty, #974, #971, #972, #970, #925)</li>
<li>Add reference to EdgeDB‚Äôs blog post in our FAQ (@max-sixty, #922)</li>
<li>Fix typos (@kianmeng, #943)</li>
</ul>
<p><strong>Integrations</strong>:</p>
<ul>
<li>Add <code>prql-lib</code>, enabling language bindings with <code>go</code> (@sigxcpu76, #923)</li>
<li>Fix line numbers in JS exceptions (@charlie-sanders, #929)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>Lock the version of the rust-toolchain, with auto-updates (@max-sixty, #926, #927)</li>
</ul>
<h2 id="026--2022-08-05"><a class="header" href="#026--2022-08-05">0.2.6 ‚Äî¬†2022-08-05</a></h2>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Adjust <code>fmt</code> to only escape names when needed (@aljazerzen, #907)</li>
<li>Fix quoting on upper case <code>table</code> names (@max-sixty, #893)</li>
<li>Fix scoping of identical column names from multiple tables (@max-sixty, #908)</li>
<li>Fix parse error on newlines in a <code>table</code> (@sebastiantoh üÜï, #902)</li>
<li>Fix quoting of upper case table names (@max-sixty, #893)</li>
</ul>
<p><strong>Documentation</strong>:</p>
<ul>
<li>Add docs on Architecture (@aljazerzen, #904)</li>
<li>Add Changelog (@max-sixty, #890 #891)</li>
</ul>
<p><strong>Internal changes</strong>:</p>
<ul>
<li>Start trial using Conventional Commits (@max-sixty, #889)</li>
<li>Add crates.io release workflow, docs (@max-sixty, #887)</li>
</ul>
<h2 id="025---2022-07-29"><a class="header" href="#025---2022-07-29">0.2.5 - 2022-07-29</a></h2>
<p>0.2.5 is a very small release following 0.2.4 yesterday. It includes:</p>
<ul>
<li>Add the ability to represent single brackets in an s-string, with two brackets (#752, @max-sixty)</li>
<li>Fix the ‚ÄúCopy to Clipboard‚Äù command in the Playground, for Firefox (#880, @mklopets)</li>
</ul>
<h2 id="024---2022-07-28"><a class="header" href="#024---2022-07-28">0.2.4 - 2022-07-28</a></h2>
<p>0.2.4 is a small release following 0.2.3 a few days ago. The 0.2.4 release includes:</p>
<ul>
<li>Enrich our CLI, adding commands to get different stages of the compilation process (@aljazerzen , #863)</li>
<li>Fix multiple <code>take n</code> statements in a query, leading to duplicate proxy columns in generated SQL (@charlie-sanders)</li>
<li>Fix BigQuery quoting of identifiers in <code>SELECT</code> statements (@max-sixty)</li>
<li>Some internal changes ‚Äî reorganize top-level functions (@aljazerzen), add a workflow to track our Rust compilation time (@max-sixty), simplify our simple prql-to-sql tests (@max-sixty)</li>
</ul>
<p>Thanks to @ankane, <code>prql-compiler</code> is now available from homebrew core; <code>brew install prql-compiler</code><sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<pre><code>   we still need to update docs and add a release workflow for this:
   &lt;https://github.com/PRQL/prql/issues/866&gt;
   ````

## 0.2.3 - 2022-07-24

A couple of weeks since the 0.2.2 release: we‚Äôve squashed a few bugs, added some
mid-sized features to the language, and made a bunch of internal improvements.

The 0.2.3 release includes:

* Allow for escaping otherwise-invalid identifiers (@aljazerzen &amp; @max-sixty)
* Fix a bug around operator precedence (@max-sixty)
* Add a section the book on the language bindings (@charlie-sanders)
* Add tests for our `Display` representation while fixing some existing bugs.
 This is gradually becoming our code formatter (@arrizalamin)
* Add a ‚Äúcopy to clipboard‚Äù button in the Playground (@mklopets)
* Add lots of guidance to our `CONTRIBUTING.md` around our tests and process for
 merging (@max-sixty)
* Add a `prql!` macro for parsing a prql query at compile time (@aljazerzen)
* Add tests for `prql-js` (@charlie-sanders)
* Add a `from_json` method for transforming json to a PRQL string (@arrizalamin)
* Add a workflow to release `prql-java` to Maven (@doki23)
* Enable running all tests from a PR by adding a `pr-run-all-tests` label
 (@max-sixty)
* Have `cargo-release` to bump all crate &amp; npm versions (@max-sixty)
* Update `prql-js` to use the bundler build of `prql-js` (@mklopets)

As well as those contribution changes, thanks to those who‚Äôve reported issues,
such as @mklopets @huw @mm444 @ajfriend.

From here, we‚Äôre planning to continue squashing bugs (albeit more minor than
those in this release), adding some features like `union`, while working on
bigger issues such as type-inference.

We‚Äôre also going to document and modularize the compiler further. It‚Äôs important
that we give more people an opportunity to contribute to the guts of PRQL,
especially given the number and enthusiasm of contributions to project in
general ‚Äî and it‚Äôs not that easy to do so at the moment. While this is ongoing
if anyone has something they‚Äôd like to work on in the more difficult parts of
the compiler, let us know on GitHub or Discord, and we‚Äôd be happy to work
together on it.

Thank you!

## 0.2.2 - 2022-07-10

We‚Äôre a couple of weeks since our 0.2.0 release. Thanks for the surge in
interest and contributions! 0.2.2 has some fixes &amp; some internal improvements:

* We now test against SQLite &amp; DuckDB on every commit, to ensure we‚Äôre producing
 correct SQL. (@aljazerzen)
* We have the beginning of Java bindings! (@doki23)
* Idents surrounded by backticks are passed through to SQL (@max-sixty)
* More examples on homepage; e.g. `join` &amp; `window`, lots of small docs
 improvements
* Automated releases to homebrew (@roG0d)
* [prql-js](https://github.com/PRQL/prql/tree/main/prqlc/bindings/js) is now a
 single package for Node, browsers &amp; webpack (@charlie-sanders)
* Parsing has some fixes, including `&gt;=` and leading underscores in idents
 (@mklopets)
* Ranges receive correct syntax highlighting (@max-sixty)

Thanks to Alja≈æ Mur Er≈æen @aljazerzen , George Roldugin @roldugin , Jasper
McCulloch @Jaspooky , Jie Han @doki23 , Marko Klopets @mklopets , Maximilian
Roos @max-sixty , Rodrigo Garcia @roG0d , Ryan Russell @ryanrussell , Steven
Maude @StevenMaude , Charlie Sanders @charlie-sanders .

We‚Äôre planning to continue collecting bugs &amp; feature requests from users, as
well as working on some of the bigger features, like type-inference.

For those interesting in joining, we also have a new
[Contributing page](https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md).

## 0.2.0 - 2022-06-27

üéâ üéâ **After several months of building, PRQL is ready to use!** üéâ üéâ

---

How we got here:

At the end of January, we published a proposal of a better language for data
transformation: PRQL. The reception was better than I could have hoped for ‚Äî we
were no. 2 on HackerNews for a day, and gained 2.5K GitHub stars over the next
few days.

But man cannot live on GitHub Stars alone ‚Äî we had to do the work to build it.
So over the next several months, during many evenings &amp; weekends, a growing
group of us gradually built the compiler, evolved the language, and wrote some
integrations.

We want to double-down on the community and its roots in open source ‚Äî it‚Äôs
incredible that a few of us from all over the globe have collaborated on a
project without ever having met. We decided early-on that PRQL would always be
open-source and would never have a commercial product (despite lots of outside
interest to fund a seed round!). Because languages are so deep in the stack, and
the data stack has so many players, the best chance of building a great language
is to build an open language.

---

We still have a long way to go. While PRQL is usable, it has lots of missing
features, and an incredible amount of unfulfilled potential, including a
language server, cohesion with databases, and type inference. Over the coming
weeks, we‚Äôd like to grow the number of intrepid users experimenting PRQL in
their projects, prioritize features that will unblock them, and then start
fulfilling PRQL‚Äôs potential by working through our
[roadmap](https://prql-lang.org/roadmap/).

The best way to experience PRQL is to try it. Check out our
[website](https://prql-lang.org) and the
[Playground](https://prql-lang.org/playground). Start using PRQL for your own
projects in [dbt](https://github.com/prql/dbt-prql),
[Jupyter notebooks](https://pyprql.readthedocs.io/en/latest/magic_readme.html)
and Prefect workflows.

Keep in touch with PRQL by following the project on
[Twitter](https://twitter.com/prql_lang), joining us on
[Discord](https://discord.gg/eQcfaCmsNc), starring the
[repo](https://github.com/PRQL/prql).

[Contribute](https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md) to
the project ‚Äî we‚Äôre a really friendly community, whether you‚Äôre a recent SQL
user or an advanced Rust programmer. We need bug reports, documentation tweaks &amp;
feature requests ‚Äî just as much as we need compiler improvements written in
Rust.

---

I especially want to give [Alja≈æ Mur Er≈æen](https://github.com/aljazerzen)
(@aljazerzen) the credit he deserves, who has contributed the majority of the
difficult work of building out the compiler. Much credit also goes to
@charlie-sanders, one of PRQL‚Äôs earliest supporters and the author of pyprql,
and [Ryan Patterson-Cross](https://github.com/rbpatt2019) (@rbpatt2019), who
built the Jupyter integration among other Python contributions.

Other contributors who deserve a special mention include: @roG0d, @snth,
@kwigley

---

Thank you, and we look forward to your feedback!
</code></pre>
 <a href="#fr-1-1">‚Ü©</a></li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="target--version"><a class="header" href="#target--version">Target &amp; Version</a></h1>
<h2 id="target-dialect"><a class="header" href="#target-dialect">Target dialect</a></h2>
<p>PRQL allows specifying a target dialect at the top of the query, which allows PRQL to compile to a database-specific SQL flavor.</p>
<h3 id="examples-10"><a class="header" href="#examples-10">Examples</a></h3>
<div class="comparison">
<div>
<h4 id="prql-135"><a class="header" href="#prql-135">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.postgres

from employees
sort age
take 10
</code></pre>
</div>
<div>
<h4 id="sql-132"><a class="header" href="#sql-132">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age
LIMIT
  10

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-136"><a class="header" href="#prql-136">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mssql

from employees
sort age
take 10
</code></pre>
</div>
<div>
<h4 id="sql-133"><a class="header" href="#sql-133">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age OFFSET 0 ROWS
FETCH FIRST
  10 ROWS ONLY

</code></pre>
</div>
</div>
<h2 id="dialects"><a class="header" href="#dialects">Dialects</a></h2>
<h3 id="supported"><a class="header" href="#supported">Supported</a></h3>
<p>Supported dialects support all PRQL language features where possible, are tested on every commit, and we‚Äôll endeavor to fix bugs.</p>
<ul>
<li><code>sql.clickhouse</code></li>
<li><code>sql.duckdb</code></li>
<li><code>sql.generic</code> <sup><a name="to-footnote-1"><a href="project/target.html#footnote-1">1</a></a></sup></li>
<li><code>sql.glaredb</code></li>
<li><code>sql.mysql</code></li>
<li><code>sql.postgres</code></li>
<li><code>sql.sqlite</code></li>
</ul>
<h3 id="unsupported"><a class="header" href="#unsupported">Unsupported</a></h3>
<p>Unsupported dialects have implementations in the compiler, but are tested minimally or not at all, and may have gaps for some features.</p>
<p>We‚Äôre open to contributions to improve our coverage of these, and to adding additional dialects.</p>
<ul>
<li><code>sql.mssql</code></li>
<li><code>sql.ansi</code></li>
<li><code>sql.bigquery</code></li>
<li><code>sql.snowflake</code></li>
</ul>
<h2 id="priority-of-targets"><a class="header" href="#priority-of-targets">Priority of targets</a></h2>
<p>The compile target of a query is defined in the query‚Äôs header or as an argument to the compiler. option. The argument to the compiler takes precedence.</p>
<p>For example, the following shell example specifies <code>sql.generic</code> in the query and <code>sql.duckdb</code> in the <code>--target</code> option of the <code>prqlc compile</code> command. In this case, <code>sql.duckdb</code> takes precedence and the SQL output is based on the DuckDB dialect.</p>
<pre><code class="language-sh">echo 'prql target:sql.generic
      from foo' | prqlc compile --target sql.duckdb
</code></pre>
<p>To use the target described in the query, a special target <code>sql.any</code> can be specified in the compiler option.</p>
<pre><code class="language-sh">echo 'prql target:sql.generic
      from foo' | prqlc compile --target sql.any
</code></pre>
<h2 id="version"><a class="header" href="#version">Version</a></h2>
<p>PRQL allows specifying a version of the language in the PRQL header, like:</p>
<div class="comparison">
<div>
<h4 id="prql-137"><a class="header" href="#prql-137">PRQL</a></h4>
<pre><code class="language-prql">prql version:"0.12.2"

from employees
</code></pre>
</div>
<div>
<h4 id="sql-134"><a class="header" href="#sql-134">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees

</code></pre>
</div>
</div>
<p>This has two roles, one of which is implemented:</p>
<ul>
<li>The compiler will raise an error if the compiler is older than the query version. This prevents confusing errors when queries use newer features of the language but the compiler hasn‚Äôt yet been upgraded.</li>
<li>The compiler will compile for the major version of the query. This allows the language to evolve without breaking existing queries, or forcing multiple installations of the compiler. This isn‚Äôt yet implemented, but is a gating feature for PRQL 1.0.</li>
</ul>
<p>The version of the compiler currently in use can be called using the special function <code>std.prql.version</code> in PRQL.</p>
<div class="comparison">
<div>
<h4 id="prql-138"><a class="header" href="#prql-138">PRQL</a></h4>
<pre><code class="language-prql">[{version = prql.version}]
</code></pre>
</div>
<div>
<h4 id="sql-135"><a class="header" href="#sql-135">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    '0.12.2' AS version
)
SELECT
  version
FROM
  table_0

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/target.html#admonition-note"></a>
</div>
<div>
<p>This function was renamed from <code>std.prql_version</code> to <code>prql.version</code> in PRQL 0.11.1. <code>std.prql_version</code> will be removed in PRQL 0.12.0.</p>
</div>
</div>
<p><hr/>
<p><a name="footnote-1"><a href="project/target.html#to-footnote-1">1</a></a>: while there‚Äôs no ‚Äúgeneric‚Äù DB to test <code>sql.generic</code> against, we still count it as supported.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bindings"><a class="header" href="#bindings">Bindings</a></h1>
<p>PRQL has bindings for many languages. These include:</p>
<p>We have three tiers of bindings:</p>
<ul>
<li>Supported</li>
<li>Unsupported</li>
<li>Nascent</li>
</ul>
<h2 id="supported-1"><a class="header" href="#supported-1">Supported</a></h2>
<p>Supported bindings require:</p>
<ul>
<li>A maintainer.</li>
<li>Implementations of the <a href="https://docs.rs/prqlc/latest/prqlc/#functions">core compile functions</a>.</li>
<li>Test coverage for these functions.</li>
<li>A published package to the language‚Äôs standard package repository.</li>
<li>A script in <code>Taskfile.yaml</code> to bootstrap a development environment.</li>
<li>Any dev tools, such as a linter &amp; formatter, in pre-commit or MegaLinter.</li>
</ul>
<p>The currently supported bindings are:</p>
<ul>
<li><a href="project/bindings/./javascript.html">JavaScript</a></li>
<li><a href="project/bindings/./python.html">Python</a></li>
<li><a href="project/bindings/./r.html">R</a></li>
<li><a href="project/bindings/./rust.html">Rust</a></li>
</ul>
<p>Most of these are in the main PRQL repo, and we gate any changes to the compiler‚Äôs API on compatible changes to the bindings.</p>
<h2 id="unsupported-1"><a class="header" href="#unsupported-1">Unsupported</a></h2>
<p>Unsupported bindings work, but don‚Äôt fulfil all of the above criteria. We don‚Äôt gate changes to the compiler‚Äôs API. If they stop working, we‚Äôll demote them to nascent.</p>
<ul>
<li><a href="project/bindings/./java.html">Java</a></li>
<li><a href="project/bindings/./elixir.html">Elixir</a></li>
<li><code>prqlc-c</code>, the C bindings</li>
</ul>
<h2 id="nascent"><a class="header" href="#nascent">Nascent</a></h2>
<p>Nascent bindings are in development, and may not yet fully work.</p>
<ul>
<li><a href="project/bindings/./dotnet.html">.NET</a></li>
<li><a href="project/bindings/./php.html">PHP</a></li>
</ul>
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<p>Over time, we‚Äôre trying to move to a consistent naming scheme:</p>
<ul>
<li>Crates are named <code>prqlc-$lang</code>.</li>
<li>Where possible, packages are published to each language‚Äôs package repository as <code>prqlc</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-dotnet"><a class="header" href="#prql-dotnet">prql-dotnet</a></h1>
<p><code>prql-net</code> offers PRQL bindings for .NET bindings as a <code>netstandard2.0</code> library.</p>
<p>It provides the <code>PrqlCompiler</code> class which contains the <code>ToJson</code> and <code>ToSql</code> static methods.</p>
<p>It‚Äôs still at an early stage, and isn‚Äôt published to NuGet. Contributions are welcome.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Make sure that <code>libprqlc_c.so</code> (Linux), <code>libprqlc_c.dylib</code> (macOS) or <code>libprqlc_c.dll</code> (Windows) is in the project‚Äôs <code>bin</code> directory together with <code>PrqlCompiler.dll</code> and the rest of the project‚Äôs compiled files. I.e. <code>{your_project}/bin/Debug/net7.0/</code>.</p>
<p>The <code>libprqlc_c</code> library gets dynamically imported at runtime.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-csharp">using Prql.Compiler;

var options = new PrqlCompilerOptions
{
    Format = false,
    SignatureComment = false,
};
var sql = PrqlCompiler.Compile("from employees", options);
Console.WriteLine(sql);
</code></pre>
<h2 id="todo"><a class="header" href="#todo">TODO</a></h2>
<p>This is currently at 0.1.0 because we‚Äôre waiting to update prqlc-c for the latest API. When we‚Äôve done that, we can match the version here with the broader PRQL version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-139"><a class="header" href="#prql-139">PRQL</a></h1>
<p><a href="https://prql-lang.org/">PRQL</a> bindings for Elixir.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code class="language-elixir">def deps do
  [
    {:prql, "~&gt; 0.1.0"}
  ]
end
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><code class="language-elixir">  iex&gt; PRQL.compile("from customers")
      {:ok, "SELECT\n  *\nFROM\n  customers\n\n-- Generated by PRQL compiler version 0.3.1 (https://prql-lang.org)\n"}


  iex&gt; PRQL.compile("from customers\ntake 10", dialect: :mssql)
  {:ok, "SELECT\n  *\nFROM\n  customers\nORDER BY\n  (\n    SELECT\n      NULL\n  ) OFFSET 0 ROWS\nFETCH FIRST\n  10 ROWS ONLY\n\n-- Generated by PRQL compiler version 0.3.1 (https://prql-lang.org)\n"}
</code></pre>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<p>We are in the early stages of developing Elixir bindings.</p>
<p>We‚Äôre using <code>Rustler</code> to provide Rust bindings for <code>prqlc</code>.</p>
<p>Currently using the bindings in an Elixir project requires compiling the Rust crate from this repo:</p>
<ul>
<li>Install dependencies with <code>mix deps.get</code></li>
<li>Compile project <code>mix compile</code></li>
<li>Run tests <code>mix test</code></li>
</ul>
<p>Future work includes publishing pre-compiled artifacts, so Elixir projects can run PRQL without needing a Rust toolchain.</p>
<h2 id="mac"><a class="header" href="#mac">Mac</a></h2>
<p>We currently don‚Äôt enable compilation for Mac. This is possible to enable, but causes some issues with cargo‚Äôs compilation cache. Briefly: it requires <code>RUSTFLAGS</code> to be set, and because of <a href="https://github.com/rust-lang/cargo/issues/8716">https://github.com/rust-lang/cargo/issues/8716</a> &amp; <a href="https://github.com/rust-lang/cargo/issues/8899">https://github.com/rust-lang/cargo/issues/8899</a>, any compilation of a different target will bust the cache.</p>
<p>The possible future workarounds include:</p>
<ul>
<li>Passing <code>--target=aarch64-apple-darwin</code> to every cargo call, which is inconvenient and can be difficult in some situations; e.g. Rust Analyzer. This disables passing <code>RUSTFLAGS</code> (I‚Äôm actually unclear why <code>prql-elixir</code> builds successfully in that case‚Ä¶)</li>
<li>Directing other cargo calls to different paths, such as <code>/target-ra</code> for Rust Analyzer and <code>/target-book</code> for the book building. But one <code>cargo build</code> from the terminal without either the <code>target</code> or <code>target_dir</code> specified will bust the cache!</li>
<li>Never compiling for other targets. But our standard tests run for <code>--target=wasm32-unknown-unknown</code>, so this requires refraining from using them.</li>
<li>Removing <code>prql-elixir</code> from our workspace, so that <code>cargo</code> commands in the PRQL workspace don‚Äôt require rust flags. This would work well, but means we need separate test coverage for this crate, which adds some weight to the tests.</li>
</ul>
<p>If <code>prql-elixir</code> becomes more used (for example, we start publishing to Hex, or Mac developers want to work on it), then we can re-enable and deal with the caching issues. We can also re-enable them if the <code>cargo</code> issue is resolved.</p>
<p>To test on Mac temporarily ‚Äî¬†for example if there‚Äôs an error in GHA and we‚Äôre on a Mac locally ‚Äî apply a diff like this, and then run <code>cargo build</code> from the <code>prql-elixir</code> path, which will enable the local <a href="https://github.com/PRQL/prql/blob/main/prqlc/bindings/elixir/native/prql/.cargo/config.toml"><code>.cargo/config.toml</code></a>). (We could also make a feature like <code>elixir-mac</code> which enabled building on Mac).</p>
<pre><code class="language-diff">diff --git a/prqlc/bindings/elixir/native/prql/Cargo.toml b/prqlc/bindings/elixir/native/prql/Cargo.toml
index 7194ca4f..9c7240ff 100644
--- a/prqlc/bindings/elixir/native/prql/Cargo.toml
+++ b/prqlc/bindings/elixir/native/prql/Cargo.toml
@@ -19,5 +19,5 @@ path = "src/lib.rs"
 prql-compiler = {path = "../../../../prql-compiler", default-features = false, version = "0.6.1"}

 # See Readme for details on Mac
-[target.'cfg(not(any(target_family="wasm", target_os = "macos")))'.dependencies]
+# [target.'cfg(not(any(target_family="wasm", target_os = "macos")))'.dependencies]
 rustler = "0.27.0"
diff --git a/prqlc/bindings/elixir/native/prql/src/lib.rs b/prqlc/bindings/elixir/native/prql/src/lib.rs
index 2c5c8f27..68e77217 100644
--- a/prqlc/bindings/elixir/native/prql/src/lib.rs
+++ b/prqlc/bindings/elixir/native/prql/src/lib.rs
@@ -1,5 +1,5 @@
 // See Readme for more information on Mac compiling
-#![cfg(not(target_os = "macos"))]
+// #![cfg(not(target_os = "macos"))]
 // These bindings aren't relevant on wasm
 #![cfg(not(target_family = "wasm"))]
 // TODO: unclear why we need this `allow`; it's required in `CompileOptions`,

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-java"><a class="header" href="#prql-java">prql-java</a></h1>
<p><code>prql-java</code> offers Java bindings to the <code>prql-compiler</code> Rust library. It exposes a Java native method <code>public static native String toSql(String query)</code>.</p>
<p>It‚Äôs still at an early stage, and currently requires compiling locally, and isn‚Äôt published to Maven. Contributions are welcome.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.prqllang&lt;/groupId&gt;
    &lt;artifactId&gt;prql-java&lt;/artifactId&gt;
    &lt;version&gt;${PRQL_VERSION}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><code class="language-java">import org.prqllang.prql4j.PrqlCompiler;

class Main {
    public static void main(String[] args) {
        String sql = PrqlCompiler.toSql("from table");
        System.out.println(sql);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prqlc-js"><a class="header" href="#prqlc-js">prqlc-js</a></h1>
<p>JavaScript bindings for <a href="https://github.com/PRQL/prql/"><code>prqlc</code></a>.</p>
<h2 id="installation-3"><a class="header" href="#installation-3">Installation</a></h2>
<pre><code class="language-sh">npm install prqlc
</code></pre>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>Currently these functions are exposed</p>
<pre><code class="language-typescript">function compile(prql_query: string, options?: CompileOptions): string;

function prql_to_pl(prql_query: string): string;

function pl_to_prql(pl_json: string): string;

function pl_to_rq(pl_json: string): string;

function rq_to_sql(rq_json: string): string;
</code></pre>
<h3 id="from-nodejs"><a class="header" href="#from-nodejs">From Node.js</a></h3>
<p>Direct usage</p>
<pre><code class="language-javascript">const prqlc = require("prqlc");

const sql = prqlc.compile(`from employees | select first_name`);
console.log(sql);
</code></pre>
<p>Options</p>
<pre><code class="language-javascript">const opts = new prqlc.CompileOptions();
opts.target = "sql.mssql";
opts.format = false;
opts.signature_comment = false;

const sql = prqlc.compile(`from employees | take 10`, opts);
console.log(sql);
</code></pre>
<p>Template literal</p>
<pre><code class="language-javascript">const prqlc = require("prqlc");
const prql = (string) =&gt; prqlc.compile(string[0] || "");

const sql = prql`from employees | select first_name`;
console.log(sql);
</code></pre>
<p>Template literal with newlines</p>
<pre><code class="language-javascript">const prqlc = require("prqlc");
const prql = (string) =&gt; prqlc.compile(string[0] || "");

const sql = prql`
    from employees
    select first_name
`;
console.log(sql);
</code></pre>
<h3 id="from-a-browser"><a class="header" href="#from-a-browser">From a browser</a></h3>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;script type="module"&gt;
      import init, { compile } from "./dist/web/prql_js.js";
      await init();

      const sql = compile("from employees | select first_name");
      console.log(sql);
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="from-a-framework-or-a-bundler"><a class="header" href="#from-a-framework-or-a-bundler">From a framework or a bundler</a></h3>
<pre><code class="language-typescript">import compile from "prqlc/dist/bundler";

const sql = compile(`from employees | select first_name`);
console.log(sql);
</code></pre>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<p>Errors are returned as following object, serialized as a JSON array:</p>
<pre><code class="language-typescript">interface ErrorMessage {
  /// Message kind. Currently only Error is implemented.
  kind: "Error" | "Warning" | "Lint";
  /// Machine-readable identifier of the error
  code: string | null;
  /// Plain text of the error
  reason: string;
  /// A list of suggestions of how to fix the error
  hint: string | null;
  /// Character offset of error origin within a source file
  span: [number, number] | null;

  /// Annotated code, containing cause and hints.
  display: string | null;
  /// Line and column number of error origin within a source file
  location: SourceLocation | null;
}

/// Location within the source file.
/// Tuples contain:
/// - line number (0-based),
/// - column number within that line (0-based),
interface SourceLocation {
  start: [number, number];

  end: [number, number];
}
</code></pre>
<p>These errors can be caught as such:</p>
<pre><code class="language-javascript">try {
  const sql = prqlJs.compile(`from employees | foo first_name`);
} catch (error) {
  const errorMessages = JSON.parse(error.message).inner;

  console.log(errorMessages[0].display);
  console.log(errorMessages[0].location);
}
</code></pre>
<h2 id="development-1"><a class="header" href="#development-1">Development</a></h2>
<p>Build:</p>
<pre><code class="language-sh">npm run build
</code></pre>
<p>This builds Node, bundler and web packages in the <code>dist</code> path.</p>
<p>Test:</p>
<pre><code class="language-sh">npm test
</code></pre>
<p>By default the <code>wasm</code> binaries are optimized on each run, even if the underlying code hasn‚Äôt changed, which can be slow. For a lower-latency dev loop, pass <code>--profile=dev</code> to <code>npm install</code> for a faster, less optimized build.</p>
<pre><code class="language-sh">npm install prqlc --profile=dev
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>This uses <a href="https://rustwasm.github.io/docs/wasm-pack/"><code>wasm-pack</code></a> to generate bindings<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>.</li>
<li>We‚Äôve added an <code>npm</code> layer on top of the usual approach of just using <code>wasm-pack</code>, so we can distribute a single package with targets of <code>node</code>, <code>bundler</code> and <code>no-modules</code> ‚Äî somewhat inverting the approach recommended by <code>wasm-pack</code>. The build instruction goes in a <code>build</code> script, rather than a <code>pack</code> script.</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<pre><code>   Though we would be very open to other approaches, given wasm-pack does not
   seem maintained, and we're eliding many of its features to build for three
   targets. See &lt;https://github.com/PRQL/prql/issues/1836&gt; for more details.
   ````
</code></pre>
 <a href="#fr-1-1">‚Ü©</a></li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="prql-php"><a class="header" href="#prql-php">prql-php</a></h1>
<p><code>prql-php</code> offers PHP bindings to <code>prql-compiler</code> crate through FFI.</p>
<p>It provides the <code>Compiler</code> class which contains <code>compile</code>, <code>prqlToPL</code>, <code>plToRQ</code> and <code>rqToSQL</code> functions.</p>
<p>It‚Äôs still at an early stage, and isn‚Äôt published to Composer. Contributions are welcome.</p>
<h2 id="installation-4"><a class="header" href="#installation-4">Installation</a></h2>
<p>The <a href="https://www.php.net/manual/en/book.ffi.php">PHP FFI extension</a> needs to be enabled. Set <code>ffi.enable</code> in your php.ini configuration file to <code>"true"</code>.</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<pre><code class="language-php">&lt;?php

use Prql\Compiler\Compiler;

$prql = new Compiler();
$result = $prql-&gt;compile("from employees");

echo $result-&gt;output;
</code></pre>
<h2 id="development-2"><a class="header" href="#development-2">Development</a></h2>
<h3 id="environment"><a class="header" href="#environment">Environment</a></h3>
<p>A way to establish a dev environment with PHP, the ext-ffi extension and Composer is to use a <a href="https://github.com/loophp/nix-shell">nix flake</a>. After installing nix, enable experimental flakes feature:</p>
<pre><code>mkdir -p ~/.config/nix
echo "experimental-features = nix-command flakes" &gt;&gt; ~/.config/nix/nix.conf
</code></pre>
<p>Now you can spawn a shell from <code>prql-php/</code>:</p>
<pre><code>nix shell github:loophp/nix-shell#env-php81 --impure
</code></pre>
<p>This will pull-in ext-ffi extension, because it‚Äôs declared in <code>composer.json</code>.</p>
<h3 id="building"><a class="header" href="#building">Building</a></h3>
<p>There is a <code>task build-php</code> script that:</p>
<ul>
<li>runs cargo to build <code>libprqlc_c</code>,</li>
<li>copies <code>libprqlc_c.*</code> into <code>lib</code>,</li>
<li>copies <code>prqlc.h</code> into <code>lib</code>.</li>
</ul>
<h3 id="tests"><a class="header" href="#tests">Tests</a></h3>
<pre><code>task build-php
task test-php
</code></pre>
<h3 id="code-style"><a class="header" href="#code-style">Code style</a></h3>
<pre><code>./vendor/bin/phpcs --standard=PSR12 src tests
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-bindings-to-prqlc"><a class="header" href="#python-bindings-to-prqlc">Python bindings to <code>prqlc</code></a></h1>
<p>The <code>prqlc-python</code> crate offer Rust bindings to the <code>prqlc</code> Rust library, published to a python package named <code>prqlc</code>.</p>
<p>The main entry point is a Python method <code>prqlc.compile(query: str) -&gt; str</code>.</p>
<p>The package is consumed by <a href="https://github.com/prql/pyprql">pyprql</a> &amp; <a href="https://github.com/prql/dbt-prql">dbt-prql</a>.</p>
<p>The crate is not published to crates.io; only to PyPI at <a href="https://pypi.org/project/prqlc/">https://pypi.org/project/prqlc/</a>.</p>
<h2 id="installation-5"><a class="header" href="#installation-5">Installation</a></h2>
<p><code>pip install prqlc</code></p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<pre><code class="language-python">import prqlc

prql_query = """
    from employees
    join salaries (==emp_id)
    group {employees.dept_id, employees.gender} (
      aggregate {
        avg_salary = average salaries.salary
      }
    )
"""

options = prqlc.CompileOptions(
    format=True, signature_comment=True, target="sql.postgres"
)

sql = prqlc.compile(prql_query)
sql_postgres = prqlc.compile(prql_query, options)
</code></pre>
<p>Relies on <a href="https://github.com/PyO3/pyo3">pyo3</a> for all the magic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="r-prqlr"><a class="header" href="#r-prqlr">R (prqlr)</a></h1>
<p>R bindings for <code>prqlc</code>.</p>
<p><code>prqlr</code> also includes <code>knitr</code> (R Markdown and Quarto) integration, which allows us to easily create documents with the PRQL conversion results embedded in.</p>
<p>Check out <a href="https://prql.github.io/prqlc-r/">https://prql.github.io/prqlc-r/</a> for more context.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/bindings/r.html#admonition-note"></a>
</div>
<div>
<p><code>prqlr</code> is generously maintained by <a href="https://github.com/eitsupi">@eitsupi</a> in the <a href="https://github.com/PRQL/prqlc-r">PRQL/prqlc-r</a> repo.</p>
</div>
</div>
<h2 id="installation-6"><a class="header" href="#installation-6">Installation</a></h2>
<pre><code class="language-r">install.packages("prqlr")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Please check the documentation of the <a href="https://docs.rs/prqlc/latest/prqlc/">prqlc crate</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrations"><a class="header" href="#integrations">Integrations</a></h1>
<p>PRQL is building integrations with lots of external tools, including:</p>
<ul>
<li><a href="project/integrations/./prqlc-cli.html"><code>prqlc</code> CLI</a> - Rust compiler for the command line</li>
<li><a href="project/integrations/./clickhouse.html">ClickHouse</a></li>
<li><a href="project/integrations/./jupyter.html">Jupyter</a></li>
<li><a href="project/integrations/./duckdb.html">DuckDB</a></li>
<li><a href="project/integrations/./qstudio.html">qStudio</a></li>
<li><a href="project/integrations/./prefect.html">Prefect</a></li>
<li><a href="project/integrations/./vscode.html">VS Code</a></li>
<li><a href="project/integrations/./rill.html">Rill</a></li>
<li><a href="project/integrations/./postgresql.html">PostgreSQL</a></li>
<li><a href="project/integrations/./databend.html">Databend</a></li>
<li><a href="project/integrations/./syntax-highlighting.html">Syntax highlighting</a> for many popular tools.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-compiler"><a class="header" href="#prql-compiler">PRQL compiler</a></h1>
<p><code>prqlc</code> is the reference implementation of a compiler from PRQL to SQL, written in Rust. It also serves as the CLI.</p>
<p>For more on PRQL, check out the <a href="https://prql-lang.org">PRQL website</a> or the <a href="https://github.com/PRQL/prql">PRQL repo</a>.</p>
<h2 id="cli"><a class="header" href="#cli">CLI</a></h2>
<p><code>prqlc</code> serves as a CLI for the PRQL compiler. It is a single, dependency-free binary that compiles PRQL into SQL.</p>
<h2 id="usage-5"><a class="header" href="#usage-5">Usage</a></h2>
<h3 id="prqlc-compile"><a class="header" href="#prqlc-compile"><code>prqlc compile</code></a></h3>
<p>This command works as a filter that compiles a PRQL string into an SQL string.</p>
<pre><code class="language-sh">$ echo 'from employees | filter has_dog | select salary' | prqlc compile

SELECT
  salary
FROM
  employees
WHERE
  has_dog
</code></pre>
<p>A PRQL query can be executed with CLI tools compatible with SQL, such as <a href="https://duckdb.org/docs/api/cli.html">DuckDB CLI</a>.</p>
<pre><code class="language-sh">$ curl -fsL https://raw.githubusercontent.com/PRQL/prql/0.8.1/prql-compiler/tests/integration/data/chinook/albums.csv -o albums.csv
$ echo 'from `albums.csv` | take 3' | prqlc compile | duckdb
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ album_id ‚îÇ                 title                 ‚îÇ artist_id ‚îÇ
‚îÇ  int64   ‚îÇ                varchar                ‚îÇ   int64   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ        1 ‚îÇ For Those About To Rock We Salute You ‚îÇ         1 ‚îÇ
‚îÇ        2 ‚îÇ Balls to the Wall                     ‚îÇ         2 ‚îÇ
‚îÇ        3 ‚îÇ Restless and Wild                     ‚îÇ         2 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<p>Executing this command without any argument will start interactive mode, allowing a PRQL query to be written interactively. In this mode, after writing PRQL and press <code>Ctrl-d</code> (Linux, macOS) or <code>Ctrl-z</code> (Windows) to display the compiled SQL.</p>
<pre><code class="language-sh">prqlc compile
</code></pre>
<p>Just like when using it as a filter, SQL string output can be passed to the DuckDB CLI and similar tools.</p>
<pre><code class="language-sh">$ prqlc compile | duckdb
Enter PRQL, then press ctrl-d to compile:

from `albums.csv`
take 3
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ album_id ‚îÇ                 title                 ‚îÇ artist_id ‚îÇ
‚îÇ  int64   ‚îÇ                varchar                ‚îÇ   int64   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ        1 ‚îÇ For Those About To Rock We Salute You ‚îÇ         1 ‚îÇ
‚îÇ        2 ‚îÇ Balls to the Wall                     ‚îÇ         2 ‚îÇ
‚îÇ        3 ‚îÇ Restless and Wild                     ‚îÇ         2 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h2 id="installation-7"><a class="header" href="#installation-7">Installation</a></h2>
<p><a href="https://repology.org/project/prqlc/versions"><img src="https://repology.org/badge/vertical-allrepos/prqlc.svg" alt="Packaging status" /></a></p>
<h3 id="via-homebrew-macos-linux"><a class="header" href="#via-homebrew-macos-linux">via Homebrew (macOS, Linux)</a></h3>
<pre><code class="language-sh">brew install prqlc
</code></pre>
<h3 id="via-winget-windows"><a class="header" href="#via-winget-windows">via winget (Windows)</a></h3>
<pre><code class="language-sh">winget install prqlc
</code></pre>
<h3 id="from-github-release-page"><a class="header" href="#from-github-release-page">From GitHub release page</a></h3>
<p>Precompiled binaries are available for Linux, macOS, and Windows on the <a href="https://github.com/PRQL/prql/releases">PRQL release page</a>.</p>
<h3 id="from-source"><a class="header" href="#from-source">From source</a></h3>
<pre><code class="language-sh"># From crates.io
cargo install prqlc
</code></pre>
<pre><code class="language-sh"># From a local PRQL repository
cargo install --path prqlc/prqlc
</code></pre>
<h3 id="shell-completions"><a class="header" href="#shell-completions">Shell completions</a></h3>
<p>The <code>prqlc shell-completion</code> command prints a shell completion script for supported shells, and saving the printed scripts to files makes for shells to load completions for each session.</p>
<h4 id="bash"><a class="header" href="#bash">Bash</a></h4>
<p>For Linux:</p>
<pre><code class="language-sh">prqlc shell-completion bash &gt;/etc/bash_completion.d/prqlc
</code></pre>
<p>For macOS:</p>
<pre><code class="language-sh">prqlc shell-completion bash &gt;/usr/local/etc/bash_completion.d/prqlc
</code></pre>
<h4 id="fish"><a class="header" href="#fish">fish</a></h4>
<pre><code class="language-sh">prqlc shell-completion fish &gt;~/.config/fish/completions/prqlc.fish
</code></pre>
<h4 id="powershell"><a class="header" href="#powershell">PowerShell</a></h4>
<pre><code class="language-powershell">mkdir -Path (Split-Path -Parent $profile) -ErrorAction SilentlyContinue
prqlc shell-completion powershell &gt;path/to/prqlc.ps1
echo 'Invoke-Expression -Command path/to/prqlc.ps1' &gt;&gt;$profile
</code></pre>
<h4 id="zsh"><a class="header" href="#zsh">zsh</a></h4>
<pre><code class="language-sh">prqlc shell-completion zsh &gt;"${fpath[1]}/_prqlc"
</code></pre>
<p>Ensure that the following lines are present in <code>~/.zshrc</code>:</p>
<pre><code class="language-sh">autoload -U compinit
compinit -i
</code></pre>
<h2 id="helpers"><a class="header" href="#helpers">Helpers</a></h2>
<p>Cheat sheets for <code>prqlc</code> are available on various websites and with various tools.</p>
<ul>
<li><a href="https://tldr.sh/"><code>tldr</code></a> (<a href="https://tldr.inbrowser.app/pages/common/prqlc">on the web</a>)</li>
<li><a href="https://github.com/srsudar/eg"><code>eg</code></a></li>
</ul>
<!-- Issues: #2034 cheat/cheatsheets, #2041 devhints.io -->
<h2 id="library"><a class="header" href="#library">Library</a></h2>
<p>For more usage examples and the library documentation, check out the <a href="https://docs.rs/prqlc/"><code>prqlc</code> documentation</a>.</p>
<h3 id="library-installation"><a class="header" href="#library-installation">Library installation</a></h3>
<pre><code class="language-shell">cargo add prqlc
</code></pre>
<h3 id="examples-11"><a class="header" href="#examples-11">Examples</a></h3>
<p>Compile a PRQL string to a SQLite dialect string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In a file src/main.rs

use prqlc::{compile, Options, DisplayOptions, Target, sql::Dialect};

let prql = "from employees | select {name, age}";
let opts = &amp;Options {
    format: false,
    target: Target::Sql(Some(Dialect::SQLite)),
    signature_comment: false,
    display: DisplayOptions::Plain,
    ..Default::default()
};
let sql = compile(&amp;prql, opts).unwrap();
assert_eq!("SELECT name, age FROM employees", sql);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clickhouse"><a class="header" href="#clickhouse">ClickHouse</a></h1>
<p>PRQL works natively in ClickHouse. Check out the <a href="https://clickhouse.com/docs/en/guides/developer/alternative-query-languages">ClickHouse docs</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jupyter"><a class="header" href="#jupyter">Jupyter</a></h1>
<p><a href="https://pypi.org/project/pyprql/">pyprql</a> contains <code>pyprql.magic</code>, a thin wrapper of <a href="https://pypi.org/project/jupysql/"><code>JupySQL</code></a>‚Äôs SQL IPython magics. This allows us to run PRQL interactively on Jupyter/IPython.</p>
<p>Check out <a href="https://pyprql.readthedocs.io/">https://pyprql.readthedocs.io/</a> for more context.</p>
<h2 id="installation-8"><a class="header" href="#installation-8">Installation</a></h2>
<pre><code class="language-sh">pip install pyprql
</code></pre>
<h2 id="usage-6"><a class="header" href="#usage-6">Usage</a></h2>
<p>When installing pyprql, the <a href="https://pypi.org/project/duckdb-engine/">duckdb-engine</a> package is also installed with it, so we can start using PRQL immediately to query CSV and Parquet files.</p>
<p>For example, running <a href="https://jupysql.ploomber.io/en/latest/quick-start.html">the example from the JupySQL documentation</a> on IPython:</p>
<pre><code class="language-python">In [1]: %load_ext pyprql.magic

In [2]: !curl -sL https://raw.githubusercontent.com/mwaskom/seaborn-data/master/penguins.csv -o penguins.csv

In [3]: %prql duckdb://

In [4]: %prql from `penguins.csv` | take 3
Out[4]:
  species     island  bill_length_mm  bill_depth_mm  flipper_length_mm  body_mass_g     sex
0  Adelie  Torgersen            39.1           18.7                181         3750    MALE
1  Adelie  Torgersen            39.5           17.4                186         3800  FEMALE
2  Adelie  Torgersen            40.3           18.0                195         3250  FEMALE

In [5]: %%prql
   ...: from `penguins.csv`
   ...: filter bill_length_mm &gt; 40
   ...: take 3
   ...:
   ...:
Out[5]:
  species     island  bill_length_mm  bill_depth_mm  flipper_length_mm  body_mass_g     sex
0  Adelie  Torgersen            40.3           18.0                195         3250  FEMALE
1  Adelie  Torgersen            42.0           20.2                190         4250    None
2  Adelie  Torgersen            41.1           17.6                182         3200  FEMALE
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="duckdb"><a class="header" href="#duckdb">DuckDB</a></h1>
<p>There‚Äôs an experimental <a href="https://duckdb.org/">DuckDB</a> extension from <strong><a href="https://github.com/ywelsch">@ywelsch</a></strong> at <a href="https://github.com/ywelsch/duckdb-prql">ywelsch/duckdb-prql</a>.</p>
<p>Check out the Readme for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qstudio-ide"><a class="header" href="#qstudio-ide">qStudio IDE</a></h1>
<p>qStudio is a SQL GUI that lets you browse tables, run SQL scripts, and chart and export the results. qStudio runs on Windows, macOS and Linux, and works with every popular database including mysql, postgresql, mssql, kdb‚Ä¶.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/integrations/qstudio.html#admonition-note"></a>
</div>
<div>
<p>qStudio relies on the PRQL compiler. You must ensure that <code>prqlc</code> is in your path. See the <a href="https://prql-lang.org/book/project/integrations/prqlc-cli.html#installation">installation instructions</a> in the PRQL reference guide for details.</p>
</div>
</div>
<p>qStudio then calls <code>prqlc</code> (the compiler) to generate SQL code from PRQL queries (.prql files). For more details, check out the <a href="https://www.timestored.com/qstudio/prql-ide">qStudio site</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefect"><a class="header" href="#prefect">Prefect</a></h1>
<p>Because <a href="https://www.prefect.io/">Prefect</a> is in native Python, it‚Äôs extremely easy to integrate with PRQL.</p>
<p>With a Postgres Task, replace:</p>
<pre><code class="language-python">PostgresExecute.run(..., query=sql)
</code></pre>
<p>‚Ä¶with‚Ä¶</p>
<pre><code class="language-python">PostgresExecute.run(..., query=prql_python.compile(prql))
</code></pre>
<p>We‚Äôre big fans of Prefect, and if there is anything that would make the integration easier, please open an issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-code-extension"><a class="header" href="#visual-studio-code-extension">Visual Studio Code extension</a></h1>
<p>PRQL has a Visual Studio Code extension that compiles a PRQL query in a VS Code editor and displays the resulting SQL code in a second pane on the side. This is very handy for editing, saving, and reusing PRQL queries in VS Code.</p>
<p>To install the VS Code extension, open VS Code and type <kbd>Ctrl</kbd>-<kbd>Shift</kbd>-<kbd>P</kbd> (<kbd>Cmd</kbd>-<kbd>Shift</kbd>-<kbd>P</kbd> on a Mac) and type <code>PRQL</code>. Install the extension as usual.</p>
<p><a href="https://github.com/PRQL/prql-vscode">Repo for the PRQL VS Code extension</a></p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=PRQL-lang.prql-vscode">Extension on VS Marketplace</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h1>
<p>PL/PRQL is a PostgreSQL extension that lets you write functions with PRQL.</p>
<p>PL/PRQL functions serve as intermediaries, compiling the user‚Äôs PRQL code into SQL statements that PostgreSQL executes. The extension is based on the <a href="https://github.com/pgcentralfoundation/pgrx">pgrx</a> framework for developing PostgreSQL extensions in Rust. This framework manages the interaction with PostgreSQL‚Äôs internal APIs, type conversions, and other function hooks necessary to integrate PRQL with PostgreSQL.</p>
<h2 id="examples-12"><a class="header" href="#examples-12">Examples</a></h2>
<p>PL/PRQL functions are defined using the <code>plprql</code> language specifier:</p>
<pre><code class="language-sql">create function match_stats(int) returns table(player text, kd_ratio float) as $$
  from matches
  filter match_id == $1
  group player (
    aggregate {
      total_kills = sum kills,
      total_deaths = sum deaths
    }
  )
  filter total_deaths &gt; 0
  derive kd_ratio = total_kills / total_deaths
  select { player, kd_ratio }
$$ language plprql;

select * from match_stats(1001)

 player  | kd_ratio
---------+----------
 Player1 |    0.625
 Player2 |      1.6
(2 rows)
</code></pre>
<p>You can also run PRQL code directly with the <code>prql</code> function which is useful for custom SQL in ORMs:</p>
<pre><code class="language-sql">select prql('from matches | filter player == ''Player1''')
as (id int, match_id int, round int, player text, kills int, deaths int)
limit 2;

 id | match_id | round | player  | kills | deaths
----+----------+-------+---------+-------+--------
  1 |     1001 |     1 | Player1 |     4 |      1
  3 |     1001 |     2 | Player1 |     1 |      7
(2 rows)

-- Same as above without the need for the static types, but returns cursor
select prql('from matches | filter player == ''Player1''', 'player1_cursor');
fetch 2 from player1_cursor;
</code></pre>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>For installation instructions and more information on the extension, see the <a href="https://github.com/kaspermarstal/plprql">PL/PRQL repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="databend"><a class="header" href="#databend">Databend</a></h1>
<p>Databend natively supports PRQL. For more details see the <a href="https://www.databend.com/blog/2024-04-03-databend-integrates-prql/">databend docs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rill"><a class="header" href="#rill">Rill</a></h1>
<p>PRQL has had some work to integrate with Rill. See the <a href="https://github.com/PRQL/prql/issues?q=is%3Aissue+rill">Rill issues</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grammars--syntax-highlighting"><a class="header" href="#grammars--syntax-highlighting">Grammars / syntax highlighting</a></h1>
<p>PRQL contains multiple grammar definitions to enable tools to highlight PRQL code. These are all intended to provide as good an experience as the grammar supports. Please raise any shortcomings in a GitHub issue.</p>
<p>The definitions are somewhat scattered around the codebase; this page serves as an index.</p>
<ul>
<li>
<p><a href="https://ace.c9.io/">Ace</a> ‚Äî supported. The grammar is upstream (<a href="https://github.com/ajaxorg/ace/blob/master/src/mode/prql_highlight_rules.js">prql_highlight_rules.js</a>). See the <a href="https://prql-lang.org/demos/ace-demo">demo</a>.</p>
</li>
<li>
<p><a href="https://github.com/alecthomas/chroma">chroma</a> ‚Äî Go library used by the static website generator Hugo. The grammar is upstream (<a href="https://github.com/alecthomas/chroma/blob/master/lexers/embedded/prql.xml">prql.xml</a>). See the <a href="https://swapoff.org/chroma/playground/">demo</a>.</p>
</li>
<li>
<p><a href="https://lezer.codemirror.net/">Lezer</a> ‚Äî used by CodeMirror editors. The PRQL file is at <a href="https://github.com/PRQL/prql/tree/main/grammars/prql-lezer/README.md"><code>grammars/prql-lezer/README.md</code></a>.</p>
</li>
<li>
<p><a href="https://handlebarsjs.com/">Handlebars</a> ‚Äî currently duplicated:</p>
<ul>
<li>The book: <a href="https://github.com/PRQL/prql/blob/main/web/book/highlight-prql.js"><code>book/highlight-prql.js</code></a></li>
<li>The website (outside of the book &amp; playground): <a href="https://github.com/PRQL/prql/blob/main/web/book/highlight-prql.js"><code>website/themes/prql-theme/static/plugins/highlight/prql.js</code></a></li>
</ul>
</li>
<li>
<p>Sublime Text ‚Äî in the <a href="https://github.com/PRQL/sublime-prql/"><code>sublime-prql</code></a> repository.</p>
</li>
<li>
<p>TextMate ‚Äî used by the VS Code extension; in the <code>prql-vscode</code> repo in <a href="https://github.com/PRQL/prql-vscode/blob/main/syntaxes/prql.tmLanguage.json"><code>prql-vscode/syntaxes/prql.tmLanguage.json</code></a>.</p>
</li>
<li>
<p><a href="https://microsoft.github.io/monaco-editor/monarch.html">Monarch</a> ‚Äî used by the Monaco editor, which we use for the Playground. The grammar is at <a href="https://github.com/PRQL/prql/blob/main/web/playground/src/workbench/prql-syntax.js"><code>playground/src/workbench/prql-syntax.js</code></a>.</p>
</li>
<li>
<p><a href="https://pygments.org/">Pygments</a> ‚Äî Python library used by Wikipedia, Bitbucket, Sphinx and <a href="https://pygments.org/faq/#who-uses-pygments">more</a>. The grammar is upstream (<a href="https://github.com/pygments/pygments/blob/master/pygments/lexers/prql.py">prql.py</a>). See the <a href="https://pygments.org/demo/">demo</a>.</p>
</li>
<li>
<p><a href="https://tree-sitter.github.io/tree-sitter">Tree-Sitter</a> ‚Äî used by the neovim and helix. The grammar can be found at <a href="https://github.com/PRQL/tree-sitter-prql">https://github.com/PRQL/tree-sitter-prql</a>.</p>
</li>
</ul>
<hr />
<p>Since the <a href="https://elm-lang.org/">Elm</a> language coincidentally provides syntax highlighting suitable for PRQL, it may look better to mark PRQL code as Elm when the above definition files are not available.</p>
<p>For example, the following Markdown code block will be nicely highlighted on GitHub, Pandoc, and other Markdown renderers:</p>
<pre><code class="language-markdown">```elm
from employees
filter start_date &gt; @2021-01-01
```
</code></pre>
<p>We hope that in the future these renderers will recognize PRQL code blocks and have syntax highlighting applied, and we are tracking these with several issues.</p>
<ul>
<li>GitHub (Linguist): <a href="https://github.com/PRQL/prql/issues/1636">https://github.com/PRQL/prql/issues/1636</a></li>
<li>Pandoc (Kate): <a href="https://github.com/PRQL/prql/issues/2213">https://github.com/PRQL/prql/issues/2213</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>If you‚Äôre interested in joining the community to build a better SQL, here are ways to start:</p>
<ul>
<li>Star the <a href="https://github.com/PRQL/prql">repo</a>.</li>
<li>Send a link to PRQL to a couple of people whose opinion you respect.</li>
<li>Subscribe to <a href="https://www.jessesquires.com/blog/2020/07/30/github-tip-watching-releases/">new releases</a> for updates.</li>
<li>Follow us on <a href="https://twitter.com/prql_lang">Twitter</a>.</li>
<li>Join our <a href="https://discord.gg/eQcfaCmsNc">Discord</a>.</li>
<li>Find an issue labeled <a href="https://github.com/prql/prql/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">Good First Issue</a> and start contributing to the code.</li>
<li>Join our <a href="https://github.com/PRQL/prql/issues/1083">fortnightly Developer Call</a>; (<a href="project/contributing/./fortnightly-dev-call.ics">iCal file</a>).</li>
</ul>
<p>PRQL is evolving from a project with lots of excitement into a project that folks are using in their work and integrating into their tools. We‚Äôre actively looking for collaborators to lead that growth with us.</p>
<h2 id="areas-for-larger-contributions"><a class="header" href="#areas-for-larger-contributions">Areas for larger contributions</a></h2>
<h3 id="compiler"><a class="header" href="#compiler">Compiler</a></h3>
<p>The compiler is written in Rust, and there‚Äôs enough to do such that any level of experience with Rust is sufficient.</p>
<p>We try to keep a few onboarding issues on hand under the <a href="https://github.com/PRQL/prql/labels/good%20first%20issue">‚Äúgood first issue‚Äù label</a>. These have been screened to have sufficient context to get started (and we very much welcome questions where there‚Äôs some context missing).</p>
<p>To get started, check out the docs on <a href="project/contributing/./development.html">Development</a> and the <a href="https://github.com/PRQL/prql/blob/main/prqlc/ARCHITECTURE.md">Compiler architecture</a></p>
<p>And if you have questions, there are lots of friendly people on the Discord who will patiently help you.</p>
<h3 id="bindings--integrations"><a class="header" href="#bindings--integrations">Bindings &amp; integrations</a></h3>
<p>For PRQL to be successful, it needs to be available for the languages &amp; tools that people already use.</p>
<ul>
<li>We currently have bindings to the PRQL compiler in a few different languages; many of these can be improved, documented, and packaged in a better way.</li>
<li>If you have experience with packaging in an ecosystem that doesn‚Äôt currently have bindings, then creating PRQL bindings for that language we don‚Äôt currently support would be valuable to the project.</li>
<li>If there‚Äôs a tool that you use yourself to run data queries which you think would benefit from a PRQL integration, suggest one to us or the tool. If it‚Äôs open-source, build &amp; share a prototype.</li>
</ul>
<p>Relevant issues are labeled <a href="https://github.com/PRQL/prql/labels/integrations">Integrations</a>.</p>
<h3 id="language-design"><a class="header" href="#language-design">Language design</a></h3>
<p>We decide on new language features in GitHub issues, usually under <a href="https://github.com/PRQL/prql/issues?q=is%3Aopen+label%3Alanguage-design+sort%3Aupdated-desc">‚Äúlanguage design‚Äù label</a>.</p>
<p>You can also contribute by:</p>
<ul>
<li>Finding instances where the compiler produces incorrect results, and post a bug report ‚Äî¬†feel free to use the <a href="https://prql-lang.org/playground">playground</a>.</li>
<li>Opening an issue / append to an existing issue with examples of queries that are difficult to express in PRQL ‚Äî¬†especially if more difficult than SQL.</li>
</ul>
<p>With sufficient examples, suggest a change to the language! (Though suggestions <em>without</em> examples are difficult to engage with, so please do anchor suggestions in examples.)</p>
<h3 id="marketing"><a class="header" href="#marketing">Marketing</a></h3>
<ul>
<li>Improve our website. We have <a href="https://github.com/PRQL/prql/labels/web">a few issues open</a> on this front and are looking for anyone with at least some design skills.</li>
<li>Contribute towards the docs. Anything from shaping a whole section of the docs, to simply improving a confusing paragraph or fixing a typo.</li>
<li>Tell people about PRQL.</li>
<li>Find a group of users who would be interested in PRQL, help them get up to speed, help the project understand what they need.</li>
</ul>
<h2 id="core-team"><a class="header" href="#core-team">Core team</a></h2>
<p>If you have any questions or feedback and don‚Äôt receive a response on one of the general channels such as GitHub or Discord, feel free to reach out to:</p>
<ul>
<li><a href="https://github.com/aljazerzen"><strong>@aljazerzen</strong></a> ‚Äî Alja≈æ Mur Er≈æen</li>
<li><a href="https://github.com/max-sixty"><strong>@max-sixty</strong></a> ‚Äî Maximilian Roos</li>
<li><a href="https://github.com/eitsupi"><strong>@eitsupi</strong></a> ‚Äî SHIMA Tatsuya</li>
<li><a href="https://github.com/snth"><strong>@snth</strong></a> ‚Äî Tobias Brandt</li>
</ul>
<h3 id="core-team-emeritus"><a class="header" href="#core-team-emeritus">Core team Emeritus</a></h3>
<p>Thank you to those who have previously served on the core team:</p>
<ul>
<li><strong>@charlie-sanders</strong> ‚Äî Charlie Sanders</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-3"><a class="header" href="#development-3">Development</a></h1>
<h2 id="setting-up-an-initial-dev-environment"><a class="header" href="#setting-up-an-initial-dev-environment">Setting up an initial dev environment</a></h2>
<p>We can set up a local development environment sufficient for navigating, editing, and testing PRQL‚Äôs compiler code in two minutes:</p>
<ul>
<li>
<p>Install <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html"><code>rustup</code> &amp; <code>cargo</code></a>.</p>
</li>
<li>
<p>[Optional but highly recommended] Install <code>cargo-insta</code>, our testing framework:</p>
<pre><code class="language-sh">cargo install cargo-insta
</code></pre>
</li>
<li>
<p>That‚Äôs it! Running the unit tests for the <code>prqlc</code> crate after cloning the repo should complete successfully:</p>
<pre><code class="language-sh">cargo test --package prqlc --lib
</code></pre>
<p>‚Ä¶or, to run tests and update the test snapshots:</p>
<pre><code class="language-sh">cargo insta test --accept --package prqlc --lib
</code></pre>
<p>There‚Äôs more context on our tests in <a href="project/contributing/development.html#how-we-test">How we test</a> below.</p>
</li>
</ul>
<p>That‚Äôs sufficient for making an initial contribution to the compiler.</p>
<hr />
<h2 id="setting-up-a-full-dev-environment"><a class="header" href="#setting-up-a-full-dev-environment">Setting up a full dev environment</a></h2>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-info"></a>
</div>
<div>
<p>We really care about this process being easy, both because the project benefits from more contributors like you, and to reciprocate your future contribution. If something isn‚Äôt easy, please let us know in a GitHub Issue. We‚Äôll enthusiastically help you, and use your feedback to improve the scripts &amp; instructions.</p>
</div>
</div>
<p>For more advanced development; for example compiling for wasm or previewing the website, we have two options:</p>
<h3 id="option-1-use-the-projects-task"><a class="header" href="#option-1-use-the-projects-task">Option 1: Use the project‚Äôs <code>task</code></a></h3>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-note"></a>
</div>
<div>
<p>This is tested on macOS, should work on amd64 Linux, but won‚Äôt work on others (include Windows), since it relies on <code>brew</code>.</p>
</div>
</div>
<ul>
<li>
<p><a href="https://taskfile.dev/installation/">Install Task</a>.</p>
</li>
<li>
<p>Then run the <code>setup-dev</code> task. This runs commands from our <a href="https://github.com/PRQL/prql/blob/main/Taskfile.yaml">Taskfile.yaml</a>, installing dependencies with <code>cargo</code>, <code>brew</code>, <code>npm</code> &amp; <code>pip</code>, and suggests some VS Code extensions.</p>
<pre><code class="language-sh">task setup-dev
</code></pre>
</li>
</ul>
<h3 id="option-2-install-tools-individually"><a class="header" href="#option-2-install-tools-individually">Option 2: Install tools individually</a></h3>
<ul>
<li>
<p>We‚Äôll need <code>cargo-insta</code>, to update snapshot tests:</p>
<pre><code class="language-sh">cargo install cargo-insta
</code></pre>
</li>
<li>
<p>We‚Äôll need Python, which most systems will have already. The easiest way to check is to try running the full tests:</p>
<pre><code class="language-sh">cargo test
</code></pre>
<p>‚Ä¶and if that doesn‚Äôt complete successfully, ensure we have Python &gt;= 3.7, to compile <code>prqlc-python</code>.</p>
</li>
<li>
<p>For more involved contributions, such as building the website, playground, book, or some release artifacts, we‚Äôll need some additional tools. But we won‚Äôt need those immediately, and the error messages on what‚Äôs missing should be clear when we attempt those things. When we hit them, the <a href="https://github.com/PRQL/prql/blob/main/Taskfile.yaml">Taskfile.yaml</a> will be a good source to copy &amp; paste instructions from.</p>
</li>
</ul>
<h3 id="option-3-use-a-dev-container"><a class="header" href="#option-3-use-a-dev-container">Option 3: Use a Dev Container</a></h3>
<p>This project has a <a href="https://github.com/PRQL/prql/blob/main/.devcontainer/devcontainer.json">devcontainer.json file</a> and a <a href="https://github.com/PRQL/prql/pkgs/container/prql-devcontainer-base">pre-built dev container base Docker image</a>. Learn more about Dev Containers at <a href="https://containers.dev/">https://containers.dev/</a></p>
<p>Currently, the tools for Rust are already installed in the pre-built image, and, Node.js, Python and others are configured to be installed when build the container.</p>
<p>While there are a variety of tools that support Dev Containers, the focus here is on developing with VS Code in a container by <a href="https://docs.github.com/en/codespaces/overview">GitHub Codespaces</a> or <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers">VS Code Dev Containers extension</a>.</p>
<p>To use a Dev Container on a local computer with VS Code, install the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers">VS Code Dev Containers extension</a> and its system requirements. Then refer to the links above to get started.</p>
<h3 id="option-4-use-nix-development-environment"><a class="header" href="#option-4-use-nix-development-environment">Option 4: Use nix development environment</a></h3>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-note-1"></a>
</div>
<div>
<p>This is used by a member of the core team on Linux, but doesn‚Äôt currently work on Mac. We‚Äôre open to contributions to improve support.</p>
</div>
</div>
<p>A <a href="https://nixos.org/">nix</a> flake <code>flake.nix</code> provides 3 development environments:</p>
<ul>
<li><strong>default</strong>, for building the compiler</li>
<li><strong>web</strong>, for the compiler and the website,</li>
<li><strong>full</strong>, for the compiler, the website and the compiler bindings.</li>
</ul>
<p>To load the shell:</p>
<ol>
<li>
<p><a href="https://nixos.org/download">Install nix (the package manager)</a>. (only first time)</p>
</li>
<li>
<p>Enable flakes, which are a (pretty stable) experimental feature of nix. (only first time)</p>
<p>For non-NixOS users:</p>
<pre><code class="language-sh">mkdir -p ~/.config/nix/
tee 'experimental-features = nix-command flakes' &gt;&gt; ~/.config/nix/nix.conf
</code></pre>
<p>For NixOS users, follow instructions <a href="https://nixos.wiki/wiki/Flakes">here</a>.</p>
</li>
<li>
<p>Run:</p>
<pre><code class="language-sh">nix develop
</code></pre>
<p>To use the ‚Äúweb‚Äù or ‚Äúfull‚Äù shell, run:</p>
<pre><code class="language-sh">nix develop .#web
</code></pre>
</li>
</ol>
<p>Optionally, you can install <a href="https://direnv.net/">direnv</a>, to automatically load the shell when you enter this repo. The easiest way is to also install <a href="https://github.com/nix-community/nix-direnv">direnv-nix</a> and configure your <code>.envrc</code> with:</p>
<pre><code class="language-sh"># .envrc
use flake .#full
</code></pre>
<hr />
<h2 id="contribution-workflow"><a class="header" href="#contribution-workflow">Contribution workflow</a></h2>
<p>We‚Äôre similar to most projects on GitHub ‚Äî open a Pull Request with a suggested change!</p>
<h3 id="commits"><a class="header" href="#commits">Commits</a></h3>
<ul>
<li>If a change is user-facing, please add a line in <a href="https://github.com/PRQL/prql/blob/main/CHANGELOG.md"><strong><code>CHANGELOG.md</code></strong></a>, with <code>{message}, ({@contributor, #X})</code> where <code>X</code> is the PR number.
<ul>
<li>If there‚Äôs a missing entry, a follow-up PR containing just the changelog entry is welcome.</li>
</ul>
</li>
<li>We‚Äôre using <a href="https://www.conventionalcommits.org">Conventional Commits</a> message format, enforced through <a href="https://github.com/amannn/action-semantic-pull-request">action-semantic-pull-request</a>.</li>
</ul>
<h3 id="merges"><a class="header" href="#merges">Merges</a></h3>
<ul>
<li><strong>We merge any code that makes PRQL better</strong></li>
<li>A PR doesn‚Äôt need to be perfect to be merged; it doesn‚Äôt need to solve a big problem. It needs to:
<ul>
<li>be in the right direction,</li>
<li>make incremental progress,</li>
<li>be explicit on its current state, so others can continue the progress.</li>
</ul>
</li>
<li>That said, there are a few instances when we need to ensure we have some consensus before merging code ‚Äî for example non-trivial changes to the language, or large refactorings to the library.</li>
<li>If you have merge permissions, and are reasonably confident that a PR is suitable to merge (whether or not you‚Äôre the author), feel free to merge.
<ul>
<li>If you don‚Äôt have merge permissions and have authored a few PRs, ask and ye shall receive.</li>
</ul>
</li>
<li>The primary way we ratchet the code quality is through automated tests.
<ul>
<li>This means PRs almost always need a test to demonstrate incremental progress.</li>
<li>If a change breaks functionality without breaking tests, our tests were probably insufficient.</li>
<li>If a change breaks existing tests (for example, changing an external API), that indicates we should be careful about merging a change, including soliciting others‚Äô views.</li>
</ul>
</li>
<li>We use PR reviews to give general context, offer specific assistance, and collaborate on larger decisions.
<ul>
<li>Reviews around ‚Äònits‚Äô like code formatting / idioms / etc are very welcome. But the norm is for them to be received as helpful advice, rather than as mandatory tasks to complete. Adding automated tests &amp; lints to automate these suggestions is welcome.</li>
<li>If you have merge permissions and would like a PR to be reviewed before it merges, that‚Äôs great ‚Äî ask or assign a reviewer.</li>
<li>If a PR hasn‚Äôt received attention after a day, please feel free to ping the pull request.</li>
</ul>
</li>
<li>People may review a PR after it‚Äôs merged. As part of the understanding that we can merge quickly, contributors are expected to incorporate substantive feedback into a future PR.</li>
<li>We should revert quickly if the impact of a PR turns out not to be consistent with our expectations, or there isn‚Äôt as much consensus on a decision as we had hoped. It‚Äôs very easy to revert code and then re-revert when we‚Äôve resolved the issue; it‚Äôs a sign of moving quickly. Other options which resolve issues immediately are also fine, such as commenting out an incorrect test or adding a quick fix for the underlying issue.</li>
</ul>
<h2 id="docs"><a class="header" href="#docs">Docs</a></h2>
<p>We‚Äôre very keen on contributions to improve our documentation.</p>
<p>This includes our docs in the book, on the website, in our code, or in a Readme. We also appreciate issues pointing out that our documentation was confusing, incorrect, or stale ‚Äî if it‚Äôs confusing for you, it‚Äôs probably confusing for others.</p>
<p>Some principles for ensuring our docs remain maintainable:</p>
<ul>
<li>Docs should be as close as possible to the code. Doctests are ideal on this dimension ‚Äî they‚Äôre literally very close to the code and they can‚Äôt drift apart since they‚Äôre tested on every commit. Or, for example, it‚Äôs better to add text to a <code>--help</code> message, rather than write a paragraph in the Readme explaining the CLI.</li>
<li>We should have some visualization of how to maintain docs when we add them. Docs have a habit of falling out of date ‚Äî the folks reading them are often different from those writing them, they‚Äôre sparse from the code, generally not possible to test, and are rarely the by-product of other contributions. Docs that are concise &amp; specific are easier to maintain.</li>
<li>Docs should be specifically relevant to PRQL; anything else we can instead link to.</li>
</ul>
<p>If something doesn‚Äôt fit into one of these categories, there are still lots of ways of getting the word out there ‚Äî a blog post / gist / etc. Let us know and we‚Äôre happy to link to it / tweet it.</p>
<h2 id="how-we-test"><a class="header" href="#how-we-test">How we test</a></h2>
<p>We use a pyramid of tests ‚Äî we have fast, focused tests at the bottom of the pyramid, which give us low latency feedback when developing, and then slower, broader tests which ensure that we don‚Äôt miss anything as PRQL develops<sup><a name="to-footnote-1"><a href="project/contributing/development.html#footnote-1">1</a></a></sup>.</p>
<!-- markdownlint-disable MD053 -->
<div id="admonition-info-1" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-1-title">
<div class="admonition-title">
<div id="admonition-info-1-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-info-1"></a>
</div>
<div>
<p>If you‚Äôre making your first contribution, you don‚Äôt need to engage with all this ‚Äî it‚Äôs fine to just make a change and push the results; the tests that run in GitHub will point you towards any errors, which can be then be run locally if needed. We‚Äôre always around to help out.</p>
</div>
</div>
<p>Our tests, from the bottom of the pyramid to the top:</p>
<ul>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/main/.pre-commit-config.yaml">Static checks</a></strong> ‚Äî we run a few static checks to ensure the code stays healthy and consistent. They‚Äôre defined in <a href="https://github.com/PRQL/prql/blob/main/.pre-commit-config.yaml"><strong><code>.pre-commit-config.yaml</code></strong></a>, using <a href="https://pre-commit.com">pre-commit</a>. They can be run locally with</p>
<pre><code class="language-sh">task test-lint
# or
pre-commit run -a
</code></pre>
<p>The tests fix most of the issues they find themselves. Most of them also run on GitHub on every commit; any changes they make are added onto the branch automatically in an additional commit.</p>
<ul>
<li>Checking by <a href="https://megalinter.io/latest/">MegaLinter</a>, which includes more Linters, is also done automatically on GitHub. (experimental)</li>
</ul>
</li>
<li>
<p><strong>Unit tests &amp; inline insta snapshots</strong> ‚Äî we rely on unit tests to rapidly check that our code basically works. We extensively use <a href="https://insta.rs/">Insta</a>, a snapshot testing tool which writes out the values generated by our code, making it fast &amp; simple to write and modify tests<sup><a name="to-footnote-2"><a href="project/contributing/development.html#footnote-2">2</a></a></sup></p>
<p>These are the fastest tests which run our code; they‚Äôre designed to run on every save while you‚Äôre developing. We include a <code>task</code> which does this:</p>
<pre><code class="language-sh">task test-rust-fast
# or
cargo insta test --accept --package prqlc --lib
# or, to run on every change:
task -w test-rust-fast
</code></pre>
</li>
</ul>
<!--
This is the previous doc. It has the advantage that it explains what it's doing, and is
easy to change (e.g. to run all packages). But because of
https://github.com/watchexec/watchexec/issues/371, the ignore behavior is unfortunately quite
inconsistent in watchexec. Let's revert back if it gets solved.

[^2]: For example, this is a command I frequently run:

    ```sh
    RUST_BACKTRACE=1 watchexec -e rs,toml,md -cr --ignore='target/**' -- cargo -q insta test --accept -p prqlc --lib
    ```

    Breaking this down:

    - `RUST_BACKTRACE=1` will print a full backtrace, including where an error
      value was created, for Rust tests which return `Result`s.
    - `watchexec -e rs,toml,md -cr --ignore='target/**' --` will run the
      subsequent command on any change to files with extensions which we are
      generally editing.
    - `cargo insta test --accept --` runs tests with `insta`, a snapshot
      library, and writes any results immediately. I rely on git to track
      changes, so I run with `--accept`, but YMMV.
    - `-p prqlc --lib` is passed to cargo by `insta`; `-p prqlc`
      tells it to only run the tests for `prqlc` rather than the other
      crates, and `--lib` to only run the unit tests rather than the integration
      tests, which are slower.
    - Note that we don't want to re-run on _any_ file changing, because we can
      get into a loop of writing snapshot files, triggering a change, writing a
      snapshot file, etc. -->
<ul>
<li>
<p><strong><a href="https://github.com/PRQL/prql/tree/main/web/book/tests/documentation">Documentation</a></strong> ‚Äî we compile all examples from our documentation in the Website, README, and PRQL Book, to test that they produce the SQL we expect, and that changes to our code don‚Äôt cause any unexpected regressions. These are included in:</p>
<pre><code class="language-sh">cargo insta test --accept
</code></pre>
</li>
<li>
<p><strong><a href="https://github.com/PRQL/prql/tree/main/prqlc/prqlc/tests/integration/dbs">Database integration tests</a></strong> ‚Äî we run tests with example queries against databases with actual data to ensure we‚Äôre producing correct SQL across our supported dialects. The in-process tests can be run locally with:</p>
<pre><code class="language-sh">task test-rust
# or
cargo insta test --accept --features=default,test-dbs
</code></pre>
<p>More details on running with external databases are in the <a href="https://github.com/PRQL/prql/tree/main/prqlc/prqlc/tests/integration/dbs">Readme</a>.</p>
</li>
</ul>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-note-2"></a>
</div>
<div>
<p>Integration tests use DuckDB, and so require a clang compiler to compile <a href="https://github.com/wangfenjin/duckdb-rs"><code>duckdb-rs</code></a>. Most development systems will have one, but if the test command fails, install a clang compiler with:</p>
<ul>
<li>On macOS, install xcode with <code>xcode-select --install</code></li>
<li>On Debian Linux, <code>apt-get update &amp;&amp; apt-get install clang</code></li>
<li>On Windows, <code>duckdb-rs</code> isn‚Äôt supported, so these tests are excluded</li>
</ul>
</div>
</div>
<ul>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/main/.github/workflows/tests.yaml">GitHub Actions on every commit</a></strong> ‚Äî we run tests relevant to a PR‚Äôs changes in CI ‚Äî for example changes to docs will attempt to build docs, changes to a binding will run that binding‚Äôs tests. The vast majority of changes trigger tests which run in less than five minutes, and we should be reassessing their scope if they take longer than that. Once these pass, a pull request can be merged.</p>
</li>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/c042eef48709e2c1af577161554fd09f14e67e0f/.github/workflows/pull-request.yaml#L124">GitHub Actions on merge</a></strong> ‚Äî we run a wider set tests on every merge to main. This includes testing across OSs, all our language bindings, a measure of test code coverage, and some performance benchmarks.</p>
<p>If these tests fail after merging, we should revert the commit before fixing the test and then re-reverting.</p>
<p>Most of these will run locally with:</p>
<pre><code class="language-sh">task test-all
</code></pre>
</li>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/main/.github/workflows/nightly.yaml">GitHub Actions nightly</a></strong> ‚Äî every night, we run tests that take longer, are less likely to fail, or are unrelated to code changes ‚Äî such as security checks, bindings‚Äô tests on multiple OSs, or expensive timing benchmarks.</p>
<p>We can run these tests before a merge by adding a label <code>pr-nightly</code> to the PR.</p>
</li>
</ul>
<p>The goal of our tests is to allow us to make changes quickly. If they‚Äôre making it more difficult to make changes, or there are missing tests that would offer the confidence to make changes faster, please raise an issue.</p>
<hr />
<h2 id="website"><a class="header" href="#website">Website</a></h2>
<p>The website is published together with the book and the playground, and is automatically built and released on any push to the <code>web</code> branch.</p>
<p>The <code>web</code> branch points to the latest release plus any website-specific fixes. That way, the compiler behavior in the playground matches the latest release while allowing us to fix mistakes in the docs with a tighter loop than every release.</p>
<p>Fixes to the playground, book, or website should have a <code>pr-backport-web</code> label added to their PR ‚Äî a bot will then open &amp; merge another PR onto the <code>web</code> branch once the initial branch merges.</p>
<p>The website components will run locally with:</p>
<pre><code class="language-sh"># Run the main website
task web:run-website
# Run the PRQL online book
task web:run-book
# Run the PRQL playground
task web:run-playground
</code></pre>
<h2 id="bindings-1"><a class="header" href="#bindings-1">Bindings</a></h2>
<p>We have a number of language bindings, as documented at <a href="https://prql-lang.org/book/project/bindings/index.html">https://prql-lang.org/book/project/bindings/index.html</a>. Some of these are within our monorepo, some are in separate repos. Here‚Äôs a provisional framework for when we use the main prql repo vs separate repos for bindings:</p>
<div class="table-wrapper"><table><thead><tr><th>Factor</th><th>Rationale</th><th>Example</th></tr></thead><tbody>
<tr><td>Does someone want to sign up to maintain a repo?</td><td>A different repo is harder for the core team to maintain</td><td><code>tree-sitter-prql</code> is well maintained</td></tr>
<tr><td>Can it change independently from the compiler?</td><td>If it‚Äôs in a different repo, it can‚Äôt be changed in lockstep with the compiler</td><td><code>prql-vscode</code> is fine to change ‚Äúbehind‚Äù the language</td></tr>
<tr><td>Would a separate repo invite new contributors?</td><td>A monorepo with all the rust code can be less inviting for those familiar with other langs</td><td><code>prql-vscode</code> had some JS-only contributors</td></tr>
<tr><td>Is there an convention for a stand-alone repo?</td><td>A small number of ecosystems require a separate repo</td><td><code>homebrew-prql</code> needs to be named that way for a Homebrew tap</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="releasing"><a class="header" href="#releasing">Releasing</a></h2>
<p>Currently we release in a semi-automated way:</p>
<ol>
<li>
<p>PR &amp; merge an updated <a href="https://github.com/PRQL/prql/blob/main/CHANGELOG.md">Changelog</a>. GitHub will produce a draft version at <a href="https://github.com/PRQL/prql/releases/new">https://github.com/PRQL/prql/releases/new</a>, including ‚ÄúNew Contributors‚Äù.</p>
<p>Use this script to generate a line introducing the enumerated changes:</p>
<pre><code class="language-sh">echo "It has $(git rev-list --count $(git rev-list --tags --max-count=1)..) commits from $(git shortlog --summary $(git rev-list --tags --max-count=1).. | wc -l | tr -d '[:space:]') contributors. Selected changes:"
</code></pre>
</li>
<li>
<p>If the current version is correct, then skip ahead. But if the version needs to be changed ‚Äî for example, we had planned on a patch release, but instead require a minor release ‚Äî then run <code>cargo release version $version -x &amp;&amp; cargo release replace -x &amp;&amp; task test-rust</code> to bump the version, and PR the resulting commit.</p>
</li>
<li>
<p>After merging, go to <a href="https://github.com/PRQL/prql/releases/new">Draft a new release</a><sup><a name="to-footnote-3"><a href="project/contributing/development.html#footnote-3">3</a></a></sup>, copy the changelog entry into the release description<sup><a name="to-footnote-4"><a href="project/contributing/development.html#footnote-4">4</a></a></sup>, enter the tag to be created, and hit ‚ÄúPublish‚Äù.</p>
</li>
<li>
<p>From there, both the tag and release is created and all packages are published automatically based on our <a href="https://github.com/PRQL/prql/blob/main/.github/workflows/release.yaml">release workflow</a>.</p>
</li>
<li>
<p>Run <code>cargo release version patch -x --no-confirm &amp;&amp; cargo release replace -x --no-confirm &amp;&amp; task test-rust</code> to bump the versions and add a new Changelog section; then PR the resulting commit. Note this currently contains <code>task test-rust</code> to update snapshot tests which contain the version.</p>
</li>
<li>
<p>Check whether there are <a href="https://github.com/PRQL/prql/milestones">milestones</a> that need to be pushed out.</p>
</li>
<li>
<p>Review the <strong>Current Status</strong> on the README.md to ensure it reflects the project state.</p>
</li>
</ol>
<p>We may make this more automated in future; e.g. automatic changelog creation.<p><hr/></p>
<p><a name="footnote-1"><a href="project/contributing/development.html#to-footnote-1">1</a></a>: Our approach is very consistent with <strong><a href="https://github.com/matklad">@matklad</a></strong>‚Äôs advice, in his excellent blog post <a href="https://matklad.github.io//2021/05/31/how-to-test.html">How to Test</a>.</p>
<p><a name="footnote-2"><a href="project/contributing/development.html#to-footnote-2">2</a></a>: <a href="https://github.com/PRQL/prql/blob/0.2.2/prql-compiler/src/parser.rs#L580-L605">Here‚Äôs an example of an insta test</a> ‚Äî note that only the initial line of each test is written by us; the remainder is filled in by insta.</p>
<p><a name="footnote-3"><a href="project/contributing/development.html#to-footnote-3">3</a></a>: Only maintainers have access to this page.</p>
<p><a name="footnote-4"><a href="project/contributing/development.html#to-footnote-4">4</a></a>: Unfortunately GitHub‚Äôs markdown parser interprets linebreaks as newlines. I haven‚Äôt found a better way of editing the markdown to look reasonable than manually editing the text or asking LLM to help.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-design-1"><a class="header" href="#language-design-1">Language design</a></h1>
<p>In a way PRQL is just a transpiler to SQL. This can cause its language design to gravitate toward thinking about PRQL features in terms of how they translate to SQL.</p>
<pre><code>PRQL feature -&gt; SQL feature -&gt; relational result
</code></pre>
<p>This is flawed because:</p>
<ul>
<li>it does not model interactions between features well,</li>
<li>SQL behavior can sometimes be misleading (the order of a subquery will not persist in the parent query) or even differs between dialects (set operations).</li>
</ul>
<p>Instead, we should think of PRQL features in terms of how they affect PRQL expressions, which in most cases means how they affect relations.</p>
<pre><code>PRQL feature -&gt; relation
                   |
                   v
PRQL feature -&gt; relation
                   |
                   v
PRQL feature -&gt; relation
                   |
                   v
            relational result
</code></pre>
<p>Thinking about SQL comes in only at the last step when relation (or rather relational expression) is translated to an SQL expression.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="highlight-prql.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
