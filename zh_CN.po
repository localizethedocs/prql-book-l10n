msgid ""
msgstr ""
"Project-Id-Version: PRQL language book\n"
"POT-Creation-Date: 2026-01-10T16:16:34Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/project/bindings/index.md:1
msgid "Bindings"
msgstr ""

#: src/project/bindings/index.md:3
msgid "PRQL has bindings for many languages. These include:"
msgstr ""

#: src/project/bindings/index.md:5
msgid "We have three tiers of bindings:"
msgstr ""

#: src/project/bindings/index.md:7 src/project/bindings/index.md:11
msgid "Supported"
msgstr ""

#: src/project/bindings/index.md:8 src/project/bindings/index.md:33
msgid "Unsupported"
msgstr ""

#: src/project/bindings/index.md:9 src/project/bindings/index.md:43
msgid "Nascent"
msgstr ""

#: src/project/bindings/index.md:13
msgid "Supported bindings require:"
msgstr ""

#: src/project/bindings/index.md:15
msgid "A maintainer."
msgstr ""

#: src/project/bindings/index.md:16
msgid ""
"Implementations of the [core compile functions](https://docs.rs/prqlc/latest/"
"prqlc/#functions)."
msgstr ""

#: src/project/bindings/index.md:18
msgid "Test coverage for these functions."
msgstr ""

#: src/project/bindings/index.md:19
msgid "A published package to the language's standard package repository."
msgstr ""

#: src/project/bindings/index.md:20
msgid "A script in `Taskfile.yaml` to bootstrap a development environment."
msgstr ""

#: src/project/bindings/index.md:21
msgid ""
"Any dev tools, such as a linter & formatter, in pre-commit or MegaLinter."
msgstr ""

#: src/project/bindings/index.md:23
msgid "The currently supported bindings are:"
msgstr ""

#: src/project/bindings/index.md:25
msgid "[JavaScript](./javascript.md)"
msgstr ""

#: src/project/bindings/index.md:26
msgid "[Python](./python.md)"
msgstr ""

#: src/project/bindings/index.md:27
msgid "[R](./r.md)"
msgstr ""

#: src/project/bindings/index.md:28
msgid "[Rust](./rust.md)"
msgstr ""

#: src/project/bindings/index.md:30
msgid ""
"Most of these are in the main PRQL repo, and we gate any changes to the "
"compiler's API on compatible changes to the bindings."
msgstr ""

#: src/project/bindings/index.md:35
msgid ""
"Unsupported bindings work, but don't fulfil all of the above criteria. We "
"don't gate changes to the compiler's API. If they stop working, we'll demote "
"them to nascent."
msgstr ""

#: src/project/bindings/index.md:39
msgid "[Java](./java.md)"
msgstr ""

#: src/project/bindings/index.md:40
msgid "[Elixir](./elixir.md)"
msgstr ""

#: src/project/bindings/index.md:41
msgid "`prqlc-c`, the C bindings"
msgstr ""

#: src/project/bindings/index.md:45
msgid "Nascent bindings are in development, and may not yet fully work."
msgstr ""

#: src/project/bindings/index.md:47
msgid "[.NET](./dotnet.md)"
msgstr ""

#: src/project/bindings/index.md:48
msgid "[PHP](./php.md)"
msgstr ""

#: src/project/bindings/index.md:50
msgid "Naming"
msgstr ""

#: src/project/bindings/index.md:52
msgid "Over time, we're trying to move to a consistent naming scheme:"
msgstr ""

#: src/project/bindings/index.md:54
msgid "Crates are named `prqlc-$lang`."
msgstr ""

#: src/project/bindings/index.md:55
msgid ""
"Where possible, packages are published to each language's package repository "
"as `prqlc`."
msgstr ""

#: src/project/bindings/elixir.md:1
msgid "PRQL"
msgstr ""

#: src/project/bindings/elixir.md:3
msgid "[PRQL](https://prql-lang.org/) bindings for Elixir."
msgstr ""

#: src/project/bindings/elixir.md:5
msgid "Installation"
msgstr ""

#: src/project/bindings/elixir.md:7
msgid ""
"```elixir\n"
"def deps do\n"
"  [\n"
"    {:prql, \"~> 0.1.0\"}\n"
"  ]\n"
"end\n"
"```"
msgstr ""

#: src/project/bindings/elixir.md:15
msgid "Basic Usage"
msgstr ""

#: src/project/bindings/elixir.md:17
msgid ""
"```elixir\n"
"  iex> PRQL.compile(\"from customers\")\n"
"      {:ok, \"SELECT\\n  *\\nFROM\\n  customers\\n\\n-- Generated by PRQL "
"compiler version 0.3.1 (https://prql-lang.org)\\n\"}\n"
"\n"
"\n"
"  iex> PRQL.compile(\"from customers\\ntake 10\", dialect: :mssql)\n"
"  {:ok, \"SELECT\\n  *\\nFROM\\n  customers\\nORDER BY\\n  (\\n    "
"SELECT\\n      NULL\\n  ) OFFSET 0 ROWS\\nFETCH FIRST\\n  10 ROWS "
"ONLY\\n\\n-- Generated by PRQL compiler version 0.3.1 (https://prql-lang."
"org)\\n\"}\n"
"```"
msgstr ""

#: src/project/bindings/elixir.md:26
msgid "Development"
msgstr ""

#: src/project/bindings/elixir.md:28
msgid "We are in the early stages of developing Elixir bindings."
msgstr ""

#: src/project/bindings/elixir.md:30
msgid "We're using `Rustler` to provide Rust bindings for `prqlc`."
msgstr ""

#: src/project/bindings/elixir.md:32
msgid ""
"Currently using the bindings in an Elixir project requires compiling the "
"Rust crate from this repo:"
msgstr ""

#: src/project/bindings/elixir.md:35
msgid "Install dependencies with `mix deps.get`"
msgstr ""

#: src/project/bindings/elixir.md:36
msgid "Compile project `mix compile`"
msgstr ""

#: src/project/bindings/elixir.md:37
msgid "Run tests `mix test`"
msgstr ""

#: src/project/bindings/elixir.md:39
msgid ""
"Future work includes publishing pre-compiled artifacts, so Elixir projects "
"can run PRQL without needing a Rust toolchain."
msgstr ""

#: src/project/bindings/elixir.md:42
msgid "Mac"
msgstr ""

#: src/project/bindings/elixir.md:44
msgid ""
"We currently don't enable compilation for Mac. This is possible to enable, "
"but causes some issues with cargo's compilation cache. Briefly: it requires "
"`RUSTFLAGS` to be set, and because of <https://github.com/rust-lang/cargo/"
"issues/8716> & <https://github.com/rust-lang/cargo/issues/8899>, any "
"compilation of a different target will bust the cache."
msgstr ""

#: src/project/bindings/elixir.md:51
msgid "The possible future workarounds include:"
msgstr ""

#: src/project/bindings/elixir.md:53
msgid ""
"Passing `--target=aarch64-apple-darwin` to every cargo call, which is "
"inconvenient and can be difficult in some situations; e.g. Rust Analyzer. "
"This disables passing `RUSTFLAGS` (I'm actually unclear why `prql-elixir` "
"builds successfully in that case...)"
msgstr ""

#: src/project/bindings/elixir.md:57
msgid ""
"Directing other cargo calls to different paths, such as `/target-ra` for "
"Rust Analyzer and `/target-book` for the book building. But one `cargo "
"build` from the terminal without either the `target` or `target_dir` "
"specified will bust the cache!"
msgstr ""

#: src/project/bindings/elixir.md:61
msgid ""
"Never compiling for other targets. But our standard tests run for `--"
"target=wasm32-unknown-unknown`, so this requires refraining from using them."
msgstr ""

#: src/project/bindings/elixir.md:64
msgid ""
"Removing `prql-elixir` from our workspace, so that `cargo` commands in the "
"PRQL workspace don't require rust flags. This would work well, but means we "
"need separate test coverage for this crate, which adds some weight to the "
"tests."
msgstr ""

#: src/project/bindings/elixir.md:69
msgid ""
"If `prql-elixir` becomes more used (for example, we start publishing to Hex, "
"or Mac developers want to work on it), then we can re-enable and deal with "
"the caching issues. We can also re-enable them if the `cargo` issue is "
"resolved."
msgstr ""

#: src/project/bindings/elixir.md:73
msgid ""
"To test on Mac temporarily — for example if there's an error in GHA and "
"we're on a Mac locally — apply a diff like this, and then run `cargo build` "
"from the `prql-elixir` path, which will enable the local [`.cargo/config."
"toml`](https://github.com/PRQL/prql/blob/main/prqlc/bindings/elixir/native/"
"prql/.cargo/config.toml)). (We could also make a feature like `elixir-mac` "
"which enabled building on Mac)."
msgstr ""

#: src/project/bindings/java.md:1
msgid "prql-java"
msgstr ""

#: src/project/bindings/java.md:3
msgid ""
"`prql-java` offers Java bindings to the `prql-compiler` Rust library. It "
"exposes a Java native method `public static native String toSql(String "
"query)`."
msgstr ""

#: src/project/bindings/java.md:6
msgid ""
"It's still at an early stage, and currently requires compiling locally, and "
"isn't published to Maven. Contributions are welcome."
msgstr ""

#: src/project/bindings/java.md:19
msgid "Usage"
msgstr ""

#: src/project/bindings/java.md:26
msgid "\"from table\""
msgstr ""

#: src/project/bindings/javascript.md:1
msgid "prqlc-js"
msgstr ""

#: src/project/bindings/javascript.md:3
msgid "JavaScript bindings for [`prqlc`](https://github.com/PRQL/prql/)."
msgstr ""

#: src/project/bindings/javascript.md:13
msgid "Currently these functions are exposed"
msgstr ""

#: src/project/bindings/javascript.md:27
msgid "From Node.js"
msgstr ""

#: src/project/bindings/javascript.md:29
msgid "Direct usage"
msgstr ""

#: src/project/bindings/javascript.md:32 src/project/bindings/javascript.md:53
#: src/project/bindings/javascript.md:63
msgid "\"prqlc\""
msgstr ""

#: src/project/bindings/javascript.md:34
msgid "`from employees | select first_name`"
msgstr ""

#: src/project/bindings/javascript.md:38
msgid "Options"
msgstr ""

#: src/project/bindings/javascript.md:42
msgid "\"sql.mssql\""
msgstr ""

#: src/project/bindings/javascript.md:46
msgid "`from employees | take 10`"
msgstr ""

#: src/project/bindings/javascript.md:50
msgid "Template literal"
msgstr ""

#: src/project/bindings/javascript.md:54 src/project/bindings/javascript.md:64
msgid "\"\""
msgstr ""

#: src/project/bindings/javascript.md:56
msgid "prql`from employees | select first_name`"
msgstr ""

#: src/project/bindings/javascript.md:60
msgid "Template literal with newlines"
msgstr ""

#: src/project/bindings/javascript.md:66
msgid ""
"prql`\n"
"    from employees\n"
"    select first_name\n"
"`"
msgstr ""

#: src/project/bindings/javascript.md:73
msgid "From a browser"
msgstr ""

#: src/project/bindings/javascript.md:78
msgid "\"module\""
msgstr ""

#: src/project/bindings/javascript.md:79
msgid "\"./dist/web/prql_js.js\""
msgstr ""

#: src/project/bindings/javascript.md:82
msgid "\"from employees | select first_name\""
msgstr ""

#: src/project/bindings/javascript.md:91
msgid "From a framework or a bundler"
msgstr ""

#: src/project/bindings/javascript.md:93
msgid ""
"```typescript\n"
"import compile from \"prqlc/dist/bundler\";\n"
"\n"
"const sql = compile(`from employees | select first_name`);\n"
"console.log(sql);\n"
"```"
msgstr ""

#: src/project/bindings/javascript.md:100
msgid "Errors"
msgstr ""

#: src/project/bindings/javascript.md:102
msgid "Errors are returned as following object, serialized as a JSON array:"
msgstr ""

#: src/project/bindings/javascript.md:104
msgid ""
"```typescript\n"
"interface ErrorMessage {\n"
"  /// Message kind. Currently only Error is implemented.\n"
"  kind: \"Error\" | \"Warning\" | \"Lint\";\n"
"  /// Machine-readable identifier of the error\n"
"  code: string | null;\n"
"  /// Plain text of the error\n"
"  reason: string;\n"
"  /// A list of suggestions of how to fix the error\n"
"  hint: string | null;\n"
"  /// Character offset of error origin within a source file\n"
"  span: [number, number] | null;\n"
"\n"
"  /// Annotated code, containing cause and hints.\n"
"  display: string | null;\n"
"  /// Line and column number of error origin within a source file\n"
"  location: SourceLocation | null;\n"
"}\n"
"\n"
"/// Location within the source file.\n"
"/// Tuples contain:\n"
"/// - line number (0-based),\n"
"/// - column number within that line (0-based),\n"
"interface SourceLocation {\n"
"  start: [number, number];\n"
"\n"
"  end: [number, number];\n"
"}\n"
"```"
msgstr ""

#: src/project/bindings/javascript.md:134
msgid "These errors can be caught as such:"
msgstr ""

#: src/project/bindings/javascript.md:138
msgid "`from employees | foo first_name`"
msgstr ""

#: src/project/bindings/javascript.md:149
msgid "Build:"
msgstr ""

#: src/project/bindings/javascript.md:155
msgid "This builds Node, bundler and web packages in the `dist` path."
msgstr ""

#: src/project/bindings/javascript.md:157
msgid "Test:"
msgstr ""

#: src/project/bindings/javascript.md:163
msgid ""
"By default the `wasm` binaries are optimized on each run, even if the "
"underlying code hasn't changed, which can be slow. For a lower-latency dev "
"loop, pass `--profile=dev` to `npm install` for a faster, less optimized "
"build."
msgstr ""

#: src/project/bindings/javascript.md:171
msgid "Notes"
msgstr ""

#: src/project/bindings/javascript.md:173
msgid ""
"This uses [`wasm-pack`](https://rustwasm.github.io/docs/wasm-pack/) to "
"generate bindings[^1]."
msgstr ""

#: src/project/bindings/javascript.md:175
msgid ""
"We've added an `npm` layer on top of the usual approach of just using `wasm-"
"pack`, so we can distribute a single package with targets of `node`, "
"`bundler` and `no-modules` — somewhat inverting the approach recommended by "
"`wasm-pack`. The build instruction goes in a `build` script, rather than a "
"`pack` script."
msgstr ""

#: src/project/bindings/javascript.md:182
msgid ""
"    Though we would be very open to other approaches, given wasm-pack does "
"not\n"
"    seem maintained, and we're eliding many of its features to build for "
"three\n"
"    targets. See <https://github.com/PRQL/prql/issues/1836> for more "
"details.\n"
"    "
msgstr ""

#: src/project/bindings/dotnet.md:1
msgid "prql-dotnet"
msgstr ""

#: src/project/bindings/dotnet.md:3
msgid ""
"`prql-net` offers PRQL bindings for .NET bindings as a `netstandard2.0` "
"library."
msgstr ""

#: src/project/bindings/dotnet.md:5
msgid ""
"It provides the `PrqlCompiler` class which contains the `ToJson` and `ToSql` "
"static methods."
msgstr ""

#: src/project/bindings/dotnet.md:8
msgid ""
"It's still at an early stage, and isn't published to NuGet. Contributions "
"are welcome."
msgstr ""

#: src/project/bindings/dotnet.md:13
msgid ""
"Make sure that `libprqlc_c.so` (Linux), `libprqlc_c.dylib` (macOS) or "
"`libprqlc_c.dll` (Windows) is in the project's `bin` directory together with "
"`PrqlCompiler.dll` and the rest of the project's compiled files. I.e. "
"`{your_project}/bin/Debug/net7.0/`."
msgstr ""

#: src/project/bindings/dotnet.md:18
msgid "The `libprqlc_c` library gets dynamically imported at runtime."
msgstr ""

#: src/project/bindings/dotnet.md:22
msgid ""
"```csharp\n"
"using Prql.Compiler;\n"
"\n"
"var options = new PrqlCompilerOptions\n"
"{\n"
"    Format = false,\n"
"    SignatureComment = false,\n"
"};\n"
"var sql = PrqlCompiler.Compile(\"from employees\", options);\n"
"Console.WriteLine(sql);\n"
"```"
msgstr ""

#: src/project/bindings/dotnet.md:34
msgid "TODO"
msgstr ""

#: src/project/bindings/dotnet.md:36
msgid ""
"This is currently at 0.1.0 because we're waiting to update prqlc-c for the "
"latest API. When we've done that, we can match the version here with the "
"broader PRQL version."
msgstr ""

#: src/project/bindings/php.md:1
msgid "prql-php"
msgstr ""

#: src/project/bindings/php.md:3
msgid "`prql-php` offers PHP bindings to `prql-compiler` crate through FFI."
msgstr ""

#: src/project/bindings/php.md:5
msgid ""
"It provides the `Compiler` class which contains `compile`, `prqlToPL`, "
"`plToRQ` and `rqToSQL` functions."
msgstr ""

#: src/project/bindings/php.md:8
msgid ""
"It's still at an early stage, and isn't published to Composer. Contributions "
"are welcome."
msgstr ""

#: src/project/bindings/php.md:13
msgid ""
"The [PHP FFI extension](https://www.php.net/manual/en/book.ffi.php) needs to "
"be enabled. Set `ffi.enable` in your php.ini configuration file to "
"`\"true\"`."
msgstr ""

#: src/project/bindings/php.md:24
msgid "\"from employees\""
msgstr ""

#: src/project/bindings/php.md:31
msgid "Environment"
msgstr ""

#: src/project/bindings/php.md:33
msgid ""
"A way to establish a dev environment with PHP, the ext-ffi extension and "
"Composer is to use a [nix flake](https://github.com/loophp/nix-shell). After "
"installing nix, enable experimental flakes feature:"
msgstr ""

#: src/project/bindings/php.md:37
msgid ""
"```\n"
"mkdir -p ~/.config/nix\n"
"echo \"experimental-features = nix-command flakes\" >> ~/.config/nix/nix."
"conf\n"
"```"
msgstr ""

#: src/project/bindings/php.md:42
msgid "Now you can spawn a shell from `prql-php/`:"
msgstr ""

#: src/project/bindings/php.md:48
msgid ""
"This will pull-in ext-ffi extension, because it's declared in `composer."
"json`."
msgstr ""

#: src/project/bindings/php.md:50
msgid "Building"
msgstr ""

#: src/project/bindings/php.md:52
msgid "There is a `task build-php` script that:"
msgstr ""

#: src/project/bindings/php.md:54
msgid "runs cargo to build `libprqlc_c`,"
msgstr ""

#: src/project/bindings/php.md:55
msgid "copies `libprqlc_c.*` into `lib`,"
msgstr ""

#: src/project/bindings/php.md:56
msgid "copies `prqlc.h` into `lib`."
msgstr ""

#: src/project/bindings/php.md:58
msgid "Tests"
msgstr ""

#: src/project/bindings/php.md:65
msgid "Code style"
msgstr ""

#: src/project/bindings/python.md:1
msgid "Python bindings to `prqlc`"
msgstr ""

#: src/project/bindings/python.md:3
msgid ""
"The `prqlc-python` crate offer Rust bindings to the `prqlc` Rust library, "
"published to a python package named `prqlc`."
msgstr ""

#: src/project/bindings/python.md:6
msgid ""
"The main entry point is a Python method `prqlc.compile(query: str) -> str`."
msgstr ""

#: src/project/bindings/python.md:8
msgid ""
"The package is consumed by [pyprql](https://github.com/prql/pyprql) & [dbt-"
"prql](https://github.com/prql/dbt-prql)."
msgstr ""

#: src/project/bindings/python.md:11
msgid ""
"The crate is not published to crates.io; only to PyPI at <https://pypi.org/"
"project/prqlc/>."
msgstr ""

#: src/project/bindings/python.md:16
msgid "`pip install prqlc`"
msgstr ""

#: src/project/bindings/python.md:23
msgid ""
"\"\"\"\n"
"    from employees\n"
"    join salaries (==emp_id)\n"
"    group {employees.dept_id, employees.gender} (\n"
"      aggregate {\n"
"        avg_salary = average salaries.salary\n"
"      }\n"
"    )\n"
"\"\"\""
msgstr ""

#: src/project/bindings/python.md:34
msgid "\"sql.postgres\""
msgstr ""

#: src/project/bindings/python.md:41
msgid "Relies on [pyo3](https://github.com/PyO3/pyo3) for all the magic."
msgstr ""

#: src/project/bindings/r.md:1
msgid "R (prqlr)"
msgstr ""

#: src/project/bindings/r.md:3
msgid "R bindings for `prqlc`."
msgstr ""

#: src/project/bindings/r.md:5
msgid ""
"`prqlr` also includes `knitr` (R Markdown and Quarto) integration, which "
"allows us to easily create documents with the PRQL conversion results "
"embedded in."
msgstr ""

#: src/project/bindings/r.md:8
msgid "Check out <https://prql.github.io/prqlc-r/> for more context."
msgstr ""

#: src/project/bindings/r.md:10
msgid ""
"```admonish note\n"
"`prqlr` is generously maintained by [@eitsupi](https://github.com/eitsupi) "
"in the\n"
"[PRQL/prqlc-r](https://github.com/PRQL/prqlc-r) repo.\n"
"```"
msgstr ""

#: src/project/bindings/r.md:18
msgid "\"prqlr\""
msgstr ""

#: src/project/bindings/rust.md:1
msgid ""
"Please check the documentation of the [prqlc crate](https://docs.rs/prqlc/"
"latest/prqlc/)."
msgstr ""

#: src/project/changelog.md:1
msgid "PRQL Changelog"
msgstr ""

#: src/project/changelog.md:3
msgid "0.12.2 — 2024-06-10"
msgstr ""

#: src/project/changelog.md:5
msgid ""
"0.12.2 is a very small release which renames `prql-js` to `prqlc-js` to "
"match our standard naming scheme. Within node the package is imported as "
"`prqlc`."
msgstr ""

#: src/project/changelog.md:8
msgid "It also fixes a mistake in the `prqlc-python` release pipeline."
msgstr ""

#: src/project/changelog.md:10
msgid "0.12.1 — 2024-06-09"
msgstr ""

#: src/project/changelog.md:12
msgid ""
"0.12.1 is a tiny hotfix release which fixes how intra-prql crate "
"dependencies were specified."
msgstr ""

#: src/project/changelog.md:15
msgid "0.12.0 — 2024-06-08"
msgstr ""

#: src/project/changelog.md:17
msgid ""
"0.12.0 contains a few months of smaller features. Our focus has been on "
"rewriting the resolver, an effort that is still ongoing."
msgstr ""

#: src/project/changelog.md:20
msgid ""
"It has 239 commits from 12 contributors. Selected changes (most are not "
"listed here, possibly we should be more conscientious about adding them...):"
msgstr ""

#: src/project/changelog.md:23 src/project/changelog.md:90
#: src/project/changelog.md:131 src/project/changelog.md:163
#: src/project/changelog.md:203 src/project/changelog.md:246
#: src/project/changelog.md:392 src/project/changelog.md:583
#: src/project/changelog.md:654 src/project/changelog.md:723
#: src/project/changelog.md:791 src/project/changelog.md:938
#: src/project/changelog.md:973 src/project/changelog.md:1022
#: src/project/changelog.md:1054 src/project/changelog.md:1215
#: src/project/changelog.md:1278 src/project/changelog.md:1321
msgid "**Features**:"
msgstr ""

#: src/project/changelog.md:25
msgid "Add `prqlc lex` command to the CLI (@max-sixty)"
msgstr ""

#: src/project/changelog.md:26
msgid ""
"Add `prqlc debug lineage` command to the CLI, creating an expression lineage "
"graph from a query (@kgutwin, #4533)"
msgstr ""

#: src/project/changelog.md:28
msgid ""
"Initial implementation of an experimental documentation generator that "
"generates Markdown documentation from `.prql` files. (@vanillajonathan, "
"\\#4152)."
msgstr ""

#: src/project/changelog.md:31
msgid ""
"Join's `side` parameter can take a reference that resolves to a literal "
"(note: this is an experimental feature which may change in the future) "
"(@kgutwin, \\#4499)"
msgstr ""

#: src/project/changelog.md:35 src/project/changelog.md:96
#: src/project/changelog.md:139 src/project/changelog.md:178
#: src/project/changelog.md:208 src/project/changelog.md:358
#: src/project/changelog.md:399 src/project/changelog.md:602
#: src/project/changelog.md:754 src/project/changelog.md:851
#: src/project/changelog.md:906 src/project/changelog.md:946
#: src/project/changelog.md:1159 src/project/changelog.md:1226
#: src/project/changelog.md:1285 src/project/changelog.md:1326
#: src/project/changelog.md:1346 src/project/changelog.md:1357
#: src/project/changelog.md:1403 src/project/changelog.md:1426
msgid "**Fixes**:"
msgstr ""

#: src/project/changelog.md:37
msgid ""
"Support expressions on left hand side of `std.in` operator. (@kgutwin, #4498)"
msgstr ""

#: src/project/changelog.md:38
msgid "Prevent panic for `from {}` and `std` (@m-span, #4538)"
msgstr ""

#: src/project/changelog.md:40 src/project/changelog.md:185
#: src/project/changelog.md:271 src/project/changelog.md:368
#: src/project/changelog.md:407 src/project/changelog.md:728
#: src/project/changelog.md:1177 src/project/changelog.md:1375
msgid "**Web**:"
msgstr ""

#: src/project/changelog.md:42
msgid ""
"The `browser` dist files are now built with `wasm-pack`'s `web` target. As a "
"result, they should be usable as ES Modules, through JS CDNs, and for "
"example with Observable Framework (@srenatus, #4274)."
msgstr ""

#: src/project/changelog.md:46 src/project/changelog.md:100
#: src/project/changelog.md:214 src/project/changelog.md:281
#: src/project/changelog.md:372 src/project/changelog.md:413
#: src/project/changelog.md:607 src/project/changelog.md:768
#: src/project/changelog.md:863 src/project/changelog.md:917
#: src/project/changelog.md:1182 src/project/changelog.md:1379
#: src/project/changelog.md:1414
msgid "**Integrations**:"
msgstr ""

#: src/project/changelog.md:48
msgid ""
"The syntax highlighter package for Sublime Text is now [published](https://"
"packagecontrol.io/packages/PRQL) (@vanillajonathan)."
msgstr ""

#: src/project/changelog.md:50
msgid ""
"The [VSCode Great Icons](https://marketplace.visualstudio.com/items?"
"itemName=emmanuelbeziat.vscode-great-icons) icon pack extension shows a "
"database icon for `.prql` files. (@EmmanuelBeziat)"
msgstr ""

#: src/project/changelog.md:53
msgid ""
"[Tokei](https://github.com/XAMPPRocky/tokei), a source lines of code counter "
"now has support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:55
msgid ""
"Add syntax highlight file for the [micro](https://micro-editor.github.io/) "
"text editor. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:58 src/project/changelog.md:121
#: src/project/changelog.md:193 src/project/changelog.md:313
#: src/project/changelog.md:381 src/project/changelog.md:434
#: src/project/changelog.md:448 src/project/changelog.md:627
#: src/project/changelog.md:743 src/project/changelog.md:883
#: src/project/changelog.md:895 src/project/changelog.md:926
#: src/project/changelog.md:965 src/project/changelog.md:1039
msgid "**New Contributors**:"
msgstr ""

#: src/project/changelog.md:60
msgid "@srenatus, with #4274"
msgstr ""

#: src/project/changelog.md:61
msgid "@jacquayj, with #4332"
msgstr ""

#: src/project/changelog.md:62
msgid "@pdelewski, with #4337"
msgstr ""

#: src/project/changelog.md:63
msgid "@m-span, with #4422"
msgstr ""

#: src/project/changelog.md:64
msgid "@kgutwin, with #4498"
msgstr ""

#: src/project/changelog.md:66
msgid "0.11.4 — 2024-02-25"
msgstr ""

#: src/project/changelog.md:68
msgid ""
"0.11.4 is a hotfix release, fixing a CI issue that caused the CLI binaries "
"to be built without the `cli` feature."
msgstr ""

#: src/project/changelog.md:71
msgid "0.11.3 — 2024-02-10"
msgstr ""

#: src/project/changelog.md:73
msgid "0.11.3 is a very small release, mostly a rename of the Python bindings."
msgstr ""

#: src/project/changelog.md:75
msgid "The release has 13 commits from 4 contributors."
msgstr ""

#: src/project/changelog.md:77 src/project/changelog.md:108
#: src/project/changelog.md:189 src/project/changelog.md:377
#: src/project/changelog.md:419 src/project/changelog.md:611
#: src/project/changelog.md:733 src/project/changelog.md:772
#: src/project/changelog.md:875 src/project/changelog.md:960
#: src/project/changelog.md:1190 src/project/changelog.md:1296
#: src/project/changelog.md:1338 src/project/changelog.md:1384
#: src/project/changelog.md:1419 src/project/changelog.md:1439
msgid "**Internal changes**:"
msgstr ""

#: src/project/changelog.md:79
msgid ""
"As part of making our names more consistent, the Python bindings are "
"renamed. `prql-python` becomes a package published and importable as "
"`prqlc`. The internal Rust crate is named `prqlc-python`."
msgstr ""

#: src/project/changelog.md:83
msgid "0.11.2 — 2024-02-07"
msgstr ""

#: src/project/changelog.md:85
msgid ""
"0.11.2 contains lots of internal changes, lots of syntax highlighting, and "
"the beginning of `lutra`, a query runner."
msgstr ""

#: src/project/changelog.md:88
msgid "This release has 122 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:92
msgid ""
"Initial implementation of `lutra`, a query runner. (@aljazerzen, #4182, "
"#4174, \\#4134)"
msgstr ""

#: src/project/changelog.md:94
msgid "`prqlc fmt` works on projects with multiple files. (@max-sixty, #4028)"
msgstr ""

#: src/project/changelog.md:98
msgid "Reduce stack memory usage (@aljazerzen, #4103)"
msgstr ""

#: src/project/changelog.md:102
msgid "Add syntax highlight file for GtkSourceView. (@vanillajonathan, #4062)"
msgstr ""

#: src/project/changelog.md:103
msgid "Add syntax highlight file for CotEditor. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:104
msgid "Add syntax highlight file for Sublime Text. (@vanillajonathan, #4127)"
msgstr ""

#: src/project/changelog.md:105
msgid ""
"[sloc](https://github.com/flosse/sloc), a source lines of code counter now "
"has support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:110
msgid ""
"`prql-compiler` has been renamed to `prqlc`, and we've established a more "
"consistent naming scheme. The existing crate will still be published, re-"
"exporting `prqlc`, so no dependencies will break. A future version will add "
"a deprecation warning."
msgstr ""

#: src/project/changelog.md:114
msgid ""
"The `prqlc-clib` crate was renamed to `prqlc-c`, and associated artifacts "
"were renamed. We're trying to make names consistent (ideally for the final "
"time!), and have a plan to rename some other bindings. (@max-sixty, #4077)"
msgstr ""

#: src/project/changelog.md:117
msgid ""
"Add lots of whitespace items to the lexer, in preparation for the completion "
"of `prqlc fmt` (@max-sixty, #4109, #4105)"
msgstr ""

#: src/project/changelog.md:119
msgid "Table declarations (@aljazerzen, #4126)"
msgstr ""

#: src/project/changelog.md:123
msgid "@kaspermarstal, with #4124"
msgstr ""

#: src/project/changelog.md:125
msgid "0.11.1 — 2023-12-26"
msgstr ""

#: src/project/changelog.md:127
msgid "0.11.1 fixes a couple of small bugs; it comes a few days after 0.11."
msgstr ""

#: src/project/changelog.md:129
msgid "This release has 16 commits from 6 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:133
msgid ""
"Infer the type of array literals to be the union of types of its items. "
"(@aljazerzen, #3989)"
msgstr ""

#: src/project/changelog.md:135
msgid ""
"`prql` module is added and the `prql_version` function is renamed to the "
"`prql.version` function. The old `prql_version` function is deprecated and "
"will be removed in the future release. (@eitsupi, #4006)"
msgstr ""

#: src/project/changelog.md:141
msgid ""
"Do not compile to `DISTINCT ON` when `take n` is used with `group` for the "
"targets `clickhouse`, `duckdb` and `postgres`. (@PrettyWood, #3988)"
msgstr ""

#: src/project/changelog.md:143
msgid ""
"Fix `take` n rows for `mssql` dialect by switching from TOP to FETCH "
"(@PrettyWood, #3994)"
msgstr ""

#: src/project/changelog.md:146
msgid "0.11.0 — 2023-12-19"
msgstr ""

#: src/project/changelog.md:148
msgid ""
"0.11.0 introduces new `date`, `text` & `math` modules with lots of standard "
"functions, including a new `date.to_text` function. It contains a few bugs "
"fixes, and lots of internal improvements to the compiler."
msgstr ""

#: src/project/changelog.md:152
msgid "This release has 119 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:154 src/project/changelog.md:240
#: src/project/changelog.md:329 src/project/changelog.md:475
msgid "**Language**:"
msgstr ""

#: src/project/changelog.md:156
msgid ""
"_Breaking_: `group`'s `by` columns are now excluded from the partition. "
"(#3490)"
msgstr ""

#: src/project/changelog.md:158
msgid ""
"_Breaking_: `round` is now in the `math` module and needs to be called via "
"`math.round`. (#3928)"
msgstr ""

#: src/project/changelog.md:160
msgid ""
"_Breaking_: `lower` and `upper` are now in the `text` module and need to be "
"called via `text.lower` and `text.upper`. (#3913, #3973)"
msgstr ""

#: src/project/changelog.md:165
msgid ""
"The `std.in` function now supports a list of values (@PrettyWood, #3883)"
msgstr ""

#: src/project/changelog.md:166
msgid ""
"Most standard mathematical functions are now supported: `abs`, `floor`, "
"`ceil`, `pi`, `exp`, `ln`, `log10`, `log`, `sqrt`, `degrees`, `radians`, "
"`cos`, `acos`, `sin`, `asin`, `tan`, `atan`, `pow` and `round`.  \n"
"Those functions are in the `math` module (@PrettyWood, #3909, #3916 & 3928)"
msgstr ""

#: src/project/changelog.md:170
msgid ""
"Most standard string functions are now supported: `ltrim`, `rtrim`, `trim`, "
"`length`, `extract`, `replace`. Utility functions `starts_with`, `contains` "
"and `ends_with` are also available.  \n"
"Those functions are in the `text` module (@PrettyWood, #3913, #3973)"
msgstr ""

#: src/project/changelog.md:174
msgid ""
"Formatting a date to a text is now available for Clickhouse, DuckDB, MySQL, "
"MSSQL and Postgres. A new `date` module has been added with the `to_text` "
"function (@PrettyWood, #3951, #3954 & #3955)"
msgstr ""

#: src/project/changelog.md:180
msgid "Fix an issue with arithmetic precedence (@max-sixty, #3846)"
msgstr ""

#: src/project/changelog.md:181
msgid "`+` and `-` can be used after a cast (@PrettyWood, #3923)"
msgstr ""

#: src/project/changelog.md:182
msgid ""
"The [Lezer](https://lezer.codemirror.net/) grammar had plenty of "
"improvements and fixes. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:187
msgid "The Playground now uses [Vite](https://vitejs.dev/). (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:191
msgid "Bump `prql-compiler`'s MSRV to 1.70.0 (@eitsupi, #3876)"
msgstr ""

#: src/project/changelog.md:195
msgid "@PrettyWood, with #3883"
msgstr ""

#: src/project/changelog.md:197
msgid "0.10.1 — 2023-11-14"
msgstr ""

#: src/project/changelog.md:199
msgid ""
"0.10.1 is a small release containing some internal fixes of the compiler."
msgstr ""

#: src/project/changelog.md:201
msgid "This release has 36 commits from 7 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:205
msgid ""
"The `std.sql.read_csv` function and the `std.sql.read_parquet` function "
"supports the `sql.glaredb` target. (@eitsupi, #3749)"
msgstr ""

#: src/project/changelog.md:210
msgid ""
"Fix the bug of compiling to `DISTINCT ON` when `take 1` is used with `group "
"by` for the targets `sql.clickhouse`, `sql.duckdb` and `sql.postgres`. "
"(@aljazerzen, #3792)"
msgstr ""

#: src/project/changelog.md:216
msgid "Enable integration tests for GlareDB. (@eitsupi, #3749)"
msgstr ""

#: src/project/changelog.md:217
msgid ""
"[trapd00r/LS_COLORS](https://github.com/trapd00r/LS_COLORS), a collection of "
"LS_COLORS definitions colorizes `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:219
msgid ""
"[vivid](https://github.com/sharkdp/vivid), a themeable LS_COLORS generator "
"colorizes `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:221
msgid ""
"[colorls](https://github.com/athityakumar/colorls), displays `.prql` files "
"with a database icon. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:223
msgid ""
"[Emoji File Icons](https://marketplace.visualstudio.com/items?"
"itemName=mightbesimon.emoji-icons), a VS Code extension displays `.prql` "
"files with a database emoji icon. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:226
msgid ""
"[eza](https://eza.rocks/), a modern ls replacement colorizes `.prql` files. "
"(@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:228
msgid ""
"[lsd](https://github.com/lsd-rs/lsd), next gen ls command displays `.prql` "
"files with a database icon. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:231
msgid "0.10.0 — 2023-10-26"
msgstr ""

#: src/project/changelog.md:233
msgid ""
"0.10.0 contains lots of small improvements, including support for new types "
"of literal notation, support for `read_*` functions in more dialects, "
"playground improvements, and a better Lezer grammar (which we're planning on "
"using for a Jupyter extension)."
msgstr ""

#: src/project/changelog.md:238
msgid "This release has 155 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:242
msgid ""
"_Breaking:_ Case syntax now uses brackets `[]` rather than braces `{}`. To "
"convert previous PRQL queries to this new syntax simply change `case { ... }"
"` to `case [ ... ]`. (@AaronMoat, #3517)"
msgstr ""

#: src/project/changelog.md:248
msgid ""
"_Breaking_: The `std.sql.read_csv` function is now compiled to `read_csv` by "
"default. Please set the target `sql.duckdb` to use the DuckDB's "
"`read_csv_auto` function as previously. (@eitsupi, #3599)"
msgstr ""

#: src/project/changelog.md:251
msgid ""
"_Breaking_: The `std.every` function is renamed to `std.all` (@aljazerzen, "
"\\#3703)"
msgstr ""

#: src/project/changelog.md:253
msgid ""
"The `std.sql.read_csv` function and the `std.sql.read_parquet` function "
"supports the `sql.clickhouse` target. (@eitsupi, #1533)"
msgstr ""

#: src/project/changelog.md:255
msgid "Add `std.prql_version` function to return PRQL version (@hulxv, #3533)"
msgstr ""

#: src/project/changelog.md:256
msgid "A new type `anytype` is added. (@aljazerzen, #3703)"
msgstr ""

#: src/project/changelog.md:257
msgid ""
"Add support for hex escape sequences in strings. Example `\"Hello \\x51\"`. "
"(@vanillajonathan, #3568)"
msgstr ""

#: src/project/changelog.md:259
msgid ""
"Add support for long Unicode escape sequences. Example `\"Hello "
"\\u{01F422}\"`. (@vanillajonathan, #3569)"
msgstr ""

#: src/project/changelog.md:261
msgid ""
"Add support for binary numerical notation. Example `filter status == "
"0b1111000011110000`. (@vanillajonathan, #3661)"
msgstr ""

#: src/project/changelog.md:263
msgid ""
"Add support for hexadecimal numerical notation. Example `filter status == "
"0xff`. (@vanillajonathan, #3654)"
msgstr ""

#: src/project/changelog.md:265
msgid ""
"Add support for octal numerical notation. Example `filter status == 0o777`. "
"(@vanillajonathan, #3672)"
msgstr ""

#: src/project/changelog.md:267
msgid ""
"New compile target `sql.glaredb` for [GlareDB](https://docs.glaredb.com/) "
"and integration tests for it (However, there is a bug in the test and it is "
"currently not running). (@universalmind303, @scsmithr, @eitsupi, #3669)"
msgstr ""

#: src/project/changelog.md:273
msgid ""
"Allow cmd-/ (Mac) or ctrl-/ (Windows) to toggle comments in the playground "
"editor (@AaronMoat, #3522)"
msgstr ""

#: src/project/changelog.md:276
msgid ""
"Limit maximum height of the playground editor's error panel to avoid taking "
"over whole screen (@AaronMoat, #3524)"
msgstr ""

#: src/project/changelog.md:279
msgid "The playground now uses [Vite](https://vitejs.dev/) (@vanillajonathan)."
msgstr ""

#: src/project/changelog.md:283
msgid ""
"Add a CLI command `prqlc collect` to collect a project's modules into a "
"single file (@aljazerzen, #3739)"
msgstr ""

#: src/project/changelog.md:285
msgid ""
"Add a CLI command `prqlc debug expand-pl` to parse & and expand into PL "
"without resolving (@aljazerzen, #3739)"
msgstr ""

#: src/project/changelog.md:287
msgid "Bump `prqlc`'s MSRV to 1.70.0 (@eitsupi, #3521)"
msgstr ""

#: src/project/changelog.md:288
msgid ""
"[Pygments](https://pygments.org/), a syntax highlighting library now has "
"syntax highlighting for PRQL. (@vanillajonathan, #3564)"
msgstr ""

#: src/project/changelog.md:290
msgid ""
"[chroma](https://github.com/alecthomas/chroma), a syntax highlighting "
"library written in Go and used by the static website generator [Hugo]"
"(https://gohugo.io/). (@vanillajonathan, #3597)"
msgstr ""

#: src/project/changelog.md:293
msgid ""
"[scc](https://github.com/boyter/scc), a source lines of code counter now has "
"support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:295
msgid ""
"[gcloc](https://github.com/JoaoDanielRufino/gcloc) a source lines of code "
"counter now has support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:297
msgid ""
"[cloc](https://github.com/AlDanial/cloc) a source lines of code counter now "
"has support for `.prql` files. (@AlDanial)"
msgstr ""

#: src/project/changelog.md:299
msgid ""
"[gocloc](https://github.com/hhatto/gocloc) a source lines of code counter "
"now has support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:301
msgid ""
"[The Quarto VS Code extension](https://marketplace.visualstudio.com/items?"
"itemName=quarto.quarto) supports editing PRQL code blocks ([`prqlr`](https://"
"prql-lang.org/book/project/bindings/r.html) is required to render Quarto "
"Markdown with PRQL code blocks). (@jjallaire)"
msgstr ""

#: src/project/changelog.md:306 src/project/changelog.md:1232
msgid "**Internal**:"
msgstr ""

#: src/project/changelog.md:308
msgid ""
"Rename some of the internal crates, and refactored their paths in the repo. "
"(@aljazerzen, #3683)."
msgstr ""

#: src/project/changelog.md:310
msgid ""
"Add a `justfile` for developers who prefer that above our `Taskfile.yaml` "
"(@aljazerzen, #3681)"
msgstr ""

#: src/project/changelog.md:315
msgid "@hulxv, with #3533"
msgstr ""

#: src/project/changelog.md:316
msgid "@AaronMoat, with #3522"
msgstr ""

#: src/project/changelog.md:317
msgid "@jangorecki, with #3634"
msgstr ""

#: src/project/changelog.md:319
msgid "0.9.5 — 2023-09-16"
msgstr ""

#: src/project/changelog.md:321
msgid ""
"0.9.5 adds a line-wrapping character, fixes a few bugs, and improves our CI. "
"The release has 77 commits from 8 contributors. Selected changes are below."
msgstr ""

#: src/project/changelog.md:324
msgid ""
"Look out for some conference talks coming up over the next few weeks, "
"including [QCon SF on Oct 2](https://qconsf.com/presentation/oct2023/prql-"
"simple-powerful-pipelined-sql-replacement) and [date2day on Oct 12](https://"
"www.data2day.de/veranstaltung-21353-0-prql-a-modern-language-for-data-"
"transformation.html)."
msgstr ""

#: src/project/changelog.md:331
msgid ""
"A new line-wrapping character, for lines that are long and we want to break "
"up into multiple physical lines. This is slightly different from from many "
"languages — it's on the subsequent line:"
msgstr ""

#: src/project/changelog.md:335
msgid ""
"```prql no-eval\n"
"from artists\n"
"select is_europe =\n"
"\\ country == \"DE\"\n"
"\\ || country == \"FR\"\n"
"\\ || country == \"ES\"\n"
"```"
msgstr ""

#: src/project/changelog.md:343
msgid ""
"This allows for easily commenting out physical lines while maintaining a "
"correct logical line; for example:"
msgstr ""

#: src/project/changelog.md:356
msgid "(@max-sixty, #3408)"
msgstr ""

#: src/project/changelog.md:360
msgid ""
"Fix stack overflow on very long queries in Windows debug builds (@max-sixty, "
"\\#2908)"
msgstr ""

#: src/project/changelog.md:363
msgid ""
"Fix panic when unresolved lineage appears in group or window (@davidot, "
"#3266)"
msgstr ""

#: src/project/changelog.md:365
msgid ""
"Fix a corner-case in handling precedence, and remove unneeded parentheses in "
"some outputs (@max-sixty, #3472)"
msgstr ""

#: src/project/changelog.md:370
msgid "Compiler panics are now printed to the console (@max-sixty, #3446)"
msgstr ""

#: src/project/changelog.md:374
msgid ""
"[Ace](https://ace.c9.io/), the JavaScript code editor now has syntax "
"highlighting for PRQL. (@vanillajonathan, #3493)"
msgstr ""

#: src/project/changelog.md:379
msgid "Simplify & speed up lexer (@max-sixty, #3426, #3418)"
msgstr ""

#: src/project/changelog.md:383
msgid "@davidot, with #3450"
msgstr ""

#: src/project/changelog.md:385
msgid "0.9.4 — 2023-08-24"
msgstr ""

#: src/project/changelog.md:387
msgid ""
"0.9.4 is a small release with some improvements and bug fixes in the "
"compiler and `prqlc`. And, the documentation and CI are continually being "
"improved."
msgstr ""

#: src/project/changelog.md:390
msgid "This release has 110 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:394
msgid ""
"Strings can be delimited with any odd number of quote characters. The logic "
"for lexing quotes is now simpler and slightly faster. Escapes in single-"
"quote-delimited strings escape single-quotes rather than double-quotes. "
"(@max-sixty, #3274)"
msgstr ""

#: src/project/changelog.md:401
msgid "S-strings within double braces now parse correctly (@max-sixty, #3265)"
msgstr ""

#: src/project/changelog.md:403 src/project/changelog.md:762
#: src/project/changelog.md:857 src/project/changelog.md:913
#: src/project/changelog.md:953 src/project/changelog.md:1165
#: src/project/changelog.md:1291 src/project/changelog.md:1332
#: src/project/changelog.md:1370 src/project/changelog.md:1408
#: src/project/changelog.md:1434
msgid "**Documentation**:"
msgstr ""

#: src/project/changelog.md:405
msgid "New docs for strings (@max-sixty, #3281)"
msgstr ""

#: src/project/changelog.md:409
msgid ""
"Improve syntax highlighting for numbers in the book & website (@max-sixty, "
"\\#3261)"
msgstr ""

#: src/project/changelog.md:411
msgid "Add ClickHouse integration to docs (@max-sixty, #3251)"
msgstr ""

#: src/project/changelog.md:415
msgid ""
"`prqlc` no longer displays a prompt when piping a query into its stdin (@max-"
"sixty, #3248)."
msgstr ""

#: src/project/changelog.md:417
msgid ""
"Add a minimal example for use `prql-lib` with Zig (@vanillajonathan, #3372)"
msgstr ""

#: src/project/changelog.md:421
msgid ""
"Overhaul our CI to run a cohesive set of tests depending on the specific "
"changes in the PR, and elide all others. This cuts CI latency to less than "
"three minutes for most changes, and enables GitHub's auto-merge to wait for "
"all relevant tests. It also reduces the CI time on merging to main, by "
"moving some tests to only run on specific path changes or on our nightly run."
msgstr ""

#: src/project/changelog.md:427
msgid ""
"We now have one label we can add to PRs to run more tests — `pr-nightly`. "
"(@max-sixty, #3317 & others)."
msgstr ""

#: src/project/changelog.md:430
msgid "Auto-merge PRs for backports or pre-commit updates (@max-sixty, #3246)"
msgstr ""

#: src/project/changelog.md:431
msgid ""
"Add a workflow to create an issue when the scheduled nightly workflow fails "
"(@max-sixty, #3304)"
msgstr ""

#: src/project/changelog.md:436
msgid "@FinnRG, with #3292"
msgstr ""

#: src/project/changelog.md:437
msgid "@sitiom, with #3353"
msgstr ""

#: src/project/changelog.md:439
msgid "0.9.3 — 2023-08-02"
msgstr ""

#: src/project/changelog.md:441
msgid ""
"0.9.3 is a small release, with mostly documentation, internal, and CI "
"changes."
msgstr ""

#: src/project/changelog.md:443
msgid "This release has 85 commits from 10 contributors."
msgstr ""

#: src/project/changelog.md:445
msgid ""
"We'd like to welcome @not-my-profile as someone who has helped with lots of "
"internal refactoring in the past couple of weeks."
msgstr ""

#: src/project/changelog.md:450
msgid "@vthriller, with #3171"
msgstr ""

#: src/project/changelog.md:451
msgid "@postmeback, with #3216"
msgstr ""

#: src/project/changelog.md:453
msgid "0.9.2 — 2023-07-25"
msgstr ""

#: src/project/changelog.md:455
msgid ""
"0.9.2 is a hotfix release to fix an issue in the 0.9.0 & 0.9.1 release "
"pipelines."
msgstr ""

#: src/project/changelog.md:458
msgid "0.9.1 — 2023-07-25"
msgstr ""

#: src/project/changelog.md:460
msgid ""
"0.9.1 is a hotfix release to fix an issue in the 0.9.0 release pipeline."
msgstr ""

#: src/project/changelog.md:462
msgid "0.9.0 — 2023-07-24"
msgstr ""

#: src/project/changelog.md:464
msgid ""
"0.9.0 is probably PRQL's biggest ever release. We have dialect-specific "
"standard-libraries, a regex operator, an initial implementation of multiple-"
"file projects & modules, lots of bug fixes, and many many internal changes."
msgstr ""

#: src/project/changelog.md:468
msgid ""
"We've made a few backward incompatible syntax changes. Most queries will "
"work with a simple find/replace; see below for details."
msgstr ""

#: src/project/changelog.md:471
msgid "The release has 421 commits from 12 contributors."
msgstr ""

#: src/project/changelog.md:473 src/project/changelog.md:721
msgid "A small selection of the changes:"
msgstr ""

#: src/project/changelog.md:477
msgid ""
"The major breaking change is a new syntax for lists, which have been renamed "
"to _tuples_, and are now represented with braces `{}` rather than brackets "
"`[]`."
msgstr ""

#: src/project/changelog.md:481
msgid ""
"To convert previous PRQL queries to this new syntax simply change `[ ... ]` "
"to `{ ... }`."
msgstr ""

#: src/project/changelog.md:484
msgid ""
"We made the syntax change to incorporate arrays. Almost every major language "
"uses `[]` for arrays. We are adopting that convention — arrays use `[]`, "
"tuples will use `{}`. (Though we recognize that `{}` for tuples is also rare "
"(Hi, Erlang!), but didn't want to further load parentheses with meaning.)"
msgstr ""

#: src/project/changelog.md:489
msgid ""
"Arrays are conceptually similar to columns — their elements have a single "
"type. Array syntax can't contain assignments."
msgstr ""

#: src/project/changelog.md:492
msgid ""
"As part of this, we've also formalized tuples as containing both individual "
"items (`select {foo, baz}`), and assignments (`select {foo=bar, baz=fuz}`)."
msgstr ""

#: src/project/changelog.md:495
msgid "Some significant changes regarding SQL dialects:"
msgstr ""

#: src/project/changelog.md:497
msgid ""
"Operators and functions can be defined on per-dialect basis. (@aljazerzen, "
"\\#2681)"
msgstr ""

#: src/project/changelog.md:499
msgid ""
"_Breaking_: The `sql.duckdb` target supports DuckDB 0.8 (@eitsupi, #2810)."
msgstr ""

#: src/project/changelog.md:500
msgid "_Breaking_: The `sql.hive` target is removed (@eitsupi, #2837)."
msgstr ""

#: src/project/changelog.md:502
msgid ""
"New arithmetic operators. These compile to different function or operator "
"depending on the target."
msgstr ""

#: src/project/changelog.md:505
msgid ""
"_Breaking_: Operator `/` now always performs floating division (@aljazerzen, "
"\\#2684). See the [Division docs](https://prql-lang.org/book/reference/"
"syntax/operators.html#division-and-integer-division) for details."
msgstr ""

#: src/project/changelog.md:510
msgid ""
"Truncated integer division operator `//` (@aljazerzen, #2684). See the "
"[Division docs](https://prql-lang.org/book/reference/syntax/operators."
"html#division-and-integer-division) for details."
msgstr ""

#: src/project/changelog.md:514
msgid "Regex search operator `~=` (@max-sixty, #2458). An example:"
msgstr ""

#: src/project/changelog.md:516
msgid ""
"```prql no-eval\n"
"from tracks\n"
"filter (name ~= \"Love\")\n"
"```"
msgstr ""

#: src/project/changelog.md:521
msgid "...compiles to;"
msgstr ""

#: src/project/changelog.md:529
msgid "'Love'"
msgstr ""

#: src/project/changelog.md:532
msgid ""
"...though the exact form differs by dialect; see the [Regex docs](https://"
"prql-lang.org/book/reference/syntax/operators.html#regex) for more details."
msgstr ""

#: src/project/changelog.md:536
msgid ""
"New aggregation functions: `every`, `any`, `average`, and `concat_array`. "
"_Breaking:_ Remove `avg` in favor of `average`."
msgstr ""

#: src/project/changelog.md:539
msgid ""
"_Breaking:_ We've changed our function declaration syntax to match other "
"declarations. Functions were one of the first language constructs in PRQL, "
"and since then we've added normal declarations there's no compelling reason "
"for functions to be different."
msgstr ""

#: src/project/changelog.md:548
msgid "Previously, this was:"
msgstr ""

#: src/project/changelog.md:554
msgid ""
"Experimental modules, which allow importing declarations from other files. "
"Docs are forthcoming."
msgstr ""

#: src/project/changelog.md:557
msgid ""
"Relation literals create a relation (a \"table\") as an _array_ of _tuples_. "
"This example demonstrates the new syntax for arrays `[]` and tuples `{}`. "
"(@aljazerzen, #2605)"
msgstr ""

#: src/project/changelog.md:567
msgid ""
"`this` can be used to refer to the current pipeline, for situations where "
"plain column name would be ambiguous:"
msgstr ""

#: src/project/changelog.md:576
msgid ""
"Within a `join` transform, there is also a reference to the right relation: "
"`that`."
msgstr ""

#: src/project/changelog.md:579
msgid ""
"_Breaking:_ functions `count`, `rank` and `row_number` now require an "
"argument of the array to operate on. In most cases you can directly replace "
"`count` with `count this`. The `non_null` argument of `count` has been "
"removed."
msgstr ""

#: src/project/changelog.md:585
msgid "We've changed how we handle colors."
msgstr ""

#: src/project/changelog.md:587
msgid ""
"`Options::color` is deprecated and has no effect. Code which consumes "
"`prql_compiler::compile` should instead accept the output with colors and "
"use a library such as `anstream` to handle the presentation of colors. To "
"ensure minimal disruption, `prql_compiler` will currently strip color codes "
"when a standard environment variable such as `CLI_COLOR=0` is set or when it "
"detects `stderr` is not a TTY."
msgstr ""

#: src/project/changelog.md:594
msgid ""
"We now use the [`anstream`](https://github.com/rust-cli/anstyle) library in "
"`prqlc` & `prql-compiler`."
msgstr ""

#: src/project/changelog.md:597
msgid "(@max-sixty, #2773)"
msgstr ""

#: src/project/changelog.md:599
msgid ""
"`prqlc` can now show backtraces when the standard backtrace env var "
"(`RUST_BACKTRACE`) is active. (@max-sixty, #2751)"
msgstr ""

#: src/project/changelog.md:604
msgid ""
"Numbers expressed with scientific notation — `1e9` — are now handled "
"correctly by the compiler (@max-sixty, #2865)."
msgstr ""

#: src/project/changelog.md:609
msgid "prql-python now provides type hints (@philpep, #2912)"
msgstr ""

#: src/project/changelog.md:613
msgid ""
"Annotations in PRQL. These have limited support but are currently used to "
"specify binding strengths. They're modeled after Rust's annotations, but "
"with `@` syntax, more similar to traditional decorators. (#2729)"
msgstr ""

#: src/project/changelog.md:617
msgid ""
"```prql no-eval\n"
"@{binding_strength=11}\n"
"let mod = l r -> s\"{l} % {r}\"\n"
"```"
msgstr ""

#: src/project/changelog.md:622
msgid ""
"Remove BigQuery's special handling of quoted identifiers, now that our "
"module system handles its semantics (@max-sixty, #2609)."
msgstr ""

#: src/project/changelog.md:625
msgid "ClickHouse is tested in CI (@eitsupi, #2815)."
msgstr ""

#: src/project/changelog.md:629
msgid "@maxmcd, with #2533"
msgstr ""

#: src/project/changelog.md:630
msgid "@khoa165, with #2876"
msgstr ""

#: src/project/changelog.md:631
msgid "@philpep, with #2912"
msgstr ""

#: src/project/changelog.md:632
msgid "@not-my-profile, with #2971"
msgstr ""

#: src/project/changelog.md:634
msgid "0.8.1 — 2023-04-29"
msgstr ""

#: src/project/changelog.md:636
msgid ""
"0.8.1 is a small release with a new `list-targets` command in `prqlc`, some "
"documentation improvements, and some internal improvements."
msgstr ""

#: src/project/changelog.md:639
msgid "This release has 41 commits from 8 contributors."
msgstr ""

#: src/project/changelog.md:641
msgid ""
"From the broader perspective of the project, we're increasing the relative "
"prioritization of it being easy for folks to actually use PRQL — either with "
"existing tools, or a tool we'd build. We'll be thinking about & discussing "
"the best way to do that over the next few weeks."
msgstr ""

#: src/project/changelog.md:646
msgid "0.8.0 — 2023-04-14"
msgstr ""

#: src/project/changelog.md:648
msgid ""
"0.8.0 renames the `and` & `or` operators to `&&` & `||` respectively, "
"reorganizes the Syntax section in the book, and introduces `read_parquet` & "
"`read_csv` functions for reading files with DuckDB."
msgstr ""

#: src/project/changelog.md:652
msgid "This release has 38 commits from 8 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:656
msgid ""
"Rename `and` to `&&` and `or` to `||`. Operators which are symbols are now "
"consistently infix, while \"words\" are now consistently functions "
"(@aljazerzen, \\#2422)."
msgstr ""

#: src/project/changelog.md:660
msgid ""
"New functions `read_parquet` and `read_csv`, which mirror the DuckDB "
"functions, instructing the database to read from files (@max-sixty, #2409)."
msgstr ""

#: src/project/changelog.md:663
msgid "0.7.1 — 2023-04-03"
msgstr ""

#: src/project/changelog.md:665
msgid ""
"0.7.1 is a hotfix release to fix `prql-js`'s `npm install` behavior when "
"being installed as a dependency."
msgstr ""

#: src/project/changelog.md:668
msgid "This release has 17 commits from 4 contributors."
msgstr ""

#: src/project/changelog.md:670
msgid "0.7.0 — 2023-04-01"
msgstr ""

#: src/project/changelog.md:672
msgid ""
"0.7.0 is a fairly small release in terms of new features, with lots of "
"internal improvements, such as integration tests with a whole range of DBs, "
"a blog post on Pi day, RFCs for a type system, and more robust language "
"bindings."
msgstr ""

#: src/project/changelog.md:676
msgid ""
"There's a very small breaking change to the Rust API, hence the minor "
"version bump."
msgstr ""

#: src/project/changelog.md:679
msgid ""
"Here's our April 2023 Update, from our [Readme](https://github.com/PRQL/prql/"
"blob/main/README.md):"
msgstr ""

#: src/project/changelog.md:682
msgid "April 2023 update"
msgstr ""

#: src/project/changelog.md:684
msgid ""
"PRQL is being actively developed by a growing community. It's ready to use "
"by the intrepid, either as part of one of our supported extensions, or "
"within your own tools, using one of our supported language bindings."
msgstr ""

#: src/project/changelog.md:688
msgid ""
"PRQL still has some minor bugs and some missing features, and probably is "
"only ready to be rolled out to non-technical teams for fairly simple queries."
msgstr ""

#: src/project/changelog.md:691
msgid ""
"Here's our current [Roadmap](https://prql-lang.org/roadmap/) and our "
"[Milestones.](https://github.com/PRQL/prql/milestones)"
msgstr ""

#: src/project/changelog.md:694
msgid "Our immediate focus for the code is on:"
msgstr ""

#: src/project/changelog.md:696
msgid ""
"Building out the next few big features, including [types](https://github.com/"
"PRQL/prql/pull/1964) and [modules](https://github.com/PRQL/prql/pull/2129)."
msgstr ""

#: src/project/changelog.md:699
msgid ""
"Ensuring our supported features feel extremely robust; resolving any "
"[priority bugs](https://github.com/PRQL/prql/issues?"
"q=is%3Aissue+is%3Aopen+label%3Abug+label%3Apriority)."
msgstr ""

#: src/project/changelog.md:702
msgid "We're also spending time thinking about:"
msgstr ""

#: src/project/changelog.md:704
msgid ""
"Making it really easy to start using PRQL. We're doing that by building "
"integrations with tools that folks already use; for example our VS Code "
"extension & Jupyter integration. If there are tools you're familiar with "
"that you think would be open to integrating with PRQL, please let us know in "
"an issue."
msgstr ""

#: src/project/changelog.md:709
msgid ""
"Making it easier to contribute to the compiler. We have a wide group of "
"contributors to the project, but contributions to the compiler itself are "
"quite concentrated. We're keen to expand this; [\\#1840](https://github.com/"
"PRQL/prql/issues/1840) for feedback."
msgstr ""

#: src/project/changelog.md:716
msgid ""
"The release has 131 commits from 10 contributors. Particular credit goes to "
"to @eitsupi & @jelenkee, who have made significant contributions, and "
"@vanillajonathan, whose prolific contribution include our growing language "
"bindings."
msgstr ""

#: src/project/changelog.md:725
msgid ""
"`prqlc compile` adds `--color` & `--include-signature-comment` options. "
"(@max-sixty, #2267)"
msgstr ""

#: src/project/changelog.md:730
msgid ""
"Added the PRQL snippets from the book to the [Playground](https://prql-lang."
"org/playground/) (@jelenkee, #2197)"
msgstr ""

#: src/project/changelog.md:735
msgid ""
"_Breaking_: The `compile` function's `Options` now includes a `color` "
"member, which determines whether error messages use ANSI color codes. This "
"is technically a breaking change to the API. (@max-sixty, #2251)"
msgstr ""

#: src/project/changelog.md:738
msgid ""
"The `Error` struct now exposes the `MessageKind` enum. (@vanillajonathan, "
"\\#2307)"
msgstr ""

#: src/project/changelog.md:740
msgid ""
"Integration tests run in CI with DuckDB, SQLite, PostgreSQL, MySQL and SQL "
"Server (@jelenkee, #2286)"
msgstr ""

#: src/project/changelog.md:745
msgid "@k-nut, with #2294"
msgstr ""

#: src/project/changelog.md:747
msgid "0.6.1 — 2023-03-12"
msgstr ""

#: src/project/changelog.md:749
msgid ""
"0.6.1 is a small release containing an internal refactoring and improved "
"bindings for C, PHP & .NET."
msgstr ""

#: src/project/changelog.md:752
msgid "This release has 54 commits from 6 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:756
msgid ""
"No longer incorrectly compile to `DISTINCT` when a `take 1` refers to a "
"different set of columns than are in the `group`. (@max-sixty, with thanks "
"to @cottrell, #2109)"
msgstr ""

#: src/project/changelog.md:759
msgid ""
"The version specification of the dependency Chumsky was bumped from `0.9.0` "
"to `0.9.2`. `0.9.0` has a bug that causes an infinite loop. (@eitsupi, #2110)"
msgstr ""

#: src/project/changelog.md:764
msgid ""
"Add a policy for which bindings are supported / unsupported / nascent. See "
"<https://prql-lang.org/book/project/bindings/index.html> for more details "
"(@max-sixty, #2062) (@max-sixty, #2062)"
msgstr ""

#: src/project/changelog.md:770
msgid "\\[prql-lib\\] Added C++ header file. (@vanillajonathan, #2126)"
msgstr ""

#: src/project/changelog.md:774
msgid ""
"Many of the items that were in the root of the repo have been aggregated "
"into `web` & `bindings`, simplifying the repo's structure. There's also "
"`grammars` & `packages` (@max-sixty, #2135, #2117, #2121)."
msgstr ""

#: src/project/changelog.md:778
msgid "0.6.0 — 2023-03-08"
msgstr ""

#: src/project/changelog.md:780
msgid ""
"0.6.0 introduces a rewritten parser, giving us the ability to dramatically "
"improve error messages, renames `switch` to `case` and includes lots of "
"minor improvements and fixes. It also introduces `loop`, which compiles to "
"`WITH RECURSIVE`, as a highly experimental feature."
msgstr ""

#: src/project/changelog.md:785
msgid ""
"There are a few cases of breaking changes, including switching `switch` to "
"`case`, in case that's confusing. There are also some minor parsing changes "
"outlined below."
msgstr ""

#: src/project/changelog.md:789
msgid "This release has 108 commits from 11 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:793
msgid ""
"Add a (highly experimental) `loop` language feature, which translates to "
"`WITH RECURSIVE`. We expect changes and refinements in upcoming releases. "
"(#1642, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:796
msgid ""
"Rename the experimental `switch` function to `case` given it more closely "
"matches the traditional semantics of `case`. (@max-sixty, #2036)"
msgstr ""

#: src/project/changelog.md:798
msgid ""
"Change the `case` syntax to use `=>` instead of `->` to distinguish it from "
"function syntax."
msgstr ""

#: src/project/changelog.md:800
msgid "Convert parser from pest to Chumsky (@aljazerzen, #1818)"
msgstr ""

#: src/project/changelog.md:801
msgid ""
"Improved error messages, and the potential to make even better in the "
"future. Many of these improvements come from error recovery."
msgstr ""

#: src/project/changelog.md:803
msgid "String escapes (`\\n \\t`)."
msgstr ""

#: src/project/changelog.md:804
msgid "Raw strings that don't escape backslashes."
msgstr ""

#: src/project/changelog.md:805
msgid ""
"String interpolations can only contain identifiers and not any expression."
msgstr ""

#: src/project/changelog.md:806
msgid ""
"Operator associativity has been changed from right-to-left to left-to-right "
"to be more similar to other conventional languages."
msgstr ""

#: src/project/changelog.md:808
msgid ""
"`and` now has a higher precedence than `or` (of same reason as the previous "
"point)."
msgstr ""

#: src/project/changelog.md:810
msgid "Dates, times and timestamps have stricter parsing rules."
msgstr ""

#: src/project/changelog.md:811
msgid "`let`, `func`, `prql`, `case` are now treated as keywords."
msgstr ""

#: src/project/changelog.md:812
msgid "Float literals without fraction part are not allowed anymore (`1.`)."
msgstr ""

#: src/project/changelog.md:813
msgid ""
"Add a `--format` option to `prqlc parse` which can return the AST in YAML "
"(@max-sixty, #1962)"
msgstr ""

#: src/project/changelog.md:815
msgid "Add a new subcommand `prqlc jinja`. (@aljazerzen, #1722)"
msgstr ""

#: src/project/changelog.md:816
msgid ""
"_Breaking_: prql-compiler no longer passes text containing `{{` & `}}` "
"through to the output. (@aljazerzen, #1722)"
msgstr ""

#: src/project/changelog.md:819
msgid "For example, the following PRQL query"
msgstr ""

#: src/project/changelog.md:825
msgid ""
"was compiled to the following SQL previously, but now it raises an error."
msgstr ""

#: src/project/changelog.md:834
msgid "This pass-through feature existed for integration with dbt."
msgstr ""

#: src/project/changelog.md:836
msgid ""
"We're again considering how to best integrate with dbt, and this change is "
"based on the idea that the jinja macro should run before the PRQL compiler."
msgstr ""

#: src/project/changelog.md:839
msgid ""
"If you're interested in dbt integration, subscribe or 👍 to <https://github."
"com/dbt-labs/dbt-core/pull/5982>."
msgstr ""

#: src/project/changelog.md:842
msgid ""
"A new compile target `\"sql.any\"`. When `\"sql.any\"` is used as the target "
"of the compile function's option, the target contained in the query header "
"will be used. (@aljazerzen, #1995)"
msgstr ""

#: src/project/changelog.md:845
msgid "Support for SQL parameters with similar syntax (#1957, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:846
msgid ""
"Allow `:` to be elided in timezones, such as `0800` in "
"`@2020-01-01T13:19:55-0800` (@max-sixty, #1991)."
msgstr ""

#: src/project/changelog.md:848
msgid ""
"Add `std.upper` and `std.lower` functions for changing string casing "
"(@Jelenkee, #2019)."
msgstr ""

#: src/project/changelog.md:853
msgid ""
"`prqlc compile` returns a non-zero exit code for invalid queries. (@max-"
"sixty, \\#1924)"
msgstr ""

#: src/project/changelog.md:855
msgid ""
"Identifiers can contain any alphabetic unicode characters (@max-sixty, #2003)"
msgstr ""

#: src/project/changelog.md:859
msgid "Operator precedence (@aljazerzen, #1818)"
msgstr ""

#: src/project/changelog.md:860
msgid ""
"Error messages for invalid queries are displayed in the book (@max-sixty, "
"\\#2015)"
msgstr ""

#: src/project/changelog.md:865
msgid "\\[prql-php\\] Added PHP bindings. (@vanillajonathan, #1860)"
msgstr ""

#: src/project/changelog.md:866
msgid "\\[prql-dotnet\\] Added .NET bindings. (@vanillajonathan, #1917)"
msgstr ""

#: src/project/changelog.md:867
msgid "\\[prql-lib\\] Added C header file. (@vanillajonathan, #1879)"
msgstr ""

#: src/project/changelog.md:868
msgid ""
"Added a workflow building a `.deb` on each release. (Note that it's not yet "
"published on each release). (@vanillajonathan, #1883)"
msgstr ""

#: src/project/changelog.md:870
msgid ""
"Added a workflow building a `.rpm` on each release. (Note that it's not yet "
"published on each release). (@vanillajonathan, #1918)"
msgstr ""

#: src/project/changelog.md:872
msgid ""
"Added a workflow building a Snap package on each release. (@vanillajonathan, "
"\\#1881)"
msgstr ""

#: src/project/changelog.md:877
msgid ""
"Test that the output of our nascent autoformatter can be successfully "
"compiled into SQL. Failing examples are now clearly labeled. (@max-sixty, "
"#2016)"
msgstr ""

#: src/project/changelog.md:879
msgid ""
"Definition files have been added to configure [Dev Containers](https://"
"containers.dev/) for Rust development environment. (@eitsupi, #1893, #2025, "
"#2028)"
msgstr ""

#: src/project/changelog.md:885
msgid "@linux-china, with #1971"
msgstr ""

#: src/project/changelog.md:886
msgid "@Jelenkee, with #2019"
msgstr ""

#: src/project/changelog.md:888
msgid "0.5.2 — 2023-02-18"
msgstr ""

#: src/project/changelog.md:890
msgid ""
"0.5.2 is a tiny release to fix an build issue in yesterday's `prql-js` 0.5.1 "
"release."
msgstr ""

#: src/project/changelog.md:893
msgid "This release has 7 commits from 2 contributors."
msgstr ""

#: src/project/changelog.md:897
msgid "@matthias-Q, with #1873"
msgstr ""

#: src/project/changelog.md:899
msgid "0.5.1 — 2023-02-17"
msgstr ""

#: src/project/changelog.md:901
msgid ""
"0.5.1 contains a few fixes, and another change to how bindings handle "
"default target / dialects."
msgstr ""

#: src/project/changelog.md:904
msgid "This release has 53 commits from 7 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:908
msgid ""
"Delegate dividing literal integers to the DB. Previously integer division "
"was executed during PRQL compilation, which could be confusing given that "
"behavior is different across DBs. Other arithmetic operations are still "
"executed during compilation. (@max-sixty, #1747)"
msgstr ""

#: src/project/changelog.md:915
msgid "Add docs on the `from_text` transform (@max-sixty, #1756)"
msgstr ""

#: src/project/changelog.md:919
msgid ""
"\\[prql-js\\] Default compile target changed from `Sql(Generic)` to "
"`Sql(None)`. (@eitsupi, #1856)"
msgstr ""

#: src/project/changelog.md:921
msgid ""
"\\[prql-python\\] Compilation options can now be specified from Python. "
"(@eitsupi, \\#1807)"
msgstr ""

#: src/project/changelog.md:923
msgid ""
"\\[prql-python\\] Default compile target changed from `Sql(Generic)` to "
"`Sql(None)`. (@eitsupi, #1861)"
msgstr ""

#: src/project/changelog.md:928
msgid "@vanillajonathan, with #1766"
msgstr ""

#: src/project/changelog.md:930
msgid "0.5.0 — 2023-02-08"
msgstr ""

#: src/project/changelog.md:932
msgid ""
"0.5.0 contains a few fixes, some improvements to bindings, lots of docs "
"improvements, and some work on forthcoming features. It contains one "
"breaking change in the compiler's `Options` interface."
msgstr ""

#: src/project/changelog.md:936
msgid "This release has 74 commits from 12 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:940
msgid ""
"Change public API to use target instead of dialect in preparation for "
"feature work (@aljazerzen, #1684)"
msgstr ""

#: src/project/changelog.md:943
msgid ""
"`prqlc watch` command which watches filesystem for changes and compiles ."
"prql files to .sql (@aljazerzen, #1708)"
msgstr ""

#: src/project/changelog.md:948
msgid ""
"Support double brackets in s-strings which aren't symmetric (@max-sixty, "
"\\#1650)"
msgstr ""

#: src/project/changelog.md:950
msgid "Support Postgres's Interval syntax (@max-sixty, #1649)"
msgstr ""

#: src/project/changelog.md:951
msgid "Fixed tests for `prql-elixir` with macOS (@kasvith, #1707)"
msgstr ""

#: src/project/changelog.md:955
msgid ""
"Add a documentation test for prql-compiler, update prql-compiler README, and "
"include the README in the prql book section for Rust bindings. The code "
"examples in the README are included and tested as doctests in the prql-"
"compiler (@nkicg6, #1679)"
msgstr ""

#: src/project/changelog.md:962
msgid ""
"Add tests for all PRQL website examples to prql-python to ensure compiled "
"results match expected SQL (@nkicg6, #1719)"
msgstr ""

#: src/project/changelog.md:967
msgid "@ruslandoga, with #1628"
msgstr ""

#: src/project/changelog.md:968
msgid "@RalfNorthman, with #1632"
msgstr ""

#: src/project/changelog.md:969
msgid "@nicot, with #1662"
msgstr ""

#: src/project/changelog.md:971
msgid "0.4.2 — 2023-01-25"
msgstr ""

#: src/project/changelog.md:975
msgid ""
"New `from_text format-arg string-arg` function that supports JSON and CSV "
"formats. _format-arg_ can be `format:csv` or `format:json`. _string-arg_ can "
"be a string in any format. (@aljazerzen & @snth, #1514)"
msgstr ""

#: src/project/changelog.md:979
msgid ""
"```prql no-eval\n"
"from_text format:csv \"\"\"\n"
"a,b,c\n"
"1,2,3\n"
"4,5,6\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/project/changelog.md:987
msgid ""
"```prql no-eval\n"
"from_text format:json '''\n"
"    [{\"a\": 1, \"b\": \"x\", \"c\": false }, {\"a\": 4, \"b\": \"y\", "
"\"c\": null }]\n"
"'''\n"
"```"
msgstr ""

#: src/project/changelog.md:993
msgid ""
"```prql no-eval\n"
"from_text format:json '''{\n"
"    \"columns\": [\"a\", \"b\", \"c\"],\n"
"    \"data\": [\n"
"        [1, \"x\", false],\n"
"        [4, \"y\", null]\n"
"    ]\n"
"}'''\n"
"```"
msgstr ""

#: src/project/changelog.md:1003
msgid "For now, the argument is limited to string constants."
msgstr ""

#: src/project/changelog.md:1005
msgid "**Fixes**"
msgstr ""

#: src/project/changelog.md:1007
msgid "Export constructor for SQLCompileOptions (@bcho, #1621)"
msgstr ""

#: src/project/changelog.md:1008
msgid "Remove backticks in count_distinct (@aljazerzen, #1611)"
msgstr ""

#: src/project/changelog.md:1010
msgid "**New Contributors**"
msgstr ""

#: src/project/changelog.md:1012
msgid "@1Kinoti, with #1596"
msgstr ""

#: src/project/changelog.md:1013
msgid "@veenaamb, with #1614"
msgstr ""

#: src/project/changelog.md:1015
msgid "0.4.1 — 2023-01-18"
msgstr ""

#: src/project/changelog.md:1017
msgid ""
"0.4.1 comes a few days after 0.4.0, with a couple of features and the "
"release of `prqlc`, the CLI crate."
msgstr ""

#: src/project/changelog.md:1020
msgid "0.4.1 has 35 commits from 6 contributors."
msgstr ""

#: src/project/changelog.md:1024
msgid "Inferred column names include the relation name (@aljazerzen, #1550):"
msgstr ""

#: src/project/changelog.md:1032
msgid ""
"Quoted identifiers such as `dir/*.parquet` are passed through to SQL. (@max-"
"sixty, #1516)."
msgstr ""

#: src/project/changelog.md:1035
msgid ""
"The CLI is installed with `cargo install prqlc`. The binary was renamed in "
"0.4.0 but required an additional `--features` flag, which has been removed "
"in favor of this new crate (@max-sixty & @aljazerzen, #1549)."
msgstr ""

#: src/project/changelog.md:1041
msgid "@fool1280, with #1554"
msgstr ""

#: src/project/changelog.md:1042
msgid "@nkicg6, with #1567"
msgstr ""

#: src/project/changelog.md:1044
msgid "0.4.0 — 2023-01-15"
msgstr ""

#: src/project/changelog.md:1046
msgid ""
"0.4.0 brings lots of new features including `case`, `select ![]` and numbers "
"with underscores. We have initial (unpublished) bindings to Elixir. And "
"there's the usual improvements to fixes & documentation (only a minority are "
"listed below in this release)."
msgstr ""

#: src/project/changelog.md:1051
msgid ""
"0.4.0 also has some breaking changes: `table` is `let`, `dialect` is renamed "
"to `target`, and the compiler's API has changed. Full details below."
msgstr ""

#: src/project/changelog.md:1056
msgid ""
"Defining a temporary table is now expressed as `let` rather than `table` "
"(@aljazerzen, #1315). See the [tables docs](https://prql-lang.org/book/"
"reference/declarations/variables.html) for details."
msgstr ""

#: src/project/changelog.md:1061
msgid ""
"_Experimental:_ The [`case`](https://prql-lang.org/book/reference/syntax/"
"case.html) function sets a variable to a value based on one of several "
"expressions (@aljazerzen, \\#1278)."
msgstr ""

#: src/project/changelog.md:1066
msgid ""
"```prql no-eval\n"
"derive var = case [\n"
"  score <= 10 -> \"low\",\n"
"  score <= 30 -> \"medium\",\n"
"  score <= 70 -> \"high\",\n"
"  true -> \"very high\",\n"
"]\n"
"```"
msgstr ""

#: src/project/changelog.md:1075
msgid "...compiles to:"
msgstr ""

#: src/project/changelog.md:1081
msgid "'low'"
msgstr ""

#: src/project/changelog.md:1082
msgid "'medium'"
msgstr ""

#: src/project/changelog.md:1083
msgid "'high'"
msgstr ""

#: src/project/changelog.md:1084
msgid "'very high'"
msgstr ""

#: src/project/changelog.md:1090
msgid ""
"Check out the [`case` docs](https://prql-lang.org/book/reference/syntax/case."
"html) for more details."
msgstr ""

#: src/project/changelog.md:1094
msgid ""
"_Experimental:_ Columns can be excluded by name with `select` (@aljazerzen, "
"\\#1329)"
msgstr ""

#: src/project/changelog.md:1102
msgid ""
"_Experimental:_ `append` transform, equivalent to `UNION ALL` in SQL. "
"(@aljazerzen, #894)"
msgstr ""

#: src/project/changelog.md:1110
msgid ""
"Check out the [`append` docs](https://prql-lang.org/book/reference/stdlib/"
"transforms/append.html) for more details."
msgstr ""

#: src/project/changelog.md:1114
msgid ""
"Numbers can contain underscores, which can make reading long numbers easier "
"(@max-sixty, #1467):"
msgstr ""

#: src/project/changelog.md:1125
msgid ""
"The SQL output contains a comment with the PRQL compiler version "
"(@aljazerzen, \\#1322)"
msgstr ""

#: src/project/changelog.md:1127
msgid ""
"`dialect` is renamed to `target`, and its values are prefixed with `sql.` "
"(@max-sixty, #1388); for example:"
msgstr ""

#: src/project/changelog.md:1136
msgid ""
"This gives us the flexibility to target other languages than SQL in the long "
"term."
msgstr ""

#: src/project/changelog.md:1139
msgid ""
"Tables definitions can contain a bare s-string (@max-sixty, #1422), which "
"enables us to include a full CTE of SQL, for example:"
msgstr ""

#: src/project/changelog.md:1142
msgid ""
"```prql no-eval\n"
"let grouping = s\"\"\"\n"
"  SELECT SUM(a)\n"
"  FROM tbl\n"
"  GROUP BY\n"
"    GROUPING SETS\n"
"    ((b, c, d), (d), (b, d))\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/project/changelog.md:1152
msgid "Ranges supplied to `in` can be half-open (@aljazerzen, #1330)."
msgstr ""

#: src/project/changelog.md:1154
msgid ""
"The crate's external API has changed to allow for compiling to intermediate "
"representation. This also affects bindings. See [`prql-compiler` docs]"
"(https://docs.rs/prql-compiler/latest/prql_compiler/) for more details."
msgstr ""

#: src/project/changelog.md:1161
msgid "\\[This release, the changelog only contains a subset of fixes\\]"
msgstr ""

#: src/project/changelog.md:1163
msgid "Allow interpolations in table s-strings (@aljazerzen, #1337)"
msgstr ""

#: src/project/changelog.md:1167
msgid ""
"\\[This release, the changelog only contains a subset of documentation "
"improvements\\]"
msgstr ""

#: src/project/changelog.md:1170
msgid ""
"Add docs on aliases in [Select](https://prql-lang.org/book/reference/stdlib/"
"transforms/select.html)"
msgstr ""

#: src/project/changelog.md:1172
msgid "Add JS template literal and multiline example (@BCsabaEngine, #1432)"
msgstr ""

#: src/project/changelog.md:1173
msgid "JS template literal and multiline example (@BCsabaEngine, #1432)"
msgstr ""

#: src/project/changelog.md:1174
msgid "Improve prql-compiler docs & examples (@aljazerzen, #1515)"
msgstr ""

#: src/project/changelog.md:1175
msgid "Fix string highlighting in book (@max-sixty, #1264)"
msgstr ""

#: src/project/changelog.md:1179
msgid ""
"The playground allows querying some sample data. As before, the result "
"updates on every keystroke. (@aljazerzen, #1305)"
msgstr ""

#: src/project/changelog.md:1184
msgid ""
"\\[This release, the changelog only contains a subset of integration "
"improvements\\]"
msgstr ""

#: src/project/changelog.md:1186
msgid ""
"Added Elixir integration exposing PRQL functions as NIFs (#1500, @kasvith)"
msgstr ""

#: src/project/changelog.md:1187
msgid "Exposed Elixir flavor with exceptions (#1513, @kasvith)"
msgstr ""

#: src/project/changelog.md:1188
msgid "Rename `prql-compiler` binary to `prqlc` (@aljazerzen #1515)"
msgstr ""

#: src/project/changelog.md:1192
msgid ""
"\\[This release, the changelog only contains a subset of internal changes\\]"
msgstr ""

#: src/project/changelog.md:1194
msgid "Add parsing for negative select (@max-sixty, #1317)"
msgstr ""

#: src/project/changelog.md:1195
msgid "Allow for additional builtin functions (@aljazerzen, #1325)"
msgstr ""

#: src/project/changelog.md:1196
msgid "Add an automated check for typos (@max-sixty, #1421)"
msgstr ""

#: src/project/changelog.md:1197
msgid "Add tasks for running playground & book (@max-sixty, #1265)"
msgstr ""

#: src/project/changelog.md:1198
msgid "Add tasks for running tests on every file change (@max-sixty, #1380)"
msgstr ""

#: src/project/changelog.md:1200
msgid "**New contributors**:"
msgstr ""

#: src/project/changelog.md:1202
msgid "@EArazli, with #1359"
msgstr ""

#: src/project/changelog.md:1203
msgid "@boramalper, with #1362"
msgstr ""

#: src/project/changelog.md:1204
msgid "@allurefx, with #1377"
msgstr ""

#: src/project/changelog.md:1205
msgid "@bcho, with #1375"
msgstr ""

#: src/project/changelog.md:1206
msgid "@JettChenT, with #1385"
msgstr ""

#: src/project/changelog.md:1207
msgid "@BlurrechDev, with #1411"
msgstr ""

#: src/project/changelog.md:1208
msgid "@BCsabaEngine, with #1432"
msgstr ""

#: src/project/changelog.md:1209
msgid "@kasvith, with #1500"
msgstr ""

#: src/project/changelog.md:1211
msgid "0.3.1 - 2022-12-03"
msgstr ""

#: src/project/changelog.md:1213
msgid "0.3.1 brings a couple of small improvements and fixes."
msgstr ""

#: src/project/changelog.md:1217
msgid "Support for using s-strings for `from` (#1197, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1219
msgid ""
"```prql no-eval\n"
"from s\"SELECT * FROM employees WHERE foo > 5\"\n"
"```"
msgstr ""

#: src/project/changelog.md:1223
msgid ""
"Helpful error message when referencing a table in an s-string (#1203, "
"@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1228
msgid "Multiple columns with same name created (#1211, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1229
msgid "Renaming via select breaks preceding sorting (#1204, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1230
msgid "Same column gets selected multiple times (#1186, @mklopets)"
msgstr ""

#: src/project/changelog.md:1234
msgid ""
"Update Github Actions and Workflows to current version numbers (and avoid "
"using Node 12)"
msgstr ""

#: src/project/changelog.md:1237
msgid "0.3.0 — 2022-11-29"
msgstr ""

#: src/project/changelog.md:1239
msgid ""
"🎉 0.3.0 is the biggest ever change in PRQL's compiler, rewriting much of "
"the internals: the compiler now has a semantic understanding of expressions, "
"including resolving names & building a DAG of column lineage 🎉."
msgstr ""

#: src/project/changelog.md:1243
msgid ""
"While the immediate changes to the language are modest — some long-running "
"bugs are fixed — this unlocks the development of many of the project's long-"
"term priorities, such as type-checking & auto-complete. And it simplifies "
"the building of our next language features, such as match-case expressions, "
"unions & table expressions."
msgstr ""

#: src/project/changelog.md:1249
msgid ""
"@aljazerzen has (mostly single-handedly) done this work over the past few "
"months. The project owes him immense appreciation."
msgstr ""

#: src/project/changelog.md:1252
msgid "**Breaking changes**:"
msgstr ""

#: src/project/changelog.md:1254
msgid "We've had to make some modest breaking changes for 0.3:"
msgstr ""

#: src/project/changelog.md:1256
msgid ""
"_Pipelines must start with `from`_. For example, a pipeline with only "
"`derive foo = 5`, with no `from` transform, is no longer valid. Depending on "
"demand for this feature, it would be possible to add this back."
msgstr ""

#: src/project/changelog.md:1260
msgid ""
"_Shared column names now require `==` in a join_. The existing approach is "
"ambiguous to the compiler — `id` in the following example could be a boolean "
"column."
msgstr ""

#: src/project/changelog.md:1270
msgid ""
"_Table references containing periods must be surrounded by backticks_. For "
"example, when referencing a schema name:"
msgstr ""

#: src/project/changelog.md:1280
msgid "Change self equality op to `==` (#1176, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1281
msgid "Add logging (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1282
msgid "Add clickhouse dialect (#1090, @max-sixty)"
msgstr ""

#: src/project/changelog.md:1283
msgid "Allow namespaces & tables to contain `.` (#1079, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1287
msgid ""
"Deduplicate column appearing in `SELECT` multiple times (#1186, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1288
msgid "Fix uppercase table names (#1184, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1289
msgid "Omit table name when only one ident in SELECT (#1094, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1293
msgid "Add chapter on semantics' internals (@aljazerzen, #1028)"
msgstr ""

#: src/project/changelog.md:1294
msgid "Add note about nesting variables in s-strings (@max-sixty, #1163)"
msgstr ""

#: src/project/changelog.md:1298
msgid "Flatten group and window (#1120, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1299
msgid "Split ast into expr and stmt (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1300
msgid "Refactor associativity (#1156, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1301
msgid "Rename Ident constructor to `from_name` (#1084, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1302
msgid "Refactor rq folding (#1177, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1303
msgid "Add tests for reported bugs fixes in semantic (#1174, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1304
msgid "Bump duckdb from 0.5.0 to 0.6.0 (#1132)"
msgstr ""

#: src/project/changelog.md:1305
msgid "Bump once_cell from 1.15.0 to 1.16.0 (#1101)"
msgstr ""

#: src/project/changelog.md:1306
msgid "Bump pest from 2.4.0 to 2.5.0 (#1161)"
msgstr ""

#: src/project/changelog.md:1307
msgid "Bump pest_derive from 2.4.0 to 2.5.0 (#1179)"
msgstr ""

#: src/project/changelog.md:1308
msgid "Bump sqlparser from 0.25.0 to 0.27.0 (#1131)"
msgstr ""

#: src/project/changelog.md:1309
msgid "Bump trash from 2.1.5 to 3.0.0 (#1178)"
msgstr ""

#: src/project/changelog.md:1311
msgid "0.2.11 — 2022-11-20"
msgstr ""

#: src/project/changelog.md:1313
msgid "0.2.11 contains a few helpful fixes."
msgstr ""

#: src/project/changelog.md:1315
msgid ""
"Work continues on our `semantic` refactor — look out for 0.3.0 soon! Many "
"thanks to @aljazerzen for his continued contributions to this."
msgstr ""

#: src/project/changelog.md:1318
msgid ""
"Note: 0.2.10 was skipped due to this maintainer's inability to read his own "
"docs on bumping versions..."
msgstr ""

#: src/project/changelog.md:1323
msgid ""
"Detect when compiler version is behind query version (@MarinPostma, #1058)"
msgstr ""

#: src/project/changelog.md:1324
msgid "Add `__version__` to prql-python package (@max-sixty, #1034)"
msgstr ""

#: src/project/changelog.md:1328
msgid ""
"Fix nesting of expressions with equal binding strength and left "
"associativity, such as `a - (b - c)` (@max-sixty, #1136)"
msgstr ""

#: src/project/changelog.md:1330
msgid "Retain floats without significant digits as floats (@max-sixty, #1141)"
msgstr ""

#: src/project/changelog.md:1334
msgid "Add documentation of `prqlr` bindings (@eitsupi, #1091)"
msgstr ""

#: src/project/changelog.md:1335
msgid "Add a 'Why PRQL' section to the website (@max-sixty, #1098)"
msgstr ""

#: src/project/changelog.md:1336
msgid "Add @snth to core-devs (@max-sixty, #1050)"
msgstr ""

#: src/project/changelog.md:1340
msgid "Use workspace versioning (@max-sixty, #1065)"
msgstr ""

#: src/project/changelog.md:1342
msgid "0.2.9 — 2022-10-14"
msgstr ""

#: src/project/changelog.md:1344
msgid "0.2.9 is a small release containing a bug fix for empty strings."
msgstr ""

#: src/project/changelog.md:1348
msgid "Fix parsing of empty strings (@aljazerzen, #1024)"
msgstr ""

#: src/project/changelog.md:1350
msgid "0.2.8 — 2022-10-10"
msgstr ""

#: src/project/changelog.md:1352
msgid ""
"0.2.8 is another modest release with some fixes, doc improvements, bindings "
"improvements, and lots of internal changes. Note that one of the fixes "
"causes the behavior of `round` and `cast` to change slightly — though it's "
"handled as a fix rather than a breaking change in semantic versioning."
msgstr ""

#: src/project/changelog.md:1359
msgid ""
"Change order of the `round` & `cast` function parameters to have the column "
"last; for example `round 2 foo_col` / `cast int foo`. This is consistent "
"with other functions, and makes piping possible:"
msgstr ""

#: src/project/changelog.md:1372
msgid "Split `DEVELOPMENT.md` from `CONTRIBUTING.md` (@richb-hanover, #1010)"
msgstr ""

#: src/project/changelog.md:1373
msgid "Make s-strings more prominent in website intro (@max-sixty, #982)"
msgstr ""

#: src/project/changelog.md:1377
msgid "Add GitHub star count to website (@max-sixty, #990)"
msgstr ""

#: src/project/changelog.md:1381
msgid ""
"Expose a shortened error message, in particular for the VS Code extension "
"(@aljazerzen, #1005)"
msgstr ""

#: src/project/changelog.md:1386
msgid "Specify 1.60.0 as minimum Rust version (@max-sixty, #1011)"
msgstr ""

#: src/project/changelog.md:1387
msgid "Remove old `wee-alloc` code (@max-sixty, #1013)"
msgstr ""

#: src/project/changelog.md:1388
msgid "Upgrade clap to version 4 (@aj-bagwell, #1004)"
msgstr ""

#: src/project/changelog.md:1389
msgid "Improve book-building script in Taskfile (@max-sixty, #989)"
msgstr ""

#: src/project/changelog.md:1390
msgid ""
"Publish website using an artifact rather than a long-lived branch (@max-"
"sixty, \\#1009)"
msgstr ""

#: src/project/changelog.md:1393
msgid "0.2.7 — 2022-09-17"
msgstr ""

#: src/project/changelog.md:1395
msgid ""
"0.2.7 is a fairly modest release, six weeks after 0.2.6. We have some more "
"significant features, including a `union` operator and an overhaul of our "
"type system, as open PRs which will follow in future releases."
msgstr ""

#: src/project/changelog.md:1399
msgid ""
"We also have new features in the [VS Code extension](https://github.com/PRQL/"
"prql-code), courtesy of @jiripospisil, including a live output panel."
msgstr ""

#: src/project/changelog.md:1405
msgid ""
"`range_of_ranges` checks the Range end is smaller than its start (@shuozeli, "
"\\#946)"
msgstr ""

#: src/project/changelog.md:1410
msgid "Improve various docs (@max-sixty, #974, #971, #972, #970, #925)"
msgstr ""

#: src/project/changelog.md:1411
msgid "Add reference to EdgeDB's blog post in our FAQ (@max-sixty, #922)"
msgstr ""

#: src/project/changelog.md:1412
msgid "Fix typos (@kianmeng, #943)"
msgstr ""

#: src/project/changelog.md:1416
msgid "Add `prql-lib`, enabling language bindings with `go` (@sigxcpu76, #923)"
msgstr ""

#: src/project/changelog.md:1417
msgid "Fix line numbers in JS exceptions (@charlie-sanders, #929)"
msgstr ""

#: src/project/changelog.md:1421
msgid ""
"Lock the version of the rust-toolchain, with auto-updates (@max-sixty, #926, "
"\\#927)"
msgstr ""

#: src/project/changelog.md:1424
msgid "0.2.6 — 2022-08-05"
msgstr ""

#: src/project/changelog.md:1428
msgid "Adjust `fmt` to only escape names when needed (@aljazerzen, #907)"
msgstr ""

#: src/project/changelog.md:1429
msgid "Fix quoting on upper case `table` names (@max-sixty, #893)"
msgstr ""

#: src/project/changelog.md:1430
msgid ""
"Fix scoping of identical column names from multiple tables (@max-sixty, #908)"
msgstr ""

#: src/project/changelog.md:1431
msgid "Fix parse error on newlines in a `table` (@sebastiantoh 🆕, #902)"
msgstr ""

#: src/project/changelog.md:1432
msgid "Fix quoting of upper case table names (@max-sixty, #893)"
msgstr ""

#: src/project/changelog.md:1436
msgid "Add docs on Architecture (@aljazerzen, #904)"
msgstr ""

#: src/project/changelog.md:1437
msgid "Add Changelog (@max-sixty, #890 #891)"
msgstr ""

#: src/project/changelog.md:1441
msgid "Start trial using Conventional Commits (@max-sixty, #889)"
msgstr ""

#: src/project/changelog.md:1442
msgid "Add crates.io release workflow, docs (@max-sixty, #887)"
msgstr ""

#: src/project/changelog.md:1444
msgid "0.2.5 - 2022-07-29"
msgstr ""

#: src/project/changelog.md:1446
msgid "0.2.5 is a very small release following 0.2.4 yesterday. It includes:"
msgstr ""

#: src/project/changelog.md:1448
msgid ""
"Add the ability to represent single brackets in an s-string, with two "
"brackets (#752, @max-sixty)"
msgstr ""

#: src/project/changelog.md:1450
msgid ""
"Fix the \"Copy to Clipboard\" command in the Playground, for Firefox (#880, "
"@mklopets)"
msgstr ""

#: src/project/changelog.md:1453
msgid "0.2.4 - 2022-07-28"
msgstr ""

#: src/project/changelog.md:1455
msgid ""
"0.2.4 is a small release following 0.2.3 a few days ago. The 0.2.4 release "
"includes:"
msgstr ""

#: src/project/changelog.md:1458
msgid ""
"Enrich our CLI, adding commands to get different stages of the compilation "
"process (@aljazerzen , #863)"
msgstr ""

#: src/project/changelog.md:1460
msgid ""
"Fix multiple `take n` statements in a query, leading to duplicate proxy "
"columns in generated SQL (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1462
msgid "Fix BigQuery quoting of identifiers in `SELECT` statements (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1463
msgid ""
"Some internal changes — reorganize top-level functions (@aljazerzen), add a "
"workflow to track our Rust compilation time (@max-sixty), simplify our "
"simple prql-to-sql tests (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1467
msgid ""
"Thanks to @ankane, `prql-compiler` is now available from homebrew core; "
"`brew install prql-compiler`[^1]."
msgstr ""

#: src/project/changelog.md:1471
msgid ""
"    we still need to update docs and add a release workflow for this:\n"
"    <https://github.com/PRQL/prql/issues/866>\n"
"    "
msgstr ""

#: src/project/changelog.md:1474
msgid "0.2.3 - 2022-07-24"
msgstr ""

#: src/project/changelog.md:1476
msgid ""
"A couple of weeks since the 0.2.2 release: we've squashed a few bugs, added "
"some mid-sized features to the language, and made a bunch of internal "
"improvements."
msgstr ""

#: src/project/changelog.md:1479
msgid "The 0.2.3 release includes:"
msgstr ""

#: src/project/changelog.md:1481
msgid ""
"Allow for escaping otherwise-invalid identifiers (@aljazerzen & @max-sixty)"
msgstr ""

#: src/project/changelog.md:1482
msgid "Fix a bug around operator precedence (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1483
msgid "Add a section the book on the language bindings (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1484
msgid ""
"Add tests for our `Display` representation while fixing some existing bugs. "
"This is gradually becoming our code formatter (@arrizalamin)"
msgstr ""

#: src/project/changelog.md:1486
msgid "Add a \"copy to clipboard\" button in the Playground (@mklopets)"
msgstr ""

#: src/project/changelog.md:1487
msgid ""
"Add lots of guidance to our `CONTRIBUTING.md` around our tests and process "
"for merging (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1489
msgid ""
"Add a `prql!` macro for parsing a prql query at compile time (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1490
msgid "Add tests for `prql-js` (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1491
msgid ""
"Add a `from_json` method for transforming json to a PRQL string "
"(@arrizalamin)"
msgstr ""

#: src/project/changelog.md:1492
msgid "Add a workflow to release `prql-java` to Maven (@doki23)"
msgstr ""

#: src/project/changelog.md:1493
msgid ""
"Enable running all tests from a PR by adding a `pr-run-all-tests` label "
"(@max-sixty)"
msgstr ""

#: src/project/changelog.md:1495
msgid "Have `cargo-release` to bump all crate & npm versions (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1496
msgid "Update `prql-js` to use the bundler build of `prql-js` (@mklopets)"
msgstr ""

#: src/project/changelog.md:1498
msgid ""
"As well as those contribution changes, thanks to those who've reported "
"issues, such as @mklopets @huw @mm444 @ajfriend."
msgstr ""

#: src/project/changelog.md:1501
msgid ""
"From here, we're planning to continue squashing bugs (albeit more minor than "
"those in this release), adding some features like `union`, while working on "
"bigger issues such as type-inference."
msgstr ""

#: src/project/changelog.md:1505
msgid ""
"We're also going to document and modularize the compiler further. It's "
"important that we give more people an opportunity to contribute to the guts "
"of PRQL, especially given the number and enthusiasm of contributions to "
"project in general — and it's not that easy to do so at the moment. While "
"this is ongoing if anyone has something they'd like to work on in the more "
"difficult parts of the compiler, let us know on GitHub or Discord, and we'd "
"be happy to work together on it."
msgstr ""

#: src/project/changelog.md:1513
msgid "Thank you!"
msgstr ""

#: src/project/changelog.md:1515
msgid "0.2.2 - 2022-07-10"
msgstr ""

#: src/project/changelog.md:1517
msgid ""
"We're a couple of weeks since our 0.2.0 release. Thanks for the surge in "
"interest and contributions! 0.2.2 has some fixes & some internal "
"improvements:"
msgstr ""

#: src/project/changelog.md:1520
msgid ""
"We now test against SQLite & DuckDB on every commit, to ensure we're "
"producing correct SQL. (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1522
msgid "We have the beginning of Java bindings! (@doki23)"
msgstr ""

#: src/project/changelog.md:1523
msgid "Idents surrounded by backticks are passed through to SQL (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1524
msgid ""
"More examples on homepage; e.g. `join` & `window`, lots of small docs "
"improvements"
msgstr ""

#: src/project/changelog.md:1526
msgid "Automated releases to homebrew (@roG0d)"
msgstr ""

#: src/project/changelog.md:1527
msgid ""
"[prql-js](https://github.com/PRQL/prql/tree/main/prqlc/bindings/js) is now a "
"single package for Node, browsers & webpack (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1529
msgid ""
"Parsing has some fixes, including `>=` and leading underscores in idents "
"(@mklopets)"
msgstr ""

#: src/project/changelog.md:1531
msgid "Ranges receive correct syntax highlighting (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1533
msgid ""
"Thanks to Aljaž Mur Eržen @aljazerzen , George Roldugin @roldugin , Jasper "
"McCulloch @Jaspooky , Jie Han @doki23 , Marko Klopets @mklopets , Maximilian "
"Roos @max-sixty , Rodrigo Garcia @roG0d , Ryan Russell @ryanrussell , Steven "
"Maude @StevenMaude , Charlie Sanders @charlie-sanders ."
msgstr ""

#: src/project/changelog.md:1538
msgid ""
"We're planning to continue collecting bugs & feature requests from users, as "
"well as working on some of the bigger features, like type-inference."
msgstr ""

#: src/project/changelog.md:1541
msgid ""
"For those interesting in joining, we also have a new [Contributing page]"
"(https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md)."
msgstr ""

#: src/project/changelog.md:1544
msgid "0.2.0 - 2022-06-27"
msgstr ""

#: src/project/changelog.md:1546
msgid "🎉 🎉 **After several months of building, PRQL is ready to use!** 🎉 🎉"
msgstr ""

#: src/project/changelog.md:1550
msgid "How we got here:"
msgstr ""

#: src/project/changelog.md:1552
msgid ""
"At the end of January, we published a proposal of a better language for data "
"transformation: PRQL. The reception was better than I could have hoped for — "
"we were no. 2 on HackerNews for a day, and gained 2.5K GitHub stars over the "
"next few days."
msgstr ""

#: src/project/changelog.md:1557
msgid ""
"But man cannot live on GitHub Stars alone — we had to do the work to build "
"it. So over the next several months, during many evenings & weekends, a "
"growing group of us gradually built the compiler, evolved the language, and "
"wrote some integrations."
msgstr ""

#: src/project/changelog.md:1562
msgid ""
"We want to double-down on the community and its roots in open source — it's "
"incredible that a few of us from all over the globe have collaborated on a "
"project without ever having met. We decided early-on that PRQL would always "
"be open-source and would never have a commercial product (despite lots of "
"outside interest to fund a seed round!). Because languages are so deep in "
"the stack, and the data stack has so many players, the best chance of "
"building a great language is to build an open language."
msgstr ""

#: src/project/changelog.md:1572
msgid ""
"We still have a long way to go. While PRQL is usable, it has lots of missing "
"features, and an incredible amount of unfulfilled potential, including a "
"language server, cohesion with databases, and type inference. Over the "
"coming weeks, we'd like to grow the number of intrepid users experimenting "
"PRQL in their projects, prioritize features that will unblock them, and then "
"start fulfilling PRQL's potential by working through our [roadmap](https://"
"prql-lang.org/roadmap/)."
msgstr ""

#: src/project/changelog.md:1580
msgid ""
"The best way to experience PRQL is to try it. Check out our [website]"
"(https://prql-lang.org) and the [Playground](https://prql-lang.org/"
"playground). Start using PRQL for your own projects in [dbt](https://github."
"com/prql/dbt-prql), [Jupyter notebooks](https://pyprql.readthedocs.io/en/"
"latest/magic_readme.html) and Prefect workflows."
msgstr ""

#: src/project/changelog.md:1587
msgid ""
"Keep in touch with PRQL by following the project on [Twitter](https://"
"twitter.com/prql_lang), joining us on [Discord](https://discord.gg/"
"eQcfaCmsNc), starring the [repo](https://github.com/PRQL/prql)."
msgstr ""

#: src/project/changelog.md:1592
msgid ""
"[Contribute](https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md) "
"to the project — we're a really friendly community, whether you're a recent "
"SQL user or an advanced Rust programmer. We need bug reports, documentation "
"tweaks & feature requests — just as much as we need compiler improvements "
"written in Rust."
msgstr ""

#: src/project/changelog.md:1600
msgid ""
"I especially want to give [Aljaž Mur Eržen](https://github.com/aljazerzen) "
"(@aljazerzen) the credit he deserves, who has contributed the majority of "
"the difficult work of building out the compiler. Much credit also goes to "
"@charlie-sanders, one of PRQL's earliest supporters and the author of "
"pyprql, and [Ryan Patterson-Cross](https://github.com/rbpatt2019) "
"(@rbpatt2019), who built the Jupyter integration among other Python "
"contributions."
msgstr ""

#: src/project/changelog.md:1607
msgid ""
"Other contributors who deserve a special mention include: @roG0d, @snth, "
"@kwigley"
msgstr ""

#: src/project/changelog.md:1612
msgid "Thank you, and we look forward to your feedback!"
msgstr ""

#: src/project/contributing/index.md:1
msgid "Contributing"
msgstr ""

#: src/project/contributing/index.md:3
msgid ""
"If you're interested in joining the community to build a better SQL, here "
"are ways to start:"
msgstr ""

#: src/project/contributing/index.md:6
msgid "Star the [repo](https://github.com/PRQL/prql)."
msgstr ""

#: src/project/contributing/index.md:7
msgid "Send a link to PRQL to a couple of people whose opinion you respect."
msgstr ""

#: src/project/contributing/index.md:8
msgid ""
"Subscribe to [new releases](https://www.jessesquires.com/blog/2020/07/30/"
"github-tip-watching-releases/) for updates."
msgstr ""

#: src/project/contributing/index.md:11
msgid "Follow us on [Twitter](https://twitter.com/prql_lang)."
msgstr ""

#: src/project/contributing/index.md:12
msgid "Join our [Discord](https://discord.gg/eQcfaCmsNc)."
msgstr ""

#: src/project/contributing/index.md:13
msgid ""
"Find an issue labeled [Good First Issue](https://github.com/prql/prql/issues?"
"q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22) and start "
"contributing to the code."
msgstr ""

#: src/project/contributing/index.md:16
msgid ""
"Join our [fortnightly Developer Call](https://github.com/PRQL/prql/"
"issues/1083); ([iCal file](./fortnightly-dev-call.ics))."
msgstr ""

#: src/project/contributing/index.md:20
msgid ""
"PRQL is evolving from a project with lots of excitement into a project that "
"folks are using in their work and integrating into their tools. We're "
"actively looking for collaborators to lead that growth with us."
msgstr ""

#: src/project/contributing/index.md:24
msgid "Areas for larger contributions"
msgstr ""

#: src/project/contributing/index.md:26
msgid "Compiler"
msgstr ""

#: src/project/contributing/index.md:28
msgid ""
"The compiler is written in Rust, and there's enough to do such that any "
"level of experience with Rust is sufficient."
msgstr ""

#: src/project/contributing/index.md:31
msgid ""
"We try to keep a few onboarding issues on hand under the [\"good first "
"issue\" label](https://github.com/PRQL/prql/labels/good%20first%20issue). "
"These have been screened to have sufficient context to get started (and we "
"very much welcome questions where there's some context missing)."
msgstr ""

#: src/project/contributing/index.md:36
msgid ""
"To get started, check out the docs on [Development](./development.md) and "
"the [Compiler architecture](https://github.com/PRQL/prql/blob/main/prqlc/"
"ARCHITECTURE.md)"
msgstr ""

#: src/project/contributing/index.md:39
msgid ""
"And if you have questions, there are lots of friendly people on the Discord "
"who will patiently help you."
msgstr ""

#: src/project/contributing/index.md:42
msgid "Bindings & integrations"
msgstr ""

#: src/project/contributing/index.md:44
msgid ""
"For PRQL to be successful, it needs to be available for the languages & "
"tools that people already use."
msgstr ""

#: src/project/contributing/index.md:47
msgid ""
"We currently have bindings to the PRQL compiler in a few different "
"languages; many of these can be improved, documented, and packaged in a "
"better way."
msgstr ""

#: src/project/contributing/index.md:49
msgid ""
"If you have experience with packaging in an ecosystem that doesn't currently "
"have bindings, then creating PRQL bindings for that language we don't "
"currently support would be valuable to the project."
msgstr ""

#: src/project/contributing/index.md:52
msgid ""
"If there's a tool that you use yourself to run data queries which you think "
"would benefit from a PRQL integration, suggest one to us or the tool. If "
"it's open-source, build & share a prototype."
msgstr ""

#: src/project/contributing/index.md:56
msgid ""
"Relevant issues are labeled [Integrations](https://github.com/PRQL/prql/"
"labels/integrations)."
msgstr ""

#: src/project/contributing/index.md:59
msgid "Language design"
msgstr ""

#: src/project/contributing/index.md:61
msgid ""
"We decide on new language features in GitHub issues, usually under "
"[\"language design\" label](https://github.com/PRQL/prql/issues?"
"q=is%3Aopen+label%3Alanguage-design+sort%3Aupdated-desc)."
msgstr ""

#: src/project/contributing/index.md:64
msgid "You can also contribute by:"
msgstr ""

#: src/project/contributing/index.md:66
msgid ""
"Finding instances where the compiler produces incorrect results, and post a "
"bug report — feel free to use the [playground](https://prql-lang.org/"
"playground)."
msgstr ""

#: src/project/contributing/index.md:69
msgid ""
"Opening an issue / append to an existing issue with examples of queries that "
"are difficult to express in PRQL — especially if more difficult than SQL."
msgstr ""

#: src/project/contributing/index.md:72
msgid ""
"With sufficient examples, suggest a change to the language! (Though "
"suggestions _without_ examples are difficult to engage with, so please do "
"anchor suggestions in examples.)"
msgstr ""

#: src/project/contributing/index.md:76
msgid "Marketing"
msgstr ""

#: src/project/contributing/index.md:78
msgid ""
"Improve our website. We have [a few issues open](https://github.com/PRQL/"
"prql/labels/web) on this front and are looking for anyone with at least some "
"design skills."
msgstr ""

#: src/project/contributing/index.md:81
msgid ""
"Contribute towards the docs. Anything from shaping a whole section of the "
"docs, to simply improving a confusing paragraph or fixing a typo."
msgstr ""

#: src/project/contributing/index.md:83
msgid "Tell people about PRQL."
msgstr ""

#: src/project/contributing/index.md:84
msgid ""
"Find a group of users who would be interested in PRQL, help them get up to "
"speed, help the project understand what they need."
msgstr ""

#: src/project/contributing/index.md:87
msgid "Core team"
msgstr ""

#: src/project/contributing/index.md:89
msgid ""
"If you have any questions or feedback and don't receive a response on one of "
"the general channels such as GitHub or Discord, feel free to reach out to:"
msgstr ""

#: src/project/contributing/index.md:92
msgid "[**@aljazerzen**](https://github.com/aljazerzen) — Aljaž Mur Eržen"
msgstr ""

#: src/project/contributing/index.md:93
msgid "[**@max-sixty**](https://github.com/max-sixty) — Maximilian Roos"
msgstr ""

#: src/project/contributing/index.md:94
msgid "[**@eitsupi**](https://github.com/eitsupi) — SHIMA Tatsuya"
msgstr ""

#: src/project/contributing/index.md:95
msgid "[**@snth**](https://github.com/snth) — Tobias Brandt"
msgstr ""

#: src/project/contributing/index.md:97
msgid "Core team Emeritus"
msgstr ""

#: src/project/contributing/index.md:99
msgid "Thank you to those who have previously served on the core team:"
msgstr ""

#: src/project/contributing/index.md:101
msgid "**@charlie-sanders** — Charlie Sanders"
msgstr ""

#: src/project/contributing/development.md:3
msgid "Setting up an initial dev environment"
msgstr ""

#: src/project/contributing/development.md:5
msgid ""
"We can set up a local development environment sufficient for navigating, "
"editing, and testing PRQL's compiler code in two minutes:"
msgstr ""

#: src/project/contributing/development.md:8
msgid ""
"Install [`rustup` & `cargo`](https://doc.rust-lang.org/cargo/getting-started/"
"installation.html)."
msgstr ""

#: src/project/contributing/development.md:10
msgid ""
"\\[Optional but highly recommended\\] Install `cargo-insta`, our testing "
"framework:"
msgstr ""

#: src/project/contributing/development.md:16
msgid ""
"That's it! Running the unit tests for the `prqlc` crate after cloning the "
"repo should complete successfully:"
msgstr ""

#: src/project/contributing/development.md:23
msgid "...or, to run tests and update the test snapshots:"
msgstr ""

#: src/project/contributing/development.md:29
msgid "There's more context on our tests in [How we test](#how-we-test) below."
msgstr ""

#: src/project/contributing/development.md:31
msgid "That's sufficient for making an initial contribution to the compiler."
msgstr ""

#: src/project/contributing/development.md:35
msgid "Setting up a full dev environment"
msgstr ""

#: src/project/contributing/development.md:45
msgid ""
"For more advanced development; for example compiling for wasm or previewing "
"the website, we have two options:"
msgstr ""

#: src/project/contributing/development.md:48
msgid "Option 1: Use the project's `task`"
msgstr ""

#: src/project/contributing/development.md:55
msgid "[Install Task](https://taskfile.dev/installation/)."
msgstr ""

#: src/project/contributing/development.md:56
msgid ""
"Then run the `setup-dev` task. This runs commands from our [Taskfile.yaml]"
"(https://github.com/PRQL/prql/blob/main/Taskfile.yaml), installing "
"dependencies with `cargo`, `brew`, `npm` & `pip`, and suggests some VS Code "
"extensions."
msgstr ""

#: src/project/contributing/development.md:65
msgid "Option 2: Install tools individually"
msgstr ""

#: src/project/contributing/development.md:67
msgid "We'll need `cargo-insta`, to update snapshot tests:"
msgstr ""

#: src/project/contributing/development.md:73
msgid ""
"We'll need Python, which most systems will have already. The easiest way to "
"check is to try running the full tests:"
msgstr ""

#: src/project/contributing/development.md:80
msgid ""
"...and if that doesn't complete successfully, ensure we have Python >= 3.7, "
"to compile `prqlc-python`."
msgstr ""

#: src/project/contributing/development.md:83
msgid ""
"For more involved contributions, such as building the website, playground, "
"book, or some release artifacts, we'll need some additional tools. But we "
"won't need those immediately, and the error messages on what's missing "
"should be clear when we attempt those things. When we hit them, the "
"[Taskfile.yaml](https://github.com/PRQL/prql/blob/main/Taskfile.yaml) will "
"be a good source to copy & paste instructions from."
msgstr ""

#: src/project/contributing/development.md:90
msgid "Option 3: Use a Dev Container"
msgstr ""

#: src/project/contributing/development.md:92
msgid ""
"This project has a [devcontainer.json file](https://github.com/PRQL/prql/"
"blob/main/.devcontainer/devcontainer.json) and a [pre-built dev container "
"base Docker image](https://github.com/PRQL/prql/pkgs/container/prql-"
"devcontainer-base). Learn more about Dev Containers at [https://containers."
"dev/](https://containers.dev/)"
msgstr ""

#: src/project/contributing/development.md:99
msgid ""
"Currently, the tools for Rust are already installed in the pre-built image, "
"and, Node.js, Python and others are configured to be installed when build "
"the container."
msgstr ""

#: src/project/contributing/development.md:103
msgid ""
"While there are a variety of tools that support Dev Containers, the focus "
"here is on developing with VS Code in a container by [GitHub Codespaces]"
"(https://docs.github.com/en/codespaces/overview) or [VS Code Dev Containers "
"extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-"
"remote.remote-containers)."
msgstr ""

#: src/project/contributing/development.md:108
msgid ""
"To use a Dev Container on a local computer with VS Code, install the [VS "
"Code Dev Containers extension](https://marketplace.visualstudio.com/items?"
"itemName=ms-vscode-remote.remote-containers) and its system requirements. "
"Then refer to the links above to get started."
msgstr ""

#: src/project/contributing/development.md:112
msgid "Option 4: Use nix development environment"
msgstr ""

#: src/project/contributing/development.md:119
msgid ""
"A [nix](https://nixos.org/) flake `flake.nix` provides 3 development "
"environments:"
msgstr ""

#: src/project/contributing/development.md:122
msgid "**default**, for building the compiler"
msgstr ""

#: src/project/contributing/development.md:123
msgid "**web**, for the compiler and the website,"
msgstr ""

#: src/project/contributing/development.md:124
msgid "**full**, for the compiler, the website and the compiler bindings."
msgstr ""

#: src/project/contributing/development.md:126
msgid "To load the shell:"
msgstr ""

#: src/project/contributing/development.md:128
msgid ""
"[Install nix (the package manager)](https://nixos.org/download). (only first "
"time)"
msgstr ""

#: src/project/contributing/development.md:131
msgid ""
"Enable flakes, which are a (pretty stable) experimental feature of nix. "
"(only first time)"
msgstr ""

#: src/project/contributing/development.md:134
msgid "For non-NixOS users:"
msgstr ""

#: src/project/contributing/development.md:138
msgid "'experimental-features = nix-command flakes'"
msgstr ""

#: src/project/contributing/development.md:141
msgid ""
"For NixOS users, follow instructions [here](https://nixos.wiki/wiki/Flakes)."
msgstr ""

#: src/project/contributing/development.md:143
msgid "Run:"
msgstr ""

#: src/project/contributing/development.md:149
msgid "To use the \"web\" or \"full\" shell, run:"
msgstr ""

#: src/project/contributing/development.md:155
msgid ""
"Optionally, you can install [direnv](https://direnv.net/), to automatically "
"load the shell when you enter this repo. The easiest way is to also install "
"[direnv-nix](https://github.com/nix-community/nix-direnv) and configure your "
"`.envrc` with:"
msgstr ""

#: src/project/contributing/development.md:161
msgid "# .envrc\n"
msgstr ""

#: src/project/contributing/development.md:167
msgid "Contribution workflow"
msgstr ""

#: src/project/contributing/development.md:169
msgid ""
"We're similar to most projects on GitHub — open a Pull Request with a "
"suggested change!"
msgstr ""

#: src/project/contributing/development.md:172
msgid "Commits"
msgstr ""

#: src/project/contributing/development.md:174
msgid ""
"If a change is user-facing, please add a line in [**`CHANGELOG.md`**]"
"(https://github.com/PRQL/prql/blob/main/CHANGELOG.md), with `{message}, "
"({@contributor, #X})` where `X` is the PR number."
msgstr ""

#: src/project/contributing/development.md:177
msgid ""
"If there's a missing entry, a follow-up PR containing just the changelog "
"entry is welcome."
msgstr ""

#: src/project/contributing/development.md:179
msgid ""
"We're using [Conventional Commits](https://www.conventionalcommits.org) "
"message format, enforced through [action-semantic-pull-request](https://"
"github.com/amannn/action-semantic-pull-request)."
msgstr ""

#: src/project/contributing/development.md:183
msgid "Merges"
msgstr ""

#: src/project/contributing/development.md:185
msgid "**We merge any code that makes PRQL better**"
msgstr ""

#: src/project/contributing/development.md:186
msgid ""
"A PR doesn't need to be perfect to be merged; it doesn't need to solve a big "
"problem. It needs to:"
msgstr ""

#: src/project/contributing/development.md:188
msgid "be in the right direction,"
msgstr ""

#: src/project/contributing/development.md:189
msgid "make incremental progress,"
msgstr ""

#: src/project/contributing/development.md:190
msgid "be explicit on its current state, so others can continue the progress."
msgstr ""

#: src/project/contributing/development.md:191
msgid ""
"That said, there are a few instances when we need to ensure we have some "
"consensus before merging code — for example non-trivial changes to the "
"language, or large refactorings to the library."
msgstr ""

#: src/project/contributing/development.md:194
msgid ""
"If you have merge permissions, and are reasonably confident that a PR is "
"suitable to merge (whether or not you're the author), feel free to merge."
msgstr ""

#: src/project/contributing/development.md:196
msgid ""
"If you don't have merge permissions and have authored a few PRs, ask and ye "
"shall receive."
msgstr ""

#: src/project/contributing/development.md:198
msgid "The primary way we ratchet the code quality is through automated tests."
msgstr ""

#: src/project/contributing/development.md:199
msgid ""
"This means PRs almost always need a test to demonstrate incremental progress."
msgstr ""

#: src/project/contributing/development.md:201
msgid ""
"If a change breaks functionality without breaking tests, our tests were "
"probably insufficient."
msgstr ""

#: src/project/contributing/development.md:203
msgid ""
"If a change breaks existing tests (for example, changing an external API), "
"that indicates we should be careful about merging a change, including "
"soliciting others' views."
msgstr ""

#: src/project/contributing/development.md:206
msgid ""
"We use PR reviews to give general context, offer specific assistance, and "
"collaborate on larger decisions."
msgstr ""

#: src/project/contributing/development.md:208
msgid ""
"Reviews around 'nits' like code formatting / idioms / etc are very welcome. "
"But the norm is for them to be received as helpful advice, rather than as "
"mandatory tasks to complete. Adding automated tests & lints to automate "
"these suggestions is welcome."
msgstr ""

#: src/project/contributing/development.md:212
msgid ""
"If you have merge permissions and would like a PR to be reviewed before it "
"merges, that's great — ask or assign a reviewer."
msgstr ""

#: src/project/contributing/development.md:214
msgid ""
"If a PR hasn't received attention after a day, please feel free to ping the "
"pull request."
msgstr ""

#: src/project/contributing/development.md:216
msgid ""
"People may review a PR after it's merged. As part of the understanding that "
"we can merge quickly, contributors are expected to incorporate substantive "
"feedback into a future PR."
msgstr ""

#: src/project/contributing/development.md:219
msgid ""
"We should revert quickly if the impact of a PR turns out not to be "
"consistent with our expectations, or there isn't as much consensus on a "
"decision as we had hoped. It's very easy to revert code and then re-revert "
"when we've resolved the issue; it's a sign of moving quickly. Other options "
"which resolve issues immediately are also fine, such as commenting out an "
"incorrect test or adding a quick fix for the underlying issue."
msgstr ""

#: src/project/contributing/development.md:226
msgid "Docs"
msgstr ""

#: src/project/contributing/development.md:228
msgid "We're very keen on contributions to improve our documentation."
msgstr ""

#: src/project/contributing/development.md:230
msgid ""
"This includes our docs in the book, on the website, in our code, or in a "
"Readme. We also appreciate issues pointing out that our documentation was "
"confusing, incorrect, or stale — if it's confusing for you, it's probably "
"confusing for others."
msgstr ""

#: src/project/contributing/development.md:235
msgid "Some principles for ensuring our docs remain maintainable:"
msgstr ""

#: src/project/contributing/development.md:237
msgid ""
"Docs should be as close as possible to the code. Doctests are ideal on this "
"dimension — they're literally very close to the code and they can't drift "
"apart since they're tested on every commit. Or, for example, it's better to "
"add text to a `--help` message, rather than write a paragraph in the Readme "
"explaining the CLI."
msgstr ""

#: src/project/contributing/development.md:242
msgid ""
"We should have some visualization of how to maintain docs when we add them. "
"Docs have a habit of falling out of date — the folks reading them are often "
"different from those writing them, they're sparse from the code, generally "
"not possible to test, and are rarely the by-product of other contributions. "
"Docs that are concise & specific are easier to maintain."
msgstr ""

#: src/project/contributing/development.md:247
msgid ""
"Docs should be specifically relevant to PRQL; anything else we can instead "
"link to."
msgstr ""

#: src/project/contributing/development.md:250
msgid ""
"If something doesn't fit into one of these categories, there are still lots "
"of ways of getting the word out there — a blog post / gist / etc. Let us "
"know and we're happy to link to it / tweet it."
msgstr ""

#: src/project/contributing/development.md:254
msgid "How we test"
msgstr ""

#: src/project/contributing/development.md:256
msgid ""
"We use a pyramid of tests — we have fast, focused tests at the bottom of the "
"pyramid, which give us low latency feedback when developing, and then "
"slower, broader tests which ensure that we don't miss anything as PRQL "
"develops<sup><a name=\"to-footnote-1\">[1](#footnote-1)</a></sup>."
msgstr ""

#: src/project/contributing/development.md:270
msgid "Our tests, from the bottom of the pyramid to the top:"
msgstr ""

#: src/project/contributing/development.md:272
msgid ""
"**[Static checks](https://github.com/PRQL/prql/blob/main/.pre-commit-config."
"yaml)** — we run a few static checks to ensure the code stays healthy and "
"consistent. They're defined in [**`.pre-commit-config.yaml`**](https://"
"github.com/PRQL/prql/blob/main/.pre-commit-config.yaml), using [pre-commit]"
"(https://pre-commit.com). They can be run locally with"
msgstr ""

#: src/project/contributing/development.md:280
#: src/project/contributing/development.md:302
#: src/project/contributing/development.md:354
msgid "# or\n"
msgstr ""

#: src/project/contributing/development.md:284
msgid ""
"The tests fix most of the issues they find themselves. Most of them also run "
"on GitHub on every commit; any changes they make are added onto the branch "
"automatically in an additional commit."
msgstr ""

#: src/project/contributing/development.md:288
msgid ""
"Checking by [MegaLinter](https://megalinter.io/latest/), which includes more "
"Linters, is also done automatically on GitHub. (experimental)"
msgstr ""

#: src/project/contributing/development.md:291
msgid ""
"**Unit tests & inline insta snapshots** — we rely on unit tests to rapidly "
"check that our code basically works. We extensively use [Insta](https://"
"insta.rs/), a snapshot testing tool which writes out the values generated by "
"our code, making it fast & simple to write and modify tests<sup><a name=\"to-"
"footnote-2\">[2](#footnote-2)</a></sup>"
msgstr ""

#: src/project/contributing/development.md:297
msgid ""
"These are the fastest tests which run our code; they're designed to run on "
"every save while you're developing. We include a `task` which does this:"
msgstr ""

#: src/project/contributing/development.md:304
msgid "# or, to run on every change:\n"
msgstr ""

#: src/project/contributing/development.md:338
msgid ""
"**[Documentation](https://github.com/PRQL/prql/tree/main/web/book/tests/"
"documentation)** — we compile all examples from our documentation in the "
"Website, README, and PRQL Book, to test that they produce the SQL we expect, "
"and that changes to our code don't cause any unexpected regressions. These "
"are included in:"
msgstr ""

#: src/project/contributing/development.md:347
msgid ""
"**[Database integration tests](https://github.com/PRQL/prql/tree/main/prqlc/"
"prqlc/tests/integration/dbs)** — we run tests with example queries against "
"databases with actual data to ensure we're producing correct SQL across our "
"supported dialects. The in-process tests can be run locally with:"
msgstr ""

#: src/project/contributing/development.md:358
msgid ""
"More details on running with external databases are in the [Readme](https://"
"github.com/PRQL/prql/tree/main/prqlc/prqlc/tests/integration/dbs)."
msgstr ""

#: src/project/contributing/development.md:361
msgid ""
"```admonish note\n"
"Integration tests use DuckDB, and so require a clang compiler to compile\n"
"[`duckdb-rs`](https://github.com/wangfenjin/duckdb-rs). Most development\n"
"systems will have one, but if the test command fails, install a clang "
"compiler with:\n"
"\n"
"  - On macOS, install xcode with `xcode-select --install`\n"
"  - On Debian Linux, `apt-get update && apt-get install clang`\n"
"  - On Windows, `duckdb-rs` isn't supported, so these tests are excluded\n"
"```"
msgstr ""

#: src/project/contributing/development.md:371
msgid ""
"**[GitHub Actions on every commit](https://github.com/PRQL/prql/blob/main/."
"github/workflows/tests.yaml)** — we run tests relevant to a PR's changes in "
"CI — for example changes to docs will attempt to build docs, changes to a "
"binding will run that binding's tests. The vast majority of changes trigger "
"tests which run in less than five minutes, and we should be reassessing "
"their scope if they take longer than that. Once these pass, a pull request "
"can be merged."
msgstr ""

#: src/project/contributing/development.md:378
msgid ""
"**[GitHub Actions on merge](https://github.com/PRQL/prql/blob/"
"c042eef48709e2c1af577161554fd09f14e67e0f/.github/workflows/pull-request."
"yaml#L124)** — we run a wider set tests on every merge to main. This "
"includes testing across OSs, all our language bindings, a measure of test "
"code coverage, and some performance benchmarks."
msgstr ""

#: src/project/contributing/development.md:383
msgid ""
"If these tests fail after merging, we should revert the commit before fixing "
"the test and then re-reverting."
msgstr ""

#: src/project/contributing/development.md:386
msgid "Most of these will run locally with:"
msgstr ""

#: src/project/contributing/development.md:392
msgid ""
"**[GitHub Actions nightly](https://github.com/PRQL/prql/blob/main/.github/"
"workflows/nightly.yaml)** — every night, we run tests that take longer, are "
"less likely to fail, or are unrelated to code changes — such as security "
"checks, bindings' tests on multiple OSs, or expensive timing benchmarks."
msgstr ""

#: src/project/contributing/development.md:397
msgid ""
"We can run these tests before a merge by adding a label `pr-nightly` to the "
"PR."
msgstr ""

#: src/project/contributing/development.md:400
msgid ""
"The goal of our tests is to allow us to make changes quickly. If they're "
"making it more difficult to make changes, or there are missing tests that "
"would offer the confidence to make changes faster, please raise an issue."
msgstr ""

#: src/project/contributing/development.md:406
msgid "Website"
msgstr ""

#: src/project/contributing/development.md:408
msgid ""
"The website is published together with the book and the playground, and is "
"automatically built and released on any push to the `web` branch."
msgstr ""

#: src/project/contributing/development.md:411
msgid ""
"The `web` branch points to the latest release plus any website-specific "
"fixes. That way, the compiler behavior in the playground matches the latest "
"release while allowing us to fix mistakes in the docs with a tighter loop "
"than every release."
msgstr ""

#: src/project/contributing/development.md:416
msgid ""
"Fixes to the playground, book, or website should have a `pr-backport-web` "
"label added to their PR — a bot will then open & merge another PR onto the "
"`web` branch once the initial branch merges."
msgstr ""

#: src/project/contributing/development.md:420
msgid "The website components will run locally with:"
msgstr ""

#: src/project/contributing/development.md:423
msgid "# Run the main website\n"
msgstr ""

#: src/project/contributing/development.md:424
msgid "# Run the PRQL online book\n"
msgstr ""

#: src/project/contributing/development.md:426
msgid "# Run the PRQL playground\n"
msgstr ""

#: src/project/contributing/development.md:433
msgid ""
"We have a number of language bindings, as documented at <https://prql-lang."
"org/book/project/bindings/index.html>. Some of these are within our "
"monorepo, some are in separate repos. Here's a provisional framework for "
"when we use the main prql repo vs separate repos for bindings:"
msgstr ""

#: src/project/contributing/development.md:438
msgid "Factor"
msgstr ""

#: src/project/contributing/development.md:438
msgid "Rationale"
msgstr ""

#: src/project/contributing/development.md:438
msgid "Example"
msgstr ""

#: src/project/contributing/development.md:440
msgid "Does someone want to sign up to maintain a repo?"
msgstr ""

#: src/project/contributing/development.md:440
msgid "A different repo is harder for the core team to maintain"
msgstr ""

#: src/project/contributing/development.md:440
msgid "`tree-sitter-prql` is well maintained"
msgstr ""

#: src/project/contributing/development.md:441
msgid "Can it change independently from the compiler?"
msgstr ""

#: src/project/contributing/development.md:441
msgid ""
"If it's in a different repo, it can't be changed in lockstep with the "
"compiler"
msgstr ""

#: src/project/contributing/development.md:441
msgid "`prql-vscode` is fine to change \"behind\" the language"
msgstr ""

#: src/project/contributing/development.md:442
msgid "Would a separate repo invite new contributors?"
msgstr ""

#: src/project/contributing/development.md:442
msgid ""
"A monorepo with all the rust code can be less inviting for those familiar "
"with other langs"
msgstr ""

#: src/project/contributing/development.md:442
msgid "`prql-vscode` had some JS-only contributors"
msgstr ""

#: src/project/contributing/development.md:443
msgid "Is there an convention for a stand-alone repo?"
msgstr ""

#: src/project/contributing/development.md:443
msgid "A small number of ecosystems require a separate repo"
msgstr ""

#: src/project/contributing/development.md:443
msgid "`homebrew-prql` needs to be named that way for a Homebrew tap"
msgstr ""

#: src/project/contributing/development.md:447
msgid "Releasing"
msgstr ""

#: src/project/contributing/development.md:449
msgid "Currently we release in a semi-automated way:"
msgstr ""

#: src/project/contributing/development.md:451
msgid ""
"PR & merge an updated [Changelog](https://github.com/PRQL/prql/blob/main/"
"CHANGELOG.md). GitHub will produce a draft version at <https://github.com/"
"PRQL/prql/releases/new>, including \"New Contributors\"."
msgstr ""

#: src/project/contributing/development.md:456
msgid "Use this script to generate a line introducing the enumerated changes:"
msgstr ""

#: src/project/contributing/development.md:459
msgid ""
"\"It has $(git rev-list --count $(git rev-list --tags --max-count=1)..) "
"commits from $(git shortlog --summary $(git rev-list --tags --max-count=1).. "
"| wc -l | tr -d '[:space:]') contributors. Selected changes:\""
msgstr ""

#: src/project/contributing/development.md:462
msgid ""
"If the current version is correct, then skip ahead. But if the version needs "
"to be changed — for example, we had planned on a patch release, but instead "
"require a minor release — then run `cargo release version $version -x && "
"cargo release replace -x && task test-rust` to bump the version, and PR the "
"resulting commit."
msgstr ""

#: src/project/contributing/development.md:468
msgid ""
"After merging, go to [Draft a new release](https://github.com/PRQL/prql/"
"releases/new)<sup><a name=\"to-footnote-3\">[3](#footnote-3)</a></sup>, copy "
"the changelog entry into the release description<sup><a name=\"to-"
"footnote-4\">[4](#footnote-4)</a></sup>, enter the tag to be created, and "
"hit \"Publish\"."
msgstr ""

#: src/project/contributing/development.md:474
msgid ""
"From there, both the tag and release is created and all packages are "
"published automatically based on our [release workflow](https://github.com/"
"PRQL/prql/blob/main/.github/workflows/release.yaml)."
msgstr ""

#: src/project/contributing/development.md:478
msgid ""
"Run `cargo release version patch -x --no-confirm && cargo release replace -x "
"--no-confirm && task test-rust` to bump the versions and add a new Changelog "
"section; then PR the resulting commit. Note this currently contains `task "
"test-rust` to update snapshot tests which contain the version."
msgstr ""

#: src/project/contributing/development.md:484
msgid ""
"Check whether there are [milestones](https://github.com/PRQL/prql/"
"milestones) that need to be pushed out."
msgstr ""

#: src/project/contributing/development.md:487
msgid ""
"Review the **Current Status** on the README.md to ensure it reflects the "
"project state."
msgstr ""

#: src/project/contributing/development.md:490
msgid ""
"We may make this more automated in future; e.g. automatic changelog creation."
msgstr ""

#: src/project/contributing/development.md:494
msgid ""
"<a name=\"footnote-1\">[1](#to-footnote-1)</a>: Our approach is very "
"consistent with **[@matklad](https://github.com/matklad)**'s advice, in his "
"excellent blog post [How to Test](https://matklad.github.io//2021/05/31/how-"
"to-test.html)."
msgstr ""

#: src/project/contributing/development.md:499
msgid ""
"<a name=\"footnote-2\">[2](#to-footnote-2)</a>: [Here's an example of an "
"insta test](https://github.com/PRQL/prql/blob/0.2.2/prql-compiler/src/parser."
"rs#L580-L605) — note that only the initial line of each test is written by "
"us; the remainder is filled in by insta."
msgstr ""

#: src/project/contributing/development.md:503
msgid ""
"<a name=\"footnote-3\">[3](#to-footnote-3)</a>: Only maintainers have access "
"to this page."
msgstr ""

#: src/project/contributing/development.md:506
msgid ""
"<a name=\"footnote-4\">[4](#to-footnote-4)</a>: Unfortunately GitHub's "
"markdown parser interprets linebreaks as newlines. I haven't found a better "
"way of editing the markdown to look reasonable than manually editing the "
"text or asking LLM to help."
msgstr ""

#: src/project/contributing/language-design.md:3
msgid ""
"In a way PRQL is just a transpiler to SQL. This can cause its language "
"design to gravitate toward thinking about PRQL features in terms of how they "
"translate to SQL."
msgstr ""

#: src/project/contributing/language-design.md:11
msgid "This is flawed because:"
msgstr ""

#: src/project/contributing/language-design.md:13
msgid "it does not model interactions between features well,"
msgstr ""

#: src/project/contributing/language-design.md:14
msgid ""
"SQL behavior can sometimes be misleading (the order of a subquery will not "
"persist in the parent query) or even differs between dialects (set "
"operations)."
msgstr ""

#: src/project/contributing/language-design.md:18
msgid ""
"Instead, we should think of PRQL features in terms of how they affect PRQL "
"expressions, which in most cases means how they affect relations."
msgstr ""

#: src/project/contributing/language-design.md:34
msgid ""
"Thinking about SQL comes in only at the last step when relation (or rather "
"relational expression) is translated to an SQL expression."
msgstr ""

#: src/project/integrations/index.md:1
msgid "Integrations"
msgstr ""

#: src/project/integrations/index.md:3
msgid "PRQL is building integrations with lots of external tools, including:"
msgstr ""

#: src/project/integrations/index.md:5
msgid "[`prqlc` CLI](./prqlc-cli.md) - Rust compiler for the command line"
msgstr ""

#: src/project/integrations/index.md:6
msgid "[ClickHouse](./clickhouse.md)"
msgstr ""

#: src/project/integrations/index.md:7
msgid "[Jupyter](./jupyter.md)"
msgstr ""

#: src/project/integrations/index.md:8
msgid "[DuckDB](./duckdb.md)"
msgstr ""

#: src/project/integrations/index.md:9
msgid "[qStudio](./qstudio.md)"
msgstr ""

#: src/project/integrations/index.md:10
msgid "[Prefect](./prefect.md)"
msgstr ""

#: src/project/integrations/index.md:11
msgid "[VS Code](./vscode.md)"
msgstr ""

#: src/project/integrations/index.md:12
msgid "[Rill](./rill.md)"
msgstr ""

#: src/project/integrations/index.md:13
msgid "[PostgreSQL](./postgresql.md)"
msgstr ""

#: src/project/integrations/index.md:14
msgid "[Databend](./databend.md)"
msgstr ""

#: src/project/integrations/index.md:15
msgid "[Syntax highlighting](./syntax-highlighting.md) for many popular tools."
msgstr ""

#: src/project/integrations/clickhouse.md:1
msgid "ClickHouse"
msgstr ""

#: src/project/integrations/clickhouse.md:3
msgid ""
"PRQL works natively in ClickHouse. Check out the [ClickHouse docs](https://"
"clickhouse.com/docs/en/guides/developer/alternative-query-languages) for "
"more details."
msgstr ""

#: src/project/integrations/databend.md:1
msgid "Databend"
msgstr ""

#: src/project/integrations/databend.md:3
msgid ""
"Databend natively supports PRQL. For more details see the [databend docs]"
"(https://www.databend.com/blog/2024-04-03-databend-integrates-prql/)."
msgstr ""

#: src/project/integrations/duckdb.md:1
msgid "DuckDB"
msgstr ""

#: src/project/integrations/duckdb.md:3
msgid ""
"There's an experimental [DuckDB](https://duckdb.org/) extension from "
"**[@ywelsch](https://github.com/ywelsch)** at [ywelsch/duckdb-prql](https://"
"github.com/ywelsch/duckdb-prql)."
msgstr ""

#: src/project/integrations/duckdb.md:7
msgid "Check out the Readme for more details."
msgstr ""

#: src/project/integrations/jupyter.md:1
msgid "Jupyter"
msgstr ""

#: src/project/integrations/jupyter.md:3
msgid ""
"[pyprql](https://pypi.org/project/pyprql/) contains `pyprql.magic`, a thin "
"wrapper of [`JupySQL`](https://pypi.org/project/jupysql/)'s SQL IPython "
"magics. This allows us to run PRQL interactively on Jupyter/IPython."
msgstr ""

#: src/project/integrations/jupyter.md:7
msgid "Check out <https://pyprql.readthedocs.io/> for more context."
msgstr ""

#: src/project/integrations/jupyter.md:17
msgid ""
"When installing pyprql, the [duckdb-engine](https://pypi.org/project/duckdb-"
"engine/) package is also installed with it, so we can start using PRQL "
"immediately to query CSV and Parquet files."
msgstr ""

#: src/project/integrations/jupyter.md:22
msgid ""
"For example, running [the example from the JupySQL documentation](https://"
"jupysql.ploomber.io/en/latest/quick-start.html) on IPython:"
msgstr ""

#: src/project/integrations/postgresql.md:1
msgid "PostgreSQL"
msgstr ""

#: src/project/integrations/postgresql.md:3
msgid ""
"PL/PRQL is a PostgreSQL extension that lets you write functions with PRQL."
msgstr ""

#: src/project/integrations/postgresql.md:5
msgid ""
"PL/PRQL functions serve as intermediaries, compiling the user's PRQL code "
"into SQL statements that PostgreSQL executes. The extension is based on the "
"[pgrx](https://github.com/pgcentralfoundation/pgrx) framework for developing "
"PostgreSQL extensions in Rust. This framework manages the interaction with "
"PostgreSQL's internal APIs, type conversions, and other function hooks "
"necessary to integrate PRQL with PostgreSQL."
msgstr ""

#: src/project/integrations/postgresql.md:12
msgid "Examples"
msgstr ""

#: src/project/integrations/postgresql.md:14
msgid "PL/PRQL functions are defined using the `plprql` language specifier:"
msgstr ""

#: src/project/integrations/postgresql.md:33
msgid "---------+----------\n"
msgstr ""

#: src/project/integrations/postgresql.md:40
msgid ""
"You can also run PRQL code directly with the `prql` function which is useful "
"for custom SQL in ORMs:"
msgstr ""

#: src/project/integrations/postgresql.md:44
#: src/project/integrations/postgresql.md:55
msgid "'from matches | filter player == ''Player1'''"
msgstr ""

#: src/project/integrations/postgresql.md:48
msgid "----+----------+-------+---------+-------+--------\n"
msgstr ""

#: src/project/integrations/postgresql.md:53
msgid ""
"-- Same as above without the need for the static types, but returns cursor\n"
msgstr ""

#: src/project/integrations/postgresql.md:55
msgid "'player1_cursor'"
msgstr ""

#: src/project/integrations/postgresql.md:59
msgid "Getting Started"
msgstr ""

#: src/project/integrations/postgresql.md:61
msgid ""
"For installation instructions and more information on the extension, see the "
"[PL/PRQL repository](https://github.com/kaspermarstal/plprql)."
msgstr ""

#: src/project/integrations/prefect.md:1
msgid "Prefect"
msgstr ""

#: src/project/integrations/prefect.md:3
msgid ""
"Because [Prefect](https://www.prefect.io/) is in native Python, it's "
"extremely easy to integrate with PRQL."
msgstr ""

#: src/project/integrations/prefect.md:6
msgid "With a Postgres Task, replace:"
msgstr ""

#: src/project/integrations/prefect.md:12
msgid "...with..."
msgstr ""

#: src/project/integrations/prefect.md:18
msgid ""
"We're big fans of Prefect, and if there is anything that would make the "
"integration easier, please open an issue."
msgstr ""

#: src/project/integrations/prqlc-cli.md:1
msgid "PRQL compiler"
msgstr ""

#: src/project/integrations/prqlc-cli.md:3
msgid ""
"`prqlc` is the reference implementation of a compiler from PRQL to SQL, "
"written in Rust. It also serves as the CLI."
msgstr ""

#: src/project/integrations/prqlc-cli.md:6
msgid ""
"For more on PRQL, check out the [PRQL website](https://prql-lang.org) or the "
"[PRQL repo](https://github.com/PRQL/prql)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:9
msgid "CLI"
msgstr ""

#: src/project/integrations/prqlc-cli.md:11
msgid ""
"`prqlc` serves as a CLI for the PRQL compiler. It is a single, dependency-"
"free binary that compiles PRQL into SQL."
msgstr ""

#: src/project/integrations/prqlc-cli.md:16
msgid "`prqlc compile`"
msgstr ""

#: src/project/integrations/prqlc-cli.md:18
msgid ""
"This command works as a filter that compiles a PRQL string into an SQL "
"string."
msgstr ""

#: src/project/integrations/prqlc-cli.md:21
msgid "'from employees | filter has_dog | select salary'"
msgstr ""

#: src/project/integrations/prqlc-cli.md:31
msgid ""
"A PRQL query can be executed with CLI tools compatible with SQL, such as "
"[DuckDB CLI](https://duckdb.org/docs/api/cli.html)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:36
msgid "'from `albums.csv` | take 3'"
msgstr ""

#: src/project/integrations/prqlc-cli.md:47
msgid ""
"Executing this command without any argument will start interactive mode, "
"allowing a PRQL query to be written interactively. In this mode, after "
"writing PRQL and press `Ctrl-d` (Linux, macOS) or `Ctrl-z` (Windows) to "
"display the compiled SQL."
msgstr ""

#: src/project/integrations/prqlc-cli.md:56
msgid ""
"Just like when using it as a filter, SQL string output can be passed to the "
"DuckDB CLI and similar tools."
msgstr ""

#: src/project/integrations/prqlc-cli.md:77
msgid ""
"[![Packaging status](https://repology.org/badge/vertical-allrepos/prqlc.svg)]"
"(https://repology.org/project/prqlc/versions)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:79
msgid "via Homebrew (macOS, Linux)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:85
msgid "via winget (Windows)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:91
msgid "From GitHub release page"
msgstr ""

#: src/project/integrations/prqlc-cli.md:93
msgid ""
"Precompiled binaries are available for Linux, macOS, and Windows on the "
"[PRQL release page](https://github.com/PRQL/prql/releases)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:96
msgid "From source"
msgstr ""

#: src/project/integrations/prqlc-cli.md:99
msgid "# From crates.io\n"
msgstr ""

#: src/project/integrations/prqlc-cli.md:104
msgid "# From a local PRQL repository\n"
msgstr ""

#: src/project/integrations/prqlc-cli.md:108
msgid "Shell completions"
msgstr ""

#: src/project/integrations/prqlc-cli.md:110
msgid ""
"The `prqlc shell-completion` command prints a shell completion script for "
"supported shells, and saving the printed scripts to files makes for shells "
"to load completions for each session."
msgstr ""

#: src/project/integrations/prqlc-cli.md:114
msgid "Bash"
msgstr ""

#: src/project/integrations/prqlc-cli.md:116
msgid "For Linux:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:122
msgid "For macOS:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:128
msgid "fish"
msgstr ""

#: src/project/integrations/prqlc-cli.md:134
msgid "PowerShell"
msgstr ""

#: src/project/integrations/prqlc-cli.md:142
msgid "zsh"
msgstr ""

#: src/project/integrations/prqlc-cli.md:145
msgid "\"${fpath[1]}/_prqlc\""
msgstr ""

#: src/project/integrations/prqlc-cli.md:148
msgid "Ensure that the following lines are present in `~/.zshrc`:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:155
msgid "Helpers"
msgstr ""

#: src/project/integrations/prqlc-cli.md:157
msgid ""
"Cheat sheets for `prqlc` are available on various websites and with various "
"tools."
msgstr ""

#: src/project/integrations/prqlc-cli.md:160
msgid ""
"[`tldr`](https://tldr.sh/) ([on the web](https://tldr.inbrowser.app/pages/"
"common/prqlc))"
msgstr ""

#: src/project/integrations/prqlc-cli.md:162
msgid "[`eg`](https://github.com/srsudar/eg)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:166
msgid "Library"
msgstr ""

#: src/project/integrations/prqlc-cli.md:168
msgid ""
"For more usage examples and the library documentation, check out the "
"[`prqlc` documentation](https://docs.rs/prqlc/)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:171
msgid "Library installation"
msgstr ""

#: src/project/integrations/prqlc-cli.md:179
msgid "Compile a PRQL string to a SQLite dialect string:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:182
msgid "// In a file src/main.rs\n"
msgstr ""

#: src/project/integrations/prqlc-cli.md:186
msgid "\"from employees | select {name, age}\""
msgstr ""

#: src/project/integrations/prqlc-cli.md:195
msgid "\"SELECT name, age FROM employees\""
msgstr ""

#: src/project/integrations/qstudio.md:1
msgid "qStudio IDE"
msgstr ""

#: src/project/integrations/qstudio.md:3
msgid ""
"qStudio is a SQL GUI that lets you browse tables, run SQL scripts, and chart "
"and export the results. qStudio runs on Windows, macOS and Linux, and works "
"with every popular database including mysql, postgresql, mssql, kdb...."
msgstr ""

#: src/project/integrations/qstudio.md:7
msgid ""
"```admonish note\n"
"qStudio relies on the PRQL compiler. You must ensure that `prqlc` is in your "
"path. See the [installation instructions](https://prql-lang.org/book/project/"
"integrations/prqlc-cli.html#installation) in the PRQL reference guide for "
"details.\n"
"```"
msgstr ""

#: src/project/integrations/qstudio.md:11
msgid ""
"qStudio then calls `prqlc` (the compiler) to generate SQL code from PRQL "
"queries (.prql files). For more details, check out the [qStudio site]"
"(https://www.timestored.com/qstudio/prql-ide)."
msgstr ""

#: src/project/integrations/rill.md:1
msgid "Rill"
msgstr ""

#: src/project/integrations/rill.md:3
msgid ""
"PRQL has had some work to integrate with Rill. See the [Rill issues](https://"
"github.com/PRQL/prql/issues?q=is%3Aissue+rill) for more details."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:1
msgid "Grammars / syntax highlighting"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:3
msgid ""
"PRQL contains multiple grammar definitions to enable tools to highlight PRQL "
"code. These are all intended to provide as good an experience as the grammar "
"supports. Please raise any shortcomings in a GitHub issue."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:7
msgid ""
"The definitions are somewhat scattered around the codebase; this page serves "
"as an index."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:10
msgid ""
"[Ace](https://ace.c9.io/) — supported. The grammar is upstream "
"([prql_highlight_rules.js](https://github.com/ajaxorg/ace/blob/master/src/"
"mode/prql_highlight_rules.js)). See the [demo](https://prql-lang.org/demos/"
"ace-demo)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:14
msgid ""
"[chroma](https://github.com/alecthomas/chroma) — Go library used by the "
"static website generator Hugo. The grammar is upstream ([prql.xml](https://"
"github.com/alecthomas/chroma/blob/master/lexers/embedded/prql.xml)). See the "
"[demo](https://swapoff.org/chroma/playground/)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:19
msgid ""
"[Lezer](https://lezer.codemirror.net/) — used by CodeMirror editors. The "
"PRQL file is at [`grammars/prql-lezer/README.md`](https://github.com/PRQL/"
"prql/tree/main/grammars/prql-lezer/README.md)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:23
msgid "[Handlebars](https://handlebarsjs.com/) — currently duplicated:"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:25
msgid ""
"The book: [`book/highlight-prql.js`](https://github.com/PRQL/prql/blob/main/"
"web/book/highlight-prql.js)"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:27
msgid ""
"The website (outside of the book & playground): [`website/themes/prql-theme/"
"static/plugins/highlight/prql.js`](https://github.com/PRQL/prql/blob/main/"
"web/book/highlight-prql.js)"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:30
msgid ""
"Sublime Text — in the [`sublime-prql`](https://github.com/PRQL/sublime-"
"prql/) repository."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:33
msgid ""
"TextMate — used by the VS Code extension; in the `prql-vscode` repo in "
"[`prql-vscode/syntaxes/prql.tmLanguage.json`](https://github.com/PRQL/prql-"
"vscode/blob/main/syntaxes/prql.tmLanguage.json)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:36
msgid ""
"[Monarch](https://microsoft.github.io/monaco-editor/monarch.html) — used by "
"the Monaco editor, which we use for the Playground. The grammar is at "
"[`playground/src/workbench/prql-syntax.js`](https://github.com/PRQL/prql/"
"blob/main/web/playground/src/workbench/prql-syntax.js)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:40
msgid ""
"[Pygments](https://pygments.org/) — Python library used by Wikipedia, "
"Bitbucket, Sphinx and [more](https://pygments.org/faq/#who-uses-pygments). "
"The grammar is upstream ([prql.py](https://github.com/pygments/pygments/blob/"
"master/pygments/lexers/prql.py)). See the [demo](https://pygments.org/demo/)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:46
msgid ""
"[Tree-Sitter](https://tree-sitter.github.io/tree-sitter) — used by the "
"neovim and helix. The grammar can be found at [https://github.com/PRQL/tree-"
"sitter-prql](https://github.com/PRQL/tree-sitter-prql)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:52
msgid ""
"Since the [Elm](https://elm-lang.org/) language coincidentally provides "
"syntax highlighting suitable for PRQL, it may look better to mark PRQL code "
"as Elm when the above definition files are not available."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:56
msgid ""
"For example, the following Markdown code block will be nicely highlighted on "
"GitHub, Pandoc, and other Markdown renderers:"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:66
msgid ""
"We hope that in the future these renderers will recognize PRQL code blocks "
"and have syntax highlighting applied, and we are tracking these with several "
"issues."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:69
msgid "GitHub (Linguist): <https://github.com/PRQL/prql/issues/1636>"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:70
msgid "Pandoc (Kate): <https://github.com/PRQL/prql/issues/2213>"
msgstr ""

#: src/project/integrations/vscode.md:1
msgid "Visual Studio Code extension"
msgstr ""

#: src/project/integrations/vscode.md:3
msgid ""
"PRQL has a Visual Studio Code extension that compiles a PRQL query in a VS "
"Code editor and displays the resulting SQL code in a second pane on the "
"side. This is very handy for editing, saving, and reusing PRQL queries in VS "
"Code."
msgstr ""

#: src/project/integrations/vscode.md:7
msgid ""
"To install the VS Code extension, open VS Code and type <kbd>Ctrl</kbd>\\-"
"<kbd>Shift</kbd>\\-<kbd>P</kbd> (<kbd>Cmd</kbd>\\-<kbd>Shift</kbd>\\-<kbd>P</"
"kbd> on a Mac) and type `PRQL`. Install the extension as usual."
msgstr ""

#: src/project/integrations/vscode.md:12
msgid ""
"[Repo for the PRQL VS Code extension](https://github.com/PRQL/prql-vscode)"
msgstr ""

#: src/project/integrations/vscode.md:14
msgid ""
"[Extension on VS Marketplace](https://marketplace.visualstudio.com/items?"
"itemName=PRQL-lang.prql-vscode)"
msgstr ""

#: src/project/target.md:1
msgid "Target & Version"
msgstr ""

#: src/project/target.md:3
msgid "Target dialect"
msgstr ""

#: src/project/target.md:5
msgid ""
"PRQL allows specifying a target dialect at the top of the query, which "
"allows PRQL to compile to a database-specific SQL flavor."
msgstr ""

#: src/project/target.md:26
msgid "Dialects"
msgstr ""

#: src/project/target.md:30
msgid ""
"Supported dialects support all PRQL language features where possible, are "
"tested on every commit, and we'll endeavor to fix bugs."
msgstr ""

#: src/project/target.md:33
msgid "`sql.clickhouse`"
msgstr ""

#: src/project/target.md:34
msgid "`sql.duckdb`"
msgstr ""

#: src/project/target.md:35
msgid "`sql.generic` <sup><a name=\"to-footnote-1\">[1](#footnote-1)</a></sup>"
msgstr ""

#: src/project/target.md:37
msgid "`sql.glaredb`"
msgstr ""

#: src/project/target.md:38
msgid "`sql.mysql`"
msgstr ""

#: src/project/target.md:39
msgid "`sql.postgres`"
msgstr ""

#: src/project/target.md:40
msgid "`sql.sqlite`"
msgstr ""

#: src/project/target.md:44
msgid ""
"Unsupported dialects have implementations in the compiler, but are tested "
"minimally or not at all, and may have gaps for some features."
msgstr ""

#: src/project/target.md:47
msgid ""
"We're open to contributions to improve our coverage of these, and to adding "
"additional dialects."
msgstr ""

#: src/project/target.md:50
msgid "`sql.mssql`"
msgstr ""

#: src/project/target.md:51
msgid "`sql.ansi`"
msgstr ""

#: src/project/target.md:52
msgid "`sql.bigquery`"
msgstr ""

#: src/project/target.md:53
msgid "`sql.snowflake`"
msgstr ""

#: src/project/target.md:55
msgid "Priority of targets"
msgstr ""

#: src/project/target.md:57
msgid ""
"The compile target of a query is defined in the query's header or as an "
"argument to the compiler. option. The argument to the compiler takes "
"precedence."
msgstr ""

#: src/project/target.md:60
msgid ""
"For example, the following shell example specifies `sql.generic` in the "
"query and `sql.duckdb` in the `--target` option of the `prqlc compile` "
"command. In this case, `sql.duckdb` takes precedence and the SQL output is "
"based on the DuckDB dialect."
msgstr ""

#: src/project/target.md:66 src/project/target.md:74
msgid ""
"'prql target:sql.generic\n"
"      from foo'"
msgstr ""

#: src/project/target.md:70
msgid ""
"To use the target described in the query, a special target `sql.any` can be "
"specified in the compiler option."
msgstr ""

#: src/project/target.md:78
msgid "Version"
msgstr ""

#: src/project/target.md:80
msgid ""
"PRQL allows specifying a version of the language in the PRQL header, like:"
msgstr ""

#: src/project/target.md:82
msgid ""
"```prql\n"
"prql version:\"0.12.2\"\n"
"\n"
"from employees\n"
"```"
msgstr ""

#: src/project/target.md:88
msgid "This has two roles, one of which is implemented:"
msgstr ""

#: src/project/target.md:90
msgid ""
"The compiler will raise an error if the compiler is older than the query "
"version. This prevents confusing errors when queries use newer features of "
"the language but the compiler hasn't yet been upgraded."
msgstr ""

#: src/project/target.md:93
msgid ""
"The compiler will compile for the major version of the query. This allows "
"the language to evolve without breaking existing queries, or forcing "
"multiple installations of the compiler. This isn't yet implemented, but is a "
"gating feature for PRQL 1.0."
msgstr ""

#: src/project/target.md:98
msgid ""
"The version of the compiler currently in use can be called using the special "
"function `std.prql.version` in PRQL."
msgstr ""

#: src/project/target.md:112
msgid ""
"<a name=\"footnote-1\">[1](#to-footnote-1)</a>: while there's no \"generic\" "
"DB to test `sql.generic` against, we still count it as supported."
msgstr ""

#: src/reference/declarations/functions.md:1
msgid "Functions"
msgstr ""

#: src/reference/declarations/functions.md:7
msgid "Functions have two types of parameters:"
msgstr ""

#: src/reference/declarations/functions.md:9
msgid "Positional parameters, which require an argument."
msgstr ""

#: src/reference/declarations/functions.md:10
msgid ""
"Named parameters, which optionally take an argument, otherwise using their "
"default value."
msgstr ""

#: src/reference/declarations/functions.md:13
msgid ""
"So this function is named `fahrenheit_to_celsius` and has one parameter "
"`temp`:"
msgstr ""

#: src/reference/declarations/functions.md:22
msgid ""
"This function is named `interp`, and has two positional parameters named "
"`high` and `x`, and one named parameter named `low` which takes a default "
"argument of `0`. It calculates the proportion of the distance that `x` is "
"between `low` and `high`."
msgstr ""

#: src/reference/declarations/functions.md:37
msgid "Other examples"
msgstr ""

#: src/reference/declarations/functions.md:39
msgid ""
"```prql\n"
"let is_adult = col -> col >= 18\n"
"let writes_code = col -> (col | in [\"PRQL\", \"Rust\"])\n"
"let square = col -> (col | math.pow 2)\n"
"let starts_with_a = col -> (col | text.lower | text.starts_with(\"a\"))\n"
"\n"
"from employees\n"
"select {\n"
"    first_name,\n"
"    last_name,\n"
"    hobby,\n"
"    adult = is_adult age,\n"
"    age_squared = square age,\n"
"}\n"
"filter ((starts_with_a last_name) && (writes_code hobby))\n"
"```"
msgstr ""

#: src/reference/declarations/functions.md:56
msgid "Piping values into functions"
msgstr ""

#: src/reference/declarations/functions.md:58
msgid ""
"Consistent with the principles of PRQL, it's possible to pipe values into "
"functions, which makes composing many functions more readable. When piping a "
"value into a function, the value is passed as an argument to the final "
"positional parameter of the function. Here's the same result as the examples "
"above with an alternative construction:"
msgstr ""

#: src/reference/declarations/functions.md:74
msgid "and"
msgstr ""

#: src/reference/declarations/functions.md:83
msgid "We can combine a chain of functions, which makes logic more readable:"
msgstr ""

#: src/reference/declarations/functions.md:93
msgid "Late binding"
msgstr ""

#: src/reference/declarations/functions.md:95
msgid ""
"Functions can bind to any variable that is in scope when the function is "
"executed. For example, here `cost_total` refers to the column that's "
"introduced in the `from`."
msgstr ""

#: src/reference/declarations/variables.md:1
msgid "Variables — `let` & `into`"
msgstr ""

#: src/reference/declarations/variables.md:3
msgid ""
"Variables assign a name — say `x` — to an expression, like in most "
"programming languages. The name can then be used in any expression, acting "
"as a substitute for the expression `x`."
msgstr ""

#: src/reference/declarations/variables.md:7
msgid "Syntactically, variables can take 3 forms."
msgstr ""

#: src/reference/declarations/variables.md:9
msgid "`let` declares the name before the expression."
msgstr ""

#: src/reference/declarations/variables.md:15
msgid ""
"`into` declares the name after the expression. This form is useful for quick "
"pipeline splitting and conforms with the \"flow from top to bottom\" rule of "
"pipelines."
msgstr ""

#: src/reference/declarations/variables.md:24
msgid "The final expression of a pipeline defaults to taking the name `main`."
msgstr ""

#: src/reference/declarations/variables.md:30
msgid "... is equivalent to:"
msgstr ""

#: src/reference/declarations/variables.md:36
msgid ""
"When compiling to SQL, relational variables are compiled to Common Table "
"Expressions (or sub-queries in some cases)."
msgstr ""

#: src/reference/declarations/variables.md:58
msgid ""
"Variables can be assigned an s-string containing the whole SQL query [s-"
"string](../syntax/s-strings.md), enabling us to use features which PRQL "
"doesn't yet support."
msgstr ""

#: src/reference/declarations/variables.md:62
msgid ""
"```prql\n"
"let grouping = s\"\"\"\n"
"  SELECT SUM(a)\n"
"  FROM tbl\n"
"  GROUP BY\n"
"    GROUPING SETS\n"
"    ((b, c, d), (d), (b, d))\n"
"\"\"\"\n"
"\n"
"from grouping\n"
"```"
msgstr ""

#: src/reference/data/index.md:1
msgid "Importing data"
msgstr ""

#: src/reference/data/relation-literals.md:1
msgid "How do I: create ad-hoc relations?"
msgstr ""

#: src/reference/data/relation-literals.md:3
msgid ""
"It's often useful to make a small inline relation, for example when "
"exploring how a database will evaluate an expression, or for a small lookup "
"table. This can be quite verbose in SQL."
msgstr ""

#: src/reference/data/relation-literals.md:7
msgid ""
"PRQL offers two approaches — array literals, and a `from_text` transform."
msgstr ""

#: src/reference/data/relation-literals.md:9
msgid "Array literals"
msgstr ""

#: src/reference/data/relation-literals.md:11
msgid ""
"Because relations (aka a table) in PRQL are just arrays of tuples, they can "
"be expressed with array and tuple syntax:"
msgstr ""

#: src/reference/data/relation-literals.md:23
msgid ""
"```prql\n"
"let my_artists = [\n"
"  {artist=\"Miles Davis\"},\n"
"  {artist=\"Marvin Gaye\"},\n"
"  {artist=\"James Brown\"},\n"
"]\n"
"\n"
"from artists\n"
"join my_artists (==artist)\n"
"join albums (==artist_id)\n"
"select {artists.artist_id, albums.title}\n"
"```"
msgstr ""

#: src/reference/data/relation-literals.md:36
msgid "`from_text`"
msgstr ""

#: src/reference/data/relation-literals.md:38
msgid ""
"`from_text` takes a string in a common format, and converts it to table. It "
"accepts a few formats:"
msgstr ""

#: src/reference/data/relation-literals.md:41
msgid "`format:csv` parses CSV (default),"
msgstr ""

#: src/reference/data/relation-literals.md:43
msgid "`format:json` parses either:"
msgstr ""

#: src/reference/data/relation-literals.md:45
msgid "an array of objects each of which represents a row, or"
msgstr ""

#: src/reference/data/relation-literals.md:47
msgid ""
"an object with fields `columns` & `data`, where `columns` take an array of "
"column names and `data` takes an array of arrays."
msgstr ""

#: src/reference/data/relation-literals.md:50
msgid ""
"```prql\n"
"from_text \"\"\"\n"
"a,b,c\n"
"1,2,3\n"
"4,5,6\n"
"\"\"\"\n"
"derive {\n"
"    d = b + c,\n"
"    answer = 20 * 2 + 2,\n"
"}\n"
"```"
msgstr ""

#: src/reference/data/relation-literals.md:62
msgid ""
"```prql\n"
"from_text format:json \"\"\"\n"
"[\n"
"    {\"a\": 1, \"m\": \"5\"},\n"
"    {\"a\": 4, \"n\": \"6\"}\n"
"]\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/reference/data/relation-literals.md:71
msgid ""
"```prql\n"
"from_text format:json \"\"\"\n"
"{\n"
"    \"columns\": [\"a\", \"b\", \"c\"],\n"
"    \"data\": [\n"
"        [1, \"x\", false],\n"
"        [4, \"y\", null]\n"
"    ]\n"
"}\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/reference/data/relation-literals.md:83
msgid "See also"
msgstr ""

#: src/reference/data/relation-literals.md:85
msgid "[How do I: read files?](./read-files.md)"
msgstr ""

#: src/reference/data/from.md:1
msgid "From"
msgstr ""

#: src/reference/data/from.md:3
msgid "Specifies a data source."
msgstr ""

#: src/reference/data/from.md:9
msgid "To introduce an alias, use an assign expression:"
msgstr ""

#: src/reference/data/from.md:16
msgid ""
"Table names containing spaces or special characters [need to be contained "
"within backticks](../syntax/keywords.md#quoting):"
msgstr ""

#: src/reference/data/from.md:23
msgid ""
"`default_db.tablename` can be used if the table name matches a function from "
"the standard library."
msgstr ""

#: src/reference/data/from.md:26
msgid ""
"```admonish note\n"
"We realize this is an awkward workaround. Track & 👍 [#3271](https://github."
"com/PRQL/prql/issues/3271) for resolving this.\n"
"```"
msgstr ""

#: src/reference/data/read-files.md:1
msgid "Reading files"
msgstr ""

#: src/reference/data/read-files.md:3
msgid ""
"There are a couple of functions mainly designed for DuckDB to read from "
"files:"
msgstr ""

#: src/reference/data/read-files.md:5
msgid ""
"```prql\n"
"prql target:sql.duckdb\n"
"\n"
"from (read_parquet \"artists.parquet\")\n"
"join (read_csv \"albums.csv\") (==track_id)\n"
"```"
msgstr ""

#: src/reference/data/read-files.md:21
msgid ""
"When specifying file names directly in the `FROM` clause without using "
"functions, which is allowed in DuckDB, enclose the file names in backticks "
"``` `` ``` as follows:"
msgstr ""

#: src/reference/data/read-files.md:31
msgid "[Target and Version](../../project/target.md)"
msgstr ""

#: src/reference/data/read-files.md:32
msgid "[Ad-hoc data](./relation-literals.md)"
msgstr ""

#: src/reference/spec/index.md:1
msgid "Specification"
msgstr ""

#: src/reference/spec/index.md:3
msgid ""
"This chapter explains PRQL's semantics: how expressions are interpreted and "
"their meaning. It's intended for advanced users and compiler contributors."
msgstr ""

#: src/reference/spec/modules.md:1
msgid "Modules"
msgstr ""

#: src/reference/spec/modules.md:16
msgid "Design goals for **modules**:"
msgstr ""

#: src/reference/spec/modules.md:18
msgid "Allow importing declarations from other files."
msgstr ""

#: src/reference/spec/modules.md:20
msgid "Have namespaces for things like `std`."
msgstr ""

#: src/reference/spec/modules.md:22
msgid "Have a hierarchical structure so we can represent files in directories."
msgstr ""

#: src/reference/spec/modules.md:24
msgid "Have an unambiguous module structure within a project."
msgstr ""

#: src/reference/spec/modules.md:26
msgid "Definition"
msgstr ""

#: src/reference/spec/modules.md:28
msgid ""
"A module is a namespace that contains declarations. A module is itself a "
"declaration, which means that it can contain nested child modules."
msgstr ""

#: src/reference/spec/modules.md:31
msgid ""
"This means that modules form a [tree graph](https://en.wikipedia.org/wiki/"
"Tree_(graph_theory)), which we call \"the module structure\"."
msgstr ""

#: src/reference/spec/modules.md:35
msgid ""
"For the sake of this document, we will express the module structure with "
"`module` keyword and a code block encased in curly braces:"
msgstr ""

#: src/reference/spec/modules.md:48
msgid ""
"The syntax `module name { ...decls... }` is not part of PRQL language, with "
"the objection that it is unnecessary as it only adds more ways of defining "
"modules. If a significant upside of this syntax is found, it may be added in "
"the future."
msgstr ""

#: src/reference/spec/modules.md:53
msgid "Name resolution"
msgstr ""

#: src/reference/spec/modules.md:55
msgid ""
"Any declarations within a module can be referenced from the outside of the "
"module:"
msgstr ""

#: src/reference/spec/modules.md:67
msgid "Identifiers are resolved relative to current module."
msgstr ""

#: src/reference/spec/modules.md:80
msgid ""
"If an identifier cannot be resolved relative to the current module, it tries "
"to resolve relative to the parent module. This is repeated, stepping up the "
"module hierarchy until a match is found or root of the module structure is "
"reached."
msgstr ""

#: src/reference/spec/modules.md:100
msgid "Main var declaration"
msgstr ""

#: src/reference/spec/modules.md:102
msgid ""
"The final variable declaration in a module can omit the leading `let main =` "
"and acquire an implicit name main."
msgstr ""

#: src/reference/spec/modules.md:115
msgid ""
"When a module is referenced as a value, the `main` variable is used instead. "
"This is especially useful when referring to a module which is to be compiled "
"to RQ (and later SQL)."
msgstr ""

#: src/reference/spec/modules.md:124
msgid "File importing"
msgstr ""

#: src/reference/spec/modules.md:134
msgid ""
"To include PRQL source code from other files, we can use the following "
"syntax:"
msgstr ""

#: src/reference/spec/modules.md:140
msgid ""
"This loads either `./my_playlists.prql` (a leaf module) or `./my_playlists/"
"_my_playlists.prql` (a directory module) and uses its contents as module "
"`my_playlists`. If none or both of the files are present, a compilation "
"error is raised."
msgstr ""

#: src/reference/spec/modules.md:145
msgid ""
"Only directory modules can contain module declarations. If a leaf module "
"contains a module declaration, a compilation error is raised, suggesting the "
"leaf module to be converted into a directory module. This is a step toward "
"any module structure having a single \"normalized\" representation in the "
"file system. Such normalization is desired because it restrains the possible "
"file system layouts to a comprehensible and predictable layout, while not "
"sacrificing any functionality."
msgstr ""

#: src/reference/spec/modules.md:153
msgid ""
"Described importing rules don't achieve this \"single normalized "
"representation\" in full, since any leaf modules could be replaced by a "
"directory module with zero submodules, without any semantic changes. "
"Restricting directory modules to have at least one sub-module would not "
"improve approachability enough to justify adding this restriction."
msgstr ""

#: src/reference/spec/modules.md:159
msgid ""
"For example, the following module structure is annotated with files names in "
"which the modules would reside:"
msgstr ""

#: src/reference/spec/modules.md:185
msgid ""
"If module `my_project.sales` wants to add a submodule `util`, it has to be "
"converted to a directory modules. This means that it has to be moved to "
"`sales/_sales.prql`. The new module would reside in `sales/util.prql`."
msgstr ""

#: src/reference/spec/modules.md:189
msgid ""
"The annotated layout is not the only possible layout for this module "
"structure, since any of the modules `sales`, `year_2023` or `year_2024` "
"could be converted into a directory module with zero sub-modules."
msgstr ""

#: src/reference/spec/modules.md:193
msgid ""
"Point 4 of design goals means that each declaration within a project has a "
"single fully-qualified name within this project. This is ensured by strict "
"rules regarding importing files and the fact that the module structure is a "
"tree."
msgstr ""

#: src/reference/spec/modules.md:197
msgid "Declaration order"
msgstr ""

#: src/reference/spec/modules.md:199
msgid ""
"The order of declarations in a module holds no semantic value, except the "
"\"last `main` variable\"."
msgstr ""

#: src/reference/spec/modules.md:202
msgid "References between modules can be cyclic."
msgstr ""

#: src/reference/spec/modules.md:214
msgid "References between variable declarations cannot be cyclic."
msgstr ""

#: src/reference/spec/modules.md:230
msgid "Compiler interface"
msgstr ""

#: src/reference/spec/modules.md:232
msgid "`prqlc` provides two interfaces for compiling files."
msgstr ""

#: src/reference/spec/modules.md:234
msgid "**Multi-file interface** requires three arguments:"
msgstr ""

#: src/reference/spec/modules.md:236
msgid ""
"path to the file containing the module which is the root of the module "
"structure,"
msgstr ""

#: src/reference/spec/modules.md:238
msgid ""
"identifier of the pipeline that should be compiled to RQ (this can also be "
"an identifier of a module that has a `main` pipeline) and,"
msgstr ""

#: src/reference/spec/modules.md:240
msgid "a \"file loader\", which can load files on-demand."
msgstr ""

#: src/reference/spec/modules.md:242
msgid ""
"The path to the root module can be automatically detected by searching for `."
"prql` files starting with `_` in the current working directory."
msgstr ""

#: src/reference/spec/modules.md:245
msgid "Example prqlc usage:"
msgstr ""

#: src/reference/spec/modules.md:252
msgid ""
"**Single-file interface** requires a single argument; the PRQL source. Any "
"attempts to load modules in this mode result in compilation errors. This "
"interface is needed, for example, when integrating the compiler with a "
"database connector (i.e. JDBC) where no other files can be loaded."
msgstr ""

#: src/reference/spec/modules.md:257
msgid "Built-in module structure"
msgstr ""

#: src/reference/spec/modules.md:259
msgid "As noted above, this facility is in discussion."
msgstr ""

#: src/reference/spec/modules.md:290
msgid ""
"This is an example project, where each of code block is a separate file."
msgstr ""

#: src/reference/spec/modules.md:345
msgid "Sources:"
msgstr ""

#: src/reference/spec/modules.md:347
msgid ""
"[Notes On Module System](https://matklad.github.io/2021/11/27/notes-on-"
"module-system.html), by @matklad."
msgstr ""

#: src/reference/spec/name-resolution.md:3
msgid ""
"Because PRQL primarily handles relational data, it has specialized scoping "
"rules for referencing columns."
msgstr ""

#: src/reference/spec/name-resolution.md:6
msgid "Scopes"
msgstr ""

#: src/reference/spec/name-resolution.md:8
msgid ""
"In PRQL's compiler, a scope is the collection of all names one can reference "
"from a specific point in the program."
msgstr ""

#: src/reference/spec/name-resolution.md:11
msgid ""
"In PRQL, names in the scope are composed from namespace and variable name "
"which are separated by a dot, similar to SQL. Namespaces can contain many "
"dots, but variable names cannot."
msgstr ""

#: src/reference/spec/name-resolution.md:21
msgid ""
"When processing a query, a scope is maintained and updated for each point in "
"the query."
msgstr ""

#: src/reference/spec/name-resolution.md:24
msgid ""
"It start with only namespace `std`, which is the standard library. It "
"contains common functions like `sum` or `count`, along with all transform "
"functions such as `derive` and `group`."
msgstr ""

#: src/reference/spec/name-resolution.md:28
msgid ""
"In pipelines (or rather in transform functions), scope is also injected with "
"namespaces of tables which may have been referenced with `from` or `join` "
"transforms. These namespaces contain simply all the columns of the table and "
"possibly a wildcard variable, which matches any variable (see the algorithm "
"below). Within transforms, there is also a special namespace that does not "
"have a name. It is called a _\"frame\"_ and it contains columns of the "
"current table the transform is operating on."
msgstr ""

#: src/reference/spec/name-resolution.md:36
msgid "Resolving"
msgstr ""

#: src/reference/spec/name-resolution.md:38
msgid ""
"For each ident we want to resolve, we search the scope's items in order. One "
"of three things can happen:"
msgstr ""

#: src/reference/spec/name-resolution.md:41
msgid ""
"Scope contains an exact match, e.g. a name that matches in namespace and the "
"variable name."
msgstr ""

#: src/reference/spec/name-resolution.md:44
msgid ""
"Scope does not contain an exact match, but the ident did not specify a "
"namespace, so we can match a namespace that contains a `*` wildcard. If "
"there's a single namespace, the matched namespace is also updated to contain "
"this new variable name."
msgstr ""

#: src/reference/spec/name-resolution.md:49
msgid "Otherwise, the nothing is matched and an error is raised."
msgstr ""

#: src/reference/spec/name-resolution.md:51
msgid "Translating to SQL"
msgstr ""

#: src/reference/spec/name-resolution.md:53
msgid ""
"When translating into an SQL statement which references only one table, "
"there is no need to reference column names with table prefix."
msgstr ""

#: src/reference/spec/name-resolution.md:61
msgid ""
"But when there are multiple tables and we don't have complete knowledge of "
"all table columns, a column without a prefix (i.e. `first_name`) may "
"actually reside in multiple tables. Because of this, we have to use table "
"prefixes for all column names."
msgstr ""

#: src/reference/spec/name-resolution.md:73
msgid ""
"As you can see, `employees.first_name` now needs table prefix, to prevent "
"conflicts with potential column with the same name in `departments` table. "
"Similarly, `d.title` needs the table prefix."
msgstr ""

#: src/reference/spec/null.md:1
msgid "Null handling"
msgstr ""

#: src/reference/spec/null.md:3
msgid ""
"SQL has an unconventional way of handling `NULL` values, since it treats "
"them as unknown values. As a result, in SQL:"
msgstr ""

#: src/reference/spec/null.md:6
msgid ""
"`NULL` is not a value indicating a missing entry, but a placeholder for "
"anything possible,"
msgstr ""

#: src/reference/spec/null.md:8
msgid ""
"`NULL = NULL` evaluates to `NULL`, since one cannot know if one unknown is "
"equal to another unknown,"
msgstr ""

#: src/reference/spec/null.md:10
msgid "`NULL <> NULL` evaluates to `NULL`, using same logic,"
msgstr ""

#: src/reference/spec/null.md:11
msgid ""
"to check if a value is `NULL`, SQL introduces `IS NULL` and `IS NOT NULL` "
"operators,"
msgstr ""

#: src/reference/spec/null.md:13
msgid "`DISTINCT column` may return multiple `NULL` values."
msgstr ""

#: src/reference/spec/null.md:15
msgid ""
"For more information, check out the [Postgres documentation](https://www."
"postgresql.org/docs/current/functions-comparison.html)."
msgstr ""

#: src/reference/spec/null.md:18
msgid "PRQL, on the other hand, treats `null` as a value, which means that:"
msgstr ""

#: src/reference/spec/null.md:20
msgid "`null == null` evaluates to `true`,"
msgstr ""

#: src/reference/spec/null.md:21
msgid "`null != null` evaluates to `false`,"
msgstr ""

#: src/reference/spec/null.md:22
msgid "distinct column cannot contain multiple `null` values."
msgstr ""

#: src/reference/spec/null.md:30
msgid ""
"Note that PRQL doesn't change how `NULL` is compared between columns, for "
"example in joins. (PRQL compiles to SQL and so can't change the behavior of "
"the database)."
msgstr ""

#: src/reference/spec/null.md:34
msgid ""
"For more context or to provide feedback check out the discussion on [issue "
"#99](https://github.com/PRQL/prql/issues/99)."
msgstr ""

#: src/reference/spec/type-system.md:1
msgid "Type system"
msgstr ""

#: src/reference/spec/type-system.md:3
msgid "Status: under development"
msgstr ""

#: src/reference/spec/type-system.md:5
msgid "The type system determines the allowed values of a term."
msgstr ""

#: src/reference/spec/type-system.md:7
msgid "Purpose"
msgstr ""

#: src/reference/spec/type-system.md:9
msgid ""
"Each of the SQL DBMSs has their own type system. Thanks to the SQL standard, "
"they are very similar, but have key differences regardless. For example, "
"SQLite does not have a type for date or time or timestamps, but it has "
"functions for handling date and time that take ISO 8601 strings or integers "
"that represent Unix timestamps. So it does support most of what is possible "
"to do with dates in other dialects, even though it stores data with a "
"different physical layout and uses different functions to achieve that."
msgstr ""

#: src/reference/spec/type-system.md:17
msgid ""
"PRQL's task is to define it's own description of _data formats_, just as how "
"it already defines common _data transformations_."
msgstr ""

#: src/reference/spec/type-system.md:20
msgid "This is done in two steps:"
msgstr ""

#: src/reference/spec/type-system.md:22
msgid ""
"Define PRQL's Type System (PTS), following principles we think a relational "
"language should have (and not fixate on what existing SQL DBMSs have)."
msgstr ""

#: src/reference/spec/type-system.md:25
msgid ""
"Define a mapping between SQL Type System (STS) and PTS, for each of the "
"DBMSs. Ideally we'd want that to be a bijection, so each type in PTS would "
"be represented by a single type in STS and vice-versa. Unfortunately this is "
"not entirely possible, as shown below."
msgstr ""

#: src/reference/spec/type-system.md:30
msgid "In practical terms, we want for a user to be able to:"
msgstr ""

#: src/reference/spec/type-system.md:32
msgid ""
"... express types of their database with PRQL (map their STS into PTS). In "
"some cases, we can allow to say \"your database is not representable with "
"PRQL, change it or use only a subset of it\". An example of what we don't "
"want to support are arrays with arbitrary indexes in Postgres (i.e. 2-based "
"index for arrays)."
msgstr ""

#: src/reference/spec/type-system.md:38
msgid ""
"This task of mapping to PTS could be automated by LSP server, by "
"introspecting user's SQL database and generating PRQL source."
msgstr ""

#: src/reference/spec/type-system.md:41
msgid ""
"... express their SQL queries in PRQL. Again, using mapping from STS to PTS, "
"one should be able to express any SQL operation in PRQL."
msgstr ""

#: src/reference/spec/type-system.md:44
msgid ""
"For example, translate MSSQL `DATEDIFF` to subtraction operator `-` in PRQL."
msgstr ""

#: src/reference/spec/type-system.md:46
msgid ""
"For now, this mapping is manual, but should be documented and may be "
"automated."
msgstr ""

#: src/reference/spec/type-system.md:49
msgid ""
"... use any PRQL feature in their database. Here we are mapping from PTS "
"into an arbitrary STS."
msgstr ""

#: src/reference/spec/type-system.md:52
msgid ""
"For example, translate PRQL's datetime operations to use TEXT in SQLite."
msgstr ""

#: src/reference/spec/type-system.md:54
msgid ""
"As of now, prqlc already does a good job of automatically doing this mapping."
msgstr ""

#: src/reference/spec/type-system.md:56
msgid "Example of the mapping between PTS and two STSs:"
msgstr ""

#: src/reference/spec/type-system.md:58
msgid "PTS"
msgstr ""

#: src/reference/spec/type-system.md:58
msgid "STS Postgres"
msgstr ""

#: src/reference/spec/type-system.md:58
msgid "STS SQLite"
msgstr ""

#: src/reference/spec/type-system.md:60
msgid "int32"
msgstr ""

#: src/reference/spec/type-system.md:60
msgid "integer"
msgstr ""

#: src/reference/spec/type-system.md:60 src/reference/spec/type-system.md:61
msgid "INTEGER"
msgstr ""

#: src/reference/spec/type-system.md:61
msgid "int64"
msgstr ""

#: src/reference/spec/type-system.md:61
msgid "bigint"
msgstr ""

#: src/reference/spec/type-system.md:62
msgid "timestamp"
msgstr ""

#: src/reference/spec/type-system.md:62
msgid "TEXT"
msgstr ""

#: src/reference/spec/type-system.md:64
msgid "Principles"
msgstr ""

#: src/reference/spec/type-system.md:66
msgid ""
"**Algebraic types** - have a way of expressing sum and product types. In "
"Rust, sum would be an enum and product would be tuple or a struct. In SQL, "
"product would be a row, since it can contain different types, all at once. "
"Sum would be harder to express, see (this post)\\[https://www.parsonsmatt."
"org/2019/03/19/sum_types_in_sql.html \\]."
msgstr ""

#: src/reference/spec/type-system.md:72
msgid ""
"The value proposition here is that algebraic types give a lot modeling "
"flexibility, all while being conceptually simple."
msgstr ""

#: src/reference/spec/type-system.md:75
msgid ""
"**Composable** - as with transformation, we'd want types to compose together."
msgstr ""

#: src/reference/spec/type-system.md:77
msgid ""
"Using Python, JavaScript, C++ or Rust, one could define many different data "
"structures that would correspond to our idea of \"relation\". Most of them "
"would be an object/struct that has column names and types and then a generic "
"array of arrays for rows."
msgstr ""

#: src/reference/spec/type-system.md:82
msgid ""
"PRQL's type system should also be able to express relations as composed from "
"primitive types, but have only one idiomatic way of doing so."
msgstr ""

#: src/reference/spec/type-system.md:85
msgid ""
"In practice, this means that builtin types include only primitives (int, "
"text, bool, float), tuple (for product), enum (for sum) and array (for "
"repeating). An SQL row translates to a tuple, and a relation translates to "
"an array of tuples."
msgstr ""

#: src/reference/spec/type-system.md:89
msgid ""
"Composability also leads to a minimal type system, which does not "
"differentiate between tuples, objects and structs. A single product type is "
"enough."
msgstr ""

#: src/reference/spec/type-system.md:92
msgid "**No subtyping** - avoid super types and inheritance."
msgstr ""

#: src/reference/spec/type-system.md:94
msgid ""
"Subtyping is a natural extension to a type system, where a type can be a "
"super type of some other type. This is base mechanism for Object Oriented "
"Programming, but is also present in most dynamically types languages. For "
"example, a type `number` might be super type of `int` and `float`."
msgstr ""

#: src/reference/spec/type-system.md:99
msgid ""
"PTS does not have subtyping, because it requires dynamic dispatch and "
"because it adds unnecessary complexity to generic type arguments."
msgstr ""

#: src/reference/spec/type-system.md:102
msgid ""
"Dynamic dispatch, is a mechanism that would be able, for example, to call "
"appropriate `to_string` function for each element of an array of `number`. "
"This array contains both elements of type `int` and type `float`, with "
"different `to_string` implementations."
msgstr ""

#: src/reference/spec/type-system.md:132
msgid ""
"For any undefined terms used in this section, refer to set theory and "
"mathematical definitions in general."
msgstr ""

#: src/reference/spec/type-system.md:135
msgid ""
"A \"type of a variable\" is a \"set of all possible values of that "
"variable\"."
msgstr ""

#: src/reference/spec/type-system.md:137
msgid "Primitives"
msgstr ""

#: src/reference/spec/type-system.md:139
msgid ""
"At the moment of writing, PRQL defines following primitive types: `int`, "
"`float`, `bool`, `text`, `date`, `time` and `timestamp`. New primitive types "
"will be added in the future and some of existing types might be split into "
"smaller subsets (see section \"Splitting primitives\")."
msgstr ""

#: src/reference/spec/type-system.md:144
msgid "Tuples"
msgstr ""

#: src/reference/spec/type-system.md:146
msgid "Tuple type is a product type."
msgstr ""

#: src/reference/spec/type-system.md:148
msgid ""
"It contains n ordered fields, where n is known at compile-time. Each field "
"has a type itself and an optional name. Fields are not necessarily of the "
"same type."
msgstr ""

#: src/reference/spec/type-system.md:151
msgid ""
"In other languages, similar constructs are named record, struct, tuple, "
"named tuple or (data)class."
msgstr ""

#: src/reference/spec/type-system.md:158
msgid "Arrays"
msgstr ""

#: src/reference/spec/type-system.md:160
msgid ""
"Array is a container type that contains n ordered fields, where n is not "
"known at compile-time. All fields are of the same type and cannot be named."
msgstr ""

#: src/reference/spec/type-system.md:173
msgid "Union"
msgstr ""

#: src/reference/spec/type-system.md:183
msgid "This is \"a sum type\"."
msgstr ""

#: src/reference/spec/type-system.md:185
msgid "Type annotations"
msgstr ""

#: src/reference/spec/type-system.md:187
msgid ""
"Variable annotations and function parameters may specify type annotations:"
msgstr ""

#: src/reference/spec/type-system.md:193
msgid "The value of `x` (and thus `a`) must be an element of `t`."
msgstr ""

#: src/reference/spec/type-system.md:199
msgid "The value of argument supplied to `x` must be an element of `t`."
msgstr ""

#: src/reference/spec/type-system.md:205
msgid "The value of function body `y` must be an element of `t`."
msgstr ""

#: src/reference/spec/type-system.md:207
msgid "Physical layout"
msgstr ""

#: src/reference/spec/type-system.md:209
msgid ""
"_Logical type_ is user-facing the notion of a type that is the building "
"block of the type system."
msgstr ""

#: src/reference/spec/type-system.md:212
msgid ""
"_Physical layout_ is the underlying memory layout of the data represented by "
"a variable."
msgstr ""

#: src/reference/spec/type-system.md:215
msgid ""
"In many programming languages, physical layout of a logical type is "
"dependent on the target platform. Similarly, physical layout of a PRQL "
"logical type is dependent on representation of that type in the target STS."
msgstr ""

#: src/reference/spec/type-system.md:223
msgid ""
"Note that not all STS types do not have a single physical layout. Postgres "
"has a logical (pseudo)type `anyelement`, which is a super type of any data "
"type. It can be used as a function parameter type, but does not have a "
"single physical layout so it cannot be used in a column declaration."
msgstr ""

#: src/reference/spec/type-system.md:228
msgid ""
"For now, PRQL does not define physical layouts of any type. It is not needed "
"since PRQL is not used for DDL (see section \"Splitting primitives\") or "
"does not support raw access to underlying memory."
msgstr ""

#: src/reference/spec/type-system.md:232
msgid ""
"As a consequence, results of a PRQL query cannot be robustly compared across "
"DBMSs, since the physical layout of the result will vary."
msgstr ""

#: src/reference/spec/type-system.md:235
msgid ""
"In the future, PRQL may define a common physical layout of types, probably "
"using Apache Arrow."
msgstr ""

#: src/reference/spec/type-system.md:261
msgid "Appendix"
msgstr ""

#: src/reference/spec/type-system.md:263
msgid "Splitting primitives"
msgstr ""

#: src/reference/spec/type-system.md:265
msgid ""
"This document mentions `int32` and `int64` as distinct types, but there is "
"no need for that in the initial implementation. The built-in `int` can "
"associate with all operations on integers and translate PRQL to valid SQL "
"regardless of the size of the integer. Later, `int` cam be replaced by "
"`int8`, `int16`, `int32`, `int64`."
msgstr ""

#: src/reference/spec/type-system.md:271
msgid ""
"The general rule for \"when to make a distinction between types\" would be "
"\"as soon as the types carry different information and we find an operation "
"that would be expressed differently\". In this example, that would require "
"some operation on `int32` to have different syntax than same operation over "
"`int64`."
msgstr ""

#: src/reference/spec/type-system.md:276
msgid ""
"We can have such relaxed rule because PRQL is not aiming to be a Data "
"Definition Language and does not have to bother with exact physical layout "
"of types."
msgstr ""

#: src/reference/spec/type-system.md:279
msgid "Type representations"
msgstr ""

#: src/reference/spec/type-system.md:281
msgid ""
"There are cases where a PTS type has multiple possible and valid "
"representations in some STSs."
msgstr ""

#: src/reference/spec/type-system.md:284
msgid ""
"For such cases, we'd want to support the use of alternative representations "
"for storing data, but also application of any function that is defined for "
"the original type."
msgstr ""

#: src/reference/spec/type-system.md:288
msgid ""
"Using SQLite as an example again, users may have some temporal data stored "
"as INTEGER unix timestamp and some as TEXT that contains ISO 8601 without "
"timezone. From the user's perspective, both of these types are `timestamp`s "
"and should be declared as such. But when compiling operations over these "
"types to SQL, the compiler should consider their different representations "
"in STS. For example a difference between two timestamps `timestamp - "
"timestamp` can be translated to a normal int subtraction for INTEGER repr, "
"but must apply SQLite's function `unixepoch` when dealing with TEXT repr."
msgstr ""

#: src/reference/spec/type-system.md:297
msgid ""
"Table declarations should therefore support annotations that give hints "
"about which representation is used:"
msgstr ""

#: src/reference/spec/type-system.md:307
msgid ""
"A similar example is an \"array of strings type\" in PTS that could be "
"represented by a `text[]` (if DBMS supports arrays) or `json` or it's "
"variant `jsonb` in Postgres. Again, the representation would affect "
"operators: in Postgres, arrays would be accessed with `my_array[1]` and json "
"arrays would use `my_json_array -> 1`. This example may not be applicable, "
"if we decide that we want a separate JSON type in PST."
msgstr ""

#: src/reference/spec/type-system.md:314
msgid "RQ functions, targets and reprs"
msgstr ""

#: src/reference/spec/type-system.md:316
msgid ""
"This part is talks about technical implementations, not the language itself"
msgstr ""

#: src/reference/spec/type-system.md:318
msgid "Idea"
msgstr ""

#: src/reference/spec/type-system.md:320
msgid ""
"RQ contains a single node kind for expressing operations and functions: "
"BuiltInFunction (may be renamed in the future)."
msgstr ""

#: src/reference/spec/type-system.md:323
msgid ""
"It is a bottleneck that we can leverage when trying to affect how an "
"operator or a function interacts with different type representations on "
"different targets."
msgstr ""

#: src/reference/spec/type-system.md:326
msgid ""
"Idea is to implement the BuiltInFunction multiple times and annotate it with "
"it intended target and parameter representation. Then we can teach the "
"compiler to pick the appropriate function implementation that suit current "
"repr and compilation target."
msgstr ""

#: src/reference/spec/type-system.md:331
msgid "Specifics"
msgstr ""

#: src/reference/spec/type-system.md:333
msgid ""
"RQ specification is an interface that contains functions, identified by name "
"(i.e. `std.int8.add`). These functions have typed parameters and a return "
"value. If an RQ function call does not match the function declaration in "
"number or in types of the parameters, this is considered an invalid RQ AST."
msgstr ""

#: src/reference/spec/type-system.md:338
msgid ""
"We provide multiple implementations for each RQ function. They are annotated "
"with a target (i.e. `#[target(sql.sqlite)]`) and have their params annotated "
"with type reprs (i.e. `#[repr(int)]`)."
msgstr ""

#: src/reference/spec/type-system.md:342
msgid ""
"```\n"
"# using a made-up syntax\n"
"\n"
"#[target(sql.sqlite)]\n"
"func std.int8.add\n"
"    #[repr(int8)] x\n"
"    #[repr(int8)] y\n"
"    -> s\"{x} + {y}\"\n"
"```"
msgstr ""

#: src/reference/spec/type-system.md:352
msgid ""
"Each RQ type has one canonical repr that serves as the reference "
"implementation for other reprs and indicates the amount of contained data (i."
"e. 1 bit, 8 bits, 64 bits)."
msgstr ""

#: src/reference/spec/type-system.md:358
msgid ""
"Let's say for example, that we'd want to support 8bit integer arithmetic, "
"and that we'd want the result of `127 + 1` to be `-128` (ideally we'd handle "
"this better, but bear with me for the sake of the example). Because some "
"RDBMSs don't support 8bit numbers and do all their integer computation with "
"64bit numbers (SQLite), we need to implement an alternative type "
"representation for that target."
msgstr ""

#: src/reference/spec/type-system.md:365
msgid "The logical type `int8` could have the following two reprs:"
msgstr ""

#: src/reference/spec/type-system.md:367
msgid ""
"canonical `repr_int8` that contains 8 bits in two's complement, covering "
"integer values in range -128 to 127 (inclusive),"
msgstr ""

#: src/reference/spec/type-system.md:369
msgid ""
"`repr_int64` that contains 64 bits of data, but is using only the values "
"that are also covered by `repr_int8`."
msgstr ""

#: src/reference/spec/type-system.md:372
msgid ""
"Now we'd implement function `std.int8.add` for each of the reprs. Let's "
"assume that the `int8` implementation is straightforward and that databases "
"don't just change the data type when a number overflows. The impl for "
"`int64` requires a CASE statement that checks if the value would overflow "
"and subtact 256 in that case."
msgstr ""

#: src/reference/spec/type-system.md:378
msgid ""
"The goal here is that the results of the two impls are equivalent. To "
"validate that, we also need a way to convert between the reprs, or another "
"`to_string` function, implemented for both reprs."
msgstr ""

#: src/reference/stdlib/index.md:1
msgid "Standard library"
msgstr ""

#: src/reference/stdlib/index.md:3
msgid ""
"The standard library currently contains commonly used functions that are "
"used in SQL. It's not yet as broad as we'd like, and we're very open to "
"expanding it."
msgstr ""

#: src/reference/stdlib/index.md:6
msgid ""
"Currently s-strings are an escape-hatch for any function that isn't in our "
"standard library. If we find ourselves using them for something frequently, "
"raise an issue and we'll add it to the stdlib."
msgstr ""

#: src/reference/stdlib/index.md:10
msgid ""
"Here's the source of the current [PRQL `std`](https://github.com/PRQL/prql/"
"blob/main/prqlc/prqlc/src/semantic/std.prql):"
msgstr ""

#: src/reference/stdlib/index.md:13
msgid ""
"```admonish note\n"
"PRQL 0.9.0 has started supporting different DB implementations for standard "
"library functions.\n"
"The source is the [`std.sql`](https://github.com/PRQL/prql/blob/main/prqlc/"
"prqlc/src/sql/std.sql.prql).\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:18
msgid ""
"````prql no-eval\n"
"# The PRQL standard library defines the following functions and transforms.\n"
"# The definitions are whitespace insensitive, and have this form:\n"
"#\n"
"# ```\n"
"# let my_func = param1 param2 ...  -> <return_type> body_expr\n"
"# ```\n"
"#\n"
"# Where:\n"
"#   * `my_func` is the name of the function\n"
"#   * `param1` is the first parameter optionally followed by a type in "
"\"< ... >\"\n"
"#   * `param2` etc. follow the same pattern as param1\n"
"#   * `<return_type>` is the type of result wrapped in \"< ... >\"\n"
"#   * `body_expr` defines the function body that creates the result.\n"
"#     It can be PRQL code or `internal ...` to indicate internal compiler "
"code.\n"
"\n"
"# Operators\n"
"\n"
"let mul = left right -> <int || float> internal std.mul\n"
"let div_i = left right -> <int || float> internal std.div_i\n"
"let div_f = left right -> <int || float> internal std.div_f\n"
"let mod = left right -> <int || float> internal std.mod\n"
"let add = left right -> <int || float || timestamp || date> internal std."
"add\n"
"let sub = left right -> <int || float || timestamp || date> internal std."
"sub\n"
"let eq = left right -> <bool> internal std.eq\n"
"let ne = left right -> <bool> internal std.ne\n"
"let gt = left right -> <bool> internal std.gt\n"
"let lt = left right -> <bool> internal std.lt\n"
"let gte = left right -> <bool> internal std.gte\n"
"let lte = left right -> <bool> internal std.lte\n"
"let and = left<bool> right<bool> -> <bool> internal std.and\n"
"let or = left<bool> right<bool> -> <bool> internal std.or\n"
"let coalesce = left right -> internal std.coalesce\n"
"let regex_search = text pattern -> <bool> internal std.regex_search\n"
"\n"
"let neg = expr<int || float> -> <int || float> internal std.neg\n"
"let not = expr<bool> -> <bool> internal std.not\n"
"\n"
"# Types\n"
"\n"
"## Type primitives\n"
"type int = int\n"
"type float = float\n"
"type bool = bool\n"
"type text = text\n"
"type date = date\n"
"type time = time\n"
"type timestamp = timestamp\n"
"type `func` = func\n"
"type anytype = anytype\n"
"\n"
"## Generic array\n"
"# TODO: an array of anything, not just nulls\n"
"type array = [anytype]\n"
"\n"
"## Scalar\n"
"type scalar = int || float || bool || text || date || time || timestamp || "
"null\n"
"type tuple = {anytype..}\n"
"\n"
"## Range\n"
"type range = {start = scalar, end = scalar}\n"
"\n"
"## Relation (an array of tuples)\n"
"type relation = [tuple]\n"
"\n"
"## Transform\n"
"type transform = func relation -> relation\n"
"\n"
"# Functions\n"
"\n"
"## Relational transforms\n"
"let from = func\n"
"  `default_db.source` <relation>\n"
"  -> <relation> source\n"
"\n"
"let select = func\n"
"  columns <anytype>\n"
"  tbl <relation>\n"
"  -> <relation> internal select\n"
"\n"
"let filter = func\n"
"  condition <bool>\n"
"  tbl <relation>\n"
"  -> <relation> internal filter\n"
"\n"
"let derive = func\n"
"  columns <anytype>\n"
"  tbl <relation>\n"
"  -> <relation> internal derive\n"
"\n"
"let aggregate = func\n"
"  columns <anytype>\n"
"  tbl <relation>\n"
"  -> <relation> internal aggregate\n"
"\n"
"let sort = func\n"
"  by <anytype>\n"
"  tbl <relation>\n"
"  -> <relation> internal sort\n"
"\n"
"let take = func\n"
"  expr <anytype>\n"
"  tbl <relation>\n"
"  -> <relation> internal take\n"
"\n"
"let join = func\n"
"  `default_db.with` <relation>\n"
"  condition <bool>\n"
"  `noresolve.side`:inner\n"
"  tbl <relation>\n"
"  -> <relation> internal join\n"
"\n"
"let group = func\n"
"  by<scalar || tuple>\n"
"  pipeline <transform>\n"
"  tbl <relation>\n"
"  -> <relation> internal group\n"
"\n"
"let window = func\n"
"  rows:0..-1\n"
"  range:0..-1\n"
"  expanding <bool>:false\n"
"  rolling <int>:0\n"
"  pipeline <transform>\n"
"  tbl <relation>\n"
"  -> <relation> internal window\n"
"\n"
"let append = `default_db.bottom`<relation> top<relation> -> <relation> "
"internal append\n"
"let intersect = `default_db.bottom`<relation> top<relation> -> <relation> (\n"
"  t = top\n"
"  join (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b.*)))\n"
"  select t.*\n"
")\n"
"let remove = `default_db.bottom`<relation> top<relation> -> <relation> (\n"
"  t = top\n"
"  join side:left (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b."
"*)))\n"
"  filter (tuple_every (tuple_map _is_null b.*))\n"
"  select t.*\n"
")\n"
"let loop = func\n"
"  pipeline <transform>\n"
"  top <relation>\n"
"  -> <relation> internal loop\n"
"\n"
"## Aggregate functions\n"
"# These return either a scalar when used within `aggregate`, or a column "
"when used anywhere else.\n"
"\n"
"let min = column <array> -> <int || float || null> internal std.min\n"
"\n"
"let max = column <array> -> <int || float || null> internal std.max\n"
"\n"
"let sum = column <array> -> <int || float> internal std.sum\n"
"\n"
"let average = column <array> -> <float || null> internal std.average\n"
"\n"
"let stddev = column <array> -> <float || null> internal std.stddev\n"
"\n"
"let all = column <array> -> <bool> internal std.all\n"
"\n"
"let any = column <array> -> <bool> internal std.any\n"
"\n"
"let concat_array = column <array> -> <text> internal std.concat_array\n"
"\n"
"# Counts number of items in the column.\n"
"# Note that the count will include null values.\n"
"let count = column<array> -> <int> internal count\n"
"\n"
"# Deprecated in favour of filterning input to the [std.count] function (not "
"yet implemented).\n"
"@{deprecated}\n"
"let count_distinct = column <array> -> internal std.count_distinct\n"
"\n"
"## Window functions\n"
"let lag =   offset <int>    column <array> -> internal std.lag\n"
"let lead =  offset <int>    column <array> -> internal std.lead\n"
"let first      = column <array> -> internal std.first\n"
"let last       = column <array> -> internal std.last\n"
"let rank       = column <array> -> internal std.rank\n"
"let rank_dense = column <array> -> internal std.rank_dense\n"
"let row_number = column <array> -> internal row_number\n"
"\n"
"# Mathematical functions\n"
"module math {\n"
"  let abs = column -> <int || float> internal std.math.abs\n"
"  let floor = column -> <int> internal std.math.floor\n"
"  let ceil = column -> <int> internal std.math.ceil\n"
"  let pi = -> <float> internal std.math.pi\n"
"  let exp = column -> <int || float> internal std.math.exp\n"
"  let ln = column -> <int || float> internal std.math.ln\n"
"  let log10 = column -> <int || float> internal std.math.log10\n"
"  let log = base<int || float> column -> <int || float> internal std.math."
"log\n"
"  let sqrt = column -> <int || float> internal std.math.sqrt\n"
"  let degrees = column -> <int || float> internal std.math.degrees\n"
"  let radians = column -> <int || float> internal std.math.radians\n"
"  let cos = column -> <int || float> internal std.math.cos\n"
"  let acos = column -> <int || float> internal std.math.acos\n"
"  let sin = column -> <int || float> internal std.math.sin\n"
"  let asin = column -> <int || float> internal std.math.asin\n"
"  let tan = column -> <int || float> internal std.math.tan\n"
"  let atan = column -> <int || float> internal std.math.atan\n"
"  let pow = exponent<int || float> column -> <int || float> internal std."
"math.pow\n"
"  let round = n_digits column -> <scalar> internal std.math.round\n"
"}\n"
"\n"
"## Misc functions\n"
"let as = `noresolve.type` column -> <scalar> internal std.as\n"
"let in = pattern value -> <bool> internal in\n"
"\n"
"## Tuple functions\n"
"let tuple_every = func list -> <bool> internal tuple_every\n"
"let tuple_map = func fn <func> list -> internal tuple_map\n"
"let tuple_zip = func a b -> internal tuple_zip\n"
"let _eq = func a -> internal _eq\n"
"let _is_null = func a -> _param.a == null\n"
"\n"
"## Misc\n"
"let from_text = input<text> `noresolve.format`:csv -> <relation> internal "
"from_text\n"
"\n"
"## Text functions\n"
"module text {\n"
"  let lower = column -> <text> internal std.text.lower\n"
"  let upper = column -> <text> internal std.text.upper\n"
"  let ltrim = column -> <text> internal std.text.ltrim\n"
"  let rtrim = column -> <text> internal std.text.rtrim\n"
"  let trim = column -> <text> internal std.text.trim\n"
"  let length = column -> <int> internal std.text.length\n"
"  let extract = offset<int> length<int> column -> <text> internal std.text."
"extract\n"
"  let replace = pattern<text> replacement<text> column -> <text> internal "
"std.text.replace\n"
"  let starts_with = prefix<text> column -> <bool> internal std.text."
"starts_with\n"
"  let contains = substr<text> column -> <bool> internal std.text.contains\n"
"  let ends_with = suffix<text> column -> <bool> internal std.text.ends_with\n"
"}\n"
"\n"
"## Date functions\n"
"module date {\n"
"  let to_text = format<text> column -> <text> internal std.date.to_text\n"
"}\n"
"\n"
"## File-reading functions, primarily for DuckDB\n"
"let read_parquet = source<text> -> <relation> internal std.read_parquet\n"
"let read_csv = source<text> -> <relation> internal std.read_csv\n"
"\n"
"\n"
"## PRQL compiler functions\n"
"module `prql` {\n"
"  let version = -> <text> internal prql_version\n"
"}\n"
"\n"
"# Deprecated, will be removed in 0.12.0\n"
"let prql_version = -> <text> internal prql_version\n"
"````"
msgstr ""

#: src/reference/stdlib/index.md:269
msgid "And a couple of examples:"
msgstr ""

#: src/reference/stdlib/index.md:271
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = (salary + payroll_tax | as int),\n"
"  gross_salary_rounded = (gross_salary | math.round 0),\n"
"  time = s\"NOW()\",  # an s-string, given no `now` function exists in PRQL\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:280
msgid "Example of different implementations of division and integer division:"
msgstr ""

#: src/reference/stdlib/index.md:282
msgid ""
"```prql\n"
"prql target:sql.sqlite\n"
"\n"
"from [{x = 13, y = 5}]\n"
"select {\n"
"  quotient = x / y,\n"
"  int_quotient = x // y,\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:292
msgid ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from [{x = 13, y = 5}]\n"
"select {\n"
"  quotient = x / y,\n"
"  int_quotient = x // y,\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/date.md:1
msgid "Date functions"
msgstr ""

#: src/reference/stdlib/date.md:3
msgid "These are all the functions defined in the `date` module:"
msgstr ""

#: src/reference/stdlib/date.md:5
msgid "`to_text`"
msgstr ""

#: src/reference/stdlib/date.md:7
msgid ""
"Converts a date into a text.  \n"
"Since there are many possible date representations, `to_text` takes a "
"`format` parameter that describes thanks to [specifiers](#date--time-format-"
"specifiers) how the date or timestamp should be structured."
msgstr ""

#: src/reference/stdlib/date.md:20
msgid ""
"```prql\n"
"prql target:sql.duckdb\n"
"\n"
"from invoices\n"
"select {\n"
"  invoice_date | date.to_text \"%d/%m/%Y\"\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/date.md:29
msgid ""
"```prql\n"
"prql target:sql.postgres\n"
"\n"
"from invoices\n"
"select {\n"
"  invoice_date | date.to_text \"%d/%m/%Y\"\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/date.md:38
msgid ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from invoices\n"
"select {\n"
"  invoice_date | date.to_text \"%d/%m/%Y\"\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/date.md:47
msgid "Date & time format specifiers"
msgstr ""

#: src/reference/stdlib/date.md:49
msgid ""
"PRQL specifiers for date and time formatting is a subset of specifiers used "
"by [`chrono`](https://docs.rs/chrono/latest/chrono/format/strftime/index."
"html)."
msgstr ""

#: src/reference/stdlib/date.md:52
msgid "Here is the list of the specifiers currently supported:"
msgstr ""

#: src/reference/stdlib/date.md:54
msgid "Spec."
msgstr ""

#: src/reference/stdlib/date.md:54
msgid "Description"
msgstr ""

#: src/reference/stdlib/date.md:57
msgid "**DATE SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:58
msgid "`%Y`"
msgstr ""

#: src/reference/stdlib/date.md:58
msgid "`2001`"
msgstr ""

#: src/reference/stdlib/date.md:58
msgid "Year number, zero-padded to 4 digits"
msgstr ""

#: src/reference/stdlib/date.md:59
msgid "`%y`"
msgstr ""

#: src/reference/stdlib/date.md:59
msgid "`01`"
msgstr ""

#: src/reference/stdlib/date.md:59
msgid "Year number, zero-padded to 2 digits"
msgstr ""

#: src/reference/stdlib/date.md:60
msgid "`%m`"
msgstr ""

#: src/reference/stdlib/date.md:60
msgid "`07`"
msgstr ""

#: src/reference/stdlib/date.md:60
msgid "Month number (01–12), zero-padded to 2 digits"
msgstr ""

#: src/reference/stdlib/date.md:61
msgid "`%-m`"
msgstr ""

#: src/reference/stdlib/date.md:61
msgid "`7`"
msgstr ""

#: src/reference/stdlib/date.md:61
msgid "Month number (1-12)"
msgstr ""

#: src/reference/stdlib/date.md:62
msgid "`%b`"
msgstr ""

#: src/reference/stdlib/date.md:62
msgid "`Jul`"
msgstr ""

#: src/reference/stdlib/date.md:62
msgid "Abbreviated month name. Always 3 letters."
msgstr ""

#: src/reference/stdlib/date.md:63
msgid "`%B`"
msgstr ""

#: src/reference/stdlib/date.md:63
msgid "`July`"
msgstr ""

#: src/reference/stdlib/date.md:63
msgid "Full month name"
msgstr ""

#: src/reference/stdlib/date.md:64
msgid "`%d`"
msgstr ""

#: src/reference/stdlib/date.md:64
msgid "`08`"
msgstr ""

#: src/reference/stdlib/date.md:64
msgid "Day number (01-31), zero-padded to 2 digits"
msgstr ""

#: src/reference/stdlib/date.md:65
msgid "`%-d`"
msgstr ""

#: src/reference/stdlib/date.md:65
msgid "` 8`"
msgstr ""

#: src/reference/stdlib/date.md:65
msgid "Day number (1-31)"
msgstr ""

#: src/reference/stdlib/date.md:66
msgid "`%a`"
msgstr ""

#: src/reference/stdlib/date.md:66
msgid "`Sun`"
msgstr ""

#: src/reference/stdlib/date.md:66
msgid "Abbreviated weekday name. Always 3 letters"
msgstr ""

#: src/reference/stdlib/date.md:67
msgid "`%A`"
msgstr ""

#: src/reference/stdlib/date.md:67
msgid "`Sunday`"
msgstr ""

#: src/reference/stdlib/date.md:67
msgid "Full weekday name"
msgstr ""

#: src/reference/stdlib/date.md:68
msgid "`%D`"
msgstr ""

#: src/reference/stdlib/date.md:68 src/reference/stdlib/date.md:69
msgid "`07/08/01`"
msgstr ""

#: src/reference/stdlib/date.md:68
msgid "Month-day-year format. Same as `%m/%d/%y`"
msgstr ""

#: src/reference/stdlib/date.md:69
msgid "`%x`"
msgstr ""

#: src/reference/stdlib/date.md:69
msgid "Locale's date representation"
msgstr ""

#: src/reference/stdlib/date.md:70
msgid "`%F`"
msgstr ""

#: src/reference/stdlib/date.md:70
msgid "`2001-07-08`"
msgstr ""

#: src/reference/stdlib/date.md:70
msgid "Year-month-day format (ISO 8601). Same as `%Y-%m-%d`"
msgstr ""

#: src/reference/stdlib/date.md:72
msgid "**TIME SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:73
msgid "`%H`"
msgstr ""

#: src/reference/stdlib/date.md:73
msgid "`00`"
msgstr ""

#: src/reference/stdlib/date.md:73
msgid "Hour number (00-23)"
msgstr ""

#: src/reference/stdlib/date.md:74
msgid "`%k`"
msgstr ""

#: src/reference/stdlib/date.md:74
msgid "` 0`"
msgstr ""

#: src/reference/stdlib/date.md:74
msgid "Same as `%H` but space-padded. Same as `%_H`."
msgstr ""

#: src/reference/stdlib/date.md:75
msgid "`%I`"
msgstr ""

#: src/reference/stdlib/date.md:75
msgid "`12`"
msgstr ""

#: src/reference/stdlib/date.md:75
msgid "Hour number in 12-hour clocks (01--12), zero-padded to 2 digits."
msgstr ""

#: src/reference/stdlib/date.md:76
msgid "`%p`"
msgstr ""

#: src/reference/stdlib/date.md:76
msgid "`AM`"
msgstr ""

#: src/reference/stdlib/date.md:76
msgid "`AM` or `PM` in 12-hour clocks."
msgstr ""

#: src/reference/stdlib/date.md:77
msgid "`%M`"
msgstr ""

#: src/reference/stdlib/date.md:77
msgid "`34`"
msgstr ""

#: src/reference/stdlib/date.md:77
msgid "Minute number (00-59), zero-padded to 2 digits."
msgstr ""

#: src/reference/stdlib/date.md:78
msgid "`%S`"
msgstr ""

#: src/reference/stdlib/date.md:78
msgid "`60`"
msgstr ""

#: src/reference/stdlib/date.md:78
msgid "Second number (00-59), zero-padded to 2 digits."
msgstr ""

#: src/reference/stdlib/date.md:79
msgid "`%f`"
msgstr ""

#: src/reference/stdlib/date.md:79
msgid "`264900`"
msgstr ""

#: src/reference/stdlib/date.md:79
msgid "Number of microseconds[^1] since last whole second"
msgstr ""

#: src/reference/stdlib/date.md:80
msgid "`%R`"
msgstr ""

#: src/reference/stdlib/date.md:80
msgid "`00:34`"
msgstr ""

#: src/reference/stdlib/date.md:80
msgid "Hour-minute format. Same as `%H:%M`."
msgstr ""

#: src/reference/stdlib/date.md:81
msgid "`%T`"
msgstr ""

#: src/reference/stdlib/date.md:81 src/reference/stdlib/date.md:82
msgid "`00:34:60`"
msgstr ""

#: src/reference/stdlib/date.md:81
msgid "Hour-minute-second format. Same as `%H:%M:%S`."
msgstr ""

#: src/reference/stdlib/date.md:82
msgid "`%X`"
msgstr ""

#: src/reference/stdlib/date.md:82
msgid "Locale's time representation (e.g., 23:13:48)."
msgstr ""

#: src/reference/stdlib/date.md:83
msgid "`%r`"
msgstr ""

#: src/reference/stdlib/date.md:83
msgid "`12:34:60 AM`"
msgstr ""

#: src/reference/stdlib/date.md:83
msgid "Locale's 12 hour clock time. (e.g., 11:11:04 PM)"
msgstr ""

#: src/reference/stdlib/date.md:85
msgid "**DATE & TIME SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:86
msgid "`%+`"
msgstr ""

#: src/reference/stdlib/date.md:86
msgid "`2001-07-08T00:34:60.026490Z`"
msgstr ""

#: src/reference/stdlib/date.md:86
msgid "ISO 8601 / RFC 3339 date & time format."
msgstr ""

#: src/reference/stdlib/date.md:88
msgid "**SPECIAL SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:89
msgid "`%t`"
msgstr ""

#: src/reference/stdlib/date.md:89
msgid "Literal tab (`\\t`)."
msgstr ""

#: src/reference/stdlib/date.md:90
msgid "`%n`"
msgstr ""

#: src/reference/stdlib/date.md:90
msgid "Literal newline (`\\n`)."
msgstr ""

#: src/reference/stdlib/date.md:91
msgid "`%%`"
msgstr ""

#: src/reference/stdlib/date.md:91
msgid "Literal percent sign."
msgstr ""

#: src/reference/stdlib/date.md:93
msgid "This is different from chrono, for which `%f` represents nanoseconds"
msgstr ""

#: src/reference/stdlib/math.md:1
msgid "Mathematical functions"
msgstr ""

#: src/reference/stdlib/math.md:3
msgid "These are all the functions defined in the `math` module:"
msgstr ""

#: src/reference/stdlib/math.md:5
msgid "function"
msgstr ""

#: src/reference/stdlib/math.md:5
msgid "parameters"
msgstr ""

#: src/reference/stdlib/math.md:5
msgid "description"
msgstr ""

#: src/reference/stdlib/math.md:7
msgid "abs"
msgstr ""

#: src/reference/stdlib/math.md:7 src/reference/stdlib/math.md:8
#: src/reference/stdlib/math.md:9 src/reference/stdlib/math.md:10
#: src/reference/stdlib/math.md:11 src/reference/stdlib/math.md:12
#: src/reference/stdlib/math.md:13 src/reference/stdlib/math.md:14
#: src/reference/stdlib/math.md:15 src/reference/stdlib/math.md:16
#: src/reference/stdlib/math.md:18 src/reference/stdlib/math.md:21
#: src/reference/stdlib/math.md:23 src/reference/stdlib/math.md:24
#: src/reference/stdlib/math.md:25
msgid "`col`"
msgstr ""

#: src/reference/stdlib/math.md:7
msgid "Absolute value of `col`"
msgstr ""

#: src/reference/stdlib/math.md:8
msgid "acos"
msgstr ""

#: src/reference/stdlib/math.md:8
msgid "Arccosine of `col`"
msgstr ""

#: src/reference/stdlib/math.md:9
msgid "asin"
msgstr ""

#: src/reference/stdlib/math.md:9
msgid "Arcsine of `col`"
msgstr ""

#: src/reference/stdlib/math.md:10
msgid "atan"
msgstr ""

#: src/reference/stdlib/math.md:10
msgid "Arctangent of `col`"
msgstr ""

#: src/reference/stdlib/math.md:11
msgid "ceil"
msgstr ""

#: src/reference/stdlib/math.md:11
msgid "Rounds the number up of `col`"
msgstr ""

#: src/reference/stdlib/math.md:12
msgid "cos"
msgstr ""

#: src/reference/stdlib/math.md:12
msgid "Cosine of `col`"
msgstr ""

#: src/reference/stdlib/math.md:13
msgid "degrees"
msgstr ""

#: src/reference/stdlib/math.md:13
msgid "Converts radians to degrees"
msgstr ""

#: src/reference/stdlib/math.md:14
msgid "exp"
msgstr ""

#: src/reference/stdlib/math.md:14
msgid "Exponential of `col`"
msgstr ""

#: src/reference/stdlib/math.md:15
msgid "floor"
msgstr ""

#: src/reference/stdlib/math.md:15
msgid "Rounds the number down"
msgstr ""

#: src/reference/stdlib/math.md:16
msgid "ln"
msgstr ""

#: src/reference/stdlib/math.md:16
msgid "Natural logarithm of `col`"
msgstr ""

#: src/reference/stdlib/math.md:17
msgid "log"
msgstr ""

#: src/reference/stdlib/math.md:17 src/reference/stdlib/math.md:20
msgid "`b` `col`"
msgstr ""

#: src/reference/stdlib/math.md:17
msgid "`b`\\-log of `col`"
msgstr ""

#: src/reference/stdlib/math.md:18
msgid "log10"
msgstr ""

#: src/reference/stdlib/math.md:18
msgid "10-log of `col`"
msgstr ""

#: src/reference/stdlib/math.md:19
msgid "pi"
msgstr ""

#: src/reference/stdlib/math.md:19
msgid "The constant π"
msgstr ""

#: src/reference/stdlib/math.md:20
msgid "pow"
msgstr ""

#: src/reference/stdlib/math.md:20
msgid "Computes `col` to the power `b`"
msgstr ""

#: src/reference/stdlib/math.md:21
msgid "radians"
msgstr ""

#: src/reference/stdlib/math.md:21
msgid "Converts degrees to radians"
msgstr ""

#: src/reference/stdlib/math.md:22
msgid "round"
msgstr ""

#: src/reference/stdlib/math.md:22
msgid "`n` `col`"
msgstr ""

#: src/reference/stdlib/math.md:22
msgid "Rounds `col` to `n` decimal places"
msgstr ""

#: src/reference/stdlib/math.md:23
msgid "sin"
msgstr ""

#: src/reference/stdlib/math.md:23
msgid "Sin of `col`"
msgstr ""

#: src/reference/stdlib/math.md:24
msgid "sqrt"
msgstr ""

#: src/reference/stdlib/math.md:24
msgid "Square root of `col`"
msgstr ""

#: src/reference/stdlib/math.md:25
msgid "tan"
msgstr ""

#: src/reference/stdlib/math.md:25
msgid "Tangent of `col`"
msgstr ""

#: src/reference/stdlib/distinct.md:1
msgid "How do I: remove duplicates?"
msgstr ""

#: src/reference/stdlib/distinct.md:3
msgid ""
"PRQL doesn't have a specific `distinct` keyword. Instead duplicate tuples in "
"a relation can be removed by using `group` and `take 1`:"
msgstr ""

#: src/reference/stdlib/distinct.md:14
msgid "This also works with a wildcard:"
msgstr ""

#: src/reference/stdlib/distinct.md:21
msgid "Remove duplicates from each group?"
msgstr ""

#: src/reference/stdlib/distinct.md:23
msgid ""
"To [select a single row from each group](https://stackoverflow.com/"
"questions/3800551/select-first-row-in-each-group-by-group) `group` can be "
"combined with `sort` and `take`:"
msgstr ""

#: src/reference/stdlib/distinct.md:36
msgid ""
"Note that we can't always compile to `DISTINCT`; when the columns in the "
"`group` aren't all the available columns, we need to use a window function:"
msgstr ""

#: src/reference/stdlib/text.md:1
msgid "Text functions"
msgstr ""

#: src/reference/stdlib/text.md:3
msgid "These are all the functions defined in the `text` module:"
msgstr ""

#: src/reference/stdlib/text.md:7
msgid "contains"
msgstr ""

#: src/reference/stdlib/text.md:7 src/reference/stdlib/text.md:8
#: src/reference/stdlib/text.md:15
msgid "`sub` `col`"
msgstr ""

#: src/reference/stdlib/text.md:7
msgid "Returns true if `col` contains `sub`"
msgstr ""

#: src/reference/stdlib/text.md:8
msgid "ends_with"
msgstr ""

#: src/reference/stdlib/text.md:8
msgid "Returns true if `col` ends with `sub`"
msgstr ""

#: src/reference/stdlib/text.md:9
msgid "extract"
msgstr ""

#: src/reference/stdlib/text.md:9
msgid "`idx` `len` `col`"
msgstr ""

#: src/reference/stdlib/text.md:9
msgid ""
"Extracts a substring at the index `idx` (starting at 1) with the length `len`"
msgstr ""

#: src/reference/stdlib/text.md:10
msgid "length"
msgstr ""

#: src/reference/stdlib/text.md:10
msgid "Returns the number of characters in `col`"
msgstr ""

#: src/reference/stdlib/text.md:11
msgid "lower"
msgstr ""

#: src/reference/stdlib/text.md:11
msgid "Converts `col` to lower case"
msgstr ""

#: src/reference/stdlib/text.md:12
msgid "ltrim"
msgstr ""

#: src/reference/stdlib/text.md:12
msgid "Removes all the whitespaces from the left side of `col`"
msgstr ""

#: src/reference/stdlib/text.md:13
msgid "replace"
msgstr ""

#: src/reference/stdlib/text.md:13
msgid "`before` `after` `col`"
msgstr ""

#: src/reference/stdlib/text.md:13
msgid "Replaces any occurrences of `before` with `after` in `col`"
msgstr ""

#: src/reference/stdlib/text.md:14
msgid "rtrim"
msgstr ""

#: src/reference/stdlib/text.md:14
msgid "Removes all the whitespaces from the right side of `col`"
msgstr ""

#: src/reference/stdlib/text.md:15
msgid "starts_with"
msgstr ""

#: src/reference/stdlib/text.md:15
msgid "Returns true if `col` starts with `sub`"
msgstr ""

#: src/reference/stdlib/text.md:16
msgid "trim"
msgstr ""

#: src/reference/stdlib/text.md:16
msgid "Removes all the whitespaces from both sides of `col`"
msgstr ""

#: src/reference/stdlib/text.md:17
msgid "upper"
msgstr ""

#: src/reference/stdlib/text.md:17
msgid "Converts `col` to upper case"
msgstr ""

#: src/reference/stdlib/text.md:21
msgid ""
"```prql\n"
"from employees\n"
"select {\n"
"  last_name | text.lower | text.starts_with(\"a\"),\n"
"  title | text.replace \"manager\" \"chief\"\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/index.md:1
msgid "Transforms"
msgstr ""

#: src/reference/stdlib/transforms/index.md:3
msgid "Transforms are functions that take a relation and produce a relation."
msgstr ""

#: src/reference/stdlib/transforms/index.md:5
msgid ""
"Usually they are chained together into a pipeline, which resembles an SQL "
"query."
msgstr ""

#: src/reference/stdlib/transforms/index.md:7
msgid ""
"Transforms were designed with a focus on modularity, so each of them is "
"fulfilling a specific purpose and has defined invariants (properties of the "
"relation that are left unaffected). That's often referred to as "
"\"orthogonality\" and its goal is to keep transform functions composable by "
"minimizing interference of their effects. Additionally, it also keeps the "
"number of transforms low."
msgstr ""

#: src/reference/stdlib/transforms/index.md:14
msgid ""
"For example, `select` and `derive` will not change the number of rows, while "
"`filter` and `take` will not change the number of columns."
msgstr ""

#: src/reference/stdlib/transforms/index.md:17
msgid ""
"In SQL, we can see this lack of invariant when an aggregation function is "
"used in the `SELECT` clause. Before, the number of rows was kept constant, "
"but introduction of an aggregation function caused the whole statement to "
"produce only one row (per group)."
msgstr ""

#: src/reference/stdlib/transforms/index.md:22
msgid "These are the currently available transforms:"
msgstr ""

#: src/reference/stdlib/transforms/index.md:24
msgid "Transform"
msgstr ""

#: src/reference/stdlib/transforms/index.md:24
msgid "SQL Equivalent"
msgstr ""

#: src/reference/stdlib/transforms/index.md:26
msgid "`derive`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:26
msgid "[Compute new columns](./derive.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:26
msgid "`SELECT *, ... AS ...`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:27
msgid "`select`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:27
msgid "[Pick & compute columns](./select.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:27
msgid "`SELECT ... AS ...`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:28
msgid "`filter`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:28
msgid "[Pick rows based on their values](./filter.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:28
msgid "`WHERE`, `HAVING`,`QUALIFY`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:29
msgid "`sort`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:29
msgid "[Order rows based on the values of columns](./sort.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:29
msgid "`ORDER BY`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:30
msgid "`join`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:30
msgid ""
"[Add columns from another table, matching rows based on a condition](./join."
"md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:30
msgid "`JOIN`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:31
msgid "`take`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:31
msgid "[Pick rows based on their position](./take.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:31
msgid "`TOP`, `LIMIT`, `OFFSET`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:32
msgid "`group`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:32
msgid ""
"[Partition rows into groups and applies a pipeline to each of them](./group."
"md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:32
msgid "`GROUP BY`, `PARTITION BY`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:33
msgid "`aggregate`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:33
msgid "[Summarize many rows into one row](./aggregate.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:33
msgid "`SELECT foo(...)`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:34
msgid "`window`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:34
msgid "[Apply a pipeline to overlapping segments of rows](./window.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:34
msgid "`OVER`, `ROWS`, `RANGE`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:35
msgid "`loop`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:35
msgid ""
"[Iteratively apply a function to a relation until it's empty](./loop.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:35
msgid "`WITH RECURSIVE ...`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:39
msgid ""
"[`from`](../../data/from.md) — `from` is the main way of getting data into a "
"pipeline (it's not listed above since it's not technically a transform, "
"since it doesn't receive an input)."
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:1
msgid "Aggregate"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:3
msgid "Summarizes many rows into one row."
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:5
msgid "When applied:"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:7
msgid "without `group`, it produces one row from the whole table,"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:8
msgid "within a `group` pipeline, it produces one row from each group."
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:40
msgid "Aggregate is required"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:42
msgid ""
"Unlike in SQL, using an aggregation function in `derive` or `select` (or any "
"other transform except `aggregate`) will not trigger aggregation. By "
"default, PRQL will interpret such attempts functions as window functions:"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:51
msgid ""
"This ensures that `derive` does not manipulate the number of rows, but only "
"ever adds a column. For more information, see [window transform](./window."
"md)."
msgstr ""

#: src/reference/stdlib/transforms/append.md:1
msgid "Append"
msgstr ""

#: src/reference/stdlib/transforms/append.md:3
msgid "Concatenates two tables together."
msgstr ""

#: src/reference/stdlib/transforms/append.md:5
msgid ""
"Equivalent to `UNION ALL` in SQL. The number of rows is always the sum of "
"the number of rows from the two input tables. To replicate `UNION DISTINCT`, "
"see [set operations](#set-operations)."
msgstr ""

#: src/reference/stdlib/transforms/append.md:14
msgid "Remove"
msgstr ""

#: src/reference/stdlib/transforms/append.md:16
#: src/reference/stdlib/transforms/append.md:28
#: src/reference/stdlib/transforms/append.md:37
msgid "_experimental_"
msgstr ""

#: src/reference/stdlib/transforms/append.md:18
msgid ""
"Removes rows that appear in another relation, like `EXCEPT ALL`. Duplicate "
"rows are removed one-for-one."
msgstr ""

#: src/reference/stdlib/transforms/append.md:26
msgid "Intersection"
msgstr ""

#: src/reference/stdlib/transforms/append.md:35
msgid "Set operations"
msgstr ""

#: src/reference/stdlib/transforms/append.md:39
msgid ""
"To imitate set operations i.e. (`UNION`, `EXCEPT` and `INTERSECT`), you can "
"use the following functions:"
msgstr ""

#: src/reference/stdlib/transforms/append.md:49
msgid ""
"Don't mind the `default_db.` and `noop`, these are compiler implementation "
"detail for now."
msgstr ""

#: src/reference/stdlib/transforms/derive.md:1
msgid "Derive"
msgstr ""

#: src/reference/stdlib/transforms/derive.md:3
msgid "Computes one or more new columns."
msgstr ""

#: src/reference/stdlib/transforms/filter.md:1
msgid "Filter"
msgstr ""

#: src/reference/stdlib/transforms/filter.md:3
msgid "Picks rows based on their values."
msgstr ""

#: src/reference/stdlib/transforms/filter.md:16
msgid ""
"```prql\n"
"from employees\n"
"filter (age > 25 || department != \"IT\")\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/filter.md:21
msgid ""
"```prql\n"
"from employees\n"
"filter (department | in [\"IT\", \"HR\"])\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/group.md:1
msgid "Group"
msgstr ""

#: src/reference/stdlib/transforms/group.md:3
msgid ""
"Partitions the rows into groups and applies a pipeline to each of the groups."
msgstr ""

#: src/reference/stdlib/transforms/group.md:9
msgid ""
"The partitioning of groups are determined by the `key_column`s (first "
"argument)."
msgstr ""

#: src/reference/stdlib/transforms/group.md:11
msgid "The most conventional use of `group` is with `aggregate`:"
msgstr ""

#: src/reference/stdlib/transforms/group.md:23
msgid ""
"In concept, a transform in context of a `group` does the same transformation "
"to the group as it would to the table — for example finding the employee who "
"joined first across the whole table:"
msgstr ""

#: src/reference/stdlib/transforms/group.md:33
msgid ""
"To find the employee who joined first in each department, it's exactly the "
"same pipeline, but within a `group` expression:"
msgstr ""

#: src/reference/stdlib/transforms/join.md:1
msgid "Join"
msgstr ""

#: src/reference/stdlib/transforms/join.md:3
msgid "Adds columns from another relation, matching rows based on a condition."
msgstr ""

#: src/reference/stdlib/transforms/join.md:9
msgid "Parameters"
msgstr ""

#: src/reference/stdlib/transforms/join.md:11
msgid "`side` specifies which rows to include, defaulting to `inner`."
msgstr ""

#: src/reference/stdlib/transforms/join.md:12
msgid ""
"`rel` - the relation to join with, possibly including an alias, e.g. "
"`a=artists`."
msgstr ""

#: src/reference/stdlib/transforms/join.md:14
msgid ""
"`condition` - the criteria on which to match the rows from the two "
"relations. Theoretically, `join` will produce a cartesian product of the two "
"input relations and then filter the result by the condition. It supports two "
"additional features:"
msgstr ""

#: src/reference/stdlib/transforms/join.md:18
msgid ""
"_Names [`this` & `that`](../../syntax/keywords.md#this--that)_: Along name "
"`this`, which refers to the first input relation, `condition` can use name "
"`that`, which refers to the second input relation."
msgstr ""

#: src/reference/stdlib/transforms/join.md:21
msgid ""
"_Self equality operator_: If the condition is an equality comparison between "
"two columns with the same name (i.e. `(this.col == that.col)`), it can be "
"expressed with only `(==col)`."
msgstr ""

#: src/reference/stdlib/transforms/join.md:51
msgid ""
"In SQL, CROSS JOIN is a join that returns each row from first relation "
"matched with all rows from the second relation. To accomplish this, we can "
"use condition `true`, which will return all rows of the cartesian product of "
"the input relations:"
msgstr ""

#: src/reference/stdlib/transforms/join.md:63
msgid ""
"[`this` & `that`](../../syntax/keywords.md#this--that) can be used to refer "
"to the current & other table respectively:"
msgstr ""

#: src/reference/stdlib/transforms/join.md:75
msgid ""
"If the join conditions are of form `left.x == right.x`, we can use \"self "
"equality operator\":"
msgstr ""

#: src/reference/stdlib/transforms/loop.md:1
msgid "Loop"
msgstr ""

#: src/reference/stdlib/transforms/loop.md:3
msgid "_Experimental_"
msgstr ""

#: src/reference/stdlib/transforms/loop.md:9
msgid ""
"Iteratively applies `step` function to `initial` relation until the `step` "
"returns an empty table. Returns a relation that contains rows of initial "
"relation and all intermediate relations."
msgstr ""

#: src/reference/stdlib/transforms/loop.md:13
msgid "This behavior could be expressed with following pseudo-code:"
msgstr ""

#: src/reference/stdlib/transforms/loop.md:38
msgid ""
"```admonish note\n"
"The behavior of `WITH RECURSIVE` may depend on the database configuration in "
"MySQL.\n"
"The compiler assumes the behavior described by\n"
"the [Postgres documentation](https://www.postgresql.org/docs/15/queries-with."
"html#QUERIES-WITH-RECURSIVE)\n"
"and will not produce correct results for\n"
"[alternative configurations of MySQL](https://dev.mysql.com/doc/refman/8.0/"
"en/with.html#common-table-expressions-recursive).\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/select.md:1
msgid "Select"
msgstr ""

#: src/reference/stdlib/transforms/select.md:3
msgid "Picks and computes columns."
msgstr ""

#: src/reference/stdlib/transforms/select.md:17
msgid ""
"```prql\n"
"from employees\n"
"select name = f\"{first_name} {last_name}\"\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/select.md:22
msgid ""
"```prql\n"
"from employees\n"
"select {\n"
"  name = f\"{first_name} {last_name}\",\n"
"  age_eoy = dob - @2022-12-31,\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/select.md:40
msgid "Excluding columns"
msgstr ""

#: src/reference/stdlib/transforms/select.md:42
msgid ""
"We can use `!` to exclude a list of columns. This can operate in two ways:"
msgstr ""

#: src/reference/stdlib/transforms/select.md:44
msgid ""
"We use `SELECT * EXCLUDE` / `SELECT * EXCEPT` for the columns supplied to "
"`select !{}` in dialects which support it."
msgstr ""

#: src/reference/stdlib/transforms/select.md:46
msgid ""
"Otherwise, the columns must have been defined prior in the query (unless all "
"of a table's columns are excluded); for example in another `select` or a "
"`group` transform. In this case, we evaluate and specify the columns that "
"should be included in the output SQL."
msgstr ""

#: src/reference/stdlib/transforms/select.md:51
msgid "Some examples:"
msgstr ""

#: src/reference/stdlib/transforms/select.md:71
msgid ""
"Note that `!` is also the `NOT` operator, so without the tuple it has a "
"different meaning:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:1
msgid "Sort"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:3
msgid ""
"Order rows based on the values of one or more expressions (generally "
"columns)."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:11
msgid "One expression or a tuple of expressions to sort by"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:12
msgid "Each expression can be prefixed with:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:13
msgid "`+`, for ascending order, the default"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:14
msgid "`-`, for descending order"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:15
msgid ""
"When using prefixes, even a single expression needs to be in a tuple or "
"parentheses. (Otherwise, `sort -foo` is parsed as a subtraction between "
"`sort` and `foo`.)"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:36
msgid "We can also use expressions:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:38
msgid ""
"```prql\n"
"from employees\n"
"sort {s\"substr({first_name}, 2, 5)\"}\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:43
msgid "Ordering guarantees"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:45
msgid "Ordering is persistent through a pipeline in PRQL. For example:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:53
msgid ""
"Here, PRQL pushes the `sort` down the pipeline, compiling the `ORDER BY` to "
"the _end_ of the query. Consequently, most relation transforms retain the "
"row order."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:56
msgid "The explicit semantics are:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:58
msgid "`sort` introduces a new order,"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:59
msgid "`group` resets the order,"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:60
msgid "`join` retains the order of the left relation,"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:61
msgid "database tables don't have a known order."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:63
msgid ""
"Comparatively, in SQL, relations possess no order, being orderable solely "
"within the context of the query result, `LIMIT` statement, or window "
"function. The lack of inherent order can result in an unexpected reshuffling "
"of a previously ordered relation from a `JOIN` or windowing operation."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:74
msgid "For instance, an SQL query such as:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:87
msgid ""
"...doesn't guarantee any row order (indeed — even without the `JOIN`, the "
"SQL standard doesn't guarantee an order, although most implementations will "
"respect it)."
msgstr ""

#: src/reference/stdlib/transforms/take.md:1
msgid "Take"
msgstr ""

#: src/reference/stdlib/transforms/take.md:3
msgid "Picks rows based on their position."
msgstr ""

#: src/reference/stdlib/transforms/take.md:9
msgid ""
"See [Ranges](../../syntax/ranges.md) for more details on how ranges work."
msgstr ""

#: src/reference/stdlib/transforms/window.md:1
msgid "Window"
msgstr ""

#: src/reference/stdlib/transforms/window.md:3
msgid ""
"Applies a pipeline to segments of rows, producing one output value for every "
"input value."
msgstr ""

#: src/reference/stdlib/transforms/window.md:10
msgid ""
"For each row, the segment over which the pipeline is applied is determined "
"by one of:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:13
msgid ""
"`rows`, which takes a range of rows relative to the current row position."
msgstr ""

#: src/reference/stdlib/transforms/window.md:14
msgid "`0` references the current row."
msgstr ""

#: src/reference/stdlib/transforms/window.md:15
msgid "`range`, which takes a range of values relative to current row value."
msgstr ""

#: src/reference/stdlib/transforms/window.md:17
msgid ""
"The bounds of the range are inclusive. If a bound is omitted, the segment "
"will extend until the edge of the table or group."
msgstr ""

#: src/reference/stdlib/transforms/window.md:20
msgid "For ease of use, there are two flags that override `rows` or `range`:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:22
msgid ""
"`expanding:true` is an alias for `rows:..0`. A sum using this window is also "
"known as \"cumulative sum\"."
msgstr ""

#: src/reference/stdlib/transforms/window.md:24
msgid ""
"`rolling:n` is an alias for `rows:(-n+1)..0`, where `n` is an integer. This "
"will include `n` last values, including current row. An average using this "
"window is also knows as a Simple Moving Average."
msgstr ""

#: src/reference/stdlib/transforms/window.md:30
msgid "Expression"
msgstr ""

#: src/reference/stdlib/transforms/window.md:30
msgid "Meaning"
msgstr ""

#: src/reference/stdlib/transforms/window.md:32
msgid "`rows:0..2`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:32
msgid "current row plus two following"
msgstr ""

#: src/reference/stdlib/transforms/window.md:33
msgid "`rows:-2..0`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:33
msgid "two preceding rows plus current row"
msgstr ""

#: src/reference/stdlib/transforms/window.md:34
msgid "`rolling:3`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:34
#: src/reference/stdlib/transforms/window.md:37
msgid "(same as previous)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:35
msgid "`rows:-2..4`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:35
msgid "two preceding rows plus current row plus four following rows"
msgstr ""

#: src/reference/stdlib/transforms/window.md:36
msgid "`rows:..0`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:36
msgid "all rows from the start of the table up to & including current row"
msgstr ""

#: src/reference/stdlib/transforms/window.md:37
msgid "`expanding:true`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:38
msgid "`rows:0..`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:38
msgid "current row and all following rows until the end of the table"
msgstr ""

#: src/reference/stdlib/transforms/window.md:39
msgid "`rows:..`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:39
msgid "all rows, which same as not having window at all"
msgstr ""

#: src/reference/stdlib/transforms/window.md:67
msgid "Rows vs Range:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "time_id"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "value"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "sma3rows"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "sma3range"
msgstr ""

#: src/reference/stdlib/transforms/window.md:90
msgid "1"
msgstr ""

#: src/reference/stdlib/transforms/window.md:90
#: src/reference/stdlib/transforms/window.md:94
msgid "15"
msgstr ""

#: src/reference/stdlib/transforms/window.md:91
msgid "2"
msgstr ""

#: src/reference/stdlib/transforms/window.md:91
msgid "11"
msgstr ""

#: src/reference/stdlib/transforms/window.md:91
msgid "13"
msgstr ""

#: src/reference/stdlib/transforms/window.md:92
msgid "3"
msgstr ""

#: src/reference/stdlib/transforms/window.md:92
msgid "16"
msgstr ""

#: src/reference/stdlib/transforms/window.md:92
msgid "14"
msgstr ""

#: src/reference/stdlib/transforms/window.md:93
msgid "4"
msgstr ""

#: src/reference/stdlib/transforms/window.md:93
msgid "9"
msgstr ""

#: src/reference/stdlib/transforms/window.md:93
msgid "12"
msgstr ""

#: src/reference/stdlib/transforms/window.md:94
msgid "7"
msgstr ""

#: src/reference/stdlib/transforms/window.md:94
msgid "20"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "8"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "22"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "17"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "21"
msgstr ""

#: src/reference/stdlib/transforms/window.md:97
msgid ""
"We can see that rows having `time_id` of 5 and 6 are missing in example "
"data; we can say there are gaps in our time series data."
msgstr ""

#: src/reference/stdlib/transforms/window.md:100
msgid "When computing SMA 3 for the fifth row (`time_id==7`) then:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:102
msgid "\"rows\" will compute average on 3 rows (`time_id` in `3, 4, 7`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:103
msgid "\"range\" will compute average on single row only (`time_id==7`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:105
msgid "When computing SMA 3 for the sixth row (`time_id==8`) then:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:107
msgid "\"rows\" will compute average on 3 rows (`time_id` in `4, 7, 8`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:108
msgid "\"range\" will compute average on 2 rows (`time_id` in `7, 8`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:110
msgid ""
"We can observe that \"rows\" ignores the content of the `time_id`, only uses "
"its order; we can say its window operates on physical rows. On the other "
"hand \"range\" looks at the content of the `time_id` and based on the "
"content decides how many rows fits into window; we can say window operates "
"on logical rows."
msgstr ""

#: src/reference/stdlib/transforms/window.md:115
msgid "Windowing by default"
msgstr ""

#: src/reference/stdlib/transforms/window.md:117
msgid ""
"If you use window functions without `window` transform, they will be applied "
"to the whole table. Unlike in SQL, they will remain window functions and "
"will not trigger aggregation."
msgstr ""

#: src/reference/stdlib/transforms/window.md:127
msgid "You can also only apply `group`:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:137
msgid "Window functions as first class citizens"
msgstr ""

#: src/reference/stdlib/transforms/window.md:139
msgid "There are no limitations on where windowed expressions can be used:"
msgstr ""

#: src/reference/syntax/index.md:1 src/reference/syntax/index.md:11
msgid "Syntax"
msgstr ""

#: src/reference/syntax/index.md:3
msgid "A summary of PRQL syntax:"
msgstr ""

#: src/reference/syntax/index.md:13
msgid "<code>\\|</code>"
msgstr ""

#: src/reference/syntax/index.md:13
msgid "[Pipelines](./function-calls.md)"
msgstr ""

#: src/reference/syntax/index.md:13
msgid "<code>from employees \\| select first_name</code>"
msgstr ""

#: src/reference/syntax/index.md:14
msgid "`=`"
msgstr ""

#: src/reference/syntax/index.md:14
msgid "[Assigns](../declarations/variables.md)"
msgstr ""

#: src/reference/syntax/index.md:14
msgid "`from e = employees` <br> `derive total = (sum salary)`"
msgstr ""

#: src/reference/syntax/index.md:15
msgid "`:`"
msgstr ""

#: src/reference/syntax/index.md:15
msgid "[Named args & parameters](../declarations/functions.md)"
msgstr ""

#: src/reference/syntax/index.md:15
msgid "`interp low:0 1600 sat_score`"
msgstr ""

#: src/reference/syntax/index.md:16
msgid "`{}`"
msgstr ""

#: src/reference/syntax/index.md:16
msgid "[Tuples](./tuples.md)"
msgstr ""

#: src/reference/syntax/index.md:16
msgid "`{id, false, total = 3}`"
msgstr ""

#: src/reference/syntax/index.md:17
msgid "`[]`"
msgstr ""

#: src/reference/syntax/index.md:17
msgid "[Arrays](./arrays.md)"
msgstr ""

#: src/reference/syntax/index.md:17
msgid "`[1, 4, 3, 4]`"
msgstr ""

#: src/reference/syntax/index.md:18
msgid "`!`,`&&`,`==`,`+`"
msgstr ""

#: src/reference/syntax/index.md:18
msgid "[Operators](./operators.md)"
msgstr ""

#: src/reference/syntax/index.md:18
msgid "<code>filter a == b + c \\|\\| d >= e</code>"
msgstr ""

#: src/reference/syntax/index.md:19
msgid "`()`"
msgstr ""

#: src/reference/syntax/index.md:19
msgid "[Parentheses](./operators.md#parentheses)"
msgstr ""

#: src/reference/syntax/index.md:19
msgid "`derive celsius = (fht - 32) / 1.8`"
msgstr ""

#: src/reference/syntax/index.md:20
msgid "`\\`"
msgstr ""

#: src/reference/syntax/index.md:20
msgid "[Line wrap](./operators.md#wrapping-lines)"
msgstr ""

#: src/reference/syntax/index.md:20
msgid "<code>1 + 2 + 3 +</code><br><code>\\\\ 4 + 5</code>"
msgstr ""

#: src/reference/syntax/index.md:21
msgid "`1`,`100_000`,`5e10`"
msgstr ""

#: src/reference/syntax/index.md:21
msgid "[Numbers](./literals.md#numbers)"
msgstr ""

#: src/reference/syntax/index.md:21
msgid "`derive { huge = 5e10 * 10_000 }`"
msgstr ""

#: src/reference/syntax/index.md:22
msgid "`''`,`\"\"`"
msgstr ""

#: src/reference/syntax/index.md:22
msgid "[Strings](./literals.md#strings)"
msgstr ""

#: src/reference/syntax/index.md:22
msgid "`derive name = 'Mary'`"
msgstr ""

#: src/reference/syntax/index.md:23
msgid "`true`,`false`"
msgstr ""

#: src/reference/syntax/index.md:23
msgid "[Booleans](./literals.md#booleans)"
msgstr ""

#: src/reference/syntax/index.md:23
msgid "`derive { Col1 = true }`"
msgstr ""

#: src/reference/syntax/index.md:24
msgid "`null`"
msgstr ""

#: src/reference/syntax/index.md:24
msgid "[Null](./literals.md#null)"
msgstr ""

#: src/reference/syntax/index.md:24
msgid "`filter ( name != null )`"
msgstr ""

#: src/reference/syntax/index.md:25
msgid "`@`"
msgstr ""

#: src/reference/syntax/index.md:25
msgid "[Dates & times](./literals.md#date-and-time)"
msgstr ""

#: src/reference/syntax/index.md:25
msgid "`@2021-01-01`"
msgstr ""

#: src/reference/syntax/index.md:26
msgid "`` ` ` ``"
msgstr ""

#: src/reference/syntax/index.md:26
msgid "[Quoted identifiers](./keywords.md#quoting)"
msgstr ""

#: src/reference/syntax/index.md:26
msgid "``select `first name` ``"
msgstr ""

#: src/reference/syntax/index.md:27
msgid "`#`"
msgstr ""

#: src/reference/syntax/index.md:27
msgid "[Comments](./comments.md)"
msgstr ""

#: src/reference/syntax/index.md:27
msgid "`# A comment`"
msgstr ""

#: src/reference/syntax/index.md:28
msgid "`==`"
msgstr ""

#: src/reference/syntax/index.md:28
msgid ""
"[Self-equality in `join`](../stdlib/transforms/join.md#self-equality-"
"operator)"
msgstr ""

#: src/reference/syntax/index.md:28
msgid "`join s=salaries (==id)`"
msgstr ""

#: src/reference/syntax/index.md:29
msgid "`->`"
msgstr ""

#: src/reference/syntax/index.md:29
msgid "[Function definitions](../declarations/functions.md)"
msgstr ""

#: src/reference/syntax/index.md:29
msgid "`let add = a b -> a + b`"
msgstr ""

#: src/reference/syntax/index.md:30
msgid "`=>`"
msgstr ""

#: src/reference/syntax/index.md:30
msgid "[Case statement](./case.md)"
msgstr ""

#: src/reference/syntax/index.md:30
msgid "`case [a==1 => c, a==2 => d]`"
msgstr ""

#: src/reference/syntax/index.md:31
msgid "`+`,`-`"
msgstr ""

#: src/reference/syntax/index.md:31
msgid "[Sort order](../stdlib/transforms/sort.md)"
msgstr ""

#: src/reference/syntax/index.md:31
msgid "`sort {-amount, +date}`"
msgstr ""

#: src/reference/syntax/index.md:32
msgid "`??`"
msgstr ""

#: src/reference/syntax/index.md:32
msgid "[Coalesce](./operators.md#coalesce)"
msgstr ""

#: src/reference/syntax/index.md:32
msgid "`amount ?? 0`"
msgstr ""

#: src/reference/syntax/arrays.md:3
msgid ""
"Array is a container type, composed of multiple items. All items must be of "
"the same type. Number of fields can be vary."
msgstr ""

#: src/reference/syntax/case.md:1
msgid "Case"
msgstr ""

#: src/reference/syntax/case.md:3
msgid ""
"Search for the first condition that evaluates to `true` and return its "
"associated value. If none of the conditions match, `null` is returned."
msgstr ""

#: src/reference/syntax/case.md:6
msgid ""
"```prql\n"
"from employees\n"
"derive distance = case [\n"
"  city == \"Calgary\" => 0,\n"
"  city == \"Edmonton\" => 300,\n"
"]\n"
"```"
msgstr ""

#: src/reference/syntax/case.md:14
msgid "To set a default, a `true` condition can be used:"
msgstr ""

#: src/reference/syntax/case.md:16
msgid ""
"```prql\n"
"from employees\n"
"derive distance = case [\n"
"  city == \"Calgary\" => 0,\n"
"  city == \"Edmonton\" => 300,\n"
"  true => \"Unknown\",\n"
"]\n"
"```"
msgstr ""

#: src/reference/syntax/comments.md:1
msgid "Comments"
msgstr ""

#: src/reference/syntax/comments.md:3
msgid "Character `#` denotes a comment until the end of the line."
msgstr ""

#: src/reference/syntax/comments.md:11
msgid "There's no distinct multiline comment syntax."
msgstr ""

#: src/reference/syntax/function-calls.md:1
msgid "Function calls"
msgstr ""

#: src/reference/syntax/function-calls.md:3
msgid "Simple"
msgstr ""

#: src/reference/syntax/function-calls.md:5
msgid ""
"A distinction between PRQL and most other programming languages is the "
"function call syntax. It consists of the function name followed by arguments "
"separated by whitespace."
msgstr ""

#: src/reference/syntax/function-calls.md:13
msgid ""
"If one of the arguments is also a function call, it must be encased in "
"parentheses, so we know where arguments of inner function end and the "
"arguments of outer function start."
msgstr ""

#: src/reference/syntax/function-calls.md:21
msgid ""
"The function name must refer to a function variable, which has either [been "
"declared](../declarations/functions.md) in the [standard library](../"
"stdlib/) or some other module."
msgstr ""

#: src/reference/syntax/function-calls.md:25
msgid "Function calls can also specify named parameters using `:` notation:"
msgstr ""

#: src/reference/syntax/function-calls.md:31
msgid "Pipeline"
msgstr ""

#: src/reference/syntax/function-calls.md:33
msgid ""
"There is a alternative way of calling functions: using a pipeline. "
"Regardless of whether the pipeline is delimited by pipe symbol `|` or a new "
"line, the pipeline is equivalent to applying each of functions as the last "
"argument of the next function."
msgstr ""

#: src/reference/syntax/function-calls.md:42
msgid "... is equivalent to ..."
msgstr ""

#: src/reference/syntax/keywords.md:1
msgid "Identifiers & keywords"
msgstr ""

#: src/reference/syntax/keywords.md:3
msgid ""
"Identifiers can contain alphanumeric characters and `_` and must not start "
"with a number. They can be chained together with the `.` indirection "
"operator, used to retrieve a tuple from a field or a variable from a module."
msgstr ""

#: src/reference/syntax/keywords.md:15
msgid "`this` & `that`"
msgstr ""

#: src/reference/syntax/keywords.md:17
msgid "`this` refers to the current relation:"
msgstr ""

#: src/reference/syntax/keywords.md:26
msgid ""
"Within a [`join`](../stdlib/transforms/join.md), `that` refers to the other "
"table:"
msgstr ""

#: src/reference/syntax/keywords.md:34
msgid ""
"`this` can also be used to remove any column ambiguity. For example, "
"currently using a bare `time` as a column name will fail, because it's also "
"a type:"
msgstr ""

#: src/reference/syntax/keywords.md:42
msgid "But with `this.time`, we can remove the ambiguity:"
msgstr ""

#: src/reference/syntax/keywords.md:49
msgid "Quoting"
msgstr ""

#: src/reference/syntax/keywords.md:51
msgid ""
"To use characters that would be otherwise invalid, identifiers can be "
"surrounded by with backticks."
msgstr ""

#: src/reference/syntax/keywords.md:54
msgid ""
"When compiling to SQL, these identifiers will use dialect-specific quotes "
"and quoting rules."
msgstr ""

#: src/reference/syntax/keywords.md:76
msgid "Schemas & database names"
msgstr ""

#: src/reference/syntax/keywords.md:78
msgid ""
"Identifiers of database tables can be prefixed with schema and databases "
"names."
msgstr ""

#: src/reference/syntax/keywords.md:84
msgid ""
"Note that all of following identifiers will be treated as separate table "
"definitions: `tracks`, `public.tracks`, `my_database.public.tracks`."
msgstr ""

#: src/reference/syntax/keywords.md:87
msgid "Keywords"
msgstr ""

#: src/reference/syntax/keywords.md:89
msgid "PRQL uses following keywords:"
msgstr ""

#: src/reference/syntax/keywords.md:91
msgid "**`prql`** - query header [_more..._](../../project/target.md)"
msgstr ""

#: src/reference/syntax/keywords.md:92
msgid ""
"**`let`** - variable definition [_more..._](../declarations/variables.md)"
msgstr ""

#: src/reference/syntax/keywords.md:93
msgid ""
"**`into`** - variable definition [_more..._](../declarations/variables.md)"
msgstr ""

#: src/reference/syntax/keywords.md:94
msgid "**`case`** - flow control [_more..._](../syntax/case.md)"
msgstr ""

#: src/reference/syntax/keywords.md:95
msgid "**`type`** - type declaration"
msgstr ""

#: src/reference/syntax/keywords.md:96
msgid ""
"**`func`** - explicit function declaration [_more..._](../declarations/"
"functions.md)"
msgstr ""

#: src/reference/syntax/keywords.md:98
msgid "**`module`** - used internally"
msgstr ""

#: src/reference/syntax/keywords.md:99
msgid "**`internal`** - used internally"
msgstr ""

#: src/reference/syntax/keywords.md:100
msgid "**`true`** - boolean [_more..._](./literals.md#booleans)"
msgstr ""

#: src/reference/syntax/keywords.md:101
msgid "**`false`** - boolean [_more..._](./literals.md#booleans)"
msgstr ""

#: src/reference/syntax/keywords.md:102
msgid "**`null`** - NULL [_more..._](./literals.md#null)"
msgstr ""

#: src/reference/syntax/keywords.md:104
msgid ""
"Keywords can be used as identifiers (of columns or variables) when encased "
"in backticks: `` `case` ``."
msgstr ""

#: src/reference/syntax/keywords.md:107
msgid ""
"Transforms are normal functions within the `std` namespace, not keywords. "
"That is, `std.from` is the same function as `from`. In the example below, "
"the resulting query is the same as without the `std.` namespace:"
msgstr ""

#: src/reference/syntax/literals.md:1
msgid "Literals"
msgstr ""

#: src/reference/syntax/literals.md:3
msgid ""
"A literal is a constant value expression, with special syntax rules for each "
"data type."
msgstr ""

#: src/reference/syntax/literals.md:6
msgid "Numbers"
msgstr ""

#: src/reference/syntax/literals.md:8
msgid ""
"Number literals can contain number characters as well as a period, "
"underscores and char `e`."
msgstr ""

#: src/reference/syntax/literals.md:11
msgid ""
"If a number literal contains a dot or character `e`, it is treated as "
"floating point number (or just _float_), otherwise it is treated as integer "
"number."
msgstr ""

#: src/reference/syntax/literals.md:14
msgid ""
"Character `e` denotes [\"scientific notation\"](https://en.wikipedia.org/"
"wiki/Scientific_notation), where the number after `e` is the exponent in 10-"
"base."
msgstr ""

#: src/reference/syntax/literals.md:18
msgid ""
"Underscores are ignored, so they can be placed at arbitrary positions, but "
"it is advised to use them as thousand separators."
msgstr ""

#: src/reference/syntax/literals.md:21
msgid ""
"Integers can, alternatively, be expressed using hexadecimal, octal or binary "
"notation using these prefixes respectively: `0x`, `0o` or `0b`."
msgstr ""

#: src/reference/syntax/literals.md:36
msgid "Strings"
msgstr ""

#: src/reference/syntax/literals.md:38
msgid ""
"PRQL supports string literals and several other formats of strings. See the "
"[Strings](./strings.md) page for more information."
msgstr ""

#: src/reference/syntax/literals.md:41
msgid "Booleans"
msgstr ""

#: src/reference/syntax/literals.md:43
msgid "Boolean values can be expressed with `true` or `false` keyword."
msgstr ""

#: src/reference/syntax/literals.md:45
msgid "Null"
msgstr ""

#: src/reference/syntax/literals.md:47
msgid ""
"The null value can be expressed with `null` keyword. See also the discussion "
"of how [PRQL handles nulls](../spec/null.md)."
msgstr ""

#: src/reference/syntax/literals.md:50
msgid "Date and time"
msgstr ""

#: src/reference/syntax/literals.md:52
msgid ""
"Date and time literals are expressed with character `@`, followed by a "
"string that encodes the date & time."
msgstr ""

#: src/reference/syntax/literals.md:61
msgid "Dates"
msgstr ""

#: src/reference/syntax/literals.md:63
msgid ""
"Dates are represented by `@{yyyy-mm-dd}` — a `@` followed by the date format."
msgstr ""

#: src/reference/syntax/literals.md:70
msgid "Times"
msgstr ""

#: src/reference/syntax/literals.md:72
msgid ""
"Times are represented by `@{HH:mm:ss.SSS±Z}` with any parts not supplied "
"defaulting to zero. This includes the timezone, which is represented by `+HH:"
"mm`, `-HH:mm` or `Z`. This is consistent with the ISO8601 time format."
msgstr ""

#: src/reference/syntax/literals.md:81
msgid "Timestamps"
msgstr ""

#: src/reference/syntax/literals.md:83
msgid ""
"Timestamps are represented by `@{yyyy-mm-ddTHH:mm:ss.SSS±Z}` / `@{date}"
"T{time}`, with any time parts not supplied being rounded to zero, including "
"the timezone, which is represented by `+HH:mm`, `-HH:mm` or `Z` (`:` is "
"optional). This is `@` followed by the ISO8601 datetime format, which uses "
"`T` to separate date & time."
msgstr ""

#: src/reference/syntax/literals.md:94
msgid "Durations"
msgstr ""

#: src/reference/syntax/literals.md:96
msgid ""
"Durations are represented by `{N}{periods}`, such as `2years` or "
"`10minutes`, without a space."
msgstr ""

#: src/reference/syntax/literals.md:114
msgid "Here's a larger list of date and time examples:"
msgstr ""

#: src/reference/syntax/literals.md:116
msgid ""
"`@20221231` is invalid — it must contain full punctuation (`-` and `:`),"
msgstr ""

#: src/reference/syntax/literals.md:117
msgid "`@2022-12-31` is a date"
msgstr ""

#: src/reference/syntax/literals.md:118
msgid ""
"`@2022-12` or `@2022` are invalid — SQL can't express a month, only a date"
msgstr ""

#: src/reference/syntax/literals.md:119
msgid "`@16:54:32.123456` is a time"
msgstr ""

#: src/reference/syntax/literals.md:120
msgid ""
"`@16:54:32`, `@16:54`, `@16` are all allowed, expressing `@16:54:32.000000`, "
"`@16:54:00.000000`, `@16:00:00.000000` respectively"
msgstr ""

#: src/reference/syntax/literals.md:122
msgid "`@2022-12-31T16:54:32.123456` is a timestamp without timezone"
msgstr ""

#: src/reference/syntax/literals.md:123
msgid "`@2022-12-31T16:54:32.123456Z` is a timestamp in UTC"
msgstr ""

#: src/reference/syntax/literals.md:124
msgid "`@2022-12-31T16:54+02` is timestamp in UTC+2"
msgstr ""

#: src/reference/syntax/literals.md:125
msgid ""
"`@2022-12-31T16:54+02:00` and `@2022-12-31T16:54+02` are datetimes in UTC+2"
msgstr ""

#: src/reference/syntax/literals.md:126
msgid ""
"`@16:54+02` is invalid — time is always local, so it cannot have a timezone"
msgstr ""

#: src/reference/syntax/literals.md:127
msgid ""
"`@2022-12-31+02` is invalid — date is always local, so it cannot have a "
"timezone"
msgstr ""

#: src/reference/syntax/literals.md:130
msgid ""
"```admonish note\n"
"Currently prqlc does not parse or validate any of the datetime strings\n"
"and will pass them to the database engine without adjustment. This might be\n"
"refined in the future to aid in compatibility across databases. We'll "
"always\n"
"support the canonical [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) "
"format\n"
"described above.\n"
"```"
msgstr ""

#: src/reference/syntax/literals.md:138
msgid "Roadmap"
msgstr ""

#: src/reference/syntax/literals.md:140
msgid ""
"Datetimes (as a distinct datatype from the timestamps) are supported by some "
"databases (e.g. MySql, BigQuery). With the addition of type casts, these "
"could be represented by a timestamp cast to a datetime:"
msgstr ""

#: src/reference/syntax/literals.md:148
msgid "These are some examples we can then add:"
msgstr ""

#: src/reference/syntax/literals.md:150
msgid "`@2022-12-31T16:54<datetime>` is datetime without timezone"
msgstr ""

#: src/reference/syntax/literals.md:151
msgid "`@2022-12-31<datetime>` is forbidden — datetime must specify time"
msgstr ""

#: src/reference/syntax/literals.md:152
msgid "`@16:54<datetime>` is forbidden — datetime must specify date"
msgstr ""

#: src/reference/syntax/operators.md:1
msgid "Operators"
msgstr ""

#: src/reference/syntax/operators.md:3
msgid ""
"Expressions can be composed from _function calls_ and _operations_, such as "
"`2 + 3` or `((1 + x) * -y)`. In the example below, note the use of "
"expressions to calculate the alias `circumference` and in the `filter` "
"transform."
msgstr ""

#: src/reference/syntax/operators.md:7
msgid ""
"```prql\n"
"from foo\n"
"select {\n"
"  circumference = diameter * 3.14159,\n"
"  color,\n"
"}\n"
"filter circumference > 10 && color != \"red\"\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:16
msgid "Operator precedence"
msgstr ""

#: src/reference/syntax/operators.md:18
msgid ""
"This table shows operator precedence. Use parentheses `()` to prioritize "
"operations and for function calls (see the discussion below.)"
msgstr ""

#: src/reference/syntax/operators.md:23
msgid ""
"\\|          Group | Operators                   | Precedence | "
"Associativity | \\| -------------: | --------------------------- "
"| :--------: | :-----------: | --- | --- | \\|    parentheses | "
"`()`                        |     0      |   see below   | \\| identifier "
"dot | `.`                         |     1      |               | "
"\\|          unary | `-` `+` `!` `==`            |     2      "
"|               | \\|          range | `..`                        |     "
"3      |               | \\|           <!-- | pow                         "
"|    `**`    |       4       |     | --> | \\|            mul | `*` `/` `//` "
"`%`            |     5      | left-to-right | \\|            add | `+` `-"
"`                     |     6      | left-to-right | \\|        compare | "
"`==` `!=` `<=` `>=` `<` `>` |     7      | left-to-right | \\|       "
"coalesce | `??`                        |     8      | left-to-right | "
"\\|            and | `&&`                        |     9      | left-to-"
"right | \\|             or | <code>\\|\\|</code>           |     10     | "
"left-to-right | \\|  function call |                             |     "
"11     |               |"
msgstr ""

#: src/reference/syntax/operators.md:38
msgid "Division and integer division"
msgstr ""

#: src/reference/syntax/operators.md:40
msgid ""
"The `/` operator performs division that always returns a float value, while "
"the `//` operator does integer division (truncated division) that always "
"returns an integer value."
msgstr ""

#: src/reference/syntax/operators.md:44
msgid ""
"```prql\n"
"prql target:sql.sqlite\n"
"\n"
"from [\n"
"  {a = 5, b = 2},\n"
"  {a = 5, b = -2},\n"
"]\n"
"select {\n"
"  div_out = a / b,\n"
"  int_div_out = a // b,\n"
"}\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:57
msgid "Coalesce"
msgstr ""

#: src/reference/syntax/operators.md:59
msgid ""
"We can coalesce values with an `??` operator. Coalescing takes either the "
"first value or, if that value is null, the second value."
msgstr ""

#: src/reference/syntax/operators.md:67
msgid "Regex expressions"
msgstr ""

#: src/reference/syntax/operators.md:73
msgid ""
"To perform a case-sensitive regex search, use the `~=` operator. This "
"generally compiles to `REGEXP`, though differs by dialect. A regex search "
"means that to match an exact value, the start and end need to be anchored "
"with `^foo$`."
msgstr ""

#: src/reference/syntax/operators.md:77
msgid ""
"```prql\n"
"from tracks\n"
"filter (name ~= \"Love\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:82
msgid ""
"```prql\n"
"prql target:sql.duckdb\n"
"\n"
"from artists\n"
"filter (name ~= \"Love.*You\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:89
msgid ""
"```prql\n"
"prql target:sql.bigquery\n"
"\n"
"from tracks\n"
"filter (name ~= \"\\\\bLove\\\\b\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:96
msgid ""
"```prql\n"
"prql target:sql.postgres\n"
"\n"
"from tracks\n"
"filter (name ~= \"\\\\(I Can't Help\\\\) Falling\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:103
msgid ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from tracks\n"
"filter (name ~= \"With You\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:110
msgid ""
"```prql\n"
"prql target:sql.sqlite\n"
"\n"
"from tracks\n"
"filter (name ~= \"But Why Isn't Your Syntax More Similar\\\\?\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:117
msgid "Parentheses"
msgstr ""

#: src/reference/syntax/operators.md:119
msgid "PRQL uses parentheses `()` for several purposes:"
msgstr ""

#: src/reference/syntax/operators.md:121
msgid ""
"Parentheses group operands to control the order of evaluation, for example: "
"`((1 + x) * y)`"
msgstr ""

#: src/reference/syntax/operators.md:124
msgid ""
"Parentheses delimit a minus sign of a function argument, for example: `add "
"(-1) (-3)`"
msgstr ""

#: src/reference/syntax/operators.md:127
msgid ""
"Parentheses delimit nested function calls that contain a pipe, either the `|"
"` symbol or a new line. “Nested” means within a transform; i.e. not just the "
"main pipeline, for example: `(column-name | in 0..20)`"
msgstr ""

#: src/reference/syntax/operators.md:131
msgid ""
"Parentheses wrap a function call that is part of a larger expression, for "
"example: `math.round 0 (sum distance)`"
msgstr ""

#: src/reference/syntax/operators.md:134
msgid ""
"Parentheses are _not_ required for expressions that do not contain function "
"calls, for example: `foo + bar`."
msgstr ""

#: src/reference/syntax/operators.md:137
msgid "Here's a set of examples of these rules:"
msgstr ""

#: src/reference/syntax/operators.md:170
msgid ""
"For example, the snippet below produces an error because the `sum` function "
"call is not in a tuple."
msgstr ""

#: src/reference/syntax/operators.md:178
msgid "...while with parentheses, it works at expected:"
msgstr ""

#: src/reference/syntax/operators.md:191
msgid "Wrapping lines"
msgstr ""

#: src/reference/syntax/operators.md:193
msgid ""
"Line breaks in PRQL have semantic meaning, so to wrap a single logical line "
"into multiple physical lines, we can use `\\` at the beginning of subsequent "
"physical lines:"
msgstr ""

#: src/reference/syntax/operators.md:197
msgid ""
"```prql\n"
"from artists\n"
"select is_europe =\n"
"\\ country == \"DE\"\n"
"\\ || country == \"FR\"\n"
"\\ || country == \"ES\"\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:205
msgid ""
"Wrapping will \"jump over\" empty lines or lines with comments. For example, "
"the `select` here is only one logical line:"
msgstr ""

#: src/reference/syntax/operators.md:227
msgid "See [Pipes](./pipes.md) for more details on line breaks."
msgstr ""

#: src/reference/syntax/parameters.md:3
msgid ""
"Parameter is a placeholder for a value provided after the compilation of the "
"query."
msgstr ""

#: src/reference/syntax/parameters.md:6
msgid ""
"It uses the following syntax: `$id`, where `id` is an arbitrary alpha "
"numeric string."
msgstr ""

#: src/reference/syntax/parameters.md:9
msgid ""
"Most database engines only support numeric positional parameter ids (i.e "
"`$3`)."
msgstr ""

#: src/reference/syntax/pipes.md:1
msgid "Pipes"
msgstr ""

#: src/reference/syntax/pipes.md:3
msgid ""
"Pipes are the connection between [transforms](../stdlib/transforms/) that "
"make up a pipeline. The relation produced by a transform before the pipe is "
"used as the input for the transform following the pipe. A pipe can be "
"represented with either a line break or a pipe character (`|`)."
msgstr ""

#: src/reference/syntax/pipes.md:8
msgid ""
"For example, here the `filter` transform operates on the result of `from "
"employees` (which is just the `employees` table), and the `select` transform "
"operates on the result of the `filter` transform."
msgstr ""

#: src/reference/syntax/pipes.md:12
msgid ""
"```prql\n"
"from employees\n"
"filter department == \"Product\"\n"
"select {first_name, last_name}\n"
"```"
msgstr ""

#: src/reference/syntax/pipes.md:18
msgid ""
"In the place of a line break, it's also possible to use the `|` character to "
"pipe results between transforms, such that this is equivalent:"
msgstr ""

#: src/reference/syntax/pipes.md:21
msgid ""
"```prql\n"
"from employees | filter department == \"Product\" | select {first_name, "
"last_name}\n"
"```"
msgstr ""

#: src/reference/syntax/pipes.md:25
msgid "\"C'est ne pas un pipe\""
msgstr ""

#: src/reference/syntax/pipes.md:27
msgid ""
"In almost all situations, a line break acts as a pipe. But there are a few "
"cases where a line break doesn't act as a pipe."
msgstr ""

#: src/reference/syntax/pipes.md:30
msgid "before or after tuple items"
msgstr ""

#: src/reference/syntax/pipes.md:31
msgid "before or after list items"
msgstr ""

#: src/reference/syntax/pipes.md:32
msgid "before a new statement, which starts with `let` or `from` (or `func`)"
msgstr ""

#: src/reference/syntax/pipes.md:33
msgid "within a [line wrap](./operators.md#wrapping-lines)"
msgstr ""

#: src/reference/syntax/pipes.md:35
msgid "For example:"
msgstr ""

#: src/reference/syntax/pipes.md:56
msgid "Inner Transforms"
msgstr ""

#: src/reference/syntax/pipes.md:60
msgid ""
"Parentheses are also used for transforms (such as `group` and `window`) that "
"pass their result to an \"inner transform\". The example below applies the "
"`aggregate` pipeline to each group of unique `title` and `country` values:"
msgstr ""

#: src/reference/syntax/ranges.md:1
msgid "Ranges"
msgstr ""

#: src/reference/syntax/ranges.md:3
msgid ""
"Range `start..end` represents as set of values between `start` and `end`, "
"inclusive (greater of equal to `start` and less than or equal to `end`)."
msgstr ""

#: src/reference/syntax/ranges.md:6
msgid ""
"To express a range that is open on one side, either `start` or `end` can be "
"omitted."
msgstr ""

#: src/reference/syntax/ranges.md:9
msgid ""
"Ranges can be used in filters with the `in` function, with any type of "
"literal, including dates:"
msgstr ""

#: src/reference/syntax/ranges.md:19
msgid "Ranges can also be used in `take`:"
msgstr ""

#: src/reference/syntax/ranges.md:34
msgid "[take transform](../stdlib/transforms/take.md)"
msgstr ""

#: src/reference/syntax/ranges.md:38
msgid ""
"We'd like to use ranges for other types, such as whether an object is in an "
"array or list literal."
msgstr ""

#: src/reference/syntax/strings.md:3
msgid ""
"String literals can use any matching odd number of either single or double "
"quotes:"
msgstr ""

#: src/reference/syntax/strings.md:6
msgid ""
"```prql\n"
"from artists\n"
"derive {\n"
"  single        =   'hello world',\n"
"  double        =   \"hello world\",\n"
"  double_triple = \"\"\"hello world\"\"\",\n"
"}\n"
"```"
msgstr ""

#: src/reference/syntax/strings.md:15
msgid "Quoting and escape characters"
msgstr ""

#: src/reference/syntax/strings.md:17
msgid ""
"To quote a string containing quote characters, use the \"other\" type of "
"quote, or use the escape character `\\`, or use more quotes."
msgstr ""

#: src/reference/syntax/strings.md:20
msgid ""
"```prql\n"
"from artists\n"
"select {\n"
"  other   = '\"hello world\"',\n"
"  escaped = \"\\\"hello world\\\"\",\n"
"  triple  = \"\"\"I said \"hello world\"!\"\"\",\n"
"}\n"
"```"
msgstr ""

#: src/reference/syntax/strings.md:29
msgid ""
"Strings can contain any escape character sequences defined by the [JSON "
"standard](https://www.ecma-international.org/publications-and-standards/"
"standards/ecma-404/)."
msgstr ""

#: src/reference/syntax/strings.md:32
msgid ""
"```prql\n"
"from artists\n"
"derive escapes = \"\\tXYZ\\n \\\\ \"                            # tab (\\t), "
"\"XYZ\", newline (\\n), \" \", \\, \" \"\n"
"derive world = \"\\u{0048}\\u{0065}\\u{006C}\\u{006C}\\u{006F}\" # "
"\"Hello\"\n"
"derive hex = \"\\x48\\x65\\x6C\\x6C\\x6F\"                       # "
"\"Hello\"\n"
"derive turtle = \"\\u{01F422}\"                              # \"🐢\"\n"
"```"
msgstr ""

#: src/reference/syntax/strings.md:40
msgid "Other string formats"
msgstr ""

#: src/reference/syntax/strings.md:42
msgid ""
"[**F-strings**](./f-strings.md) - Build up a new string from a set of "
"columns or values."
msgstr ""

#: src/reference/syntax/strings.md:44
msgid ""
"[**R-strings**](./r-strings.md) - Include the raw characters of the string "
"without any form of escaping."
msgstr ""

#: src/reference/syntax/strings.md:46
msgid ""
"[**S-strings**](./s-strings.md) - Insert SQL statements directly into the "
"query. Use when PRQL doesn't have an equivalent facility."
msgstr ""

#: src/reference/syntax/strings.md:64
msgid "Escape sequences"
msgstr ""

#: src/reference/syntax/strings.md:66
msgid ""
"Unless an `r` prefix is present, escape sequences in string literals are "
"interpreted according to rules similar to those used by Standard C. The "
"recognized escape sequences are:"
msgstr ""

#: src/reference/syntax/strings.md:70
msgid "Escape Sequence"
msgstr ""

#: src/reference/syntax/strings.md:72
msgid "`\\\\`"
msgstr ""

#: src/reference/syntax/strings.md:72
msgid "Backslash ()"
msgstr ""

#: src/reference/syntax/strings.md:73
msgid "`\\'`"
msgstr ""

#: src/reference/syntax/strings.md:73
msgid "Single quote (')"
msgstr ""

#: src/reference/syntax/strings.md:74
msgid "`\\\"`"
msgstr ""

#: src/reference/syntax/strings.md:74
msgid "Double quote (\")"
msgstr ""

#: src/reference/syntax/strings.md:75
msgid "`\\b`"
msgstr ""

#: src/reference/syntax/strings.md:75
msgid "Backspace"
msgstr ""

#: src/reference/syntax/strings.md:76
msgid "`\\f`"
msgstr ""

#: src/reference/syntax/strings.md:76
msgid "Formfeed"
msgstr ""

#: src/reference/syntax/strings.md:77
msgid "`\\n`"
msgstr ""

#: src/reference/syntax/strings.md:77
msgid "ASCII Linefeed (LF)"
msgstr ""

#: src/reference/syntax/strings.md:78
msgid "`\\r`"
msgstr ""

#: src/reference/syntax/strings.md:78
msgid "ASCII Carriage Return (CR)"
msgstr ""

#: src/reference/syntax/strings.md:79
msgid "`\\t`"
msgstr ""

#: src/reference/syntax/strings.md:79
msgid "ASCII Horizontal Tab (TAB)"
msgstr ""

#: src/reference/syntax/strings.md:80
msgid "`\\xhh`"
msgstr ""

#: src/reference/syntax/strings.md:80
msgid "Character with hex value hh"
msgstr ""

#: src/reference/syntax/strings.md:81
msgid "`\\u{xxxx}`"
msgstr ""

#: src/reference/syntax/strings.md:81
msgid "Character with hex value xxxx"
msgstr ""

#: src/reference/syntax/f-strings.md:1
msgid "F-strings"
msgstr ""

#: src/reference/syntax/f-strings.md:3
msgid ""
"F-strings are a readable approach to building new strings from existing "
"strings & variables."
msgstr ""

#: src/reference/syntax/f-strings.md:6
msgid ""
"```prql\n"
"from employees\n"
"select full_name = f\"{first_name} {last_name}\"\n"
"```"
msgstr ""

#: src/reference/syntax/f-strings.md:11
msgid ""
"This can be much easier to read for longer strings, relative to the SQL "
"approach:"
msgstr ""

#: src/reference/syntax/f-strings.md:14
msgid ""
"```prql\n"
"from web\n"
"select url = f\"http{tls}://www.{domain}.{tld}/{page}\"\n"
"```"
msgstr ""

#: src/reference/syntax/f-strings.md:19
msgid ""
"Note that currently interpolations can only contain plain variable names and "
"not whole expressions like Python, so this won't work:"
msgstr ""

#: src/reference/syntax/f-strings.md:22
msgid ""
"```prql error no-fmt\n"
"from tracks\n"
"select length_str = f\"{length_seconds / 60} minutes\"\n"
"```"
msgstr ""

#: src/reference/syntax/f-strings.md:29
msgid ""
"In the future, f-strings may incorporate string formatting such as "
"datetimes, numbers, and padding. If there's a feature that would be helpful, "
"please [post an issue](https://github.com/PRQL/prql/issues/new/)."
msgstr ""

#: src/reference/syntax/r-strings.md:1
msgid "R-strings"
msgstr ""

#: src/reference/syntax/r-strings.md:3
msgid "R-strings handle escape characters without special treatment:"
msgstr ""

#: src/reference/syntax/r-strings.md:5
msgid ""
"```prql\n"
"from artists\n"
"derive normal_string =  \"\\\\\\t\"   #  two characters - \\ and tab (\\t)\n"
"derive raw_string    = r\"\\\\\\t\"   # four characters - \\, \\, \\, and t\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:1
msgid "S-strings"
msgstr ""

#: src/reference/syntax/s-strings.md:3
msgid ""
"An s-string inserts SQL directly, as an escape hatch when there's something "
"that PRQL doesn't yet implement. For example, there's a `version()` function "
"in PostgreSQL that returns the PostgreSQL version, so if we want to use "
"that, we use an s-string:"
msgstr ""

#: src/reference/syntax/s-strings.md:8
msgid ""
"```prql\n"
"from my_table\n"
"select db_version = s\"version()\"\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:13
msgid ""
"Embed a column name in an s-string using braces. For example, PRQL's "
"standard library defines the `average` function as:"
msgstr ""

#: src/reference/syntax/s-strings.md:16
msgid ""
"```prql no-eval\n"
"let average = column -> s\"AVG({column})\"\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:20
msgid "So this compiles using the function:"
msgstr ""

#: src/reference/syntax/s-strings.md:27
msgid ""
"```admonish note\n"
"Because S-string contents are SQL, double-quotes (`\"`) will denote a "
"_column name_.\n"
"To avoid that, use single-quotes (`'`) around the SQL string, and\n"
"adjust the quotes of the S-string. For example, instead of "
"`s'CONCAT(\"hello\", \"world\")'` use `s\"CONCAT('hello', 'world')\"`\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:33
msgid "Here's an example of a more involved use of an s-string:"
msgstr ""

#: src/reference/syntax/s-strings.md:35
msgid ""
"```prql\n"
"from de=dept_emp\n"
"join s=salaries side:left (s.emp_no == de.emp_no && s\"\"\"\n"
"  ({s.from_date}, {s.to_date})\n"
"  OVERLAPS\n"
"  ({de.from_date}, {de.to_date})\n"
"\"\"\")\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:44
msgid ""
"For those who have used Python, s-strings are similar to Python's f-strings, "
"but the result is SQL code, rather than a string literal. For example, a "
"Python f-string of `f\"average({col})\"` would produce "
"`\"average(salary)\"`, with quotes; while in PRQL, `s\"average({col})\"` "
"produces `average(salary)`, without quotes."
msgstr ""

#: src/reference/syntax/s-strings.md:49
msgid ""
"Note that interpolations can only contain plain variable names and not whole "
"expression like Python."
msgstr ""

#: src/reference/syntax/s-strings.md:52
msgid "We can also use s-strings to produce a full table:"
msgstr ""

#: src/reference/syntax/s-strings.md:54
msgid ""
"```prql\n"
"from s\"SELECT DISTINCT ON first_name, id, age FROM employees ORDER BY age "
"ASC\"\n"
"join s = s\"SELECT * FROM salaries\" (==id)\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:59
msgid ""
"```admonish note\n"
"S-strings in user code are intended as an escape hatch for an unimplemented\n"
"feature. If we often need s-strings to express something, that's a sign we\n"
"should implement it in PRQL or PRQL's stdlib. If you often require an s-"
"string,\n"
"[submit an issue with your use case](https://github.com/PRQL/prql/issues/new/"
"choose).\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:66
msgid "Braces"
msgstr ""

#: src/reference/syntax/s-strings.md:68
msgid "To output braces from an s-string, use double braces:"
msgstr ""

#: src/reference/syntax/s-strings.md:70
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  has_valid_title = s\"regexp_contains(title, '([a-z0-9]*-){{2,}}')\"\n"
"}\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:77
msgid "Precedence within s-strings"
msgstr ""

#: src/reference/syntax/s-strings.md:79
msgid ""
"Variables in s-strings are inserted into the SQL source as-is, which means "
"we may get surprising behavior when the variable has multiple terms and the "
"s-string isn't parenthesized."
msgstr ""

#: src/reference/syntax/s-strings.md:83
msgid ""
"In this toy example, the expression `salary + benefits / 365` gets "
"precedence wrong. The generated SQL code is as if we had written `salary + "
"(benefits / 365)`."
msgstr ""

#: src/reference/syntax/s-strings.md:87
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"{gross_salary} / 365\"\n"
"}\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:95
msgid "Instead, the numerator `{gross_salary}` must be encased in parentheses:"
msgstr ""

#: src/reference/syntax/s-strings.md:97
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"({gross_salary}) / 365\"\n"
"}\n"
"```"
msgstr ""

#: src/reference/syntax/tuples.md:3
msgid ""
"Tuple is a container type, composed of multiple fields. Each field can have "
"a different type. Number of fields and their types must be known at compile "
"time."
msgstr ""

#: src/reference/syntax/tuples.md:6
msgid ""
"Tuple is represented by `{}`. It can span multiple lines. Fields can be "
"assigned a name. Fields are separated by commas, trailing trailing comma is "
"optional."
msgstr ""

#: src/reference/syntax/tuples.md:23
msgid ""
"Tuples are the type of a table row, which means that they are expected by "
"many transforms. Most transforms can also take a single field, which will be "
"converted into a tuple. These are equivalent:"
msgstr ""

#: src/index.md:1
msgid "PRQL language book"
msgstr ""

#: src/index.md:3
msgid ""
"**P**ipelined **R**elational **Q**uery **L**anguage, pronounced \"Prequel\"."
msgstr ""

#: src/index.md:5
msgid ""
"PRQL is a modern language for transforming data — a simple, powerful, "
"pipelined SQL replacement. Like SQL, it's readable, explicit and "
"declarative. Unlike SQL, it forms a logical pipeline of transformations, and "
"supports abstractions such as variables and functions. It can be used with "
"any database that uses SQL, since it compiles to SQL."
msgstr ""

#: src/index.md:11
msgid ""
"This book serves as a tutorial and reference guide on the language and the "
"broader project. It currently has three sections, navigated by links on the "
"left:"
msgstr ""

#: src/index.md:15
msgid ""
"**Tutorial** — A friendly & accessible guide for learning PRQL. It has a "
"gradual increase of difficulty and requires only basic understanding of "
"programming languages. Knowledge of SQL is beneficial, because of many "
"comparisons to SQL, but not required."
msgstr ""

#: src/index.md:19
msgid ""
"**Reference** — In-depth information about the PRQL language. Includes "
"justifications for language design decisions and formal specifications for "
"parts of the language."
msgstr ""

#: src/index.md:22
msgid ""
"**Project** — General information about the project, tooling and development."
msgstr ""

#: src/index.md:26
msgid ""
"To lead with a couple of examples, with a comparison to SQL: the language "
"can be as simple as:"
msgstr ""

#: src/index.md:29
msgid ""
"```prql\n"
"from tracks\n"
"filter artist == \"Bob Marley\"                 # Each line transforms the "
"previous result\n"
"aggregate {                                   # `aggregate` reduces each "
"column to a value\n"
"  plays    = sum plays,\n"
"  longest  = max length,\n"
"  shortest = min length,                      # Trailing commas are allowed\n"
"}\n"
"```"
msgstr ""

#: src/index.md:39
msgid "...and here's a fuller example:"
msgstr ""

#: src/index.md:41
msgid ""
"```prql\n"
"from employees\n"
"filter start_date > @2021-01-01               # Clear date syntax\n"
"derive {                                      # `derive` adds columns / "
"variables\n"
"  gross_salary = salary + (tax ?? 0),         # Terse coalesce\n"
"  gross_cost = gross_salary + benefits_cost,  # Variables can use other "
"variables\n"
"}\n"
"filter gross_cost > 0\n"
"group {title, country} (                      # `group` runs a pipeline over "
"each group\n"
"  aggregate {                                 # `aggregate` reduces each "
"group to a value\n"
"    average gross_salary,\n"
"    sum_gross_cost = sum gross_cost,          # `=` sets a column name\n"
"  }\n"
")\n"
"filter sum_gross_cost > 100_000               # `filter` replaces both of "
"SQL's `WHERE` & `HAVING`\n"
"derive id = f\"{title}_{country}\"              # F-strings like Python\n"
"derive country_code = s\"LEFT(country, 2)\"     # S-strings allow using SQL "
"as an escape hatch\n"
"sort {sum_gross_cost, -country}               # `-country` means descending "
"order\n"
"take 1..20                                    # Range expressions (also "
"valid here as `take 20`)\n"
"```"
msgstr ""

#: src/SUMMARY.md:3 src/SUMMARY.md:5
msgid "Introduction"
msgstr ""

#: src/SUMMARY.md:7
msgid "Tutorial"
msgstr ""

#: src/SUMMARY.md:9
msgid ""
"A friendly & accessible guide for learning PRQL. It has a gradual increase "
"of difficulty and requires only basic understanding of programming "
"languages. Knowledge of SQL is beneficial, because of many comparisons to "
"SQL, but not required."
msgstr ""

#: src/SUMMARY.md:14
msgid "Relations"
msgstr ""

#: src/SUMMARY.md:15
msgid "Filtering"
msgstr ""

#: src/SUMMARY.md:16
msgid "Aggregation"
msgstr ""

#: src/SUMMARY.md:21
msgid "Reference"
msgstr ""

#: src/SUMMARY.md:23
msgid ""
"In-depth information about the PRQL language. Includes justifications for "
"language design decisions and formal specifications for parts of the "
"language."
msgstr ""

#: src/SUMMARY.md:48
msgid "Ad-hoc data"
msgstr ""

#: src/SUMMARY.md:50
msgid "Declarations"
msgstr ""

#: src/SUMMARY.md:72
msgid "Aggregation functions"
msgstr ""

#: src/SUMMARY.md:76
msgid "Removing duplicates"
msgstr ""

#: src/SUMMARY.md:85
msgid "Project"
msgstr ""

#: src/SUMMARY.md:87
msgid "General information about the project, tooling and development."
msgstr ""

#: src/SUMMARY.md:89
msgid "Changelog"
msgstr ""

#: src/SUMMARY.md:91
msgid "Target & version"
msgstr ""

#: src/SUMMARY.md:95
msgid ".NET"
msgstr ""

#: src/SUMMARY.md:96
msgid "Elixir"
msgstr ""

#: src/SUMMARY.md:97
msgid "Java"
msgstr ""

#: src/SUMMARY.md:98
msgid "JavaScript"
msgstr ""

#: src/SUMMARY.md:99
msgid "PHP"
msgstr ""

#: src/SUMMARY.md:100
msgid "Python"
msgstr ""

#: src/SUMMARY.md:101
msgid "R"
msgstr ""

#: src/SUMMARY.md:102
msgid "Rust"
msgstr ""

#: src/SUMMARY.md:106
msgid "`prqlc CLI`"
msgstr ""

#: src/SUMMARY.md:110
msgid "qStudio"
msgstr ""

#: src/SUMMARY.md:112
msgid "VS Code"
msgstr ""

#: src/SUMMARY.md:116
msgid "Syntax highlighting"
msgstr ""

#: src/SUMMARY.md:118
msgid "Contributing to PRQL"
msgstr ""

#: src/tutorial/aggregation.md:3
msgid ""
"A key feature of analytics is reducing many values down to some summary. "
"This act is called \"aggregation\" and always includes a function — for "
"example, `average` or `sum` — that reduces values in the table to a single "
"row."
msgstr ""

#: src/tutorial/aggregation.md:7
msgid "`aggregate` transform"
msgstr ""

#: src/tutorial/aggregation.md:9
msgid ""
"The `aggregate` transform takes a tuple to create one or more new columns "
"that \"distill down\" data from all the rows."
msgstr ""

#: src/tutorial/aggregation.md:17
msgid ""
"The query above computes the sum of the `total` column of all rows of the "
"`invoices` table to produce a single value."
msgstr ""

#: src/tutorial/aggregation.md:20
msgid ""
"`aggregate` can produce multiple summaries at once when one or more "
"aggregation expressions are contained in a tuple. `aggregate` discards all "
"columns that are not present in the tuple."
msgstr ""

#: src/tutorial/aggregation.md:32
msgid ""
"In the example above, the result is a single row with two columns. The "
"`count` function displays the number of rows in the table that was passed "
"in; the `sum` function adds up the values of the `total` column of all rows."
msgstr ""

#: src/tutorial/aggregation.md:36
msgid "Grouping"
msgstr ""

#: src/tutorial/aggregation.md:38
msgid ""
"Suppose we want to produce summaries of invoices _for each city_ in the "
"table. We could create a query for each city, and aggregate its rows:"
msgstr ""

#: src/tutorial/aggregation.md:41
msgid ""
"```prql no-eval\n"
"from albums\n"
"filter billing_city == \"Oslo\"\n"
"aggregate { sum_of_orders = sum total }\n"
"```"
msgstr ""

#: src/tutorial/aggregation.md:47
msgid ""
"But we would need to do it for each city: `London`, `Frankfurt`, etc. Of "
"course this is repetitive (and boring) and error prone (because we would "
"need to type each `billing_city` by hand). Moreover, we would need to create "
"a list of each `billing_city` before we started."
msgstr ""

#: src/tutorial/aggregation.md:52
msgid "`group` transform"
msgstr ""

#: src/tutorial/aggregation.md:54
msgid ""
"The `group` transform separates the table into groups (say, those having the "
"same city) using information that's already in the table. It then applies a "
"transform to each group, and combines the results back together:"
msgstr ""

#: src/tutorial/aggregation.md:68
msgid ""
"Those familiar with SQL have probably noticed that we just decoupled "
"aggregation from grouping."
msgstr ""

#: src/tutorial/aggregation.md:71
msgid ""
"Although these operations are connected in SQL, PRQL makes it "
"straightforward to use `group` and `aggregate` separate from each other, "
"while combining with other transform functions, such as:"
msgstr ""

#: src/tutorial/aggregation.md:82
msgid "This code collects the first two rows for each city's `group`."
msgstr ""

#: src/tutorial/filtering.md:1
msgid "Filtering rows"
msgstr ""

#: src/tutorial/filtering.md:3
msgid ""
"In the previous page we learned how `select`, `derive`, and `join` change "
"the columns of a table."
msgstr ""

#: src/tutorial/filtering.md:6
msgid ""
"Now we will explore how to manipulate the rows of a table using `filter` and "
"`take`."
msgstr ""

#: src/tutorial/filtering.md:9
msgid "`filter` transform"
msgstr ""

#: src/tutorial/filtering.md:11
msgid ""
"The `filter` transform picks rows to pass through based on their values:"
msgstr ""

#: src/tutorial/filtering.md:13
msgid ""
"```prql no-eval\n"
"from invoices\n"
"filter billing_city == \"Berlin\"\n"
"```"
msgstr ""

#: src/tutorial/filtering.md:18
msgid "The resulting table contains all the rows that came from Berlin."
msgstr ""

#: src/tutorial/filtering.md:20
msgid ""
"PRQL converts the single `filter` transform to use the appropriate SQL "
"`WHERE` or `HAVING` command, depending on where it appears in the pipeline."
msgstr ""

#: src/tutorial/filtering.md:23
msgid "`take` transform"
msgstr ""

#: src/tutorial/filtering.md:25
msgid ""
"The `take` transform picks rows to pass through based on their position "
"within the table. The set of rows picked can be specified in two ways:"
msgstr ""

#: src/tutorial/filtering.md:28
msgid "a plain number `x`, which will pick the first `x` rows, or"
msgstr ""

#: src/tutorial/filtering.md:29
msgid "an inclusive range of rows `start..end`."
msgstr ""

#: src/tutorial/filtering.md:41
msgid ""
"Of course, it is possible combine all these transforms into a single "
"pipeline:"
msgstr ""

#: src/tutorial/filtering.md:43
msgid ""
"```prql no-eval\n"
"from invoices\n"
"\n"
"# retain only rows for orders from Berlin\n"
"filter billing_city == \"Berlin\"\n"
"\n"
"# skip first 10 rows and take the next 10\n"
"take 11..20\n"
"\n"
"# take only first 3 rows of *that* result\n"
"take 3\n"
"```"
msgstr ""

#: src/tutorial/filtering.md:56
msgid ""
"We did something a bit odd at the end: first we took rows `11..20` and then "
"took the first 3 rows from that result."
msgstr ""

#: src/tutorial/filtering.md:59
msgid ""
"```admonish note\n"
"Note that a single\n"
"transform `take 11..13` would have produced the same SQL. The example\n"
"serves an example of how PRQL allows fast data exploration by\n"
"\"stacking\" transforms in the pipeline, reducing the cognitive burden of "
"how\n"
"a new transform with the previous query.\n"
"```"
msgstr ""

#: src/tutorial/relations.md:3
msgid ""
"PRQL is designed on top of _relational algebra_, which is the established "
"data model used by modern SQL databases. A _relation_ has a rigid "
"mathematical definition, which can be simplified to \"a table of data\". For "
"example, the `invoices` table from the Chinook database ([https://github.com/"
"lerocha/chinook-database](https://github.com/lerocha/chinook-database)) "
"looks like this:"
msgstr ""

#: src/tutorial/relations.md:10
msgid "invoice_id"
msgstr ""

#: src/tutorial/relations.md:10
msgid "customer_id"
msgstr ""

#: src/tutorial/relations.md:10
msgid "billing_city"
msgstr ""

#: src/tutorial/relations.md:10
msgid "_other columns_"
msgstr ""

#: src/tutorial/relations.md:10
msgid "total"
msgstr ""

#: src/tutorial/relations.md:12
msgid "Stuttgart"
msgstr ""

#: src/tutorial/relations.md:12 src/tutorial/relations.md:13
#: src/tutorial/relations.md:14 src/tutorial/relations.md:15
#: src/tutorial/relations.md:16 src/tutorial/relations.md:17
msgid "..."
msgstr ""

#: src/tutorial/relations.md:12
msgid "1.98"
msgstr ""

#: src/tutorial/relations.md:13
msgid "Oslo"
msgstr ""

#: src/tutorial/relations.md:13
msgid "3.96"
msgstr ""

#: src/tutorial/relations.md:14
msgid "Brussels"
msgstr ""

#: src/tutorial/relations.md:14
msgid "5.94"
msgstr ""

#: src/tutorial/relations.md:15
msgid "Edmonton"
msgstr ""

#: src/tutorial/relations.md:15
msgid "8.91"
msgstr ""

#: src/tutorial/relations.md:16
msgid "5"
msgstr ""

#: src/tutorial/relations.md:16
msgid "23"
msgstr ""

#: src/tutorial/relations.md:16
msgid "Boston"
msgstr ""

#: src/tutorial/relations.md:16
msgid "13.86"
msgstr ""

#: src/tutorial/relations.md:17
msgid "6"
msgstr ""

#: src/tutorial/relations.md:17
msgid "37"
msgstr ""

#: src/tutorial/relations.md:17
msgid "Frankfurt"
msgstr ""

#: src/tutorial/relations.md:17
msgid "0.99"
msgstr ""

#: src/tutorial/relations.md:19
msgid ""
"A relation is composed of rows. Each row in a relation contains a value for "
"each of the relation's columns. Each column in a relation has an unique name "
"and a designated data type. The table above is a relation, and has columns "
"named `invoice_id`and `customer_id` each with a data type of \"integer "
"number\", a `billing_city` column with a data type of \"text\", several "
"other columns, and a `total` column that contains floating-point numbers."
msgstr ""

#: src/tutorial/relations.md:26
msgid "Queries"
msgstr ""

#: src/tutorial/relations.md:28
msgid ""
"The main purpose of PRQL is to build queries that combine and transform data "
"from relations such as the `invoices` table above. Here is the most basic "
"query:"
msgstr ""

#: src/tutorial/relations.md:35
msgid ""
"```admonish note\n"
"Try each of these examples here in the\n"
"[Playground.](https://prql-lang.org/playground/) Enter the query on the\n"
"left-hand side, and click **output.arrow** in the right-hand side to see "
"the\n"
"result.\n"
"```"
msgstr ""

#: src/tutorial/relations.md:42
msgid ""
"The result of the query above is not terribly interesting, it's just the "
"same relation as before."
msgstr ""

#: src/tutorial/relations.md:45
msgid "`select` transform"
msgstr ""

#: src/tutorial/relations.md:47
msgid ""
"The `select` function picks the columns to pass through based on a list and "
"discards all others. Formally, that list is a _tuple_ of comma-separated "
"expressions wrapped in `{ ... }`."
msgstr ""

#: src/tutorial/relations.md:51
msgid ""
"Suppose we only need the `order_id` and `total` columns. Use `select` to "
"choose the columns to pass through. _(Try it in the [Playground.](https://"
"prql-lang.org/playground/))_"
msgstr ""

#: src/tutorial/relations.md:60
msgid ""
"We can write the items in the tuple on one or several lines: trailing commas "
"are ignored. In addition, we can assign any of the expressions to a "
"_variable_ that becomes the name of the resulting column in the SQL output."
msgstr ""

#: src/tutorial/relations.md:72
msgid ""
"This is the same query as above, rewritten on multiple lines, and assigning "
"`OrderID` and `Total` names to the columns."
msgstr ""

#: src/tutorial/relations.md:75
msgid ""
"Once we `select` certain columns, subsequent transforms will have access "
"only to those columns named in the tuple."
msgstr ""

#: src/tutorial/relations.md:78
msgid "`derive` transform"
msgstr ""

#: src/tutorial/relations.md:80
msgid ""
"To add columns to a relation, we can use `derive` function. Let's define a "
"new column for Value Added Tax, set at 19% of the invoice total."
msgstr ""

#: src/tutorial/relations.md:90
msgid ""
"The value of the new column can be a constant (such as a number or a "
"string), or can be computed from the value of an existing column. Note that "
"the value of the new column is assigned the name `VAT`."
msgstr ""

#: src/tutorial/relations.md:94
msgid "`join` transform"
msgstr ""

#: src/tutorial/relations.md:96
msgid ""
"The `join` transform also adds columns to the relation by combining the rows "
"from two relations \"side by side\". To determine which rows from each "
"relation should be joined, `join` has match criteria, written in `( ... )`."
msgstr ""

#: src/tutorial/relations.md:105
msgid ""
"This example \"connects\" the customer information from the `customers` "
"relation with the information from the `invoices` relation, using identical "
"values of the `customer_id` column from each relation to match the rows."
msgstr ""

#: src/tutorial/relations.md:109
msgid ""
"It is frequently useful to assign an alias to both relations being joined "
"together so that each relation's columns can be referred to uniquely."
msgstr ""

#: src/tutorial/relations.md:117
msgid ""
"In the example above, the alias `inv` represents the `invoices` relation and "
"`cust` represents the `customers` relation. It then becomes possible to "
"refer to `inv.billing_city` and `cust.last_name` unambiguously."
msgstr ""

#: src/tutorial/relations.md:121
msgid "Summary"
msgstr ""

#: src/tutorial/relations.md:123
msgid ""
"PRQL manipulates relations (tables) of data. The `derive`, `select`, and "
"`join` transforms change the number of columns in a table. The first two "
"never affect the number of rows in a table. `join` may change the number of "
"rows, depending on the variation chosen."
msgstr ""

#: src/tutorial/relations.md:128
msgid ""
"This final example combines the above into a single query. It illustrates _a "
"pipeline_ - the fundamental basis of PRQL. We simply add new lines "
"(transforms) at the end of the query. Each transform modifies the relation "
"produced by the statement above to produce the desired result."
msgstr ""
