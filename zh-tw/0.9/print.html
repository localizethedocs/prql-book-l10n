<!DOCTYPE HTML>
<html lang="zh_TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PRQL language book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="Modern language for transforming data — a simple, powerful, pipelined SQL replacement">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="comparison-table.css">
        <link rel="stylesheet" href="mdbook-admonish.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PRQL language book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/PRQL/prql" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>PRQL project documentation.</p>
<h2 id="tutorial"><a class="header" href="#tutorial"><a href="./tutorial/relations.html">Tutorial</a></a></h2>
<p>A friendly &amp; accessible guide for learning PRQL. It has a gradual increase of difficulty and requires only basic understanding of programming languages. Knowledge of SQL is beneficial, because of many comparisons to SQL, but it is not required.</p>
<!-- TODO: add a time estimate, "learn PRQL in 15 minutes" -->
<h2 id="language-reference"><a class="header" href="#language-reference"><a href="./reference/syntax/">Language reference</a></a></h2>
<p>關於 PRQL 語言的深入資訊。包含語言設計決策的理據，以及語言各部分的正式規範。</p>
<h2 id="how-do-i"><a class="header" href="#how-do-i"><a href="./how-do-i/distinct.html">How do I?</a></a></h2>
<p>Frequently asked questions and small guides on how to use the language.</p>
<h2 id="project"><a class="header" href="#project"><a href="./project/changelog.html">Project</a></a></h2>
<p>關於專案、工具與開發的一般資訊。</p>
<ul>
<li><a href="./project/changelog.html">Changelog</a></li>
<li><a href="./project/target.html">Target &amp; version</a></li>
<li><a href="./project/bindings/">Bindings</a></li>
<li><a href="./project/integrations/">Integrations</a></li>
<li><a href="./project/contributing/">Contributing to PRQL</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="關係"><a class="header" href="#關係">關係</a></h1>
<p>PRQL is designed on top of <em>relational algebra</em>, which is the established data model used by modern SQL databases. A <em>relation</em> has a rigid mathematical definition, which can be simplified to “a table of data”. For example, the <code>invoices</code> table from the Chinook database (<a href="https://github.com/lerocha/chinook-database">https://github.com/lerocha/chinook-database</a>) looks like this:</p>
<div class="table-wrapper"><table><thead><tr><th>invoice_id</th><th>customer_id</th><th>billing_city</th><th style="text-align: center"><em>other columns</em></th><th>total</th></tr></thead><tbody>
<tr><td>1</td><td>2</td><td>Stuttgart</td><td style="text-align: center">…</td><td>1.98</td></tr>
<tr><td>2</td><td>4</td><td>Oslo</td><td style="text-align: center">…</td><td>3.96</td></tr>
<tr><td>3</td><td>8</td><td>Brussels</td><td style="text-align: center">…</td><td>5.94</td></tr>
<tr><td>4</td><td>14</td><td>Edmonton</td><td style="text-align: center">…</td><td>8.91</td></tr>
<tr><td>5</td><td>23</td><td>Boston</td><td style="text-align: center">…</td><td>13.86</td></tr>
<tr><td>6</td><td>37</td><td>Frankfurt</td><td style="text-align: center">…</td><td>0.99</td></tr>
</tbody></table>
</div>
<p>A relation is composed of rows. Each row in a relation contains a value for each of the relation’s columns. Each column in a relation has an unique name and a designated data type. The table above is a relation, and has columns named <code>invoice_id</code>and <code>customer_id</code> each with a data type of “integer number”, a <code>billing_city</code> column with a data type of “text”, several other columns, and a <code>total</code> column that contains floating-point numbers.</p>
<h2 id="查詢"><a class="header" href="#查詢">查詢</a></h2>
<p>PRQL 的主要目的是建立查詢，以結合和轉換來自關係（如上面的 <code>invoices</code> 表）的資料。以下是最基本的查詢：</p>
<pre><code class="language-prql no-eval">from invoices
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="tutorial/relations.html#admonition-note"></a>
</div>
<div>
<p>Try each of these examples here in the <a href="https://prql-lang.org/playground/">Playground.</a> Enter the query on the left-hand side, and click <strong>output.arrow</strong> in the right-hand side to see the result.</p>
</div>
</div>
<p>The result of the query above is not terribly interesting, it’s just the same relation as before.</p>
<h3 id="select-變換"><a class="header" href="#select-變換"><code>select</code> 變換</a></h3>
<p><code>select</code> 函式基於列表選擇要通過的列，並捨棄所有其他列。形式上，該列表是以 <code>{ ... }</code> 包裹的逗號分隔表達式的 <em>元組</em>。</p>
<p>假設我們只需要 <code>order_id</code> 和 <code>total</code> 列。使用 <code>select</code> 來選擇要通過的列。<em>（在 <a href="https://prql-lang.org/playground/">Playground</a> 中試試看。）</em></p>
<pre><code class="language-prql no-eval">from invoices
select { order_id, total }
</code></pre>
<p>我們可以在一行或多行上寫入元組中的項目：尾部逗號被忽略。此外，我們可以將任何表達式指派給 <em>變數</em>，該變數成為 SQL 輸出中結果列的名稱。</p>
<pre><code class="language-prql no-eval">from invoices
select {
  OrderID = invoice_id,
  Total = total,
}
</code></pre>
<p>這是與上面相同的查詢，改寫在多行上，並將 <code>OrderID</code> 和 <code>Total</code> 名稱指派給列。</p>
<p>一旦我們 <code>select</code> 某些列，後續變換將只能訪問在元組中命名的那些列。</p>
<h3 id="derive-變換"><a class="header" href="#derive-變換"><code>derive</code> 變換</a></h3>
<p>To add columns to a relation, we can use <code>derive</code> function. Let’s define a new column for Value Added Tax, set at 19% of the invoice total.</p>
<pre><code class="language-prql no-eval">from invoices
derive { VAT = total * 0.19 }
</code></pre>
<!-- todo: make sure that the new column is unnamed -->
<p>新列的值可以是常數（例如數字或字串），也可以從現有列的值計算得出。注意新列被指派名稱 <code>VAT</code>。</p>
<h3 id="join-變換"><a class="header" href="#join-變換"><code>join</code> 變換</a></h3>
<p>The <code>join</code> transform also adds columns to the relation by combining the rows from two relations “side by side”. To determine which rows from each relation should be joined, <code>join</code> has match criteria, written in <code>( ... )</code>.</p>
<pre><code class="language-prql no-eval">from invoices
join customers ( ==customer_id )
</code></pre>
<p>This example “connects” the customer information from the <code>customers</code> relation with the information from the <code>invoices</code> relation, using identical values of the <code>customer_id</code> column from each relation to match the rows.</p>
<p>It is frequently useful to assign an alias to both relations being joined together so that each relation’s columns can be referred to uniquely.</p>
<pre><code class="language-prql no-eval">from inv=invoices
join cust=customers ( ==customer_id )
</code></pre>
<p>在上面的示例中，別名 <code>inv</code> 代表 <code>invoices</code> 關係，<code>cust</code> 代表 <code>customers</code> 關係。然後可以明確地參考 <code>inv.billing_city</code> 和 <code>cust.last_name</code>。</p>
<h3 id="摘要"><a class="header" href="#摘要">摘要</a></h3>
<p>PRQL manipulates relations (tables) of data. The <code>derive</code>, <code>select</code>, and <code>join</code> transforms change the number of columns in a table. The first two never affect the number of rows in a table. <code>join</code> may change the number of rows, depending on the variation chosen.</p>
<p>這個最後的示例將上述內容組合成一個單一查詢。它說明了 <em>管道</em> - PRQL 的基礎。我們只是在查詢末尾新增新的行（變換）。每個變換修改由上述語句產生的關係，以產生所需的結果。</p>
<pre><code class="language-prql no-eval">from inv=invoices
join cust=customers (==customer_id)
derive { VAT = inv.total * 0.19 }
select {
  OrderID = inv.invoice_id,
  CustomerName = cust.last_name,
  Total = inv.total,
  VAT,
}
</code></pre>
<!-- PRQL uses the data from... _Where does our data come from? Do we use some canonical version?_ -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="篩選行"><a class="header" href="#篩選行">篩選行</a></h1>
<p>在前一頁，我們學到了 <code>select</code>、<code>derive</code> 和 <code>join</code> 如何改變表的列。</p>
<p>現在我們將探索如何使用 <code>filter</code> 和 <code>take</code> 操作表的行。</p>
<h3 id="filter-變換"><a class="header" href="#filter-變換"><code>filter</code> 變換</a></h3>
<p><code>filter</code> 變換根據值選擇要通過的行：</p>
<pre><code class="language-prql no-eval">from invoices
filter billing_city == "Berlin"
</code></pre>
<p>結果表包含來自柏林的所有行。</p>
<p>PRQL 將單個 <code>filter</code> 變換轉換為使用適當的 SQL <code>WHERE</code> 或 <code>HAVING</code> 命令，取決於它在管道中出現的位置。</p>
<h3 id="take-變換"><a class="header" href="#take-變換"><code>take</code> 變換</a></h3>
<p><code>take</code> 變換根據行在表中的位置選擇要通過的行。所選行的集合可以用兩種方式指定：</p>
<ul>
<li>一個純數字 <code>x</code>，將選擇前 <code>x</code> 行，或</li>
<li>行的包含範圍 <code>start..end</code>。</li>
</ul>
<pre><code class="language-prql no-eval">from invoices
take 4
</code></pre>
<pre><code class="language-prql no-eval">from invoices
take 4..7
</code></pre>
<p>當然，可以將所有這些變換組合到一個管道中：</p>
<pre><code class="language-prql no-eval">from invoices

# retain only rows for orders from Berlin
filter billing_city == "Berlin"

# skip first 10 rows and take the next 10
take 11..20

# take only first 3 rows of *that* result
take 3
</code></pre>
<p>在最後我們做了一些有點奇怪的事情：首先我們取了行 <code>11..20</code>，然後從該結果中取前 3 行。</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="tutorial/filtering.html#admonition-note"></a>
</div>
<div>
<p>Note that a single transform <code>take 11..13</code> would have produced the same SQL. The example serves an example of how PRQL allows fast data exploration by “stacking” transforms in the pipeline, reducing the cognitive burden of how a new transform with the previous query.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="聚合"><a class="header" href="#聚合">聚合</a></h1>
<p>A key feature of analytics is reducing many values down to some summary. This act is called “aggregation” and always includes a function — for example, <code>average</code> or <code>sum</code> — that reduces values in the table to a single row.</p>
<h3 id="aggregate-變換"><a class="header" href="#aggregate-變換"><code>aggregate</code> 變換</a></h3>
<p>The <code>aggregate</code> transform takes a tuple to create one or more new columns that “distill down” data from all the rows.</p>
<pre><code class="language-prql no-eval">from invoices
aggregate { sum_of_orders = sum total }
</code></pre>
<p>上面的查詢計算 <code>invoices</code> 表所有行的 <code>total</code> 列的總和，以產生單一值。</p>
<p>當元組中包含一個或多個聚合表達式時，<code>aggregate</code> 可以一次產生多個摘要。<code>aggregate</code> 會捨棄元組中不存在的所有列。</p>
<pre><code class="language-prql no-eval">from invoices
aggregate {
    num_orders = count this,
    sum_of_orders = sum total,
}
</code></pre>
<p>在上面的示例中，結果是有兩列的單一行。<code>count</code> 函式顯示傳入的表中的行數；<code>sum</code> 函式將所有行的 <code>total</code> 列的值相加。</p>
<h2 id="分組"><a class="header" href="#分組">分組</a></h2>
<p>假設我們想要產生表中 <em>每個城市</em> 發票的摘要。我們可以為每個城市建立一個查詢，並聚合其行：</p>
<pre><code class="language-prql no-eval">from albums
filter billing_city == "Oslo"
aggregate { sum_of_orders = sum total }
</code></pre>
<p>但我們需要為每個城市做這種操作：<code>London</code>、<code>Frankfurt</code> 等。當然這是重複的（且令人厭倦的）且容易出錯（因為我們需要手動輸入每個 <code>billing_city</code>）。此外，我們需要在開始前建立每個 <code>billing_city</code> 的列表。</p>
<h3 id="group-變換"><a class="header" href="#group-變換"><code>group</code> 變換</a></h3>
<p>The <code>group</code> transform separates the table into groups (say, those having the same city) using information that’s already in the table. It then applies a transform to each group, and combines the results back together:</p>
<pre><code class="language-prql no-eval">from invoices
group billing_city (
    aggregate {
        num_orders = count this,
        sum_of_orders = sum total,
    }
)
</code></pre>
<p>熟悉 SQL 的人可能已經注意到，我們剛才將聚合與分組分離了。</p>
<p>雖然這些操作在 SQL 中是相關的，但 PRQL 使得可以直接將 <code>group</code> 和 <code>aggregate</code>分開使用，同時與其他變換函式結合，例如：</p>
<pre><code class="language-prql no-eval">from invoices
group billing_city (
    take 2
)
</code></pre>
<p>This code collects the first two rows for each city’s <code>group</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-read-files"><a class="header" href="#how-do-i-read-files">How do I: read files?</a></h1>
<p>There are a couple of functions designed for DuckDB:</p>
<div class="comparison">
<div>
<h4 id="prql"><a class="header" href="#prql">PRQL</a></h4>
<pre><code class="language-prql">from (read_parquet 'artists.parquet')
join (read_csv 'albums.csv') (==track_id)
</code></pre>
</div>
<div>
<h4 id="sql"><a class="header" href="#sql">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *
  FROM
    read_parquet('artists.parquet')
),
table_1 AS (
  SELECT
    *
  FROM
    read_csv_auto('albums.csv')
)
SELECT
  table_0.*,
  table_1.*
FROM
  table_0
  JOIN table_1 ON table_0.track_id = table_1.track_id

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="how-do-i/read-files.html#admonition-note"></a>
</div>
<div>
<p>These don’t currently have all the DuckDB options. If those would be helpful, please log an issue and it’s a fairly easy addition.</p>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="how-do-i/read-files.html#admonition-info"></a>
</div>
<div>
<p>We may be able to reduce the boilerplate <code>WITH table_x AS SELECT * FROM...</code> in future versions.</p>
</div>
</div>
<h2 id="另請參見"><a class="header" href="#另請參見">另請參見</a></h2>
<ul>
<li><a href="how-do-i/./relation-literals.html">How do I: create ad-hoc relations?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-remove-duplicates"><a class="header" href="#how-do-i-remove-duplicates">How do I: remove duplicates?</a></h1>
<p>PRQL doesn’t have a specific <code>distinct</code> keyword. Instead duplicate tuples in a relation can be removed by using <code>group</code> and <code>take 1</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-1"><a class="header" href="#prql-1">PRQL</a></h4>
<pre><code class="language-prql">from employees
select department
group employees.* (
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-1"><a class="header" href="#sql-1">SQL</a></h4>
<pre><code class="language-sql">SELECT
  DISTINCT department
FROM
  employees

</code></pre>
</div>
</div>
<p>This also works with a wildcard:</p>
<div class="comparison">
<div>
<h4 id="prql-2"><a class="header" href="#prql-2">PRQL</a></h4>
<pre><code class="language-prql">from employees
group employees.* (take 1)
</code></pre>
</div>
<div>
<h4 id="sql-2"><a class="header" href="#sql-2">SQL</a></h4>
<pre><code class="language-sql">SELECT
  DISTINCT *
FROM
  employees

</code></pre>
</div>
</div>
<h2 id="remove-duplicates-from-each-group"><a class="header" href="#remove-duplicates-from-each-group">Remove duplicates from each group?</a></h2>
<p>To <a href="https://stackoverflow.com/questions/3800551/select-first-row-in-each-group-by-group">select a single row from each group</a> <code>group</code> can be combined with <code>sort</code> and <code>take</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-3"><a class="header" href="#prql-3">PRQL</a></h4>
<pre><code class="language-prql"># youngest employee from each department
from employees
group department (
  sort age
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-3"><a class="header" href="#sql-3">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    ROW_NUMBER() OVER (
      PARTITION BY department
      ORDER BY
        age
    ) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  _expr_0 &lt;= 1

</code></pre>
</div>
</div>
<p>Note that we can’t always compile to <code>DISTINCT</code>; when the columns in the <code>group</code> aren’t all the available columns, we need to use a window function:</p>
<div class="comparison">
<div>
<h4 id="prql-4"><a class="header" href="#prql-4">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {first_name, last_name} (take 1)
</code></pre>
</div>
<div>
<h4 id="sql-4"><a class="header" href="#sql-4">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    ROW_NUMBER() OVER (PARTITION BY first_name, last_name) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  _expr_0 &lt;= 1

</code></pre>
</div>
</div>
<p>When compiling to Postgres or DuckDB dialect, such queries will be compiled to <code>DISTINCT ON</code>, which is <a href="https://stackoverflow.com/a/7630564">the most performant option</a>.</p>
<div class="comparison">
<div>
<h4 id="prql-5"><a class="header" href="#prql-5">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.postgres

from employees
group department (
  sort age
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-5"><a class="header" href="#sql-5">SQL</a></h4>
<pre><code class="language-sql">SELECT
  DISTINCT ON (department) *
FROM
  employees
ORDER BY
  department,
  age

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-create-ad-hoc-relations"><a class="header" href="#how-do-i-create-ad-hoc-relations">How do I: create ad-hoc relations?</a></h1>
<p>It’s often useful to make a small inline relation, for example when exploring how a database will evaluate an expression, or for a small lookup table. This can be quite verbose in SQL.</p>
<p>PRQL offers two approaches — array literals, and a <code>from_text</code> transform.</p>
<h2 id="array-literals"><a class="header" href="#array-literals">Array literals</a></h2>
<p>Because relations (aka a table) in PRQL are just arrays of tuples, they can be expressed with array and tuple syntax:</p>
<div class="comparison">
<div>
<h4 id="prql-6"><a class="header" href="#prql-6">PRQL</a></h4>
<pre><code class="language-prql">from [
  {a=5, b=false},
  {a=6, b=true},
]
filter b == true
select a
</code></pre>
</div>
<div>
<h4 id="sql-6"><a class="header" href="#sql-6">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    5 AS a,
    false AS b
  UNION
  ALL
  SELECT
    6 AS a,
    true AS b
)
SELECT
  a
FROM
  table_0
WHERE
  b = true

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-7"><a class="header" href="#prql-7">PRQL</a></h4>
<pre><code class="language-prql">let my_artists = [
  {artist="Miles Davis"},
  {artist="Marvin Gaye"},
  {artist="James Brown"},
]

from artists
join my_artists (==artist)
join albums (==artist_id)
select {artists.artist_id, albums.title}
</code></pre>
</div>
<div>
<h4 id="sql-7"><a class="header" href="#sql-7">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    'Miles Davis' AS artist
  UNION
  ALL
  SELECT
    'Marvin Gaye' AS artist
  UNION
  ALL
  SELECT
    'James Brown' AS artist
),
my_artists AS (
  SELECT
    artist
  FROM
    table_0
)
SELECT
  artists.artist_id,
  albums.title
FROM
  artists
  JOIN my_artists ON artists.artist = my_artists.artist
  JOIN albums ON artists.artist_id = albums.artist_id

</code></pre>
</div>
</div>
<h2 id="from_text"><a class="header" href="#from_text"><code>from_text</code></a></h2>
<p><code>from_text</code> takes a string in a common format, and converts it to table. It accepts a few formats:</p>
<ul>
<li>
<p><code>format:csv</code> parses CSV (default),</p>
</li>
<li>
<p><code>format:json</code> parses either:</p>
<ul>
<li>
<p>an array of objects each of which represents a row, or</p>
</li>
<li>
<p>an object with fields <code>columns</code> &amp; <code>data</code>, where <code>columns</code> take an array of column names and <code>data</code> takes an array of arrays.</p>
</li>
</ul>
</li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-8"><a class="header" href="#prql-8">PRQL</a></h4>
<pre><code class="language-prql">from_text """
a,b,c
1,2,3
4,5,6
"""
derive {
    d = b + c,
    answer = 20 * 2 + 2,
}
</code></pre>
</div>
<div>
<h4 id="sql-8"><a class="header" href="#sql-8">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    '1' AS a,
    '2' AS b,
    '3' AS c
  UNION
  ALL
  SELECT
    '4' AS a,
    '5' AS b,
    '6' AS c
)
SELECT
  a,
  b,
  c,
  b + c AS d,
  20 * 2 + 2 AS answer
FROM
  table_0

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-9"><a class="header" href="#prql-9">PRQL</a></h4>
<pre><code class="language-prql">from_text format:json """
[
    {"a": 1, "m": "5"},
    {"a": 4, "n": "6"}
]
"""
</code></pre>
</div>
<div>
<h4 id="sql-9"><a class="header" href="#sql-9">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    1 AS a,
    '5' AS m
  UNION
  ALL
  SELECT
    4 AS a,
    NULL AS m
)
SELECT
  a,
  m
FROM
  table_0

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-10"><a class="header" href="#prql-10">PRQL</a></h4>
<pre><code class="language-prql">from_text format:json """
{
    "columns": ["a", "b", "c"],
    "data": [
        [1, "x", false],
        [4, "y", null]
    ]
}
"""
</code></pre>
</div>
<div>
<h4 id="sql-10"><a class="header" href="#sql-10">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    1 AS a,
    'x' AS b,
    false AS c
  UNION
  ALL
  SELECT
    4 AS a,
    'y' AS b,
    NULL AS c
)
SELECT
  a,
  b,
  c
FROM
  table_0

</code></pre>
</div>
</div>
<h2 id="另請參見-1"><a class="header" href="#另請參見-1">另請參見</a></h2>
<ul>
<li><a href="how-do-i/./read-files.html">How do I: read files?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="語法"><a class="header" href="#語法">語法</a></h1>
<p>PRQL 語法摘要：</p>
<!-- markdownlint-disable MD033 — the `|` characters need to be escaped, and surrounded with tags rather than backticks   -->
<!-- I can't seem to get "Quoted identifies" to work without a space between the backticks. VS Code will preview ` `` ` correctly, but not mdbook -->
<!-- TODO: assigns links to select, aliases to join, potentially we should have explicit sections for them?  -->
<div class="table-wrapper"><table><thead><tr><th>語法</th><th>用法</th><th>範例</th></tr></thead><tbody>
<tr><td><code>|</code></td><td><a href="reference/syntax/./function-calls.html">管道</a></td><td><code>from employees | select first_name</code></td></tr>
<tr><td><code>=</code></td><td><a href="reference/syntax/./tuples.html">Assigns</a></td><td><code>from e = employees</code> <br> <code>derive total = (sum salary)</code></td></tr>
<tr><td><code>:</code></td><td><a href="reference/syntax/../declarations/functions.html">具名引數和參數</a></td><td><code>interp low:0 1600 sat_score</code></td></tr>
<tr><td><code>{}</code></td><td><a href="reference/syntax/./tuples.html">值組</a></td><td><code>{id, false, total = 3}</code></td></tr>
<tr><td><code>[]</code></td><td><a href="reference/syntax/./arrays.html">陣列</a></td><td><code>[1, 4, 3, 4]</code></td></tr>
<tr><td><code>!</code>,<code>&amp;&amp;</code>,<code>==</code>,<code>+</code></td><td><a href="reference/syntax/./operators.html">運算子</a></td><td><code>filter a == b + c || d &gt;= e</code></td></tr>
<tr><td><code>()</code></td><td><a href="reference/syntax/./operators.html#parentheses">括號</a></td><td><code>derive celsius = (fht - 32) / 1.8</code></td></tr>
<tr><td><code>\</code></td><td><a href="reference/syntax/./operators.html#wrapping-lines">換行</a></td><td><code>1 + 2 + 3 +</code><br><code>\ 4 + 5</code></td></tr>
<tr><td><code>1</code>、<code>100_000</code>、<code>5e10</code></td><td><a href="reference/syntax/./literals.html#numbers">數字</a></td><td><code>derive { huge = 5e10 * 10_000 }</code></td></tr>
<tr><td><code>''</code>、<code>""</code></td><td><a href="reference/syntax/./literals.html#strings">字串</a></td><td><code>derive name = 'Mary'</code></td></tr>
<tr><td><code>true</code>、<code>false</code></td><td><a href="reference/syntax/./literals.html#booleans">布林值</a></td><td><code>derive { Col1 = true }</code></td></tr>
<tr><td><code>null</code></td><td><a href="reference/syntax/./literals.html#null">Null</a></td><td><code>filter ( name != null )</code></td></tr>
<tr><td><code>@</code></td><td><a href="reference/syntax/./literals.html#date-and-time">日期和時間</a></td><td><code>@2021-01-01</code></td></tr>
<tr><td><code>` `</code></td><td><a href="reference/syntax/./keywords.html#quoting">引用的識別符號</a></td><td><code>select `first name` </code></td></tr>
<tr><td><code>#</code></td><td><a href="reference/syntax/./comments.html">註釋</a></td><td><code># A comment</code></td></tr>
<tr><td><code>==</code></td><td><a href="reference/syntax/../stdlib/transforms/join.html#self-equality-operator"><code>join</code> 中的自相等</a></td><td><code>join s=salaries (==id)</code></td></tr>
<tr><td><code>-&gt;</code></td><td><a href="reference/syntax/../declarations/functions.html">函式定義</a></td><td><code>let add = a b -&gt; a + b</code></td></tr>
<tr><td><code>=&gt;</code></td><td><a href="reference/syntax/./case.html">Case 語句</a></td><td><code>case {a==1 =&gt; c, a==2 =&gt; d }</code></td></tr>
<tr><td><code>+</code>、<code>-</code></td><td><a href="reference/syntax/../stdlib/transforms/sort.html">排序順序</a></td><td><code>sort {-amount, +date}</code></td></tr>
<tr><td><code>??</code></td><td><a href="reference/syntax/./operators.html#coalesce">合併</a></td><td><code>amount ?? 0</code></td></tr>
</tbody></table>
</div><!-- markdownlint-enable MD033 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="字面值"><a class="header" href="#字面值">字面值</a></h1>
<p>字面值是一個常數值表達式，每種資料型別都有特殊的語法規則。</p>
<h2 id="數字"><a class="header" href="#數字">數字</a></h2>
<p>數字字面值可以包含數字字元以及句號、底線和字元 <code>e</code>。</p>
<p>如果數字字面值包含點或字元 <code>e</code>，則將其視為浮點數（或稱為 <em>float</em>），否則將其視為整數。</p>
<p>Character <code>e</code> denotes <a href="https://en.wikipedia.org/wiki/Scientific_notation">“scientific notation”</a>, where the number after <code>e</code> is the exponent in 10-base.</p>
<p>底線被忽略，所以它們可以放在任意位置，但建議將它們用作千位分隔符。</p>
<div class="comparison">
<div>
<h4 id="prql-11"><a class="header" href="#prql-11">PRQL</a></h4>
<pre><code class="language-prql">from numbers
select {
    small = 1.000_000_1,
    big = 5_000_000,
    huge = 5e9,
}
</code></pre>
</div>
<div>
<h4 id="sql-11"><a class="header" href="#sql-11">SQL</a></h4>
<pre><code class="language-sql">SELECT
  1.0000001 AS small,
  5000000 AS big,
  5000000000.0 AS huge
FROM
  numbers

</code></pre>
</div>
</div>
<h2 id="字串"><a class="header" href="#字串">字串</a></h2>
<p>PRQL 支援字串字面值和多種其他字串格式。如需詳細資訊，請參閱<a href="reference/syntax/./strings.html">字串</a>頁面。</p>
<h2 id="布林值"><a class="header" href="#布林值">布林值</a></h2>
<p>布林值可以用 <code>true</code> 或 <code>false</code> 關鍵字表示。</p>
<h2 id="空值"><a class="header" href="#空值">空值</a></h2>
<p>空值可以用 <code>null</code> 關鍵字表示。另請參閱 <a href="reference/syntax/../spec/null.html">PRQL 如何處理空值</a>的討論。</p>
<h2 id="日期和時間"><a class="header" href="#日期和時間">日期和時間</a></h2>
<p>日期和時間字面值用字元 <code>@</code> 表示，後面跟著編碼日期和時間的字串。</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/literals.html#admonition-note"></a>
</div>
<div>
<p>PRQL’s notation is designed to be less verbose than SQL’s <code>TIMESTAMP '2004-10-19 10:23:54'</code> and more explicit than SQL’s implicit option that just uses a string <code>'2004-10-19 10:23:54'</code>.</p>
</div>
</div>
<h3 id="日期"><a class="header" href="#日期">日期</a></h3>
<p>日期由 <code>@{yyyy-mm-dd}</code> 表示 — <code>@</code> 後面跟著日期格式。</p>
<div class="comparison">
<div>
<h4 id="prql-12"><a class="header" href="#prql-12">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive age_at_year_end = (@2022-12-31 - dob)
</code></pre>
</div>
<div>
<h4 id="sql-12"><a class="header" href="#sql-12">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  DATE '2022-12-31' - dob AS age_at_year_end
FROM
  employees

</code></pre>
</div>
</div>
<h3 id="時間"><a class="header" href="#時間">時間</a></h3>
<p>時間由 <code>@{HH:mm:ss.SSS±Z}</code> 表示，任何未提供的部分預設為零。這包括由 <code>+HH:mm</code>、<code>-HH:mm</code> 或 <code>Z</code> 表示的時區。這符合 ISO8601 時間格式。</p>
<div class="comparison">
<div>
<h4 id="prql-13"><a class="header" href="#prql-13">PRQL</a></h4>
<pre><code class="language-prql">from orders
derive should_have_shipped_today = (order_time &lt; @08:30)
</code></pre>
</div>
<div>
<h4 id="sql-13"><a class="header" href="#sql-13">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  order_time &lt; TIME '08:30' AS should_have_shipped_today
FROM
  orders

</code></pre>
</div>
</div>
<h3 id="時間戳記"><a class="header" href="#時間戳記">時間戳記</a></h3>
<p>""時間戳記由 <code>@{yyyy-mm-ddTHH:mm:ss.SSS±Z}</code> / <code>@{date}T{time}</code> 表示，任何未提供的時間部分被四捨五入為零，包括由 <code>+HH:mm</code>、<code>-HH:mm</code> 或 <code>Z</code>（<code>:</code> 是可選的）表示的時區。這是 <code>@</code> 後面跟著 ISO8601 日期時間格式，該格式使用 <code>T</code> 分隔日期和時間。</p>
<div class="comparison">
<div>
<h4 id="prql-14"><a class="header" href="#prql-14">PRQL</a></h4>
<pre><code class="language-prql">from commits
derive first_prql_commit = @2020-01-01T13:19:55-08:00
</code></pre>
</div>
<div>
<h4 id="sql-14"><a class="header" href="#sql-14">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  TIMESTAMP '2020-01-01T13:19:55-0800' AS first_prql_commit
FROM
  commits

</code></pre>
</div>
</div>
<h3 id="持續時間"><a class="header" href="#持續時間">持續時間</a></h3>
<p>持續時間由 <code>{N}{periods}</code> 表示，例如 <code>2years</code> 或 <code>10minutes</code>，中間沒有空格。</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/literals.html#admonition-note-1"></a>
</div>
<div>
<p>These aren’t the same as ISO8601, because we evaluated <code>P3Y6M4DT12H30M5S</code> to be difficult to understand, but we could support a simplified form if there’s demand for it. We don’t currently support compound expressions, for example <code>2years10months</code>, but most DBs will allow <code>2years + 10months</code>. Please raise an issue if this is inconvenient.</p>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-15"><a class="header" href="#prql-15">PRQL</a></h4>
<pre><code class="language-prql">from projects
derive first_check_in = start + 10days
</code></pre>
</div>
<div>
<h4 id="sql-15"><a class="header" href="#sql-15">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  start + INTERVAL 10 DAY AS first_check_in
FROM
  projects

</code></pre>
</div>
</div>
<h3 id="範例"><a class="header" href="#範例">範例</a></h3>
<p>Here’s a larger list of date and time examples:</p>
<ul>
<li><code>@20221231</code> 無效 — 它必須包含完整的標點符號（<code>-</code> 和 <code>:</code>），</li>
<li><code>@2022-12-31</code> 是日期</li>
<li><code>@2022-12</code> or <code>@2022</code> are invalid — SQL can’t express a month, only a date</li>
<li><code>@16:54:32.123456</code> 是時間</li>
<li><code>@16:54:32</code>、<code>@16:54</code>、<code>@16</code> 都是允許的，分別表示 <code>@16:54:32.000000</code>、<code>@16:54:00.000000</code>、<code>@16:00:00.000000</code></li>
<li><code>@2022-12-31T16:54:32.123456</code> 是沒有時區的時間戳記</li>
<li><code>@2022-12-31T16:54:32.123456Z</code> 是 UTC 時區的時間戳記</li>
<li><code>@2022-12-31T16:54+02</code> 是 UTC+2 時區的時間戳記</li>
<li><code>@2022-12-31T16:54+02:00</code> 和 <code>@2022-12-31T16:54+02</code> 是 UTC+2 時區的日期時間</li>
<li><code>@16:54+02</code> 無效 — 時間總是本地的，所以它不能有時區</li>
<li><code>@2022-12-31+02</code> 無效 — 日期總是本地的，所以它不能有時區</li>
</ul>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/literals.html#admonition-note-2"></a>
</div>
<div>
<p>Currently prql-compiler does not parse or validate any of the datetime strings and will pass them to the database engine without adjustment. This might be refined in the future to aid in compatibility across databases. We’ll always support the canonical <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO8601</a> format described above.</p>
</div>
</div>
<h3 id="路線圖"><a class="header" href="#路線圖">路線圖</a></h3>
<p>日期時間（作為與時間戳記不同的資料型別）受某些資料庫支援（例如 MySql、BigQuery）。通過添加型別轉換，這些可以通過將時間戳記轉換為日期時間來表示：</p>
<pre><code class="language-prql no-eval">derive pi_day = @2017-03-14T15:09:26.535898&lt;datetime&gt;
</code></pre>
<p>以下是我們可以添加的一些範例：</p>
<ul>
<li><code>@2022-12-31T16:54&lt;datetime&gt;</code> is datetime without timezone</li>
<li><code>@2022-12-31&lt;datetime&gt;</code> is forbidden — datetime must specify time</li>
<li><code>@16:54&lt;datetime&gt;</code> is forbidden — datetime must specify date</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字串-1"><a class="header" href="#字串-1">字串</a></h1>
<p>字串字面值可以使用任何匹配的奇數個單引號或雙引號：</p>
<div class="comparison">
<div>
<h4 id="prql-16"><a class="header" href="#prql-16">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive {
  single        =   'hello world',
  double        =   "hello world",
  double_triple = """hello world""",
}
</code></pre>
</div>
<div>
<h4 id="sql-16"><a class="header" href="#sql-16">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  'hello world' AS single,
  'hello world' AS double,
  'hello world' AS double_triple
FROM
  artists

</code></pre>
</div>
</div>
<h2 id="引用和轉義字元"><a class="header" href="#引用和轉義字元">引用和轉義字元</a></h2>
<p>To quote a string containing quote characters, use the “other” type of quote, or use the escape character <code>\</code>, or use more quotes.</p>
<div class="comparison">
<div>
<h4 id="prql-17"><a class="header" href="#prql-17">PRQL</a></h4>
<pre><code class="language-prql">from artists
select {
  other   = '"hello world"',
  escaped = "\"hello world\"",
  triple  = """I said "hello world"!""",
}
</code></pre>
</div>
<div>
<h4 id="sql-17"><a class="header" href="#sql-17">SQL</a></h4>
<pre><code class="language-sql">SELECT
  '"hello world"' AS other,
  '"hello world"' AS escaped,
  'I said "hello world"!' AS triple
FROM
  artists

</code></pre>
</div>
</div>
<p>字串可以包含 <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">JSON 標準</a>定義的任何轉義字元序列。</p>
<div class="comparison">
<div>
<h4 id="prql-18"><a class="header" href="#prql-18">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive escapes = "\tXYZ\n \\ "                  # tab (\t), "XYZ", newline (\n), " ", \, " "
derive world = "\u0048\u0065\u006C\u006C\u006F" # "Hello"
</code></pre>
</div>
<div>
<h4 id="sql-18"><a class="header" href="#sql-18">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  '	XYZ
 \ ' AS escapes,
  'Hello' AS world
FROM
  artists

</code></pre>
</div>
</div>
<h2 id="其他字串格式"><a class="header" href="#其他字串格式">其他字串格式</a></h2>
<ul>
<li><a href="reference/syntax/./f-strings.html"><strong>F-字串</strong></a> - 從一組欄位或值建立新字串。</li>
<li><a href="reference/syntax/./r-strings.html"><strong>R-字串</strong></a> - 不含任何形式轉義的字串的原始字元。</li>
<li><a href="reference/syntax/./s-strings.html"><strong>S-strings</strong></a> - Insert SQL statements directly into the query. Use when PRQL doesn’t have an equivalent facility.</li>
</ul>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/strings.html#admonition-warning"></a>
</div>
<div>
<p>Currently PRQL allows multiline strings with either a single character or multiple character quotes. This may change for strings using a single character quote in future versions.</p>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/strings.html#admonition-note"></a>
</div>
<div>
<p>These escape rules specify how PRQL interprets escape characters when compiling strings to SQL, not necessarily how the database will interpret the string. Dialects interpret escape characters differently, and PRQL doesn’t currently account for these differences. Please open issues with any difficulties in the current implementation.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-字串"><a class="header" href="#f-字串">F-字串</a></h1>
<p>F-strings are a readable approach to building new strings from existing strings &amp; variables.</p>
<div class="comparison">
<div>
<h4 id="prql-19"><a class="header" href="#prql-19">PRQL</a></h4>
<pre><code class="language-prql">from employees
select full_name = f"{first_name} {last_name}"
</code></pre>
</div>
<div>
<h4 id="sql-19"><a class="header" href="#sql-19">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS full_name
FROM
  employees

</code></pre>
</div>
</div>
<p>This can be much easier to read for longer strings, relative to the SQL approach:</p>
<div class="comparison">
<div>
<h4 id="prql-20"><a class="header" href="#prql-20">PRQL</a></h4>
<pre><code class="language-prql">from web
select url = f"http{tls}://www.{domain}.{tld}/{page}"
</code></pre>
</div>
<div>
<h4 id="sql-20"><a class="header" href="#sql-20">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(
    'http',
    tls,
    '://www.',
    domain,
    '.',
    tld,
    '/',
    page
  ) AS url
FROM
  web

</code></pre>
</div>
</div>
<p>Note that currently interpolations can only contain plain variable names and not whole expression like Python, so this won’t work:</p>
<div class="comparison">
<div>
<h4 id="prql-21"><a class="header" href="#prql-21">PRQL</a></h4>
<pre><code class="language-prql">from tracks
select length_str = f"{length_seconds / 60} minutes"
</code></pre>
</div>
<div>
<h4 id="error"><a class="header" href="#error">Error</a></h4>
<pre><code class="hljs language-undefined">Error:
   ╭─[:2:37]
   │
 2 │ select length_str = f&quot;{length_seconds / 60} minutes&quot;
   │                                     ┬
   │                                     ╰── unexpected end of input while parsing interpolated string
───╯
</code></pre>
</div>
</div>
<h2 id="路線圖-1"><a class="header" href="#路線圖-1">路線圖</a></h2>
<p>In the future, f-strings may incorporate string formatting such as datetimes, numbers, and padding. If there’s a feature that would be helpful, please <a href="https://github.com/PRQL/prql/issues/new/">post an issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="r-字串"><a class="header" href="#r-字串">R-字串</a></h1>
<p>R-strings handle escape characters without special treatment:</p>
<div class="comparison">
<div>
<h4 id="prql-22"><a class="header" href="#prql-22">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive normal_string =  "\\\t"   #  two characters - \ and tab (\t)
derive raw_string    = r"\\\t"   # four characters - \, \, \, and t
</code></pre>
</div>
<div>
<h4 id="sql-21"><a class="header" href="#sql-21">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  '\	' AS normal_string,
  '\\\t' AS raw_string
FROM
  artists

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="s-字串"><a class="header" href="#s-字串">S-字串</a></h1>
<p>An s-string inserts SQL directly, as an escape hatch when there’s something that PRQL doesn’t yet implement. For example, there’s a <code>version()</code> function in PostgreSQL that returns the PostgreSQL version, so if we want to use that, we use an s-string:</p>
<div class="comparison">
<div>
<h4 id="prql-23"><a class="header" href="#prql-23">PRQL</a></h4>
<pre><code class="language-prql">from my_table
select db_version = s"version()"
</code></pre>
</div>
<div>
<h4 id="sql-22"><a class="header" href="#sql-22">SQL</a></h4>
<pre><code class="language-sql">SELECT
  version() AS db_version
FROM
  my_table

</code></pre>
</div>
</div>
<p>Embed a column name in an s-string using braces. For example, PRQL’s standard library defines the <code>average</code> function as:</p>
<pre><code class="language-prql no-eval">let average = column -&gt; s"AVG({column})"
</code></pre>
<p>So this compiles using the function:</p>
<div class="comparison">
<div>
<h4 id="prql-24"><a class="header" href="#prql-24">PRQL</a></h4>
<pre><code class="language-prql">from employees
aggregate {average salary}
</code></pre>
</div>
<div>
<h4 id="sql-23"><a class="header" href="#sql-23">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary)
FROM
  employees

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/s-strings.html#admonition-note"></a>
</div>
<div>
<p>Because S-string contents are SQL, double-quotes (<code>"</code>) will denote a <em>column name</em>. To avoid that, use single-quotes (<code>'</code>) around the SQL string, and adjust the quotes of the S-string. For example, instead of <code>s'CONCAT("hello", "world")'</code> use <code>s"CONCAT('hello', 'world')"</code></p>
</div>
</div>
<p>Here’s an example of a more involved use of an s-string:</p>
<div class="comparison">
<div>
<h4 id="prql-25"><a class="header" href="#prql-25">PRQL</a></h4>
<pre><code class="language-prql">from de=dept_emp
join s=salaries side:left (s.emp_no == de.emp_no &amp;&amp; s"""
  ({s.from_date}, {s.to_date})
  OVERLAPS
  ({de.from_date}, {de.to_date})
""")
</code></pre>
</div>
<div>
<h4 id="sql-24"><a class="header" href="#sql-24">SQL</a></h4>
<pre><code class="language-sql">SELECT
  de.*,
  s.*
FROM
  dept_emp AS de
  LEFT JOIN salaries AS s ON s.emp_no = de.emp_no
  AND (s.from_date, s.to_date) OVERLAPS (de.from_date, de.to_date)

</code></pre>
</div>
</div>
<p>For those who have used Python, s-strings are similar to Python’s f-strings, but the result is SQL code, rather than a string literal. For example, a Python f-string of <code>f"average({col})"</code> would produce <code>"average(salary)"</code>, with quotes; while in PRQL, <code>s"average({col})"</code> produces <code>average(salary)</code>, without quotes.</p>
<p>Note that interpolations can only contain plain variable names and not whole expression like Python.</p>
<p>We can also use s-strings to produce a full table:</p>
<div class="comparison">
<div>
<h4 id="prql-26"><a class="header" href="#prql-26">PRQL</a></h4>
<pre><code class="language-prql">from s"SELECT DISTINCT ON first_name, id, age FROM employees ORDER BY age ASC"
join s = s"SELECT * FROM salaries" (==id)
</code></pre>
</div>
<div>
<h4 id="sql-25"><a class="header" href="#sql-25">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    DISTINCT ON first_name,
    id,
    age
  FROM
    employees
  ORDER BY
    age ASC
),
table_1 AS (
  SELECT
    *
  FROM
    salaries
)
SELECT
  table_0.*,
  table_1.*
FROM
  table_0
  JOIN table_1 ON table_0.id = table_1.id

</code></pre>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/s-strings.html#admonition-note-1"></a>
</div>
<div>
<p>S-strings in user code are intended as an escape hatch for an unimplemented feature. If we often need s-strings to express something, that’s a sign we should implement it in PRQL or PRQL’s stdlib. If you often require an s-string, <a href="https://github.com/PRQL/prql/issues/new/choose">submit an issue with your use case</a>.</p>
</div>
</div>
<h2 id="braces"><a class="header" href="#braces">Braces</a></h2>
<p>To output braces from an s-string, use double braces:</p>
<div class="comparison">
<div>
<h4 id="prql-27"><a class="header" href="#prql-27">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  has_valid_title = s"regexp_contains(title, '([a-z0-9]*-){{2,}}')"
}
</code></pre>
</div>
<div>
<h4 id="sql-26"><a class="header" href="#sql-26">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  regexp_contains(title, '([a-z0-9]*-){2,}') AS has_valid_title
FROM
  employees

</code></pre>
</div>
</div>
<h2 id="precedence-within-s-strings"><a class="header" href="#precedence-within-s-strings">Precedence within s-strings</a></h2>
<p>Variables in s-strings are inserted into the SQL source as-is, which means we may get surprising behavior when the variable has multiple terms and the s-string isn’t parenthesized.</p>
<p>In this toy example, the expression <code>salary + benefits / 365</code> gets precedence wrong. The generated SQL code is as if we had written <code>salary + (benefits / 365)</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-28"><a class="header" href="#prql-28">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = salary + benefits,
  daily_rate = s"{gross_salary} / 365"
}
</code></pre>
</div>
<div>
<h4 id="sql-27"><a class="header" href="#sql-27">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + benefits AS gross_salary,
  salary + benefits / 365 AS daily_rate
FROM
  employees

</code></pre>
</div>
</div>
<p>Instead, the numerator <code>{gross_salary}</code> must be encased in parentheses:</p>
<div class="comparison">
<div>
<h4 id="prql-29"><a class="header" href="#prql-29">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = salary + benefits,
  daily_rate = s"({gross_salary}) / 365"
}
</code></pre>
</div>
<div>
<h4 id="sql-28"><a class="header" href="#sql-28">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + benefits AS gross_salary,
  (salary + benefits) / 365 AS daily_rate
FROM
  employees

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="值組"><a class="header" href="#值組">值組</a></h1>
<p>值組是一個容器型別，由多個欄位組成。每個欄位可以有不同的型別。欄位的數量和型別必須在編譯時已知。</p>
<p>值組由 <code>{}</code> 表示。它可以跨越多行。欄位可以分配名稱。欄位由逗號分隔，尾部逗號是可選的。</p>
<pre><code class="language-prql no-eval">let var1 = {x = 1, y = 2}

let var2 = {           # Span multiple lines
  a = x,
  b = y                # Optional trailing comma
}

let var3 = {
  c,                   # Individual item
  d = b,               # Assignment
}
</code></pre>
<p>值組是表格行的型別，這意味著許多轉換都期望它們。大多數轉換也可以採用單個欄位，該欄位將被轉換為值組。這些是等效的：</p>
<div class="comparison">
<div>
<h4 id="prql-30"><a class="header" href="#prql-30">PRQL</a></h4>
<pre><code class="language-prql">from employees
select {first_name}
</code></pre>
</div>
<div>
<h4 id="sql-29"><a class="header" href="#sql-29">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-31"><a class="header" href="#prql-31">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-30"><a class="header" href="#sql-30">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/tuples.html#admonition-note"></a>
</div>
<div>
<p>Prior to <code>0.9.0</code>, tuples were previously named Lists, and represented with <code>[]</code> syntax. There may still be references to the old naming.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="陣列"><a class="header" href="#陣列">陣列</a></h1>
<p>陣列是一個容器型別，由多個項目組成。所有項目必須是相同型別。欄位數量可以變化。</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/arrays.html#admonition-warning"></a>
</div>
<div>
<p>This page is a stub.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="識別符與關鍵字"><a class="header" href="#識別符與關鍵字">識別符與關鍵字</a></h1>
<p>Identifiers can contain alphanumeric characters and <code>_</code> and must not start with a number. They can be chained together with the <code>.</code> indirection operator, used to retrieve a tuple from a field or a variable from a module.</p>
<pre><code class="language-prql no-eval">hello

_h3llo

hello.world
</code></pre>
<h2 id="this-和-that"><a class="header" href="#this-和-that"><code>this</code> 和 <code>that</code></a></h2>
<p><code>this</code> 指的是目前的關聯：</p>
<div class="comparison">
<div>
<h4 id="prql-32"><a class="header" href="#prql-32">PRQL</a></h4>
<pre><code class="language-prql">from invoices
aggregate (
    count this
)
</code></pre>
</div>
<div>
<h4 id="sql-31"><a class="header" href="#sql-31">SQL</a></h4>
<pre><code class="language-sql">SELECT
  COUNT(*)
FROM
  invoices

</code></pre>
</div>
</div>
<p>在 <a href="reference/syntax/../stdlib/transforms/join.html"><code>join</code></a> 中，<code>that</code> 指的是另一個表格：</p>
<div class="comparison">
<div>
<h4 id="prql-33"><a class="header" href="#prql-33">PRQL</a></h4>
<pre><code class="language-prql">from invoices
join tracks (this.track_id==that.id)
</code></pre>
</div>
<div>
<h4 id="sql-32"><a class="header" href="#sql-32">SQL</a></h4>
<pre><code class="language-sql">SELECT
  invoices.*,
  tracks.*
FROM
  invoices
  JOIN tracks ON invoices.track_id = tracks.id

</code></pre>
</div>
</div>
<p><code>this</code> can also be used to remove any column ambiguity. For example, currently using a bare <code>time</code> as a column name will fail, because it’s also a type:</p>
<div class="comparison">
<div>
<h4 id="prql-34"><a class="header" href="#prql-34">PRQL</a></h4>
<pre><code class="language-prql">from invoices
derive t = time
</code></pre>
</div>
<div>
<h4 id="error-1"><a class="header" href="#error-1">Error</a></h4>
<pre><code class="hljs language-undefined">Error:
   ╭─[:2:12]
   │
 2 │ derive t = time
   │            ──┬─
   │              ╰─── unexpected `t = `&lt;time&gt;``
   │
   │ Help: this is probably a &#39;bad type&#39; error (we are working on that)
───╯
</code></pre>
</div>
</div>
<p>但有了 <code>this.time</code>，我們可以移除歧義：</p>
<div class="comparison">
<div>
<h4 id="prql-35"><a class="header" href="#prql-35">PRQL</a></h4>
<pre><code class="language-prql">from invoices
derive t = this.time
</code></pre>
</div>
<div>
<h4 id="sql-33"><a class="header" href="#sql-33">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  time AS t
FROM
  invoices

</code></pre>
</div>
</div>
<h2 id="引述"><a class="header" href="#引述">引述</a></h2>
<p>為了使用其他方式無效的字元，識別符可以用反引號括起來。</p>
<p>編譯為 SQL 時，這些識別符將使用方言特定的引號和引述規則。</p>
<div class="comparison">
<div>
<h4 id="prql-36"><a class="header" href="#prql-36">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mysql
from employees
select `first name`
</code></pre>
</div>
<div>
<h4 id="sql-34"><a class="header" href="#sql-34">SQL</a></h4>
<pre><code class="language-sql">SELECT
  `first name`
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-37"><a class="header" href="#prql-37">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.postgres
from employees
select `first name`
</code></pre>
</div>
<div>
<h4 id="sql-35"><a class="header" href="#sql-35">SQL</a></h4>
<pre><code class="language-sql">SELECT
  "first name"
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-38"><a class="header" href="#prql-38">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.bigquery

from `project-foo.dataset.table`
join `project-bar.dataset.table` (==col_bax)
</code></pre>
</div>
<div>
<h4 id="sql-36"><a class="header" href="#sql-36">SQL</a></h4>
<pre><code class="language-sql">SELECT
  `project-foo.dataset.table`.*,
  `project-bar.dataset.table`.*
FROM
  `project-foo.dataset.table`
  JOIN `project-bar.dataset.table` ON `project-foo.dataset.table`.col_bax = `project-bar.dataset.table`.col_bax

</code></pre>
</div>
</div>
<h2 id="綱要和資料庫名稱"><a class="header" href="#綱要和資料庫名稱">綱要和資料庫名稱</a></h2>
<p>資料庫表格的識別符可以加上綱要和資料庫名稱的前綴。</p>
<div class="comparison">
<div>
<h4 id="prql-39"><a class="header" href="#prql-39">PRQL</a></h4>
<pre><code class="language-prql">from my_database.chinook.albums
</code></pre>
</div>
<div>
<h4 id="sql-37"><a class="header" href="#sql-37">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  my_database.chinook.albums

</code></pre>
</div>
</div>
<p>請注意，以下所有識別符都將被視為單獨的表格定義：<code>tracks</code>、<code>public.tracks</code>、<code>my_database.public.tracks</code>。</p>
<h2 id="關鍵字"><a class="header" href="#關鍵字">關鍵字</a></h2>
<p>PRQL 使用了以下關鍵字：</p>
<ul>
<li><strong><code>prql</code></strong> - query header <a href="reference/syntax/../../project/target.html"><em>more…</em></a></li>
<li><strong><code>let</code></strong> - variable definition <a href="reference/syntax/../declarations/variables.html"><em>more…</em></a></li>
<li><strong><code>into</code></strong> - variable definition <a href="reference/syntax/../declarations/variables.html"><em>more…</em></a></li>
<li><strong><code>case</code></strong> - flow control <a href="reference/syntax/../syntax/case.html"><em>more…</em></a></li>
<li><strong><code>type</code></strong> - 型別宣告</li>
<li><strong><code>func</code></strong> - explicit function declaration <a href="reference/syntax/../declarations/functions.html"><em>more…</em></a></li>
<li><strong><code>module</code></strong> - 內部使用</li>
<li><strong><code>internal</code></strong> - 內部使用</li>
<li><strong><code>true</code></strong> - boolean <a href="reference/syntax/./literals.html#booleans"><em>more…</em></a></li>
<li><strong><code>false</code></strong> - boolean <a href="reference/syntax/./literals.html#booleans"><em>more…</em></a></li>
<li><strong><code>null</code></strong> - NULL <a href="reference/syntax/./literals.html#null"><em>more…</em></a></li>
</ul>
<p>關鍵字可以用作識別符（欄位或變數），當被反引號括起來時：<code>`case`</code>。</p>
<p>轉換是 <code>std</code> 命名空間中的普通函式，不是關鍵字。也就是說，<code>std.from</code> 與 <code>from</code> 是相同的函式。在下面的範例中，產生的查詢與沒有 <code>std.</code> 命名空間時相同：</p>
<div class="comparison">
<div>
<h4 id="prql-40"><a class="header" href="#prql-40">PRQL</a></h4>
<pre><code class="language-prql">std.from my_table
std.select {from = my_table.a, take = my_table.b}
std.take 3
</code></pre>
</div>
<div>
<h4 id="sql-38"><a class="header" href="#sql-38">SQL</a></h4>
<pre><code class="language-sql">SELECT
  a AS "from",
  b AS take
FROM
  my_table
LIMIT
  3

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函式呼叫"><a class="header" href="#函式呼叫">函式呼叫</a></h1>
<h2 id="簡單"><a class="header" href="#簡單">簡單</a></h2>
<p>PRQL 和大多數其他程式語言之間的區別是函式呼叫語法。它由函式名稱組成，後面跟著以空格分隔的引數。</p>
<pre><code class="language-prql no-eval">function_name arg1 arg2 arg3
</code></pre>
<p>如果其中一個引數也是函式呼叫，它必須用括號括起來，這樣我們才能知道內部函式的引數在哪裡結束，外部函式的引數在哪裡開始。</p>
<pre><code class="language-prql no-eval">outer_func arg_1 (inner_func arg_a, arg_b) arg_2
</code></pre>
<p>函式名稱必須指向函式變數，該變數要麼在<a href="reference/syntax/../stdlib/">標準函式庫</a>中<a href="reference/syntax/../declarations/functions.html">已被宣告</a>，要麼在其他某個模組中。</p>
<p>函式呼叫也可以使用 <code>:</code> 符號指定具名參數：</p>
<pre><code class="language-prql no-eval">function_name arg1 named_param:arg2 arg3
</code></pre>
<h2 id="管道"><a class="header" href="#管道">管道</a></h2>
<p>有另一種呼叫函式的方式：使用管道。無論管道是由管道符號 <code>|</code> 還是新行分隔，管道相當於將每個函式作為下一個函式的最後一個引數應用。</p>
<pre><code class="language-prql no-eval">a | foo 3 | bar 'hello' 'world' | baz
</code></pre>
<p>… is equivalent to …</p>
<pre><code class="language-prql no-eval">baz (bar 'hello' 'world' (foo 3 a))
</code></pre>
<!--
TODO: this should be a part of the tutorial


As you may have noticed, transforms are regular functions too!

```prql
from employees
filter age > 50
sort name
```

... is equivalent to ...

```prql
from employees | filter age > 50 | sort name
```

... is equivalent to ...

```prql
filter age > 50 (from employees) | sort name
```

... is equivalent to ...

```prql
sort name (filter age > 50 (from employees))
```

As you can see, the first example with pipeline notation is much easier to
comprehend, compared to the last one with the regular function call notation.
This is why it is recommended to use pipelines for nested function calls that
are 3 or more levels deep.

-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="管道-1"><a class="header" href="#管道-1">管道</a></h1>
<p>管道是組成管道的<a href="reference/syntax/../stdlib/transforms/">轉換</a>之間的連接。管道前的轉換所產生的關聯用作管道後轉換的輸入。管道可以用換行符或管道字元 (<code>|</code>) 表示。</p>
<p>例如，這裡 <code>filter</code> 轉換對 <code>from employees</code>（這只是 <code>employees</code> 表格）的結果進行操作，<code>select</code> 轉換對 <code>filter</code> 轉換的結果進行操作。</p>
<div class="comparison">
<div>
<h4 id="prql-41"><a class="header" href="#prql-41">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter department == "Product"
select {first_name, last_name}
</code></pre>
</div>
<div>
<h4 id="sql-39"><a class="header" href="#sql-39">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees
WHERE
  department = 'Product'

</code></pre>
</div>
</div>
<p>In the place of a line break, it’s also possible to use the <code>|</code> character to pipe results between transforms, such that this is equivalent:</p>
<div class="comparison">
<div>
<h4 id="prql-42"><a class="header" href="#prql-42">PRQL</a></h4>
<pre><code class="language-prql">from employees | filter department == "Product" | select {first_name, last_name}
</code></pre>
</div>
<div>
<h4 id="sql-40"><a class="header" href="#sql-40">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees
WHERE
  department = 'Product'

</code></pre>
</div>
</div>
<p>In almost all situations, a line break acts as a pipe. But there are a few exceptions where a line break doesn’t create a pipeline:</p>
<ul>
<li>within a tuple</li>
<li>within an array</li>
<li>when the following line is a new statement, which starts with a keyword of <code>func</code>, <code>let</code> or <code>from</code></li>
<li>Within a <a href="reference/syntax/./operators.html#wrapping-lines">line wrap</a></li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-43"><a class="header" href="#prql-43">PRQL</a></h4>
<pre><code class="language-prql">from [        # Line break OK in an array
  {a=2, b=3}
]
derive {      # Line break OK in a tuple
  c = 2 * a,
}
</code></pre>
</div>
<div>
<h4 id="sql-41"><a class="header" href="#sql-41">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    2 AS a,
    3 AS b
)
SELECT
  a,
  b,
  2 * a AS c
FROM
  table_0

</code></pre>
</div>
</div>
<h2 id="inner-transforms"><a class="header" href="#inner-transforms">Inner Transforms</a></h2>
<!-- TODO: I don't think this really fits here -->
<p>Parentheses are also used for transforms (such as <code>group</code> and <code>window</code>) that pass their result to an “inner transform”. The example below applies the <code>aggregate</code> pipeline to each group of unique <code>title</code> and <code>country</code> values:</p>
<div class="comparison">
<div>
<h4 id="prql-44"><a class="header" href="#prql-44">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {title, country} (
  aggregate {
    average salary,
    ct = count salary,
  }
)
</code></pre>
</div>
<div>
<h4 id="sql-42"><a class="header" href="#sql-42">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="運算子"><a class="header" href="#運算子">運算子</a></h1>
<p>表達式可以由 <em>函式呼叫</em> 和 <em>運算</em> 組成，例如 <code>2 + 3</code> 或 <code>((1 + x) * -y)</code>。在下方的範例中，請注意使用表達式計算別名 <code>circumference</code> 和在 <code>filter</code> 轉換中的用法。</p>
<div class="comparison">
<div>
<h4 id="prql-45"><a class="header" href="#prql-45">PRQL</a></h4>
<pre><code class="language-prql">from foo
select {
  circumference = diameter * 3.14159,
  color,
}
filter circumference &gt; 10 &amp;&amp; color != "red"
</code></pre>
</div>
<div>
<h4 id="sql-43"><a class="header" href="#sql-43">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    diameter * 3.14159 AS circumference,
    color
  FROM
    foo
)
SELECT
  circumference,
  color
FROM
  table_0
WHERE
  circumference &gt; 10
  AND color &lt;&gt; 'red'

</code></pre>
</div>
</div>
<h2 id="運算子優先級"><a class="header" href="#運算子優先級">運算子優先級</a></h2>
<p>此表顯示運算子優先級。使用括號 <code>()</code> 優先順序排列運算和函式呼叫（參閱下面的討論。）</p>
<!-- markdownlint-disable MD033 — the `|` characters need to be escaped, and surrounded with tags rather than backticks   -->
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">群組</th><th>運算子</th><th style="text-align: center">優先級</th><th style="text-align: center">結合性</th></tr></thead><tbody>
<tr><td style="text-align: right">括號</td><td><code>()</code></td><td style="text-align: center">0</td><td style="text-align: center">見下文</td></tr>
<tr><td style="text-align: right">識別符點</td><td><code>.</code></td><td style="text-align: center">1</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: right">一元</td><td><code>-</code> <code>+</code> <code>!</code> <code>==</code></td><td style="text-align: center">2</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: right">範圍</td><td><code>..</code></td><td style="text-align: center">3</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: right">乘法</td><td><code>*</code> <code>/</code> <code>//</code> <code>%</code></td><td style="text-align: center">4</td><td style="text-align: center">左至右</td></tr>
<tr><td style="text-align: right">加法</td><td><code>+</code> <code>-</code></td><td style="text-align: center">5</td><td style="text-align: center">左至右</td></tr>
<tr><td style="text-align: right">比較</td><td><code>==</code> <code>!=</code> <code>&lt;=</code> <code>&gt;=</code> <code>&lt;</code> <code>&gt;</code></td><td style="text-align: center">6</td><td style="text-align: center">左至右</td></tr>
<tr><td style="text-align: right">合併</td><td><code>??</code></td><td style="text-align: center">7</td><td style="text-align: center">左至右</td></tr>
<tr><td style="text-align: right">且</td><td><code>&amp;&amp;</code></td><td style="text-align: center">8</td><td style="text-align: center">左至右</td></tr>
<tr><td style="text-align: right">或</td><td><code>|&lt;/code&gt;</td><td style="text-align: center">9</td><td style="text-align: center">左至右</td></tr>
<tr><td style="text-align: right">函式呼叫</td><td></td><td style="text-align: center">10</td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<h2 id="合併"><a class="header" href="#合併">合併</a></h2>
<p>我們可以使用 <code>??</code> 運算子合併值。合併會取第一個值，或者如果該值為空，則取第二個值。</p>
<div class="comparison">
<div>
<h4 id="prql-46"><a class="header" href="#prql-46">PRQL</a></h4>
<pre><code class="language-prql">from orders
derive amount ?? 0
</code></pre>
</div>
<div>
<h4 id="sql-44"><a class="header" href="#sql-44">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  COALESCE(amount, 0)
FROM
  orders

</code></pre>
</div>
</div>
<h2 id="常規表達式"><a class="header" href="#常規表達式">常規表達式</a></h2>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/operators.html#admonition-note"></a>
</div>
<div>
<p>This is currently experimental</p>
</div>
</div>
<p>要執行區分大小寫的常規表達式搜索，請使用 <code>~=</code> 運算子。這通常編譯為 <code>REGEXP</code>，儘管因方言而異。常規表達式搜索意味著要匹配確切的值，開始和結束需要用 <code>^foo$</code> 錨定。</p>
<div class="comparison">
<div>
<h4 id="prql-47"><a class="header" href="#prql-47">PRQL</a></h4>
<pre><code class="language-prql">from tracks
filter (name ~= "Love")
</code></pre>
</div>
<div>
<h4 id="sql-45"><a class="header" href="#sql-45">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP(name, 'Love')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-48"><a class="header" href="#prql-48">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.duckdb

from artists
filter (name ~= "Love.*You")
</code></pre>
</div>
<div>
<h4 id="sql-46"><a class="header" href="#sql-46">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  artists
WHERE
  REGEXP_MATCHES(name, 'Love.*You')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-49"><a class="header" href="#prql-49">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.bigquery

from tracks
filter (name ~= "\\bLove\\b")
</code></pre>
</div>
<div>
<h4 id="sql-47"><a class="header" href="#sql-47">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP_CONTAINS(name, '\bLove\b')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-50"><a class="header" href="#prql-50">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.postgres

from tracks
filter (name ~= "\\(I Can't Help\\) Falling")
</code></pre>
</div>
<div>
<h4 id="sql-48"><a class="header" href="#sql-48">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  name ~ '\(I Can''t Help\) Falling'

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-51"><a class="header" href="#prql-51">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mysql

from tracks
filter (name ~= "With You")
</code></pre>
</div>
<div>
<h4 id="sql-49"><a class="header" href="#sql-49">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP_LIKE(name, 'With You', 'c')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-52"><a class="header" href="#prql-52">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.sqlite

from tracks
filter (name ~= "But Why Isn't Your Syntax More Similar\\?")
</code></pre>
</div>
<div>
<h4 id="sql-50"><a class="header" href="#sql-50">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  name REGEXP 'But Why Isn''t Your Syntax More Similar\?'

</code></pre>
</div>
</div>
<h2 id="括號"><a class="header" href="#括號">括號</a></h2>
<p>PRQL 使用括號 <code>()</code> 有幾個目的：</p>
<ul>
<li>
<p>括號對操作數進行分組以控制評估順序，例如：<code>((1 + x) * y)</code></p>
</li>
<li>
<p>括號用於分隔函式引數的減號，例如：<code>add (-1) (-3)</code></p>
</li>
<li>
<p>""括號用於分隔包含管道的嵌套函式呼叫，可以是 <code>|</code> 符號或新行。"嵌套"是指在轉換中；即不僅僅是主管道，例如：<code>(column-name | in 0..20)</code></p>
</li>
<li>
<p>Parentheses wrap a function call that is part of a larger expression, for example: <code>round 0 (sum distance)</code></p>
</li>
</ul>
<p>括號對於不包含函式呼叫的表達式<strong>不是</strong>必需的，例如：<code>foo + bar</code>。</p>
<p>Here’s a set of examples of these rules:</p>
<div class="comparison">
<div>
<h4 id="prql-53"><a class="header" href="#prql-53">PRQL</a></h4>
<pre><code class="language-prql">from employees
# Requires parentheses, because it contains a pipe
derive is_proximate = (distance | in 0..20)
# Requires parentheses, because it's a function call
derive total_distance = (sum distance)
# `??` doesn't require parentheses, as it's not a function call
derive min_capped_distance = (min distance ?? 5)
# No parentheses needed, because no function call
derive travel_time = distance / 40
# No inner parentheses needed around `1+1` because no function call
derive distance_rounded_2_dp = (round 1+1 distance)
derive {
  # Requires parentheses, because it contains a pipe
  is_far = (distance | in 100..),
  # The left value of the range requires parentheses,
  # because of the minus sign
  is_negative = (distance | in (-100..0)),
  # ...this is equivalent
  is_negative = (distance | in (-100)..0),
  # _Technically_, this doesn't require parentheses, because it's
  # the RHS of an assignment in a tuple
  # (this is especially confusing)
  average_distance = average distance,
}
# Requires parentheses because of the minus sign
sort (-distance)
# A tuple is fine too
sort {-distance}
</code></pre>
</div>
<div>
<h4 id="sql-51"><a class="header" href="#sql-51">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  distance BETWEEN 0 AND 20 AS is_proximate,
  SUM(distance) OVER () AS total_distance,
  MIN(COALESCE(distance, 5)) OVER () AS min_capped_distance,
  distance / 40 AS travel_time,
  ROUND(distance, 1 + 1) AS distance_rounded_2_dp,
  distance &gt;= 100 AS is_far,
  distance BETWEEN -100 AND 0,
  distance BETWEEN -100 AND 0 AS is_negative,
  AVG(distance) OVER () AS average_distance
FROM
  employees
ORDER BY
  distance DESC

</code></pre>
</div>
</div>
<p>例如，下面的代碼片段產生錯誤，因為 <code>sum</code> 函式呼叫不在元組中。</p>
<div class="comparison">
<div>
<h4 id="prql-54"><a class="header" href="#prql-54">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive total_distance = sum distance
</code></pre>
</div>
<div>
<h4 id="error-2"><a class="header" href="#error-2">Error</a></h4>
<pre><code class="hljs language-undefined">Error:
   ╭─[:2:29]
   │
 2 │ derive total_distance = sum distance
   │                             ────┬───
   │                                 ╰───── Unknown name
───╯
</code></pre>
</div>
</div>
<p>…while with parentheses, it works at expected:</p>
<div class="comparison">
<div>
<h4 id="prql-55"><a class="header" href="#prql-55">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive other_distance = (sum distance)
</code></pre>
</div>
<div>
<h4 id="sql-52"><a class="header" href="#sql-52">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  SUM(distance) OVER () AS other_distance
FROM
  employees

</code></pre>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/operators.html#admonition-note-1"></a>
</div>
<div>
<p>We’re continuing to think whether these rules can be more intuitive. We’re also planning to make the error messages much better, so the compiler can help out.</p>
</div>
</div>
<h2 id="換行"><a class="header" href="#換行">換行</a></h2>
<p>PRQL 中的換行有語義含義，所以要將單個邏輯行換行為多個物理行，我們可以在後續物理行的開始處使用 <code>\</code>：</p>
<div class="comparison">
<div>
<h4 id="prql-56"><a class="header" href="#prql-56">PRQL</a></h4>
<pre><code class="language-prql">from artists
select is_europe =
\ country == "DE"
\ || country == "FR"
\ || country == "ES"
</code></pre>
</div>
<div>
<h4 id="sql-53"><a class="header" href="#sql-53">SQL</a></h4>
<pre><code class="language-sql">SELECT
  country = 'DE'
  OR country = 'FR'
  OR country = 'ES' AS is_europe
FROM
  artists

</code></pre>
</div>
</div>
<p>Wrapping will “jump over” empty lines or lines with comments. For example, the <code>select</code> here is only one logical line:</p>
<div class="comparison">
<div>
<h4 id="prql-57"><a class="header" href="#prql-57">PRQL</a></h4>
<pre><code class="language-prql">from tracks
# This would be a really long line without being able to split it:
select listening_time_years = (spotify_plays + apple_music_plays + pandora_plays)
# * length_seconds
# Actually it's `length_s` I think:
\ * length_s
#   min  hour day  year
\ / 60 / 60 / 24 / 365
</code></pre>
</div>
<div>
<h4 id="sql-54"><a class="header" href="#sql-54">SQL</a></h4>
<pre><code class="language-sql">SELECT
  (
    spotify_plays + apple_music_plays + pandora_plays
  ) * length_s / 60 / 60 / 24 / 365 AS listening_time_years
FROM
  tracks

</code></pre>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/operators.html#admonition-info"></a>
</div>
<div>
<p>Note that most languages use a <code>\</code> at the <em>end</em> of the preceding line. Because PRQL aims to be friendly for data exploration, we want to make it easy to comment out a line, which requires the character at the start of the following line.</p>
</div>
</div>
<p>有關換行的更多詳細資訊，請參閱 <a href="reference/syntax/./pipes.html">Pipes</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="情況"><a class="header" href="#情況">情況</a></h1>
<p>搜尋第一個評估為 <code>true</code> 的條件並返回其關聯值。如果沒有條件符合，則返回 <code>null</code>。</p>
<div class="comparison">
<div>
<h4 id="prql-58"><a class="header" href="#prql-58">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive distance = case {
  city == "Calgary" =&gt; 0,
  city == "Edmonton" =&gt; 300,
}
</code></pre>
</div>
<div>
<h4 id="sql-55"><a class="header" href="#sql-55">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  CASE
    WHEN city = 'Calgary' THEN 0
    WHEN city = 'Edmonton' THEN 300
    ELSE NULL
  END AS distance
FROM
  employees

</code></pre>
</div>
</div>
<p>要設定預設值，可以使用 <code>true</code> 條件：</p>
<div class="comparison">
<div>
<h4 id="prql-59"><a class="header" href="#prql-59">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive distance = case {
  city == "Calgary" =&gt; 0,
  city == "Edmonton" =&gt; 300,
  true =&gt; "Unknown",
}
</code></pre>
</div>
<div>
<h4 id="sql-56"><a class="header" href="#sql-56">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  CASE
    WHEN city = 'Calgary' THEN 0
    WHEN city = 'Edmonton' THEN 300
    ELSE 'Unknown'
  END AS distance
FROM
  employees

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="範圍"><a class="header" href="#範圍">範圍</a></h1>
<p>範圍 <code>start..end</code> 表示 <code>start</code> 和 <code>end</code> 之間的一組值（含括，大於等於 <code>start</code> 且小於等於 <code>end</code>）。</p>
<p>若要表示在一側開放的範圍，可以省略 <code>start</code> 或 <code>end</code>。</p>
<p>範圍可以在 <code>in</code> 函式的篩選器中使用，具有任何型別的字面值，包括日期：</p>
<div class="comparison">
<div>
<h4 id="prql-60"><a class="header" href="#prql-60">PRQL</a></h4>
<pre><code class="language-prql">from events
filter (created_at | in @1776-07-04..@1787-09-17)
filter (magnitude | in 50..100)
derive is_northern = (latitude | in 0..)
</code></pre>
</div>
<div>
<h4 id="sql-57"><a class="header" href="#sql-57">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  latitude &gt;= 0 AS is_northern
FROM
  events
WHERE
  created_at BETWEEN DATE '1776-07-04' AND DATE '1787-09-17'
  AND magnitude BETWEEN 50 AND 100

</code></pre>
</div>
</div>
<p>範圍也可以在 <code>take</code> 中使用：</p>
<div class="comparison">
<div>
<h4 id="prql-61"><a class="header" href="#prql-61">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort {-value, created_at}
take 101..110
</code></pre>
</div>
<div>
<h4 id="sql-58"><a class="header" href="#sql-58">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  orders
ORDER BY
  value DESC,
  created_at
LIMIT
  10 OFFSET 100

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/ranges.html#admonition-note"></a>
</div>
<div>
<p>Half-open ranges are generally less intuitive to read than a simple <code>&gt;=</code> or <code>&lt;=</code> operator.</p>
</div>
</div>
<h2 id="另請參見-2"><a class="header" href="#另請參見-2">另請參見</a></h2>
<ul>
<li><a href="reference/syntax/../stdlib/transforms/take.html">take 變換</a></li>
</ul>
<h2 id="路線圖-2"><a class="header" href="#路線圖-2">路線圖</a></h2>
<p>We’d like to use ranges for other types, such as whether an object is in an array or list literal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="註釋"><a class="header" href="#註釋">註釋</a></h1>
<p>字元 <code>#</code> 表示註釋到行的結尾。</p>
<div class="comparison">
<div>
<h4 id="prql-62"><a class="header" href="#prql-62">PRQL</a></h4>
<pre><code class="language-prql">from employees  # Comment 1
# Comment 2
aggregate {average salary}
</code></pre>
</div>
<div>
<h4 id="sql-59"><a class="header" href="#sql-59">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary)
FROM
  employees

</code></pre>
</div>
</div>
<p>There’s no distinct multiline comment syntax.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="參數"><a class="header" href="#參數">參數</a></h1>
<p>參數是查詢編譯後提供的值的佔位符。</p>
<p>它使用以下語法：<code>$id</code>，其中 <code>id</code> 是任意英數字元字串。</p>
<p>大多數資料庫引擎只支援數字位置參數 ID（例如 <code>$3</code>）。</p>
<div class="comparison">
<div>
<h4 id="prql-63"><a class="header" href="#prql-63">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter id == $1
</code></pre>
</div>
<div>
<h4 id="sql-60"><a class="header" href="#sql-60">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  id = $1

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Variables assign a name to an expression (let’s call it <code>x</code>). The name can then be used in any expression, acting as a substitute for the expression <code>x</code>.</p>
<p>Syntactically, variables can take 3 forms.</p>
<ul>
<li>
<p><code>let</code> declares the name before the expression.</p>
<pre><code class="language-prql no-eval">let my_name = x
</code></pre>
</li>
<li>
<p><code>into</code> declares the name after the expression. This form is useful for quick pipeline splitting and conforms with the “flow from top to bottom” rule of pipelines.</p>
<pre><code class="language-prql no-eval">x
into my_name
</code></pre>
</li>
<li>
<p>implicit name, does not declare a name at all, but uses name <code>main</code> as the default. This is practical, as <code>main</code> is the variable that is compiled as the main relational query by default.</p>
<pre><code class="language-prql no-eval">x
</code></pre>
<p>… is equivalent to:</p>
<pre><code>let main = x
</code></pre>
</li>
</ul>
<p>When compiling to SQL, relational variables are compiled to Common Table Expressions (or sub-queries in some cases).</p>
<div class="comparison">
<div>
<h4 id="prql-64"><a class="header" href="#prql-64">PRQL</a></h4>
<pre><code class="language-prql">let top_50 = (
  from employees
  sort salary
  take 50
  aggregate {total_salary = sum salary}
)

from top_50      # Starts a new pipeline
</code></pre>
</div>
<div>
<h4 id="sql-61"><a class="header" href="#sql-61">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    salary
  FROM
    employees
  ORDER BY
    salary
  LIMIT
    50
), top_50 AS (
  SELECT
    COALESCE(SUM(salary), 0) AS total_salary
  FROM
    table_0
)
SELECT
  total_salary
FROM
  top_50

</code></pre>
</div>
</div>
<pre><code class="language-prqls">from employees
take 50
into first_50

from first_50
</code></pre>
<p>Variables can be assigned an s-string containing the whole SQL query <a href="reference/declarations/../syntax/s-strings.html">s-string</a>, enabling us to use features which PRQL doesn’t yet support.</p>
<div class="comparison">
<div>
<h4 id="prql-65"><a class="header" href="#prql-65">PRQL</a></h4>
<pre><code class="language-prql">let grouping = s"""
  SELECT SUM(a)
  FROM tbl
  GROUP BY
    GROUPING SETS
    ((b, c, d), (d), (b, d))
"""

from grouping
</code></pre>
</div>
<div>
<h4 id="sql-62"><a class="header" href="#sql-62">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    SUM(a)
  FROM
    tbl
  GROUP BY
    GROUPING SETS ((b, c, d), (d), (b, d))
)
SELECT
  *
FROM
  table_0

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函式"><a class="header" href="#函式">函式</a></h1>
<!--
TODOs:
- Examples are a bit artificial — the interp is just "divide by 100" in one case!  -->
<p>Functions have two types of parameters:</p>
<ol>
<li>Positional parameters, which require an argument.</li>
<li>Named parameters, which optionally take an argument, otherwise using their default value.</li>
</ol>
<p>So this function is named <code>fahrenheit_to_celsius</code> and has one parameter <code>temp</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-66"><a class="header" href="#prql-66">PRQL</a></h4>
<pre><code class="language-prql">let fahrenheit_to_celsius = temp -&gt; (temp - 32) / 1.8

from cities
derive temp_c = (fahrenheit_to_celsius temp_f)
</code></pre>
</div>
<div>
<h4 id="sql-63"><a class="header" href="#sql-63">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (temp_f - 32) / 1.8 AS temp_c
FROM
  cities

</code></pre>
</div>
</div>
<p>This function is named <code>interp</code>, and has two positional parameters named <code>high</code> and <code>x</code>, and one named parameter named <code>low</code> which takes a default argument of <code>0</code>. It calculates the proportion of the distance that <code>x</code> is between <code>low</code> and <code>high</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-67"><a class="header" href="#prql-67">PRQL</a></h4>
<pre><code class="language-prql">let interp = low:0 high x -&gt; (x - low) / (high - low)

from students
derive {
  sat_proportion_1 = (interp 1600 sat_score),
  sat_proportion_2 = (interp low:0 1600 sat_score),
}
</code></pre>
</div>
<div>
<h4 id="sql-64"><a class="header" href="#sql-64">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_1,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_2
FROM
  students

</code></pre>
</div>
</div>
<h2 id="piping-values-into-functions"><a class="header" href="#piping-values-into-functions">Piping values into functions</a></h2>
<p>Consistent with the principles of PRQL, it’s possible to pipe values into functions, which makes composing many functions more readable. When piping a value into a function, the value is passed as an argument to the final positional parameter of the function. Here’s the same result as the examples above with an alternative construction:</p>
<div class="comparison">
<div>
<h4 id="prql-68"><a class="header" href="#prql-68">PRQL</a></h4>
<pre><code class="language-prql">let interp = low:0 high x -&gt; (x - low) / (high - low)

from students
derive {
  sat_proportion_1 = (sat_score | interp 1600),
  sat_proportion_2 = (sat_score | interp low:0 1600),
}
</code></pre>
</div>
<div>
<h4 id="sql-65"><a class="header" href="#sql-65">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_1,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_2
FROM
  students

</code></pre>
</div>
</div>
<p>且</p>
<div class="comparison">
<div>
<h4 id="prql-69"><a class="header" href="#prql-69">PRQL</a></h4>
<pre><code class="language-prql">let fahrenheit_to_celsius = temp -&gt; (temp - 32) / 1.8

from cities
derive temp_c = (temp_f | fahrenheit_to_celsius)
</code></pre>
</div>
<div>
<h4 id="sql-66"><a class="header" href="#sql-66">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (temp_f - 32) / 1.8 AS temp_c
FROM
  cities

</code></pre>
</div>
</div>
<p>We can combine a chain of functions, which makes logic more readable:</p>
<div class="comparison">
<div>
<h4 id="prql-70"><a class="header" href="#prql-70">PRQL</a></h4>
<pre><code class="language-prql">let fahrenheit_to_celsius = temp -&gt; (temp - 32) / 1.8
let interp = low:0 high x -&gt; (x - low) / (high - low)

from kettles
derive boiling_proportion = (temp_c | fahrenheit_to_celsius | interp 100)
</code></pre>
</div>
<div>
<h4 id="sql-67"><a class="header" href="#sql-67">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  ((temp_c - 32) / 1.8 - 0) / (100 - 0) AS boiling_proportion
FROM
  kettles

</code></pre>
</div>
</div>
<h3 id="late-binding"><a class="header" href="#late-binding">Late binding</a></h3>
<p>Functions can bind to any variable that is in scope when the function is executed. For example, here <code>cost_total</code> refers to the column that’s introduced in the <code>from</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-71"><a class="header" href="#prql-71">PRQL</a></h4>
<pre><code class="language-prql">let cost_share = cost -&gt; cost / cost_total

from costs
select {materials, labor, overhead, cost_total}
derive {
  materials_share = (cost_share materials),
  labor_share = (cost_share labor),
  overhead_share = (cost_share overhead),
}
</code></pre>
</div>
<div>
<h4 id="sql-68"><a class="header" href="#sql-68">SQL</a></h4>
<pre><code class="language-sql">SELECT
  materials,
  labor,
  overhead,
  cost_total,
  materials / cost_total AS materials_share,
  labor / cost_total AS labor_share,
  overhead / cost_total AS overhead_share
FROM
  costs

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="標準庫"><a class="header" href="#標準庫">標準庫</a></h1>
<p>The standard library currently contains commonly used functions that are used in SQL. It’s not yet as broad as we’d like, and we’re very open to expanding it.</p>
<p>Currently s-strings are an escape-hatch for any function that isn’t in our standard library. If we find ourselves using them for something frequently, raise an issue and we’ll add it to the stdlib.</p>
<p>Here’s the source of the current <a href="https://github.com/PRQL/prql/blob/main/crates/prql-compiler/src/semantic/std.prql">PRQL <code>std</code></a>:</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/index.html#admonition-note"></a>
</div>
<div>
<p>PRQL 0.9.0 has started supporting different DB implementations for standard library functions. The source is the <a href="https://github.com/PRQL/prql/blob/main/crates/prql-compiler/src/sql/std.sql.prql"><code>std.sql</code></a>.</p>
</div>
</div>
<pre><code class="language-prql no-eval"># The PRQL standard library defines the following functions and transforms.
# The definitions are whitespace insensitive, and have this form:
#
# ```
# let my_func = param1 param2 ...  -&gt; &lt;return_type&gt; body_expr
# ```
#
# Where:
#   * `my_func` is the name of the function
#   * `param1` is the first parameter optionally followed by a type in "&lt; ... &gt;"
#   * `param2` etc. follow the same pattern as param1
#   * `&lt;return_type&gt;` is the type of result wrapped in "&lt; ... &gt;"
#   * `body_expr` defines the function body that creates the result.
#     It can be PRQL code or `internal ...` to indicate internal compiler code.

# Operators

let mul = left right -&gt; &lt;int || float&gt; internal std.mul
let div_i = left right -&gt; &lt;int || float&gt; internal std.div_i
let div_f = left right -&gt; &lt;int || float&gt; internal std.div_f
let mod = left right -&gt; &lt;int || float&gt; internal std.mod
let add = left&lt;int || float || timestamp || date&gt; right&lt;int || float || timestamp || date&gt; -&gt; &lt;int || float || timestamp || date&gt; internal std.add
let sub = left&lt;int || float || timestamp || date&gt; right&lt;int || float || timestamp || date&gt; -&gt; &lt;int || float || timestamp || date&gt; internal std.sub
let eq = left right -&gt; &lt;bool&gt; internal std.eq
let ne = left right -&gt; &lt;bool&gt; internal std.ne
let gt = left right -&gt; &lt;bool&gt; internal std.gt
let lt = left right -&gt; &lt;bool&gt; internal std.lt
let gte = left right -&gt; &lt;bool&gt; internal std.gte
let lte = left right -&gt; &lt;bool&gt; internal std.lte
let and = left&lt;bool&gt; right&lt;bool&gt; -&gt; &lt;bool&gt; internal std.and
let or = left&lt;bool&gt; right&lt;bool&gt; -&gt; &lt;bool&gt; internal std.or
let coalesce = left right -&gt; internal std.coalesce
let regex_search = text pattern -&gt; &lt;bool&gt; internal std.regex_search

let neg = expr&lt;int || float&gt; -&gt; &lt;int || float&gt; internal std.neg
let not = expr&lt;bool&gt; -&gt; &lt;bool&gt; internal std.not

# Types

## Type primitives
type int
type float
type bool
type text
type date
type time
type timestamp
type `func`

## Generic array
# TODO: an array of anything, not just nulls
type array = [null]

## Scalar
type scalar = int || float || bool || text || date || time || timestamp || null
type tuple_of_scalars = {scalar..}

## Relation (an array of tuples)
type relation = [tuple_of_scalars]

## Transform
type transform = (func relation -&gt; relation)

# Functions

## Relational transforms
let from = func
  `default_db.source` &lt;relation&gt;
  -&gt; &lt;relation&gt; internal from

let select = func
  columns &lt;scalar || tuple_of_scalars&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal select

let filter = func
  condition &lt;bool&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal filter

let derive = func
  columns &lt;scalar || tuple_of_scalars&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal derive

let aggregate = func
  columns &lt;scalar || tuple_of_scalars&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal aggregate

let sort = func
  by &lt;scalar || tuple_of_scalars&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal sort

let take = func
  expr &lt;scalar&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal take

let join = func
  `default_db.with` &lt;relation&gt;
  condition &lt;bool&gt;
  `noresolve.side`:inner
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal join

let group = func
  by&lt;scalar || tuple_of_scalars&gt;
  pipeline &lt;transform&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal group

let window = func
  rows:0..0
  range:0..0
  expanding &lt;bool&gt;:false
  rolling &lt;int&gt;:0
  pipeline &lt;transform&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal window

let append = `default_db.bottom`&lt;relation&gt; top&lt;relation&gt; -&gt; &lt;relation&gt; internal append
let intersect = `default_db.bottom`&lt;relation&gt; top&lt;relation&gt; -&gt; &lt;relation&gt; (
  t = top
  join (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b.*)))
  select t.*
)
let remove = `default_db.bottom`&lt;relation&gt; top&lt;relation&gt; -&gt; &lt;relation&gt; (
  t = top
  join side:left (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b.*)))
  filter (tuple_every (tuple_map _is_null b.*))
  select t.*
)
let loop = func
  pipeline &lt;transform&gt;
  top &lt;relation&gt;
  -&gt; &lt;relation&gt; internal loop

## Aggregate functions
# These return either a scalar when used within `aggregate`, or a column when used anywhere else.

let min = column &lt;array&gt; -&gt; &lt;int || float || null&gt; internal std.min

let max = column &lt;array&gt; -&gt; &lt;int || float || null&gt; internal std.max

let sum = column &lt;array&gt; -&gt; &lt;int || float&gt; internal std.sum

let average = column &lt;array&gt; -&gt; &lt;float || null&gt; internal std.average

let stddev = column &lt;array&gt; -&gt; &lt;float || null&gt; internal std.stddev

let every = column &lt;array&gt; -&gt; &lt;bool&gt; internal std.every

let any = column &lt;array&gt; -&gt; &lt;bool&gt; internal std.any

let concat_array = column &lt;array&gt; -&gt; &lt;text&gt; internal std.concat_array

# Counts number of items in the column.
# Note that the count will include null values.
let count = column&lt;array&gt; -&gt; &lt;int&gt; internal std.count

# Deprecated in favour of filterning input to the [std.count] function (not yet implemented).
@{deprecated}
let count_distinct = column &lt;array&gt; -&gt; internal std.count_distinct

## Window functions
let lag =   offset &lt;int&gt;    column &lt;array&gt; -&gt; internal std.lag
let lead =  offset &lt;int&gt;    column &lt;array&gt; -&gt; internal std.lead
let first      = column &lt;array&gt; -&gt; internal std.first
let last       = column &lt;array&gt; -&gt; internal std.last
let rank       = column &lt;array&gt; -&gt; internal std.rank
let rank_dense = column &lt;array&gt; -&gt; internal std.rank_dense
let row_number = column &lt;array&gt; -&gt; internal std.row_number

## Misc functions
let round = n_digits column -&gt; &lt;scalar&gt; internal std.round
let as = `noresolve.type` column -&gt; &lt;scalar&gt; internal std.as
let in = pattern value -&gt; &lt;bool&gt; internal in

## Tuple functions
let tuple_every = func list -&gt; &lt;bool&gt; internal tuple_every
let tuple_map = func fn &lt;func&gt; list -&gt; internal tuple_map
let tuple_zip = func a b -&gt; internal tuple_zip
let _eq = func a -&gt; internal _eq
let _is_null = func a -&gt; _param.a == null

## Misc
let from_text = input&lt;text&gt; `noresolve.format`:csv -&gt; &lt;relation&gt; internal from_text

## String functions
let lower = column -&gt; &lt;text&gt; internal std.lower
let upper = column -&gt; &lt;text&gt; internal std.upper

## File-reading functions, primarily for DuckDB
let read_parquet = source&lt;text&gt; -&gt; &lt;relation&gt; internal std.read_parquet
let read_csv = source&lt;text&gt; -&gt; &lt;relation&gt; internal std.read_csv
</code></pre>
<p>以下是幾個示例：</p>
<div class="comparison">
<div>
<h4 id="prql-72"><a class="header" href="#prql-72">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = (salary + payroll_tax | as int),
  gross_salary_rounded = (gross_salary | round 0),
  time = s"NOW()",  # an s-string, given no `now` function exists in PRQL
}
</code></pre>
</div>
<div>
<h4 id="sql-69"><a class="header" href="#sql-69">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  CAST(salary + payroll_tax AS int) AS gross_salary,
  ROUND(CAST(salary + payroll_tax AS int), 0) AS gross_salary_rounded,
  NOW() AS time
FROM
  employees

</code></pre>
</div>
</div>
<p>不同實現的除法和整數除法的示例：</p>
<div class="comparison">
<div>
<h4 id="prql-73"><a class="header" href="#prql-73">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.sqlite

from [{x = 13, y = 5}]
select {
  quotient = x / y,
  int_quotient = x // y,
}
</code></pre>
</div>
<div>
<h4 id="sql-70"><a class="header" href="#sql-70">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    13 AS x,
    5 AS y
)
SELECT
  (x * 1.0 / y) AS quotient,
  ROUND(ABS(x / y) - 0.5) * SIGN(x) * SIGN(y) AS int_quotient
FROM
  table_0

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-74"><a class="header" href="#prql-74">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mysql

from [{x = 13, y = 5}]
select {
  quotient = x / y,
  int_quotient = x // y,
}
</code></pre>
</div>
<div>
<h4 id="sql-71"><a class="header" href="#sql-71">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    13 AS x,
    5 AS y
)
SELECT
  (x / y) AS quotient,
  (x DIV y) AS int_quotient
FROM
  table_0

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="變換"><a class="header" href="#變換">變換</a></h1>
<p>Transforms are functions that take a relation and produce a relation.</p>
<p>Usually they are chained together into a pipeline, which resembles an SQL query.</p>
<p>Transforms were designed with a focus on modularity, so each of them is fulfilling a specific purpose and has defined invariants (properties of the relation that are left unaffected). That’s often referred to as “orthogonality” and its goal is to keep transform functions composable by minimizing interference of their effects. Additionally, it also keeps the number of transforms low.</p>
<p>For example, <code>select</code> and <code>derive</code> will not change the number of rows, while <code>filter</code> and <code>take</code> will not change the number of columns.</p>
<p>In SQL, we can see this lack of invariant when an aggregation function is used in the <code>SELECT</code> clause. Before, the number of rows was kept constant, but introduction of an aggregation function caused the whole statement to produce only one row (per group).</p>
<p>These are the currently available transforms:</p>
<div class="table-wrapper"><table><thead><tr><th>Transform</th><th>Purpose</th><th>SQL Equivalent</th></tr></thead><tbody>
<tr><td><code>from</code></td><td><a href="reference/stdlib/transforms/./from.html">Start from a table</a></td><td><code>FROM</code></td></tr>
<tr><td><code>derive</code></td><td><a href="reference/stdlib/transforms/./derive.html">Compute new columns</a></td><td><code>SELECT *, ... AS ...</code></td></tr>
<tr><td><code>select</code></td><td><a href="reference/stdlib/transforms/./select.html">Pick &amp; compute columns</a></td><td><code>SELECT ... AS ...</code></td></tr>
<tr><td><code>filter</code></td><td><a href="reference/stdlib/transforms/./filter.html">Pick rows based on their values</a></td><td><code>WHERE</code>, <code>HAVING</code>,<code>QUALIFY</code></td></tr>
<tr><td><code>sort</code></td><td><a href="reference/stdlib/transforms/./sort.html">Order rows based on the values of columns</a></td><td><code>ORDER BY</code></td></tr>
<tr><td><code>join</code></td><td><a href="reference/stdlib/transforms/./join.html">Add columns from another table, matching rows based on a condition</a></td><td><code>JOIN</code></td></tr>
<tr><td><code>take</code></td><td><a href="reference/stdlib/transforms/./take.html">Pick rows based on their position</a></td><td><code>TOP</code>, <code>LIMIT</code>, <code>OFFSET</code></td></tr>
<tr><td><code>group</code></td><td><a href="reference/stdlib/transforms/./group.html">Partition rows into groups and applies a pipeline to each of them</a></td><td><code>GROUP BY</code>, <code>PARTITION BY</code></td></tr>
<tr><td><code>aggregate</code></td><td><a href="reference/stdlib/transforms/./aggregate.html">Summarize many rows into one row</a></td><td><code>SELECT foo(...)</code></td></tr>
<tr><td><code>window</code></td><td><a href="reference/stdlib/transforms/./window.html">Apply a pipeline to overlapping segments of rows</a></td><td><code>OVER</code>, <code>ROWS</code>, <code>RANGE</code></td></tr>
<tr><td><code>loop</code></td><td><a href="reference/stdlib/transforms/./loop.html">Iteratively apply a function to a relation until it’s empty</a></td><td><code>WITH RECURSIVE ...</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="聚合-1"><a class="header" href="#聚合-1">聚合</a></h1>
<p>Summarizes many rows into one row.</p>
<p>When applied:</p>
<ul>
<li>without <code>group</code>, it produces one row from the whole table,</li>
<li>within a <code>group</code> pipeline, it produces one row from each group.</li>
</ul>
<pre><code class="language-prql no-eval">aggregate {expression or assign operations}
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/aggregate.html#admonition-note"></a>
</div>
<div>
<p>Currently, all declared aggregation functions are <code>min</code>, <code>max</code>, <code>count</code>, <code>average</code>, <code>stddev</code>, <code>avg</code>, <code>sum</code> and <code>count_distinct</code>. We are in the process of filling out <a href="reference/stdlib/transforms/../">std lib</a>.</p>
</div>
</div>
<h2 id="範例-1"><a class="header" href="#範例-1">範例</a></h2>
<div class="comparison">
<div>
<h4 id="prql-75"><a class="header" href="#prql-75">PRQL</a></h4>
<pre><code class="language-prql">from employees
aggregate {
  average salary,
  ct = count salary
}
</code></pre>
</div>
<div>
<h4 id="sql-72"><a class="header" href="#sql-72">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-76"><a class="header" href="#prql-76">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {title, country} (
  aggregate {
    average salary,
    ct = count salary,
  }
)
</code></pre>
</div>
<div>
<h4 id="sql-73"><a class="header" href="#sql-73">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country

</code></pre>
</div>
</div>
<h2 id="aggregate-is-required"><a class="header" href="#aggregate-is-required">Aggregate is required</a></h2>
<p>Unlike in SQL, using an aggregation function in <code>derive</code> or <code>select</code> (or any other transform except <code>aggregate</code>) will not trigger aggregation. By default, PRQL will interpret such attempts functions as window functions:</p>
<div class="comparison">
<div>
<h4 id="prql-77"><a class="header" href="#prql-77">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {avg_sal = average salary}
</code></pre>
</div>
<div>
<h4 id="sql-74"><a class="header" href="#sql-74">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  AVG(salary) OVER () AS avg_sal
FROM
  employees

</code></pre>
</div>
</div>
<p>This ensures that <code>derive</code> does not manipulate the number of rows, but only ever adds a column. For more information, see <a href="reference/stdlib/transforms/./window.html">window transform</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附加"><a class="header" href="#附加">附加</a></h1>
<p>Concatenates two tables together.</p>
<p>Equivalent to <code>UNION ALL</code> in SQL. The number of rows is always the sum of the number of rows from the two input tables. To replicate <code>UNION DISTINCT</code>, see <a href="reference/stdlib/transforms/append.html#set-operations">set operations</a>.</p>
<div class="comparison">
<div>
<h4 id="prql-78"><a class="header" href="#prql-78">PRQL</a></h4>
<pre><code class="language-prql">from employees_1
append employees_2
</code></pre>
</div>
<div>
<h4 id="sql-75"><a class="header" href="#sql-75">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees_1
UNION
ALL
SELECT
  *
FROM
  employees_2

</code></pre>
</div>
</div>
<h2 id="remove"><a class="header" href="#remove">Remove</a></h2>
<blockquote>
<p><em>experimental</em></p>
</blockquote>
<p>Removes rows that appear in another relation, like <code>EXCEPT ALL</code>. Duplicate rows are removed one-for-one.</p>
<div class="comparison">
<div>
<h4 id="prql-79"><a class="header" href="#prql-79">PRQL</a></h4>
<pre><code class="language-prql">from employees_1
remove employees_2
</code></pre>
</div>
<div>
<h4 id="sql-76"><a class="header" href="#sql-76">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees_1 AS t
EXCEPT
  ALL
SELECT
  *
FROM
  employees_2 AS b

</code></pre>
</div>
</div>
<h2 id="intersection"><a class="header" href="#intersection">Intersection</a></h2>
<blockquote>
<p><em>experimental</em></p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-80"><a class="header" href="#prql-80">PRQL</a></h4>
<pre><code class="language-prql">from employees_1
intersect employees_2
</code></pre>
</div>
<div>
<h4 id="sql-77"><a class="header" href="#sql-77">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees_1 AS t
INTERSECT
ALL
SELECT
  *
FROM
  employees_2 AS b

</code></pre>
</div>
</div>
<h2 id="set-operations"><a class="header" href="#set-operations">Set operations</a></h2>
<blockquote>
<p><em>experimental</em></p>
</blockquote>
<p>To imitate set operations i.e. (<code>UNION</code>, <code>EXCEPT</code> and <code>INTERSECT</code>), you can use the following functions:</p>
<pre><code class="language-prql no-eval">let distinct = rel -&gt; (from t = _param.rel | group {t.*} (take 1))
let union = `default_db.bottom` top -&gt; (top | append bottom | distinct)
let except = `default_db.bottom` top -&gt; (top | distinct | remove bottom)
let intersect_distinct = `default_db.bottom` top -&gt; (top | intersect bottom | distinct)
</code></pre>
<p>Don’t mind the <code>default_db.</code> and <code>noop</code>, these are compiler implementation detail for now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="衍生"><a class="header" href="#衍生">衍生</a></h1>
<p>計算一個或多個新欄位。</p>
<pre><code class="language-prql no-eval">derive {
  name = expression,
  # or
  column,
}
</code></pre>
<h2 id="範例-2"><a class="header" href="#範例-2">範例</a></h2>
<div class="comparison">
<div>
<h4 id="prql-81"><a class="header" href="#prql-81">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive gross_salary = salary + payroll_tax
</code></pre>
</div>
<div>
<h4 id="sql-78"><a class="header" href="#sql-78">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + payroll_tax AS gross_salary
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-82"><a class="header" href="#prql-82">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = salary + payroll_tax,
  gross_cost = gross_salary + benefits_cost
}
</code></pre>
</div>
<div>
<h4 id="sql-79"><a class="header" href="#sql-79">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + payroll_tax AS gross_salary,
  salary + payroll_tax + benefits_cost AS gross_cost
FROM
  employees

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="篩選"><a class="header" href="#篩選">篩選</a></h1>
<p>Picks rows based on their values.</p>
<pre><code class="language-prql no-eval">filter boolean_expression
</code></pre>
<h2 id="範例-3"><a class="header" href="#範例-3">範例</a></h2>
<div class="comparison">
<div>
<h4 id="prql-83"><a class="header" href="#prql-83">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter age &gt; 25
</code></pre>
</div>
<div>
<h4 id="sql-80"><a class="header" href="#sql-80">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  age &gt; 25

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-84"><a class="header" href="#prql-84">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter (age &gt; 25 || department != "IT")
</code></pre>
</div>
<div>
<h4 id="sql-81"><a class="header" href="#sql-81">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  age &gt; 25
  OR department &lt;&gt; 'IT'

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-85"><a class="header" href="#prql-85">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter (age | in 25..40)
</code></pre>
</div>
<div>
<h4 id="sql-82"><a class="header" href="#sql-82">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  age BETWEEN 25 AND 40

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="從"><a class="header" href="#從">從</a></h1>
<p>Specifies a data source.</p>
<div class="comparison">
<div>
<h4 id="prql-86"><a class="header" href="#prql-86">PRQL</a></h4>
<pre><code class="language-prql">from artists
</code></pre>
</div>
<div>
<h4 id="sql-83"><a class="header" href="#sql-83">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  artists

</code></pre>
</div>
</div>
<p>To introduce an alias, use an assign expression:</p>
<div class="comparison">
<div>
<h4 id="prql-87"><a class="header" href="#prql-87">PRQL</a></h4>
<pre><code class="language-prql">from e = employees
select e.first_name
</code></pre>
</div>
<div>
<h4 id="sql-84"><a class="header" href="#sql-84">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees AS e

</code></pre>
</div>
</div>
<p>Table names containing spaces or special characters <a href="reference/stdlib/transforms/../../syntax/keywords.html#quoting">need to be contained within backticks</a>:</p>
<div class="comparison">
<div>
<h4 id="prql-88"><a class="header" href="#prql-88">PRQL</a></h4>
<pre><code class="language-prql">from `artist tracks`
</code></pre>
</div>
<div>
<h4 id="sql-85"><a class="header" href="#sql-85">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  "artist tracks"

</code></pre>
</div>
</div>
<p><code>default_db.tablename</code> can be used if the table name matches a function from the standard library.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/from.html#admonition-note"></a>
</div>
<div>
<p>We realize this is an awkward workaround. Track &amp; 👍 <a href="https://github.com/PRQL/prql/issues/3271">#3271</a> for resolving this.</p>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-89"><a class="header" href="#prql-89">PRQL</a></h4>
<pre><code class="language-prql">default_db.group  # in place of `from group`
take 1
</code></pre>
</div>
<div>
<h4 id="sql-86"><a class="header" href="#sql-86">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  "group"
LIMIT
  1

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="群組"><a class="header" href="#群組">群組</a></h1>
<p>Partitions the rows into groups and applies a pipeline to each of the groups.</p>
<pre><code class="language-prql no-eval">group {key_columns} (pipeline)
</code></pre>
<p>The partitioning of groups are determined by the <code>key_column</code>s (first argument).</p>
<p>The most conventional use of <code>group</code> is with <code>aggregate</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-90"><a class="header" href="#prql-90">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {title, country} (
  aggregate {
    average salary,
    ct = count salary
  }
)
</code></pre>
</div>
<div>
<h4 id="sql-87"><a class="header" href="#sql-87">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country

</code></pre>
</div>
</div>
<p>In concept, a transform in context of a <code>group</code> does the same transformation to the group as it would to the table — for example finding the employee who joined first across the whole table:</p>
<div class="comparison">
<div>
<h4 id="prql-91"><a class="header" href="#prql-91">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort join_date
take 1
</code></pre>
</div>
<div>
<h4 id="sql-88"><a class="header" href="#sql-88">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  join_date
LIMIT
  1

</code></pre>
</div>
</div>
<p>To find the employee who joined first in each department, it’s exactly the same pipeline, but within a <code>group</code> expression:</p>
<div class="comparison">
<div>
<h4 id="prql-92"><a class="header" href="#prql-92">PRQL</a></h4>
<pre><code class="language-prql">from employees
group role (
  sort join_date  # taken from above
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-89"><a class="header" href="#sql-89">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    ROW_NUMBER() OVER (
      PARTITION BY role
      ORDER BY
        join_date
    ) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  _expr_0 &lt;= 1

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="聯接"><a class="header" href="#聯接">聯接</a></h1>
<p>Adds columns from another table, matching rows based on a condition.</p>
<pre><code class="language-prql no-eval">join side:{inner|left|right|full} table (condition)
</code></pre>
<h2 id="參數-1"><a class="header" href="#參數-1">參數</a></h2>
<ul>
<li><code>side</code> specifies which rows to include, defaulting to <code>inner</code>.</li>
<li><em>table</em> - a reference to a relation, possibly including an alias, e.g. <code>a=artists</code></li>
<li><em>condition</em> - a boolean condition
<ul>
<li>If the condition evaluates to true for a given row, the row will be joined</li>
<li>If name is the same from both tables, it can be expressed with only <code>(==col)</code>.</li>
</ul>
</li>
</ul>
<h2 id="範例-4"><a class="header" href="#範例-4">範例</a></h2>
<div class="comparison">
<div>
<h4 id="prql-93"><a class="header" href="#prql-93">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:left positions (employees.id==positions.employee_id)
</code></pre>
</div>
<div>
<h4 id="sql-90"><a class="header" href="#sql-90">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*
FROM
  employees
  LEFT JOIN positions ON employees.id = positions.employee_id

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-94"><a class="header" href="#prql-94">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:left p=positions (employees.id==p.employee_id)
</code></pre>
</div>
<div>
<h4 id="sql-91"><a class="header" href="#sql-91">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  p.*
FROM
  employees
  LEFT JOIN positions AS p ON employees.id = p.employee_id

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-95"><a class="header" href="#prql-95">PRQL</a></h4>
<pre><code class="language-prql">from tracks
join side:left artists (
  # This adds a `country` condition, as an alternative to filtering
  artists.id==tracks.artist_id &amp;&amp; artists.country=='UK'
)
</code></pre>
</div>
<div>
<h4 id="sql-92"><a class="header" href="#sql-92">SQL</a></h4>
<pre><code class="language-sql">SELECT
  tracks.*,
  artists.*
FROM
  tracks
  LEFT JOIN artists ON artists.id = tracks.artist_id
  AND artists.country = 'UK'

</code></pre>
</div>
</div>
<p><a href="reference/stdlib/transforms/../../syntax/keywords.html#this--that"><code>this</code> &amp; <code>that</code></a> can be used to refer to the current &amp; other table respectively:</p>
<div class="comparison">
<div>
<h4 id="prql-96"><a class="header" href="#prql-96">PRQL</a></h4>
<pre><code class="language-prql">from tracks
join side:inner artists (
  this.id==that.artist_id
)
</code></pre>
</div>
<div>
<h4 id="sql-93"><a class="header" href="#sql-93">SQL</a></h4>
<pre><code class="language-sql">SELECT
  tracks.*,
  artists.*
FROM
  tracks
  JOIN artists ON tracks.id = artists.artist_id

</code></pre>
</div>
</div>
<h2 id="self-equality-operator"><a class="header" href="#self-equality-operator">Self equality operator</a></h2>
<p>If the join conditions are of form <code>left.x == right.x</code>, we can use “self equality operator”:</p>
<div class="comparison">
<div>
<h4 id="prql-97"><a class="header" href="#prql-97">PRQL</a></h4>
<pre><code class="language-prql">from employees
join positions (==emp_no)
</code></pre>
</div>
<div>
<h4 id="sql-94"><a class="header" href="#sql-94">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*
FROM
  employees
  JOIN positions ON employees.emp_no = positions.emp_no

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="循環"><a class="header" href="#循環">循環</a></h1>
<blockquote>
<p><em>Experimental</em></p>
</blockquote>
<pre><code class="language-prql no-eval">loop {step_function} {initial_relation}
</code></pre>
<p>Iteratively applies <code>step</code> function to <code>initial</code> relation until the <code>step</code> returns an empty table. Returns a relation that contains rows of initial relation and all intermediate relations.</p>
<p>This behavior could be expressed with following pseudo-code:</p>
<pre><code class="language-python">def loop(step, initial):
    result = []
    current = initial
    while current is not empty:
        result = append(result, current)
        current = step(current)

    return result
</code></pre>
<h2 id="範例-5"><a class="header" href="#範例-5">範例</a></h2>
<div class="comparison">
<div>
<h4 id="prql-98"><a class="header" href="#prql-98">PRQL</a></h4>
<pre><code class="language-prql">from [{n = 1}]
loop (
    filter n&lt;4
    select n = n+1
)

# returns [1, 2, 3, 4]
</code></pre>
</div>
<div>
<h4 id="sql-95"><a class="header" href="#sql-95">SQL</a></h4>
<pre><code class="language-sql">WITH RECURSIVE table_1 AS (
  SELECT
    1 AS n
),
table_0 AS (
  SELECT
    n
  FROM
    table_1
  UNION
  ALL
  SELECT
    n + 1
  FROM
    table_0
  WHERE
    n &lt; 4
)
SELECT
  n
FROM
  table_0

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/loop.html#admonition-note"></a>
</div>
<div>
<p>The behavior of <code>WITH RECURSIVE</code> may depend on the database configuration in MySQL. The compiler assumes the behavior described by the <a href="https://www.postgresql.org/docs/15/queries-with.html#QUERIES-WITH-RECURSIVE">Postgres documentation</a> and will not produce correct results for <a href="https://dev.mysql.com/doc/refman/8.0/en/with.html#common-table-expressions-recursive">alternative configurations of MySQL</a>.</p>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/loop.html#admonition-note-1"></a>
</div>
<div>
<p>Currently, <code>loop</code> may produce references to the recursive CTE in sub-queries, which is not supported by some database engines, e.g. SQLite. For now, we suggest step functions are kept simple enough to fit into a single SELECT statement.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="選擇"><a class="header" href="#選擇">選擇</a></h1>
<p>Picks and computes columns.</p>
<pre><code class="language-prql no-eval">select {
  name = expression,
  # or
  column,
}
# or
select !{column}
</code></pre>
<h2 id="範例-6"><a class="header" href="#範例-6">範例</a></h2>
<div class="comparison">
<div>
<h4 id="prql-99"><a class="header" href="#prql-99">PRQL</a></h4>
<pre><code class="language-prql">from employees
select name = f"{first_name} {last_name}"
</code></pre>
</div>
<div>
<h4 id="sql-96"><a class="header" href="#sql-96">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS name
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-100"><a class="header" href="#prql-100">PRQL</a></h4>
<pre><code class="language-prql">from employees
select {
  name = f"{first_name} {last_name}",
  age_eoy = dob - @2022-12-31,
}
</code></pre>
</div>
<div>
<h4 id="sql-97"><a class="header" href="#sql-97">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS name,
  dob - DATE '2022-12-31' AS age_eoy
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-101"><a class="header" href="#prql-101">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-98"><a class="header" href="#sql-98">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-102"><a class="header" href="#prql-102">PRQL</a></h4>
<pre><code class="language-prql">from e=employees
select {e.first_name, e.last_name}
</code></pre>
</div>
<div>
<h4 id="sql-99"><a class="header" href="#sql-99">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees AS e

</code></pre>
</div>
</div>
<h3 id="excluding-columns"><a class="header" href="#excluding-columns">Excluding columns</a></h3>
<p>We can use <code>!</code> to exclude a list of columns. This can operate in two ways:</p>
<ul>
<li>We use <code>SELECT * EXCLUDE</code> / <code>SELECT * EXCEPT</code> for the columns supplied to <code>select ![]</code> in dialects which support it.</li>
<li>Otherwise, the columns must have been defined prior in the query (unless all of a table’s columns are excluded); for example in another <code>select</code> or a <code>group</code> transform. In this case, we evaluate and specify the columns that should be included in the output SQL.</li>
</ul>
<p>Some examples:</p>
<div class="comparison">
<div>
<h4 id="prql-103"><a class="header" href="#prql-103">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.bigquery
from tracks
select !{milliseconds,bytes}
</code></pre>
</div>
<div>
<h4 id="sql-100"><a class="header" href="#sql-100">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
EXCEPT
  (milliseconds, bytes)
FROM
  tracks

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-104"><a class="header" href="#prql-104">PRQL</a></h4>
<pre><code class="language-prql">from tracks
select {track_id, title, composer, bytes}
select !{title, composer}
</code></pre>
</div>
<div>
<h4 id="sql-101"><a class="header" href="#sql-101">SQL</a></h4>
<pre><code class="language-sql">SELECT
  track_id,
  bytes
FROM
  tracks

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-105"><a class="header" href="#prql-105">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive nick = name
select !{artists.*}
</code></pre>
</div>
<div>
<h4 id="sql-102"><a class="header" href="#sql-102">SQL</a></h4>
<pre><code class="language-sql">SELECT
  name AS nick
FROM
  artists

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="排序"><a class="header" href="#排序">排序</a></h1>
<p>Order rows based on the values of one or more expressions (generally columns).</p>
<pre><code class="language-prql no-eval">sort {(+|-) column}
</code></pre>
<h2 id="參數-2"><a class="header" href="#參數-2">參數</a></h2>
<ul>
<li>One expression or a tuple of expressions to sort by</li>
<li>Each expression can be prefixed with:
<ul>
<li><code>+</code>, for ascending order, the default</li>
<li><code>-</code>, for descending order</li>
</ul>
</li>
<li>When using prefixes, even a single expression needs to be in a tuple or parentheses. (Otherwise, <code>sort -foo</code> is parsed as a subtraction between <code>sort</code> and <code>foo</code>.)</li>
</ul>
<h2 id="範例-7"><a class="header" href="#範例-7">範例</a></h2>
<div class="comparison">
<div>
<h4 id="prql-106"><a class="header" href="#prql-106">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort age
</code></pre>
</div>
<div>
<h4 id="sql-103"><a class="header" href="#sql-103">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-107"><a class="header" href="#prql-107">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort {-age}
</code></pre>
</div>
<div>
<h4 id="sql-104"><a class="header" href="#sql-104">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age DESC

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-108"><a class="header" href="#prql-108">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort {age, -tenure, +salary}
</code></pre>
</div>
<div>
<h4 id="sql-105"><a class="header" href="#sql-105">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age,
  tenure DESC,
  salary

</code></pre>
</div>
</div>
<p>We can also use expressions:</p>
<div class="comparison">
<div>
<h4 id="prql-109"><a class="header" href="#prql-109">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort {s"substr({first_name}, 2, 5)"}
</code></pre>
</div>
<div>
<h4 id="sql-106"><a class="header" href="#sql-106">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    substr(first_name, 2, 5) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
ORDER BY
  _expr_0

</code></pre>
</div>
</div>
<h2 id="ordering-guarantees"><a class="header" href="#ordering-guarantees">Ordering guarantees</a></h2>
<p>Ordering is persistent through a pipeline in PRQL. For example:</p>
<div class="comparison">
<div>
<h4 id="prql-110"><a class="header" href="#prql-110">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort tenure
join locations (==employee_id)
</code></pre>
</div>
<div>
<h4 id="sql-107"><a class="header" href="#sql-107">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  locations.*
FROM
  employees
  JOIN locations ON employees.employee_id = locations.employee_id
ORDER BY
  employees.tenure

</code></pre>
</div>
</div>
<p>Here, PRQL pushes the <code>sort</code> down the pipeline, compiling the <code>ORDER BY</code> to the <em>end</em> of the query. Consequently, most relation transforms retain the row order.</p>
<p>The explicit semantics are:</p>
<ul>
<li><code>sort</code> introduces a new order,</li>
<li><code>group</code> resets the order,</li>
<li><code>join</code> retains the order of the left relation,</li>
<li>database tables don’t have a known order.</li>
</ul>
<p>Comparatively, in SQL, relations possess no order, being orderable solely within the context of the query result, <code>LIMIT</code> statement, or window function. The lack of inherent order can result in an unexpected reshuffling of a previously ordered relation from a <code>JOIN</code> or windowing operation.</p>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/sort.html#admonition-info"></a>
</div>
<div>
<p>To be precise — in PRQL, a relation is an <em>array of tuples</em> and not a set or a bag. The persistent nature of this order remains intact through sub-queries and intermediate table definitions.</p>
</div>
</div>
<p>For instance, an SQL query such as:</p>
<pre><code class="language-sql">WITH albums_sorted AS (
  SELECT *
  FROM albums
  ORDER BY title
)
SELECT *
FROM albums_sorted
JOIN artists USING (artist_id)
</code></pre>
<p>…doesn’t guarantee any row order (indeed — even without the <code>JOIN</code>, the SQL standard doesn’t guarantee an order, although most implementations will respect it).</p>
<!-- We rolling this back. Waiting on the outcome of https://github.com/PRQL/prql/issues/2622 -->
<!-- ## Nulls

PRQL defaults to `NULLS LAST` when compiling to SQL. Because databases have
different defaults, the compiler emits this for all targets for which it's not a
default<sup><a name="to-footnote-1">[1](#footnote-1)</a></sup>.

The main benefit of this approach is that `take 42` will select non-null values
for both ascending and descending sorts, which is generally what is wanted.

There isn't currently a way to change this for a query, but if that would be
helpful, please raise an issue.

Note how DuckDB doesn't require a `NULLS LAST`, unlike the generic targets
above:

```prql
prql target:sql.duckdb

from artists
sort artist_id
take 42
```

```admonish info
Check out [DuckDB #7174](https://github.com/duckdb/duckdb/pull/7174) for a survey of various databases' implementations.
```
<p><hr/>


<a name="footnote-1">[1](#to-footnote-1)</a>: except for MSSQL, which doesn't support this<div style="break-before: page; page-break-before: always;"></div><h1 id="取"><a class="header" href="#取">取</a></h1>
<p>Picks rows based on their position.</p>
<pre><code class="language-prql no-eval">take (n|range)
</code></pre>
<p>See <a href="reference/stdlib/transforms/../../syntax/ranges.html">Ranges</a> for more details on how ranges work.</p>
<h2 id="範例-8"><a class="header" href="#範例-8">範例</a></h2>
<div class="comparison">
<div>
<h4 id="prql-111"><a class="header" href="#prql-111">PRQL</a></h4>
<pre><code class="language-prql">from employees
take 10
</code></pre>
</div>
<div>
<h4 id="sql-108"><a class="header" href="#sql-108">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
LIMIT
  10

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-112"><a class="header" href="#prql-112">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort {-value, created_at}
take 101..110
</code></pre>
</div>
<div>
<h4 id="sql-109"><a class="header" href="#sql-109">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  orders
ORDER BY
  value DESC,
  created_at
LIMIT
  10 OFFSET 100

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="視窗"><a class="header" href="#視窗">視窗</a></h1>
<p>Applies a pipeline to segments of rows, producing one output value for every input value.</p>
<pre><code class="language-prql no-eval">window rows:(range) range:(range) expanding:false rolling:0 (pipeline)
</code></pre>
<p>For each row, the segment over which the pipeline is applied is determined by one of:</p>
<ul>
<li><code>rows</code>, which takes a range of rows relative to the current row position.
<ul>
<li><code>0</code> references the current row.</li>
</ul>
</li>
<li><code>range</code>, which takes a range of values relative to current row value.</li>
</ul>
<p>The bounds of the range are inclusive. If a bound is omitted, the segment will extend until the edge of the table or group.</p>
<!-- TODO: rows vs range example, with visualization -->
<p>For ease of use, there are two flags that override <code>rows</code> or <code>range</code>:</p>
<ul>
<li><code>expanding:true</code> is an alias for <code>rows:..0</code>. A sum using this window is also known as “cumulative sum”.</li>
<li><code>rolling:n</code> is an alias for <code>row:(-n+1)..0</code>, where <code>n</code> is an integer. This will include <code>n</code> last values, including current row. An average using this window is also knows as a Simple Moving Average.</li>
</ul>
<p>Some examples:</p>
<div class="table-wrapper"><table><thead><tr><th>表達式</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>rows:0..2</code></td><td>current row plus two following</td></tr>
<tr><td><code>rows:-2..0</code></td><td>two preceding rows plus current row</td></tr>
<tr><td><code>rolling:3</code></td><td>(same as previous)</td></tr>
<tr><td><code>rows:-2..4</code></td><td>two preceding rows plus current row plus four following rows</td></tr>
<tr><td><code>rows:..0</code></td><td>all rows from the start of the table up to &amp; including current row</td></tr>
<tr><td><code>expanding:true</code></td><td>(same as previous)</td></tr>
<tr><td><code>rows:0..</code></td><td>current row and all following rows until the end of the table</td></tr>
<tr><td><code>rows:..</code></td><td>all rows, which same as not having window at all</td></tr>
</tbody></table>
</div>
<h2 id="範例-9"><a class="header" href="#範例-9">範例</a></h2>
<div class="comparison">
<div>
<h4 id="prql-113"><a class="header" href="#prql-113">PRQL</a></h4>
<pre><code class="language-prql">from employees
group employee_id (
  sort month
  window rolling:12 (
    derive {trail_12_m_comp = sum paycheck}
  )
)
</code></pre>
</div>
<div>
<h4 id="sql-110"><a class="header" href="#sql-110">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  SUM(paycheck) OVER (
    PARTITION BY employee_id
    ORDER BY
      month ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
  ) AS trail_12_m_comp
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-114"><a class="header" href="#prql-114">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort day
window rows:-3..3 (
  derive {centered_weekly_average = average value}
)
group {order_month} (
  sort day
  window expanding:true (
    derive {monthly_running_total = sum value}
  )
)
</code></pre>
</div>
<div>
<h4 id="sql-111"><a class="header" href="#sql-111">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  AVG(value) OVER (
    ORDER BY
      day ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING
  ) AS centered_weekly_average,
  SUM(value) OVER (
    PARTITION BY order_month
    ORDER BY
      day ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) AS monthly_running_total
FROM
  orders

</code></pre>
</div>
</div>
<h2 id="windowing-by-default"><a class="header" href="#windowing-by-default">Windowing by default</a></h2>
<p>If you use window functions without <code>window</code> transform, they will be applied to the whole table. Unlike in SQL, they will remain window functions and will not trigger aggregation.</p>
<div class="comparison">
<div>
<h4 id="prql-115"><a class="header" href="#prql-115">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort age
derive {rnk = rank age}
</code></pre>
</div>
<div>
<h4 id="sql-112"><a class="header" href="#sql-112">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  RANK() OVER (
    ORDER BY
      age
  ) AS rnk
FROM
  employees
ORDER BY
  age

</code></pre>
</div>
</div>
<p>You can also only apply <code>group</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-116"><a class="header" href="#prql-116">PRQL</a></h4>
<pre><code class="language-prql">from employees
group department (
  sort age
  derive {rnk = rank age}
)
</code></pre>
</div>
<div>
<h4 id="sql-113"><a class="header" href="#sql-113">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  RANK() OVER (
    PARTITION BY department
    ORDER BY
      age
  ) AS rnk
FROM
  employees

</code></pre>
</div>
</div>
<h2 id="window-functions-as-first-class-citizens"><a class="header" href="#window-functions-as-first-class-citizens">Window functions as first class citizens</a></h2>
<p>There are no limitations on where windowed expressions can be used:</p>
<div class="comparison">
<div>
<h4 id="prql-117"><a class="header" href="#prql-117">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter salary &lt; (average salary)
</code></pre>
</div>
<div>
<h4 id="sql-114"><a class="header" href="#sql-114">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    AVG(salary) OVER () AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  salary &lt; _expr_0

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="規範"><a class="header" href="#規範">規範</a></h1>
<p>This chapter explains PRQL’s semantics: how expressions are interpreted and their meaning. It’s intended for advanced users and compiler contributors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-處理"><a class="header" href="#null-處理">Null 處理</a></h1>
<p>SQL has an unconventional way of handling <code>NULL</code> values, since it treats them as unknown values. As a result, in SQL:</p>
<ul>
<li><code>NULL</code> is not a value indicating a missing entry, but a placeholder for anything possible,</li>
<li><code>NULL = NULL</code> evaluates to <code>NULL</code>, since one cannot know if one unknown is equal to another unknown,</li>
<li><code>NULL &lt;&gt; NULL</code> evaluates to <code>NULL</code>, using same logic,</li>
<li>to check if a value is <code>NULL</code>, SQL introduces <code>IS NULL</code> and <code>IS NOT NULL</code> operators,</li>
<li><code>DISTINCT column</code> may return multiple <code>NULL</code> values.</li>
</ul>
<p>For more information, check out the <a href="https://www.postgresql.org/docs/current/functions-comparison.html">Postgres documentation</a>.</p>
<p>PRQL, on the other hand, treats <code>null</code> as a value, which means that:</p>
<ul>
<li><code>null == null</code> evaluates to <code>true</code>,</li>
<li><code>null != null</code> evaluates to <code>false</code>,</li>
<li>distinct column cannot contain multiple <code>null</code> values.</li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-118"><a class="header" href="#prql-118">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter first_name == null
filter null != last_name
</code></pre>
</div>
<div>
<h4 id="sql-115"><a class="header" href="#sql-115">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  first_name IS NULL
  AND last_name IS NOT NULL

</code></pre>
</div>
</div>
<p>Note that PRQL doesn’t change how <code>NULL</code> is compared between columns, for example in joins. (PRQL compiles to SQL and so can’t change the behavior of the database).</p>
<p>For more context or to provide feedback check out the discussion on <a href="https://github.com/PRQL/prql/issues/99">issue #99</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="名稱解析"><a class="header" href="#名稱解析">名稱解析</a></h1>
<p>Because PRQL primarily handles relational data, it has specialized scoping rules for referencing columns.</p>
<h2 id="scopes"><a class="header" href="#scopes">Scopes</a></h2>
<p>In PRQL’s compiler, a scope is the collection of all names one can reference from a specific point in the program.</p>
<p>In PRQL, names in the scope are composed from namespace and variable name which are separated by a dot, similar to SQL. Namespaces can contain many dots, but variable names cannot.</p>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>範例</p>
</div>
<a class="admonition-anchor-link" href="reference/spec/name-resolution.html#admonition-example"></a>
</div>
<div>
<p>Name <code>my_table.some_column</code> is a variable <code>some_column</code> from namespace <code>my_table</code>.</p>
<p>Name <code>foo.bar.baz</code> is a variable <code>baz</code> from namespace <code>foo.bar</code>.</p>
</div>
</div>
<p>When processing a query, a scope is maintained and updated for each point in the query.</p>
<p>It start with only namespace <code>std</code>, which is the standard library. It contains common functions like <code>sum</code> or <code>count</code>, along with all transform functions such as <code>derive</code> and <code>group</code>.</p>
<p>In pipelines (or rather in transform functions), scope is also injected with namespaces of tables which may have been referenced with <code>from</code> or <code>join</code> transforms. These namespaces contain simply all the columns of the table and possibly a wildcard variable, which matches any variable (see the algorithm below). Within transforms, there is also a special namespace that does not have a name. It is called a <em>“frame”</em> and it contains columns of the current table the transform is operating on.</p>
<h2 id="resolving"><a class="header" href="#resolving">Resolving</a></h2>
<p>For each ident we want to resolve, we search the scope’s items in order. One of three things can happen:</p>
<ul>
<li>
<p>Scope contains an exact match, e.g. a name that matches in namespace and the variable name.</p>
</li>
<li>
<p>Scope does not contain an exact match, but the ident did not specify a namespace, so we can match a namespace that contains a <code>*</code> wildcard. If there’s a single namespace, the matched namespace is also updated to contain this new variable name.</p>
</li>
<li>
<p>Otherwise, the nothing is matched and an error is raised.</p>
</li>
</ul>
<h2 id="翻譯為-sql"><a class="header" href="#翻譯為-sql">翻譯為 SQL</a></h2>
<p>When translating into an SQL statement which references only one table, there is no need to reference column names with table prefix.</p>
<div class="comparison">
<div>
<h4 id="prql-119"><a class="header" href="#prql-119">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-116"><a class="header" href="#sql-116">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<p>But when there are multiple tables and we don’t have complete knowledge of all table columns, a column without a prefix (i.e. <code>first_name</code>) may actually reside in multiple tables. Because of this, we have to use table prefixes for all column names.</p>
<div class="comparison">
<div>
<h4 id="prql-120"><a class="header" href="#prql-120">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {first_name, dept_id}
join d=departments (==dept_id)
select {first_name, d.title}
</code></pre>
</div>
<div>
<h4 id="sql-117"><a class="header" href="#sql-117">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.first_name,
  d.title
FROM
  employees
  JOIN departments AS d ON employees.dept_id = d.dept_id

</code></pre>
</div>
</div>
<p>As you can see, <code>employees.first_name</code> now needs table prefix, to prevent conflicts with potential column with the same name in <code>departments</code> table. Similarly, <code>d.title</code> needs the table prefix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模組"><a class="header" href="#模組">模組</a></h1>
<blockquote>
<p>This is a technical document. For a “how to use” or a TLDR; skip to the <a href="reference/spec/modules.html#example">Example</a> section.</p>
</blockquote>
<p>Design goals:</p>
<ol>
<li>
<p>Allow importing declarations from other files.</p>
</li>
<li>
<p>Have namespaces for things like <code>std</code>.</p>
</li>
<li>
<p>Have a hierarchical structure so we can represent files in directories.</p>
</li>
<li>
<p>Have an unambiguous module structure within a project.</p>
</li>
</ol>
<h2 id="定義"><a class="header" href="#定義">定義</a></h2>
<p>A module is a namespace that contains declarations. A module is itself a declaration, which means that it can contain nested child modules.</p>
<p>This means that modules form a <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">tree graph</a>, which we call “the module structure”.</p>
<p>For the sake of this document, we will express the module structure with <code>module</code> keyword and a code block encased in curly braces:</p>
<pre><code>module my_playlists {
    let bangers = ... # a declaration

    module soundtracks {
        let movie_albums = ... # another declaration
    }
}
</code></pre>
<blockquote>
<p>The syntax <code>module name { ...decls... }</code> is not part of PRQL language, with the objection that it is unnecessary as it only adds more ways of defining modules. If a significant upside of this syntax is found, it may be added in the future.</p>
</blockquote>
<h2 id="名稱解析-1"><a class="header" href="#名稱解析-1">名稱解析</a></h2>
<p>Any declarations within a module can be referenced from the outside of the module:</p>
<pre><code class="language-prql no-eval"># using module structure declared above
module my_playlists

let great_tracks = my_playlists.bangers

let movie_scores = my_playlists.soundtracks.movie_albums
</code></pre>
<p>Identifiers are resolved relative to current module.</p>
<pre><code class="language-prql no-eval">module my_playlists {
    module soundtracks {
        let movie_albums = (from albums | filter id == 3)
    }

    from soundtracks.movie_albums
}
from my_playlists.soundtracks.movie_albums
</code></pre>
<p>If an identifier cannot be resolved relative to the current module, it tries to resolve relative to the parent module. This is repeated, stepping up the module hierarchy until a match is found or root of the module structure is reached.</p>
<pre><code class="language-prql no-eval">module my_playlists {
    let decl_1 = ...

    module soundtracks {
        let decl_2 = ...
    }

    module upbeat_rock {
        let decl_3 = ...

        from decl_1 | join soundtracks.decl2 | join decl_3
    }
}
</code></pre>
<h2 id="main-var-declaration"><a class="header" href="#main-var-declaration">Main var declaration</a></h2>
<p>The final variable declaration in a module can omit the leading <code>let main =</code> and acquire an implicit name main.</p>
<pre><code>module my_playlists {
    let bangers = (from tracks | take 10)

    from playlists | take 10
}

let album_titles = my_playlists.main
</code></pre>
<p>When a module is referenced as a value, the <code>main</code> variable is used instead. This is especially useful when referring to a module which is to be compiled to RQ (and later SQL).</p>
<pre><code># last line from previous example could thus be shortened to:
let album_titles = my_playlists
</code></pre>
<h2 id="file-importing"><a class="header" href="#file-importing">File importing</a></h2>
<blockquote>
<p>This section is under discussion. Current implementation plans do not include <code>module</code> declarations, but loading of all files under the compilation path.</p>
</blockquote>
<p>To include PRQL source code from other files, we can use the following syntax:</p>
<pre><code>module my_playlists
</code></pre>
<p>This loads either <code>./my_playlists.prql</code> (a leaf module) or <code>./my_playlists/_my_playlists.prql</code> (a directory module) and uses its contents as module <code>my_playlists</code>. If none or both of the files are present, a compilation error is raised.</p>
<p>Only directory modules can contain module declarations. If a leaf module contains a module declaration, a compilation error is raised, suggesting the leaf module to be converted into a directory module. This is a step toward any module structure having a single “normalized” representation in the file system. Such normalization is desired because it restrains the possible file system layouts to a comprehensible and predictable layout, while not sacrificing any functionality.</p>
<p>Described importing rules don’t achieve this “single normalized representation” in full, since any leaf modules could be replaced by a directory module with zero submodules, without any semantic changes. Restricting directory modules to have at least one sub-module would not improve approachability enough to justify adding this restriction.</p>
<p>For example, the following module structure is annotated with files names in which the modules would reside:</p>
<pre><code class="language-prql no-eval">
module my_project {
    # _my_project.prql

    module sales {
        # sales.prql
    }

    module projections {
        # projections/_projections.prql

        module year_2023 {
            # projections/year_2023.prql
        }

        module year_2024 {
            # projections/year_2024.prql
        }
    }
}
</code></pre>
<p>If module <code>my_project.sales</code> wants to add a submodule <code>util</code>, it has to be converted to a directory modules. This means that it has to be moved to <code>sales/_sales.prql</code>. The new module would reside in <code>sales/util.prql</code>.</p>
<p>The annotated layout is not the only possible layout for this module structure, since any of the modules <code>sales</code>, <code>year_2023</code> or <code>year_2024</code> could be converted into a directory module with zero sub-modules.</p>
<p>Point 4 of design goals means that each declaration within a project has a single fully-qualified name within this project. This is ensured by strict rules regarding importing files and the fact that the module structure is a tree.</p>
<h2 id="declaration-order"><a class="header" href="#declaration-order">Declaration order</a></h2>
<p>The order of declarations in a module holds no semantic value, except the “last <code>main</code> variable”.</p>
<p>References between modules can be cyclic.</p>
<pre><code>module mod_a {
    let decl_a_1 = ...
    let decl_a_2 = (from mod_b.decl_b | take 10)
}
module mod_b {
    let decl_b = (from mod_a.decl_a | take 10)
}
</code></pre>
<p>References between variable declarations cannot be cyclic.</p>
<pre><code>let decl_a = (from decl_b)
let decl_b = (from decl_a) # error: cyclic reference
</code></pre>
<pre><code>module mod_a {
    let decl_a = (from mod_b.decl_b)
}
module mod_b {
    let decl_b = (from mod_a.decl_a) # error: cyclic reference
}
</code></pre>
<h2 id="compiler-interface"><a class="header" href="#compiler-interface">Compiler interface</a></h2>
<p><code>prql-compiler</code> provides two interfaces for compiling files.</p>
<p><strong>Multi-file interface</strong> requires three arguments:</p>
<ul>
<li>path to the file containing the module which is the root of the module structure,</li>
<li>identifier of the pipeline that should be compiled to RQ (this can also be an identifier of a module that has a <code>main</code> pipeline) and,</li>
<li>a “file loader”, which can load files on-demand.</li>
</ul>
<p>The path to the root module can be automatically detected by searching for <code>.prql</code> files starting with <code>_</code> in the current working directory.</p>
<p>Example prqlc usage:</p>
<pre><code>$ prqlc compile _project.prql sales.projections.orders_2024
$ prqlc compile sales.projections.orders_2024
</code></pre>
<p><strong>Single-file interface</strong> requires a single argument; the PRQL source. Any attempts to load modules in this mode result in compilation errors. This interface is needed, for example, when integrating the compiler with a database connector (i.e. JDBC) where no other files can be loaded.</p>
<h2 id="built-in-module-structure"><a class="header" href="#built-in-module-structure">Built-in module structure</a></h2>
<blockquote>
<p>Work In Progress</p>
</blockquote>
<pre><code># root module of every project
module project {
	module std {
		let sum = a -&gt; ...
		let mean = a -&gt; ...
	}

	module default_db {
		# all inferred tables and defined CTEs
	}

	let main = (
		from t = tracks
		select [track_id, title]
	)
}
</code></pre>
<h2 id="範例-10"><a class="header" href="#範例-10">範例</a></h2>
<p>This is an example project, where each of code block is a separate file.</p>
<pre><code># _project.prql

module employees
module sales
module util
</code></pre>
<pre><code># employees.prql

let employees = (...)

let salaries = (...)

let departments = (...)
</code></pre>
<pre><code># sales/_sales.prql

module orders
module projections

let revenue_by_source = (...)
</code></pre>
<pre><code># sales/orders.prql

let current_year = (...)

let archived = (...)

let by_employee = (from orders | join employees.employees ...)
</code></pre>
<pre><code># sales/projections.prql

let orders_2023 = (from orders.current_year | append orders.archived)

let orders_2024 = (...)
</code></pre>
<pre><code># util.prql

let pretty_print_num = col -&gt; (...)
</code></pre>
<hr />
<p>Sources:</p>
<ul>
<li><a href="https://matklad.github.io/2021/11/27/notes-on-module-system.html">Notes On Module System</a>, by @matklad.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="型別系統"><a class="header" href="#型別系統">型別系統</a></h1>
<blockquote>
<p>The type system determines the allowed values of a term.</p>
<p>– Wikipedia</p>
</blockquote>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>Each of the SQL DBMSs has their own type system. Thanks to SQL standard, they are very similar, but have key differences. For example, SQLite does not have a type for date or time or timestamps, but it has functions for handling date and time that take ISO 8601 strings or integers that represent Unix timestamps. So it does support most of what is possible to do with dates in other dialects, even though it stores data with a different physical layout and uses different functions to achieve that.</p>
<p>PRQL’s task is to define common description of <em>data formats</em>, just as how it already defines common <em>data transformations</em>.</p>
<p>We believe this should best be done in two steps:</p>
<ol>
<li>
<p>Define PRQL’s Type System (PTS), following principles we think a relational language should have (and not focus on what existing SQL DBMSs have).</p>
</li>
<li>
<p>Define a mapping between SQL Type System (STS) and PTS, for each of the DBMSs. Ideally we’d want that to be a bijection, so each type in PTS would be represented by a single type in STS and vice-versa. Unfortunately this is not entirely possible, as shown below.</p>
</li>
</ol>
<p>In practical terms, we want for a user to be able to:</p>
<ul>
<li>
<p>… express types of their database with PRQL (map their STS into PTS). In some cases, we can allow to say “your database is not representable with PRQL, change it or use only a subset of it”. An example of what we don’t want to support are arrays with arbitrary indexes in Postgres (i.e. 2-based index for arrays).</p>
<p>This task of mapping to PTS could be automated by LSP server, by introspecting user’s SQL database and generating PRQL source.</p>
</li>
<li>
<p>… express their SQL queries in PRQL. Again, using mapping from STS to PTS, one should be able to express any SQL operation in PRQL.</p>
<p>For example, translate MSSQL <code>DATEDIFF</code> to subtraction operator <code>-</code> in PRQL.</p>
<p>For now, this mapping is manual, but should be documented and may be automated.</p>
</li>
<li>
<p>… use any PRQL feature in their database. Here we are mapping back from PTS into STS. Note that STS may have changed to a different dialect.</p>
<p>For example, translate PRQL’s datetime operations to use TEXT in SQLite.</p>
<p>As of now, prql-compiler already does a good job of automatically doing this mapping.</p>
</li>
</ul>
<p>Example of the mapping between PTS and two STSs:</p>
<div class="table-wrapper"><table><thead><tr><th>PTS</th><th>STS Postgres</th><th>STS SQLite</th></tr></thead><tbody>
<tr><td>int32</td><td>integer</td><td>INTEGER</td></tr>
<tr><td>int64</td><td>bigint</td><td>INTEGER</td></tr>
<tr><td>timestamp</td><td>timestamp</td><td>TEXT</td></tr>
</tbody></table>
</div>
<h2 id="principles"><a class="header" href="#principles">Principles</a></h2>
<p><strong>Algebraic types</strong> - have a way of expressing sum and product types. In Rust, sum would be an enum and product would be tuple or a struct. In SQL, product would be a row, since it can contain different types, all at once. Sum would be harder to express, see (this post)[https://www.parsonsmatt.org/2019/03/19/sum_types_in_sql.html ].</p>
<p>The value proposition here is that algebraic types give a lot modeling flexibility, all while being conceptually simple.</p>
<p><strong>Composable</strong> - as with transformation, we’d want types to compose together.</p>
<p>Using Python, JavaScript, C++ or Rust, one could define many different data structures that would correspond to our idea of “relation”. Most of them would be an object/struct that has column names and types and then a generic array of arrays for rows.</p>
<p>PRQL’s type system should also be able to express relations as composed from primitive types, but have only one idiomatic way of doing so.</p>
<p>In practice this means that builtin types include only primitives (int, text, bool, float), tuple (for product), enum (for sum) and array (for repeating).</p>
<p>An SQL row would translate to tuple, and a relation would translate to an array of tuples.</p>
<p>I would also strive for the type system to be minimal - don’t differentiate between tuples, objects and structs. Choose one and stick to it.</p>
<p><strong>Type constraints</strong> - constrain a type with a predicate. For example, have a type of <code>int64</code>s that are equal or greater than 10. Postgres <a href="https://news.ycombinator.com/item?id=34835063">does support this</a>. The primary value of using constrained types would not be validation (as it is used in linked article), but when matching the type.</p>
<p>Say, for example, that we have a pipeline like this:</p>
<pre><code>derive color = switch [x =&gt; 'red', true =&gt; 'green']
derive is_red = switch [color == 'red' =&gt; true, color == 'green' =&gt; false]
</code></pre>
<p>It should be possible to infer that <code>color</code> is of type <code>text</code>, but only when equal to <code>'red'</code> or <code>'green'</code>. This means that the second switch covers all possible cases and <code>is_red</code> cannot be <code>null</code>.</p>
<h2 id="theory"><a class="header" href="#theory">Theory</a></h2>
<blockquote>
<p>For any undefined terms used in this section, refer to set theory and mathematical definitions in general.</p>
</blockquote>
<p>A “type of a variable” is a “set of all possible values of that variable”. This means that terms “type” and “set” are equivalent in this context.</p>
<p>Types (sets) can be expressions. For example, a union of two types is a type itself. This means a type expression is equivalent to any other expression whose type is a “set of sets”.</p>
<p>So let’s introduce a “set” as a PRQL expression construct (alongside existing idents, literals, ranges and so on). For now, it does not need any special syntax. Because sets are normal expressions, existing syntax can be repurposed to define operations on sets:</p>
<ul>
<li>
<p>Binary operation <code>or</code> of two sets represents a union of those two sets:</p>
<pre><code>let number = int or float
</code></pre>
<p>With algebraic types, this is named “a sum type”.</p>
</li>
<li>
<p>Literals can be coerced into a singleton set (i.e. <code>false</code> is converted into a set with only one element <code>false</code>):</p>
<pre><code>let int_or_null = int or null
</code></pre>
</li>
<li>
<p>A list of set expressions can be coerced into a set of tuples, where entries of the tuples correspond to elements of the set expressions in the list:</p>
<pre><code>let my_row = [id = int, bool, name = str]
</code></pre>
</li>
<li>
<p>An array of set expressions with exactly one entry can be coerced into a set of arrays of that set expression:</p>
<pre><code>let array_of_int = {int} # proposed syntax for arrays
</code></pre>
</li>
<li>
<p>A function that takes set as params and returns a set is converted into a set of functions.</p>
<pre><code>let floor_signature = (float -&gt; int)
# using a proposed syntax for lambda functions
</code></pre>
</li>
</ul>
<p>Module <code>std</code> defines built-in sets <code>int</code>, <code>float</code>, <code>bool</code>, <code>text</code> and <code>set</code>. Other built-in sets will be added in the future.</p>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type annotations</a></h2>
<p>Let’s extend the syntax for declaration of variable <code>a</code>, whose value can be computed by evaluating <code>x</code>, with a type annotation:</p>
<pre><code>let a &lt;t&gt; = x
</code></pre>
<p>This extended syntax applies following assertions:</p>
<ul>
<li><code>t</code> can be evaluated statically (at compile time),</li>
<li><code>t</code> can be coerced into a set,</li>
<li>value of <code>x</code> (and <code>a</code>) must be an element of <code>t</code>. This assertion must be possible to evaluate statically.</li>
</ul>
<p>Similar rules apply to type annotations of return types of functions and function parameter definitions.</p>
<h2 id="type-definitions"><a class="header" href="#type-definitions">Type definitions</a></h2>
<p>As shown, types can be defined by defining expressions and coercing them to set expressions by using <code>&lt; &gt;</code>.</p>
<p>But similar to how both <code>func</code> and <code>let</code> can be used to define functions (when we introduce lambda function syntax), let’s also introduce syntactic sugar for type definitions:</p>
<pre><code># these two are equivalent
let my_type &lt;set&gt; = set_expr
type my_type = set_expr
</code></pre>
<h2 id="container-types"><a class="header" href="#container-types">Container types</a></h2>
<blockquote>
<p>Terminology is under discussion</p>
</blockquote>
<p><strong>Tuple</strong> is the only product type in PTS. It contains n ordered fields, where n is known at compile-time. Each field has a type itself and an optional name. Fields are not necessarily of the same type.</p>
<p>In other languages, similar constructs are named record, struct, tuple, named tuple or (data)class.</p>
<p><strong>Array</strong> is a container type that contains n ordered fields, where n is not known at compile-time. All fields are of the same type and cannot be named.</p>
<p><strong>Relation</strong> is an array of tuples.</p>
<p>The first argument of transforms <code>select</code> and <code>derive</code> contains a known number of entries, which can be of different types. Thus, it is a tuple.</p>
<pre><code>select [1.4, false, "foo"]
</code></pre>
<h2 id="physical-layout"><a class="header" href="#physical-layout">Physical layout</a></h2>
<p><em>Logical type</em> is user-facing the notion of a type that is the building block of the type system.</p>
<p><em>Physical layout</em> is the underlying memory layout of the data represented by a variable.</p>
<p>In many programming languages, physical layout of a logical type is dependent on the target platform. Similarly, physical layout of a PRQL logical type is dependent on representation of that type in the target STS.</p>
<pre><code>PTS logical type  ---&gt;  STS logical type  ---&gt; STS physical layout
</code></pre>
<p>Note that STS types do not have a single physical layout. Postgres has a logical (pseudo)type <code>anyelement</code>, which is a super type of any data type. It can be used as a function parameter type, but does not have a single physical layout so it cannot be used in a column declaration.</p>
<p>For now, PRQL does not define physical layouts of any type. It is not needed since PRQL is not used for DDL (see section “Built-in primitives”) or does not support raw access to underlying memory.</p>
<p>As a consequence, results of a PRQL query cannot be robustly compared across DBMSs, since the physical layout of the result will vary.</p>
<p>In the future, PRQL may define a common physical layout of types, probably using Apache Arrow.</p>
<!-- ## Enums

```
# user-defined enum
type open
type pending
type closed
type status = open or pending or closed
``` -->
<h2 id="範例-11"><a class="header" href="#範例-11">範例</a></h2>
<pre><code>type my_relation = {[
	id = int,
	title = text,
	age = int
]}

type invoices = {[
    invoice_id = int64,
    issued_at = timestamp,
    labels = {text}

    #[repr(json)]
    items = [{
        article_id = int64,
        count = int16 where x -&gt; x &gt;= 1,
    }],
    paid_by_user_id = int64 or null,
    status = status,
]}
</code></pre>
<h2 id="附錄"><a class="header" href="#附錄">附錄</a></h2>
<h3 id="built-in-primitives"><a class="header" href="#built-in-primitives">Built-in primitives</a></h3>
<p>This document mentions <code>int32</code> and <code>int64</code> as distinct types, but there is no need for that in the initial implementation. The built-in <code>int</code> can associate with all operations on integers and translate PRQL to valid SQL regardless of the size of the integer. Later, <code>int</code> cam be replaced by:</p>
<pre><code>type int = int8 || int16 || int32 || int64
</code></pre>
<p>The general rule for “when to make a distinction between types” would be “as soon as the types carry different information and we find an operation that would be expressed differently”. In this example, that would require some operation on <code>int32</code> to have different syntax than same operation over <code>int64</code>.</p>
<p>We can have such relaxed rule because PRQL is not aiming to be a Data Definition Language and does not have to bother with exact physical layout of types.</p>
<h3 id="type-representations"><a class="header" href="#type-representations">Type representations</a></h3>
<p>There are cases where a PTS type has multiple possible and valid representations in some STSs.</p>
<p>For such cases, we’d want to support the use of alternative representations for storing data, but also application of any function that is defined for the original type.</p>
<p>Using SQLite as an example again, users may have some temporal data stored as INTEGER unix timestamp and some as TEXT that contains ISO 8601 without timezone. From the user’s perspective, both of these types are <code>timestamp</code>s and should be declared as such. But when compiling operations over these types to SQL, the compiler should consider their different representations in STS. For example a difference between two timestamps <code>timestamp - timestamp</code> can be translated to a normal int subtraction for INTEGER repr, but must apply SQLite’s function <code>unixepoch</code> when dealing with TEXT repr.</p>
<p>Table declarations should therefore support annotations that give hints about which representation is used:</p>
<pre><code>table foo {
    #[repr(text)]
    created_at: timestamp,
}
</code></pre>
<p>A similar example is an “array of strings type” in PTS that could be represented by a <code>text[]</code> (if DBMS supports arrays) or <code>json</code> or it’s variant <code>jsonb</code> in Postgres. Again, the representation would affect operators: in Postgres, arrays would be accessed with <code>my_array[1]</code> and json arrays would use <code>my_json_array -&gt; 1</code>. This example may not be applicable, if we decide that we want a separate JSON type in PST.</p>
<h3 id="rq-functions-targets-and-reprs"><a class="header" href="#rq-functions-targets-and-reprs">RQ functions, targets and reprs</a></h3>
<blockquote>
<p>This part is talks about technical implementations, not the language itself</p>
</blockquote>
<h4 id="idea"><a class="header" href="#idea">Idea</a></h4>
<p>RQ contains a single node kind for expressing operations and functions: BuiltInFunction (may be renamed in the future).</p>
<p>It is a bottleneck that we can leverage when trying to affect how an operator or a function interacts with different type representations on different targets.</p>
<p>Idea is to implement the BuiltInFunction multiple times and annotate it with it intended target and parameter representation. Then we can teach the compiler to pick the appropriate function implementation that suit current repr and compilation target.</p>
<h4 id="specifics"><a class="header" href="#specifics">Specifics</a></h4>
<p>RQ specification is an interface that contains functions, identified by name (i.e. <code>std.int8.add</code>). These functions have typed parameters and a return value. If an RQ function call does not match the function declaration in number or in types of the parameters, this is considered an invalid RQ AST.</p>
<p>We provide multiple implementations for each RQ function. They are annotated with a target (i.e. <code>#[target(sql.sqlite)]</code>) and have their params annotated with type reprs (i.e. <code>#[repr(int)]</code>).</p>
<pre><code># using a made-up syntax

#[target(sql.sqlite)]
func std.int8.add
    #[repr(int8)] x
    #[repr(int8)] y
    -&gt; s"{x} + {y}"
</code></pre>
<p>Each RQ type has one canonical repr that serves as the reference implementation for other reprs and indicates the amount of contained data (i.e. 1 bit, 8 bits, 64 bits).</p>
<h4 id="範例-12"><a class="header" href="#範例-12">範例</a></h4>
<p>Let’s say for example, that we’d want to support 8bit integer arithmetic, and that we’d want the result of <code>127 + 1</code> to be <code>-128</code> (ideally we’d handle this better, but bear with me for the sake of the example). Because some RDBMSs don’t support 8bit numbers and do all their integer computation with 64bit numbers (SQLite), we need to implement an alternative type representation for that target.</p>
<p>The logical type <code>int8</code> could have the following two reprs:</p>
<ul>
<li>canonical <code>repr_int8</code> that contains 8 bits in two’s complement, covering integer values in range -128 to 127 (inclusive),</li>
<li><code>repr_int64</code> that contains 64 bits of data, but is using only the values that are also covered by <code>repr_int8</code>.</li>
</ul>
<p>Now we’d implement function <code>std.int8.add</code> for each of the reprs. Let’s assume that the <code>int8</code> implementation is straightforward and that databases don’t just change the data type when a number overflows. The impl for <code>int64</code> requires a CASE statement that checks if the value would overflow and subtact 256 in that case.</p>
<p>The goal here is that the results of the two impls are equivalent. To validate that, we also need a way to convert between the reprs, or another <code>to_string</code> function, implemented for both reprs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-變更日誌"><a class="header" href="#prql-變更日誌">PRQL 變更日誌</a></h1>
<h2 id="095--2023-09-12"><a class="header" href="#095--2023-09-12">0.9.5 — 2023-09-12</a></h2>
<p>0.9.5 adds a line-wrapping character, fixes a few bugs, and improves our CI. The release has 77 commits from 8 contributors. Selected changes are below.</p>
<p>Look out for some conference talks coming up over the next few weeks, including <a href="https://qconsf.com/presentation/oct2023/prql-simple-powerful-pipelined-sql-replacement">QCon SF on Oct 2</a> and <a href="https://www.data2day.de/veranstaltung-21353-0-prql-a-modern-language-for-data-transformation.html">date2day on Oct 12</a>.</p>
<p><strong>語言</strong>：</p>
<ul>
<li>
<p>A new line-wrapping character, for lines that are long and we want to break up into multiple physical lines. This is slightly different from from many languages — it’s on the subsequent line:</p>
<pre><code class="language-prql no-eval">from artists
select is_europe =
\ country == "DE"
\ || country == "FR"
\ || country == "ES"
</code></pre>
<p>This allows for easily commenting out physical lines while maintaining a correct logical line; for example:</p>
<pre><code class="language-diff">from artists
select is_europe =
\ country == "DE"
\ || country == "FR"
\ || country == "FR"
-\ || country == "ES"
+#\ || country == "ES"
</code></pre>
<p>(@max-sixty, #3408)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>
<p>Fix stack overflow on very long queries in Windows debug builds (@max-sixty, #2908)</p>
</li>
<li>
<p>Fix panic when unresolved lineage appears in group or window (@davidot, #3266)</p>
</li>
<li>
<p>Fix a corner-case in handling precedence, and remove unneeded parentheses in some outputs (@max-sixty, #3472)</p>
</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Any panics in the compiler are now printed to the console (@max-sixty, #3446)</li>
</ul>
<p><strong>整合</strong>：</p>
<ul>
<li><a href="https://ace.c9.io/">Ace</a>, the JavaScript code editor now has syntax highlighting for PRQL. (@vanillajonathan, #3493)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li>Simplify &amp; speed up lexer (@max-sixty, #3426, #3418)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@davidot, with #3450</li>
</ul>
<h2 id="094--2023-08-24"><a class="header" href="#094--2023-08-24">0.9.4 — 2023-08-24</a></h2>
<p>0.9.4 is a small release with some improvements and bug fixes in the compiler and <code>prqlc</code>. And, the documentation and CI are continually being improved.</p>
<p>This release has 110 commits from 9 contributors. Selected changes:</p>
<p><strong>功能</strong>：</p>
<ul>
<li>Strings can be delimited with any odd number of quote characters. The logic for lexing quotes is now simpler and slightly faster. Escapes in single-quote-delimited strings escape single-quotes rather than double-quotes. (@max-sixty, #3274)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>S-strings within double braces now parse correctly (@max-sixty, #3265)</li>
</ul>
<p><strong>文件</strong>：</p>
<ul>
<li>New docs for strings (@max-sixty, #3281)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Improve syntax highlighting for numbers in the book &amp; website (@max-sixty, #3261)</li>
<li>Add ClickHouse integration to docs (@max-sixty, #3251)</li>
</ul>
<p><strong>整合</strong>：</p>
<ul>
<li><code>prqlc</code> no longer displays a prompt when piping a query into its stdin (@max-sixty, #3248).</li>
<li>Add a minimal example for use <code>prql-lib</code> with Zig (@vanillajonathan, #3372)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li>
<p>Overhaul our CI to run a cohesive set of tests depending on the specific changes in the PR, and elide all others. This cuts CI latency to less than three minutes for most changes, and enables GitHub’s auto-merge to wait for all relevant tests. It also reduces the CI time on merging to main, by moving some tests to only run on specific path changes or on our nightly run.</p>
<p>We now have one label we can add to PRs to run more tests — <code>pr-nightly</code>. (@max-sixty, #3317 &amp; others).</p>
</li>
<li>
<p>Auto-merge PRs for backports or pre-commit updates (@max-sixty, #3246)</p>
</li>
<li>
<p>Add a workflow to create an issue when the scheduled nightly workflow fails (@max-sixty, #3304)</p>
</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@FinnRG, with #3292</li>
<li>@sitiom, with #3353</li>
</ul>
<h2 id="093--2023-08-02"><a class="header" href="#093--2023-08-02">0.9.3 — 2023-08-02</a></h2>
<p>0.9.3 is a small release, with mostly documentation, internal, and CI changes.</p>
<p>This release has 85 commits from 10 contributors.</p>
<p>We’d like to welcome @not-my-profile as someone who has helped with lots of internal refactoring in the past couple of weeks.</p>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@vthriller, with #3171</li>
<li>@postmeback, with #3216</li>
</ul>
<h2 id="092--2023-07-25"><a class="header" href="#092--2023-07-25">0.9.2 — 2023-07-25</a></h2>
<p>0.9.2 is a hotfix release to fix an issue in the 0.9.0 &amp; 0.9.1 release pipelines.</p>
<h2 id="091--2023-07-25"><a class="header" href="#091--2023-07-25">0.9.1 — 2023-07-25</a></h2>
<p>0.9.1 is a hotfix release to fix an issue in the 0.9.0 release pipeline.</p>
<h2 id="090--2023-07-24"><a class="header" href="#090--2023-07-24">0.9.0 — 2023-07-24</a></h2>
<p>0.9.0 is probably PRQL’s biggest ever release. We have dialect-specific standard-libraries, a regex operator, an initial implementation of multiple-file projects &amp; modules, lots of bug fixes, and many many internal changes.</p>
<p>We’ve made a few backward incompatible syntax changes. Most queries will work with a simple find/replace; see below for details.</p>
<p>The release has 421 commits from 12 contributors.</p>
<p>A small selection of the changes:</p>
<p><strong>語言</strong>：</p>
<ul>
<li>
<p>The major breaking change is a new syntax for lists, which have been renamed to <em>tuples</em>, and are now represented with braces <code>{}</code> rather than brackets <code>[]</code>.</p>
<p>To convert previous PRQL queries to this new syntax simply change <code>[ ... ]</code> to <code>{ ... }</code>.</p>
<p>We made the syntax change to incorporate arrays. Almost every major language uses <code>[]</code> for arrays. We are adopting that convention — arrays use <code>[]</code>, tuples will use <code>{}</code>. (Though we recognize that <code>{}</code> for tuples is also rare (Hi, Erlang!), but didn’t want to further load parentheses with meaning.)</p>
<p>Arrays are conceptually similar to columns — their elements have a single type. Array syntax can’t contain assignments.</p>
<p>As part of this, we’ve also formalized tuples as containing both individual items (<code>select {foo, baz}</code>), and assignments (<code>select {foo=bar, baz=fuz}</code>).</p>
</li>
<li>
<p>Some significant changes regarding SQL dialects:</p>
<ul>
<li>Operators and functions can be defined on per-dialect basis. (@aljazerzen, #2681)</li>
<li><em>Breaking</em>: The <code>sql.duckdb</code> target supports DuckDB 0.8 (@eitsupi, #2810).</li>
<li><em>Breaking</em>: The <code>sql.hive</code> target is removed (@eitsupi, #2837).</li>
</ul>
</li>
<li>
<p>New arithmetic operators. These compile to different function or operator depending on the target.</p>
<ul>
<li>
<p><em>Breaking:</em> Operator <code>/</code> now always performs floating division (@aljazerzen, #2684). <em>TODO: add link to division operator docs</em></p>
</li>
<li>
<p>Truncated integer division operator <code>//</code> (@aljazerzen, #2684).</p>
</li>
<li>
<p>Regex search operator <code>~=</code> (@max-sixty, #2458). An example:</p>
<pre><code class="language-prql no-eval">from tracks
filter (name ~= "Love")
</code></pre>
<p>…compiles to;</p>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP(name, 'Love')
</code></pre>
<p>…though the exact form differs by dialect; see the <a href="https://prql-lang.org/book/reference/syntax/operators.html#regex">Regex docs</a> for more details.</p>
</li>
</ul>
</li>
<li>
<p>New aggregation functions: <code>every</code>, <code>any</code>, <code>average</code>, and <code>concat_array</code>. <em>Breaking:</em> Remove <code>avg</code> in favor of <code>average</code>.</p>
</li>
<li>
<p><em>Breaking:</em> We’ve changed our function declaration syntax to match other declarations. Functions were one of the first language constructs in PRQL, and since then we’ve added normal declarations there’s no compelling reason for functions to be different.</p>
<pre><code class="language-prql no-eval">let add = a b -&gt; a + b
</code></pre>
<p>Previously, this was:</p>
<pre><code class="language-prql no-eval">func add a b -&gt; a + b
</code></pre>
</li>
<li>
<p>Experimental modules, which allow importing declarations from other files. Docs are forthcoming.</p>
</li>
<li>
<p>Relation literals create a relation (a “table”) as an <em>array</em> of <em>tuples</em>. This example demonstrates the new syntax for arrays <code>[]</code> and tuples <code>{}</code>. (@aljazerzen, #2605)</p>
<pre><code class="language-prql no-eval">from [{a=5, b=false}, {a=6, b=true}]
filter b == true
select a
</code></pre>
</li>
<li>
<p><code>this</code> can be used to refer to the current pipeline, for situations where plain column name would be ambiguous:</p>
<pre><code class="language-prql no-eval">from x
derive sum = my_column
select this.sum   # does not conflict with `std.sum`
</code></pre>
<p>Within a <code>join</code> transform, there is also a reference to the right relation: <code>that</code>.</p>
</li>
<li>
<p><em>Breaking:</em> functions <code>count</code>, <code>rank</code> and <code>row_number</code> now require an argument of the array to operate on. In most cases you can directly replace <code>count</code> with <code>count this</code>. The <code>non_null</code> argument of <code>count</code> has been removed.</p>
</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li>
<p>We’ve changed how we handle colors.</p>
<p><code>Options::color</code> is deprecated and has no effect. Code which consumes <code>prql_compiler::compile</code> should instead accept the output with colors and use a library such as <code>anstream</code> to handle the presentation of colors. To ensure minimal disruption, <code>prql_compiler</code> will currently strip color codes when a standard environment variable such as <code>CLI_COLOR=0</code> is set or when it detects <code>stderr</code> is not a TTY.</p>
<p>We now use the <a href="https://github.com/rust-cli/anstyle"><code>anstream</code></a> library in <code>prqlc</code> &amp; <code>prql-compiler</code>.</p>
<p>(@max-sixty, #2773)</p>
</li>
<li>
<p><code>prqlc</code> can now show backtraces when the standard backtrace env var (<code>RUST_BACKTRACE</code>) is active. (@max-sixty, #2751)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Numbers expressed with scientific notation — <code>1e9</code> — are now handled correctly by the compiler (@max-sixty, #2865).</li>
</ul>
<p><strong>整合</strong>：</p>
<ul>
<li>prql-python now provides type hints (@philpep, #2912)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li>
<p>Annotations in PRQL. These have limited support but are currently used to specify binding strengths. They’re modeled after Rust’s annotations, but with <code>@</code> syntax, more similar to traditional decorators. (#2729)</p>
<pre><code class="language-prql no-eval">@{binding_strength=11}
let mod = l r -&gt; s"{l} % {r}"
</code></pre>
</li>
<li>
<p>Remove BigQuery’s special handling of quoted identifiers, now that our module system handles its semantics (@max-sixty, #2609).</p>
</li>
<li>
<p>ClickHouse is tested in CI (@eitsupi, #2815).</p>
</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@maxmcd, with #2533</li>
<li>@khoa165, with #2876</li>
<li>@philpep, with #2912</li>
<li>@not-my-profile, with #2971</li>
</ul>
<h2 id="081--2023-04-29"><a class="header" href="#081--2023-04-29">0.8.1 — 2023-04-29</a></h2>
<p>0.8.1 is a small release with a new <code>list-targets</code> command in <code>prqlc</code>, some documentation improvements, and some internal improvements.</p>
<p>This release has 41 commits from 8 contributors.</p>
<p>From the broader perspective of the project, we’re increasing the relative prioritization of it being easy for folks to actually use PRQL — either with existing tools, or a tool we’d build. We’ll be thinking about &amp; discussing the best way to do that over the next few weeks.</p>
<h2 id="080--2023-04-14"><a class="header" href="#080--2023-04-14">0.8.0 — 2023-04-14</a></h2>
<p>0.8.0 renames the <code>and</code> &amp; <code>or</code> operators to <code>&amp;&amp;</code> &amp; <code>||</code> respectively, reorganizes the Syntax section in the book, and introduces <code>read_parquet</code> &amp; <code>read_csv</code> functions for reading files with DuckDB.</p>
<p>This release has 38 commits from 8 contributors. Selected changes:</p>
<p><strong>功能</strong>：</p>
<ul>
<li>
<p>Rename <code>and</code> to <code>&amp;&amp;</code> and <code>or</code> to <code>||</code>. Operators which are symbols are now consistently infix, while “words” are now consistently functions (@aljazerzen, #2422).</p>
</li>
<li>
<p>New functions <code>read_parquet</code> and <code>read_csv</code>, which mirror the DuckDB functions, instructing the database to read from files (@max-sixty, #2409).</p>
</li>
</ul>
<h2 id="071--2023-04-03"><a class="header" href="#071--2023-04-03">0.7.1 — 2023-04-03</a></h2>
<p>0.7.1 is a hotfix release to fix <code>prql-js</code>’s <code>npm install</code> behavior when being installed as a dependency.</p>
<p>This release has 17 commits from 4 contributors.</p>
<h2 id="070--2023-04-01"><a class="header" href="#070--2023-04-01">0.7.0 — 2023-04-01</a></h2>
<p>0.7.0 is a fairly small release in terms of new features, with lots of internal improvements, such as integration tests with a whole range of DBs, a blog post on Pi day, RFCs for a type system, and more robust language bindings.</p>
<p>There’s a very small breaking change to the rust API, hence the minor version bump.</p>
<p>Here’s our April 2023 Update, from our <a href="https://github.com/PRQL/prql/blob/main/README.md">Readme</a>:</p>
<blockquote>
<h3 id="april-2023-update"><a class="header" href="#april-2023-update">April 2023 update</a></h3>
<p>PRQL is being actively developed by a growing community. It’s ready to use by the intrepid, either as part of one of our supported extensions, or within your own tools, using one of our supported language bindings.</p>
<p>PRQL still has some minor bugs and some missing features, and probably is only ready to be rolled out to non-technical teams for fairly simple queries.</p>
<p>Here’s our current <a href="https://prql-lang.org/roadmap/">Roadmap</a> and our <a href="https://github.com/PRQL/prql/milestones">Milestones.</a></p>
<p>Our immediate focus for the code is on:</p>
<ul>
<li>Building out the next few big features, including <a href="https://github.com/PRQL/prql/pull/1964">types</a> and <a href="https://github.com/PRQL/prql/pull/2129">modules</a>.</li>
<li>Ensuring our supported features feel extremely robust; resolving any <a href="https://github.com/PRQL/prql/issues?q=is%3Aissue+is%3Aopen+label%3Abug+label%3Apriority">priority bugs</a>.</li>
</ul>
<p>We’re also spending time thinking about:</p>
<ul>
<li>Making it really easy to start using PRQL. We’re doing that by building integrations with tools that folks already use; for example our VS Code extension &amp; Jupyter integration. If there are tools you’re familiar with that you think would be open to integrating with PRQL, please let us know in an issue.</li>
<li>Making it easier to contribute to the compiler. We have a wide group of contributors to the project, but contributions to the compiler itself are quite concentrated. We’re keen to expand this; <a href="https://github.com/PRQL/prql/issues/1840">#1840</a> for feedback.</li>
</ul>
</blockquote>
<hr />
<p>The release has 131 commits from 10 contributors. Particular credit goes to to @eitsupi &amp; @jelenkee, who have made significant contributions, and @vanillajonathan, whose prolific contribution include our growing language bindings.</p>
<p>A small selection of the changes:</p>
<p><strong>功能</strong>：</p>
<ul>
<li><code>prqlc compile</code> adds <code>--color</code> &amp; <code>--include-signature-comment</code> options. (@max-sixty, #2267)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Added the PRQL snippets from the book to the <a href="https://prql-lang.org/playground/">Playground</a> (@jelenkee, #2197)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li><em>Breaking</em>: The <code>compile</code> function’s <code>Options</code> now includes a <code>color</code> member, which determines whether error messages use ANSI color codes. This is technically a breaking change to the API. (@max-sixty, #2251)</li>
<li>The <code>Error</code> struct now exposes the <code>MessageKind</code> enum. (@vanillajonathan, #2307)</li>
<li>Integration tests run in CI with DuckDB, SQLite, PostgreSQL, MySQL and SQL Server (@jelenkee, #2286)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@k-nut, with #2294</li>
</ul>
<h2 id="061--2023-03-12"><a class="header" href="#061--2023-03-12">0.6.1 — 2023-03-12</a></h2>
<p>0.6.1 is a small release containing an internal refactoring and improved bindings for C, PHP &amp; .NET.</p>
<p>This release has 54 commits from 6 contributors. Selected changes:</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>No longer incorrectly compile to <code>DISTINCT</code> when a <code>take 1</code> refers to a different set of columns than are in the <code>group</code>. (@max-sixty, with thanks to @cottrell, #2109)</li>
<li>The version specification of the dependency Chumsky was bumped from <code>0.9.0</code> to <code>0.9.2</code>. <code>0.9.0</code> has a bug that causes an infinite loop. (@eitsupi, #2110)</li>
</ul>
<p><strong>文件</strong>：</p>
<ul>
<li>Add a policy for which bindings are supported / unsupported / nascent. See <a href="https://prql-lang.org/book/project/bindings/index.html">https://prql-lang.org/book/project/bindings/index.html</a> for more details (@max-sixty, #2062) (@max-sixty, #2062)</li>
</ul>
<p><strong>整合</strong>：</p>
<ul>
<li>[prql-lib] Added C++ header file. (@vanillajonathan, #2126)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li>Many of the items that were in the root of the repo have been aggregated into <code>web</code> &amp; <code>bindings</code>, simplifying the repo’s structure. There’s also <code>grammars</code> &amp; <code>packages</code> (@max-sixty, #2135, #2117, #2121).</li>
</ul>
<h2 id="060--2023-03-08"><a class="header" href="#060--2023-03-08">0.6.0 — 2023-03-08</a></h2>
<p>0.6.0 introduces a rewritten parser, giving us the ability to dramatically improve error messages, renames <code>switch</code> to <code>case</code> and includes lots of minor improvements and fixes. It also introduces <code>loop</code>, which compiles to <code>WITH RECURSIVE</code>, as a highly experimental feature.</p>
<p>There are a few cases of breaking changes, including switching <code>switch</code> to <code>case</code>, in case that’s confusing. There are also some minor parsing changes outlined below.</p>
<p>This release has 108 commits from 11 contributors. Selected changes:</p>
<p><strong>功能</strong>：</p>
<ul>
<li>
<p>Add a (highly experimental) <code>loop</code> language feature, which translates to <code>WITH RECURSIVE</code>. We expect changes and refinements in upcoming releases. (#1642, @aljazerzen)</p>
</li>
<li>
<p>Rename the experimental <code>switch</code> function to <code>case</code> given it more closely matches the traditional semantics of <code>case</code>. (@max-sixty, #2036)</p>
</li>
<li>
<p>Change the <code>case</code> syntax to use <code>=&gt;</code> instead of <code>-&gt;</code> to distinguish it from function syntax.</p>
</li>
<li>
<p>Convert parser from pest to Chumsky (@aljazerzen, #1818)</p>
<ul>
<li>Improved error messages, and the potential to make even better in the future. Many of these improvements come from error recovery.</li>
<li>String escapes (<code>\n \t</code>).</li>
<li>Raw strings that don’t escape backslashes.</li>
<li>String interpolations can only contain identifiers and not any expression.</li>
<li>Operator associativity has been changed from right-to-left to left-to-right to be more similar to other conventional languages.</li>
<li><code>and</code> now has a higher precedence than <code>or</code> (of same reason as the previous point).</li>
<li>Dates, times and timestamps have stricter parsing rules.</li>
<li><code>let</code>, <code>func</code>, <code>prql</code>, <code>case</code> are now treated as keywords.</li>
<li>Float literals without fraction part are not allowed anymore (<code>1.</code>).</li>
</ul>
</li>
<li>
<p>Add a <code>--format</code> option to <code>prqlc parse</code> which can return the AST in YAML (@max-sixty, #1962)</p>
</li>
<li>
<p>Add a new subcommand <code>prqlc jinja</code>. (@aljazerzen, #1722)</p>
</li>
<li>
<p><em>Breaking</em>: prql-compiler no longer passes text containing <code>{{</code> &amp; <code>}}</code> through to the output. (@aljazerzen, #1722)</p>
<p>For example, the following PRQL query</p>
<pre><code class="language-prql no-eval">from {{foo}}
</code></pre>
<p>was compiled to the following SQL previously, but now it raises an error.</p>
<pre><code class="language-sql">SELECT
  *
FROM
  {{ foo }}
</code></pre>
<p>This pass-through feature existed for integration with dbt.</p>
<p>We’re again considering how to best integrate with dbt, and this change is based on the idea that the jinja macro should run before the PRQL compiler.</p>
<p>If you’re interested in dbt integration, subscribe or 👍 to <a href="https://github.com/dbt-labs/dbt-core/pull/5982">https://github.com/dbt-labs/dbt-core/pull/5982</a>.</p>
</li>
<li>
<p>A new compile target <code>"sql.any"</code>. When <code>"sql.any"</code> is used as the target of the compile function’s option, the target contained in the query header will be used. (@aljazerzen, #1995)</p>
</li>
<li>
<p>Support for SQL parameters with similar syntax (#1957, @aljazerzen)</p>
</li>
<li>
<p>Allow <code>:</code> to be elided in timezones, such as <code>0800</code> in <code>@2020-01-01T13:19:55-0800</code> (@max-sixty, #1991).</p>
</li>
<li>
<p>Add <code>std.upper</code> and <code>std.lower</code> functions for changing string casing (@Jelenkee, #2019).</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li><code>prqlc compile</code> returns a non-zero exit code for invalid queries. (@max-sixty, #1924)</li>
<li>Identifiers can contain any alphabetic unicode characters (@max-sixty, #2003)</li>
</ul>
<p><strong>文件</strong>：</p>
<ul>
<li>Operator precedence (@aljazerzen, #1818)</li>
<li>Error messages for invalid queries are displayed in the book (@max-sixty, #2015)</li>
</ul>
<p><strong>整合</strong>：</p>
<ul>
<li>[prql-php] Added PHP bindings. (@vanillajonathan, #1860)</li>
<li>[prql-dotnet] Added .NET bindings. (@vanillajonathan, #1917)</li>
<li>[prql-lib] Added C header file. (@vanillajonathan, #1879)</li>
<li>Added a workflow building a <code>.deb</code> on each release. (Note that it’s not yet published on each release). (@vanillajonathan, #1883)</li>
<li>Added a workflow building a <code>.rpm</code> on each release. (Note that it’s not yet published on each release). (@vanillajonathan, #1918)</li>
<li>Added a workflow building a Snap package on each release. (@vanillajonathan, #1881)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li>Test that the output of our nascent autoformatter can be successfully compiled into SQL. Failing examples are now clearly labeled. (@max-sixty, #2016)</li>
<li>Definition files have been added to configure <a href="https://containers.dev/">Dev Containers</a> for Rust development environment. (@eitsupi, #1893, #2025, #2028)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@linux-china, with #1971</li>
<li>@Jelenkee, with #2019</li>
</ul>
<h2 id="052--2023-02-18"><a class="header" href="#052--2023-02-18">0.5.2 — 2023-02-18</a></h2>
<p>0.5.2 is a tiny release to fix an build issue in yesterday’s <code>prql-js</code> 0.5.1 release.</p>
<p>This release has 7 commits from 2 contributors.</p>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@matthias-Q, with #1873</li>
</ul>
<h2 id="051--2023-02-17"><a class="header" href="#051--2023-02-17">0.5.1 — 2023-02-17</a></h2>
<p>0.5.1 contains a few fixes, and another change to how bindings handle default target / dialects.</p>
<p>This release has 53 commits from 7 contributors. Selected changes:</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Delegate dividing literal integers to the DB. Previously integer division was executed during PRQL compilation, which could be confusing given that behavior is different across DBs. Other arithmetic operations are still executed during compilation. (@max-sixty, #1747)</li>
</ul>
<p><strong>文件</strong>：</p>
<ul>
<li>Add docs on the <code>from_text</code> transform (@max-sixty, #1756)</li>
</ul>
<p><strong>整合</strong>：</p>
<ul>
<li>[prql-js] Default compile target changed from <code>Sql(Generic)</code> to <code>Sql(None)</code>. (@eitsupi, #1856)</li>
<li>[prql-python] Compilation options can now be specified from Python. (@eitsupi, #1807)</li>
<li>[prql-python] Default compile target changed from <code>Sql(Generic)</code> to <code>Sql(None)</code>. (@eitsupi, #1861)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@vanillajonathan, with #1766</li>
</ul>
<h2 id="050--2023-02-08"><a class="header" href="#050--2023-02-08">0.5.0 — 2023-02-08</a></h2>
<p>0.5.0 contains a few fixes, some improvements to bindings, lots of docs improvements, and some work on forthcoming features. It contains one breaking change in the compiler’s <code>Options</code> interface.</p>
<p>This release has 74 commits from 12 contributors. Selected changes:</p>
<p><strong>功能</strong>：</p>
<ul>
<li>
<p>Change public API to use target instead of dialect in preparation for feature work (@aljazerzen, #1684)</p>
</li>
<li>
<p><code>prqlc watch</code> command which watches filesystem for changes and compiles .prql files to .sql (@aljazerzen, #1708)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Support double brackets in s-strings which aren’t symmetric (@max-sixty, #1650)</li>
<li>Support Postgres’s Interval syntax (@max-sixty, #1649)</li>
<li>Fixed tests for <code>prql-elixir</code> with MacOS (@kasvith, #1707)</li>
</ul>
<p><strong>文件</strong>：</p>
<ul>
<li>Add a documentation test for prql-compiler, update prql-compiler README, and include the README in the prql book section for Rust bindings. The code examples in the README are included and tested as doctests in the prql-compiler (@nkicg6, #1679)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li>Add tests for all PRQL website examples to prql-python to ensure compiled results match expected SQL (@nkicg6, #1719)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@ruslandoga, with #1628</li>
<li>@RalfNorthman, with #1632</li>
<li>@nicot, with #1662</li>
</ul>
<h2 id="042--2023-01-25"><a class="header" href="#042--2023-01-25">0.4.2 — 2023-01-25</a></h2>
<p><strong>功能</strong>：</p>
<ul>
<li>
<p>New <code>from_text format-arg string-arg</code> function that supports JSON and CSV formats. <em>format-arg</em> can be <code>format:csv</code> or <code>format:json</code>. <em>string-arg</em> can be a string in any format. (@aljazerzen &amp; @snth, #1514)</p>
<pre><code class="language-prql no-eval">from_text format:csv """
a,b,c
1,2,3
4,5,6
"""
</code></pre>
<pre><code class="language-prql no-eval">from_text format:json '''
    [{"a": 1, "b": "x", "c": false }, {"a": 4, "b": "y", "c": null }]
'''
</code></pre>
<pre><code class="language-prql no-eval">from_text format:json '''{
    "columns": ["a", "b", "c"],
    "data": [
        [1, "x", false],
        [4, "y", null]
    ]
}'''
</code></pre>
<p>For now, the argument is limited to string constants.</p>
</li>
</ul>
<p><strong>Fixes</strong></p>
<ul>
<li>Export constructor for SQLCompileOptions (@bcho, #1621)</li>
<li>Remove backticks in count_distinct (@aljazerzen, #1611)</li>
</ul>
<p><strong>New Contributors</strong></p>
<ul>
<li>@1Kinoti, with #1596</li>
<li>@veenaamb, with #1614</li>
</ul>
<h2 id="041--2023-01-18"><a class="header" href="#041--2023-01-18">0.4.1 — 2023-01-18</a></h2>
<p>0.4.1 comes a few days after 0.4.0, with a couple of features and the release of <code>prqlc</code>, the CLI crate.</p>
<p>0.4.1 has 35 commits from 6 contributors.</p>
<p><strong>功能</strong>：</p>
<ul>
<li>
<p>Inferred column names include the relation name (@aljazerzen, #1550):</p>
<pre><code class="language-prql no-eval">from albums
select title # name used to be inferred as title only
select albums.title # so using albums was not possible here
</code></pre>
</li>
<li>
<p>Quoted identifiers such as <code>dir/*.parquet</code> are passed through to SQL. (@max-sixty, #1516).</p>
</li>
<li>
<p>The CLI is installed with <code>cargo install prqlc</code>. The binary was renamed in 0.4.0 but required an additional <code>--features</code> flag, which has been removed in favor of this new crate (@max-sixty &amp; @aljazerzen, #1549).</p>
</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@fool1280, with #1554</li>
<li>@nkicg6, with #1567</li>
</ul>
<h2 id="040--2023-01-15"><a class="header" href="#040--2023-01-15">0.4.0 — 2023-01-15</a></h2>
<p>0.4.0 brings lots of new features including <code>case</code>, <code>select ![]</code> and numbers with underscores. We have initial (unpublished) bindings to Elixir. And there’s the usual improvements to fixes &amp; documentation (only a minority are listed below in this release).</p>
<p>0.4.0 also has some breaking changes: <code>table</code> is <code>let</code>, <code>dialect</code> is renamed to <code>target</code>, and the compiler’s API has changed. Full details below.</p>
<p><strong>功能</strong>：</p>
<ul>
<li>
<p>Defining a temporary table is now expressed as <code>let</code> rather than <code>table</code> (@aljazerzen, #1315). See the <a href="https://prql-lang.org/book/reference/declarations/variables.html">tables docs</a> for details.</p>
</li>
<li>
<p><em>Experimental:</em> The <a href="https://prql-lang.org/book/reference/syntax/case.html"><code>case</code></a> function sets a variable to a value based on one of several expressions (@aljazerzen, #1278).</p>
<pre><code class="language-prql no-eval">derive var = case [
  score &lt;= 10 -&gt; "low",
  score &lt;= 30 -&gt; "medium",
  score &lt;= 70 -&gt; "high",
  true -&gt; "very high",
]
</code></pre>
<p>…compiles to:</p>
<pre><code class="language-sql">SELECT
  *,
  CASE
    WHEN score &lt;= 10 THEN 'low'
    WHEN score &lt;= 30 THEN 'medium'
    WHEN score &lt;= 70 THEN 'high'
    ELSE 'very high'
  END AS var
FROM
  bar
</code></pre>
<p>Check out the <a href="https://prql-lang.org/book/reference/syntax/case.html"><code>case</code> docs</a> for more details.</p>
</li>
<li>
<p><em>Experimental:</em> Columns can be excluded by name with <code>select</code> (@aljazerzen, #1329)</p>
<pre><code class="language-prql no-eval">from albums
select ![title, composer]
</code></pre>
</li>
<li>
<p><em>Experimental:</em> <code>append</code> transform, equivalent to <code>UNION ALL</code> in SQL. (@aljazerzen, #894)</p>
<pre><code class="language-prql no-eval">from employees
append managers
</code></pre>
<p>Check out the <a href="https://prql-lang.org/book/reference/stdlib/transforms/append.html"><code>append</code> docs</a> for more details.</p>
</li>
<li>
<p>Numbers can contain underscores, which can make reading long numbers easier (@max-sixty, #1467):</p>
<pre><code class="language-prql no-eval">from numbers
select {
    small = 1.000_000_1,
    big = 5_000_000,
}
</code></pre>
</li>
<li>
<p>The SQL output contains a comment with the PRQL compiler version (@aljazerzen, #1322)</p>
</li>
<li>
<p><code>dialect</code> is renamed to <code>target</code>, and its values are prefixed with <code>sql.</code> (@max-sixty, #1388); for example:</p>
<pre><code class="language-prql no-eval">prql target:sql.bigquery  # previously was `dialect:bigquery`

from employees
</code></pre>
<p>This gives us the flexibility to target other languages than SQL in the long term.</p>
</li>
<li>
<p>Tables definitions can contain a bare s-string (@max-sixty, #1422), which enables us to include a full CTE of SQL, for example:</p>
<pre><code class="language-prql no-eval">let grouping = s"""
  SELECT SUM(a)
  FROM tbl
  GROUP BY
    GROUPING SETS
    ((b, c, d), (d), (b, d))
"""
</code></pre>
</li>
<li>
<p>Ranges supplied to <code>in</code> can be half-open (@aljazerzen, #1330).</p>
</li>
<li>
<p>The crate’s external API has changed to allow for compiling to intermediate representation. This also affects bindings. See <a href="https://docs.rs/prql-compiler/latest/prql_compiler/"><code>prql-compiler</code> docs</a> for more details.</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<p>[This release, the changelog only contains a subset of fixes]</p>
<ul>
<li>Allow interpolations in table s-strings (@aljazerzen, #1337)</li>
</ul>
<p><strong>文件</strong>：</p>
<p>[This release, the changelog only contains a subset of documentation improvements]</p>
<ul>
<li>Add docs on aliases in <a href="https://prql-lang.org/book/reference/stdlib/transforms/select.html">Select</a></li>
<li>Add JS template literal and multiline example (@BCsabaEngine, #1432)</li>
<li>JS template literal and multiline example (@BCsabaEngine, #1432)</li>
<li>Improve prql-compiler docs &amp; examples (@aljazerzen, #1515)</li>
<li>Fix string highlighting in book (@max-sixty, #1264)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>The playground allows querying some sample data. As before, the result updates on every keystroke. (@aljazerzen, #1305)</li>
</ul>
<p><strong>整合</strong>：</p>
<p>[This release, the changelog only contains a subset of integration improvements]</p>
<ul>
<li>Added Elixir integration exposing PRQL functions as NIFs (#1500, @kasvith)</li>
<li>Exposed Elixir flavor with exceptions (#1513, @kasvith)</li>
<li>Rename <code>prql-compiler</code> binary to <code>prqlc</code> (@aljazerzen #1515)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<p>[This release, the changelog only contains a subset of internal changes]</p>
<ul>
<li>Add parsing for negative select (@max-sixty, #1317)</li>
<li>Allow for additional builtin functions (@aljazerzen, #1325)</li>
<li>Add an automated check for typos (@max-sixty, #1421)</li>
<li>Add tasks for running playground &amp; book (@max-sixty, #1265)</li>
<li>Add tasks for running tests on every file change (@max-sixty, #1380)</li>
</ul>
<p><strong>New contributors</strong>:</p>
<ul>
<li>@EArazli, with #1359</li>
<li>@boramalper, with #1362</li>
<li>@allurefx, with #1377</li>
<li>@bcho, with #1375</li>
<li>@JettChenT, with #1385</li>
<li>@BlurrechDev, with #1411</li>
<li>@BCsabaEngine, with #1432</li>
<li>@kasvith, with #1500</li>
</ul>
<h2 id="031---2022-12-03"><a class="header" href="#031---2022-12-03">0.3.1 - 2022-12-03</a></h2>
<p>0.3.1 brings a couple of small improvements and fixes.</p>
<p><strong>功能</strong>：</p>
<ul>
<li>
<p>Support for using s-strings for <code>from</code> (#1197, @aljazerzen)</p>
<pre><code class="language-prql no-eval">from s"SELECT * FROM employees WHERE foo &gt; 5"
</code></pre>
</li>
<li>
<p>Helpful error message when referencing a table in an s-string (#1203, @aljazerzen)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Multiple columns with same name created (#1211, @aljazerzen)</li>
<li>Renaming via select breaks preceding sorting (#1204, @aljazerzen)</li>
<li>Same column gets selected multiple times (#1186, @mklopets)</li>
</ul>
<p><strong>Internal</strong>:</p>
<ul>
<li>Update Github Actions and Workflows to current version numbers (and avoid using Node 12)</li>
</ul>
<h2 id="030--2022-11-29"><a class="header" href="#030--2022-11-29">0.3.0 — 2022-11-29</a></h2>
<p>🎉 0.3.0 is the biggest ever change in PRQL’s compiler, rewriting much of the internals: the compiler now has a semantic understanding of expressions, including resolving names &amp; building a DAG of column lineage 🎉.</p>
<p>While the immediate changes to the language are modest — some long-running bugs are fixed — this unlocks the development of many of the project’s long-term priorities, such as type-checking &amp; auto-complete. And it simplifies the building of our next language features, such as match-case expressions, unions &amp; table expressions.</p>
<p>@aljazerzen has (mostly single-handedly) done this work over the past few months. The project owes him immense appreciation.</p>
<p><strong>Breaking changes</strong>:</p>
<p>We’ve had to make some modest breaking changes for 0.3:</p>
<ul>
<li>
<p><em>Pipelines must start with <code>from</code></em>. For example, a pipeline with only <code>derive foo = 5</code>, with no <code>from</code> transform, is no longer valid. Depending on demand for this feature, it would be possible to add this back.</p>
</li>
<li>
<p><em>Shared column names now require <code>==</code> in a join</em>. The existing approach is ambiguous to the compiler — <code>id</code> in the following example could be a boolean column.</p>
<pre><code class="language-diff">from employees
-join positions [id]
+join positions [==id]
</code></pre>
</li>
<li>
<p><em>Table references containing periods must be surrounded by backticks</em>. For example, when referencing a schema name:</p>
<pre><code class="language-diff">-from public.sometable
+from `public.sometable`
</code></pre>
</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li>Change self equality op to <code>==</code> (#1176, @aljazerzen)</li>
<li>Add logging (@aljazerzen)</li>
<li>Add clickhouse dialect (#1090, @max-sixty)</li>
<li>Allow namespaces &amp; tables to contain <code>.</code> (#1079, @aljazerzen)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Deduplicate column appearing in <code>SELECT</code> multiple times (#1186, @aljazerzen)</li>
<li>Fix uppercase table names (#1184, @aljazerzen)</li>
<li>Omit table name when only one ident in SELECT (#1094, @aljazerzen)</li>
</ul>
<p><strong>文件</strong>：</p>
<ul>
<li>Add chapter on semantics’ internals (@aljazerzen, #1028)</li>
<li>Add note about nesting variables in s-strings (@max-sixty, #1163)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li>Flatten group and window (#1120, @aljazerzen)</li>
<li>Split ast into expr and stmt (@aljazerzen)</li>
<li>Refactor associativity (#1156, @aljazerzen)</li>
<li>Rename Ident constructor to <code>from_name</code> (#1084, @aljazerzen)</li>
<li>Refactor rq folding (#1177, @aljazerzen)</li>
<li>Add tests for reported bugs fixes in semantic (#1174, @aljazerzen)</li>
<li>Bump duckdb from 0.5.0 to 0.6.0 (#1132)</li>
<li>Bump once_cell from 1.15.0 to 1.16.0 (#1101)</li>
<li>Bump pest from 2.4.0 to 2.5.0 (#1161)</li>
<li>Bump pest_derive from 2.4.0 to 2.5.0 (#1179)</li>
<li>Bump sqlparser from 0.25.0 to 0.27.0 (#1131)</li>
<li>Bump trash from 2.1.5 to 3.0.0 (#1178)</li>
</ul>
<h2 id="0211--2022-11-20"><a class="header" href="#0211--2022-11-20">0.2.11 — 2022-11-20</a></h2>
<p>0.2.11 contains a few helpful fixes.</p>
<p>Work continues on our <code>semantic</code> refactor — look out for 0.3.0 soon! Many thanks to @aljazerzen for his continued contributions to this.</p>
<p>Note: 0.2.10 was skipped due to this maintainer’s inability to read his own docs on bumping versions…</p>
<p><strong>功能</strong>：</p>
<ul>
<li>Detect when compiler version is behind query version (@MarinPostma, #1058)</li>
<li>Add <code>__version__</code> to prql-python package (@max-sixty, #1034)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Fix nesting of expressions with equal binding strength and left associativity, such as <code>a - (b - c)</code> (@max-sixty, #1136)</li>
<li>Retain floats without significant digits as floats (@max-sixty, #1141)</li>
</ul>
<p><strong>文件</strong>：</p>
<ul>
<li>Add documentation of <code>prqlr</code> bindings (@eitsupi, #1091)</li>
<li>Add a ‘Why PRQL’ section to the website (@max-sixty, #1098)</li>
<li>Add @snth to core-devs (@max-sixty, #1050)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li>Use workspace versioning (@max-sixty, #1065)</li>
</ul>
<h2 id="029--2022-10-14"><a class="header" href="#029--2022-10-14">0.2.9 — 2022-10-14</a></h2>
<p>0.2.9 is a small release containing a bug fix for empty strings.</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Fix parsing of empty strings (@aljazerzen, #1024)</li>
</ul>
<h2 id="028--2022-10-10"><a class="header" href="#028--2022-10-10">0.2.8 — 2022-10-10</a></h2>
<p>0.2.8 is another modest release with some fixes, doc improvements, bindings improvements, and lots of internal changes. Note that one of the fixes causes the behavior of <code>round</code> and <code>cast</code> to change slightly — though it’s handled as a fix rather than a breaking change in semantic versioning.</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>
<p>Change order of the <code>round</code> &amp; <code>cast</code> function parameters to have the column last; for example <code>round 2 foo_col</code> / <code>cast int foo</code>. This is consistent with other functions, and makes piping possible:</p>
<pre><code class="language-prql no-eval">derive [
  gross_salary = (salary + payroll_tax | as int),
  gross_salary_rounded = (gross_salary | round 0),
]
</code></pre>
</li>
</ul>
<p><strong>文件</strong>：</p>
<ul>
<li>Split <code>DEVELOPMENT.md</code> from <code>CONTRIBUTING.md</code> (@richb-hanover, #1010)</li>
<li>Make s-strings more prominent in website intro (@max-sixty, #982)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Add GitHub star count to website (@max-sixty, #990)</li>
</ul>
<p><strong>整合</strong>：</p>
<ul>
<li>Expose a shortened error message, in particular for the VS Code extension (@aljazerzen, #1005)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li>Specify 1.60.0 as minimum Rust version (@max-sixty, #1011)</li>
<li>Remove old <code>wee-alloc</code> code (@max-sixty, #1013)</li>
<li>Upgrade clap to version 4 (@aj-bagwell, #1004)</li>
<li>Improve book-building script in Taskfile (@max-sixty, #989)</li>
<li>Publish website using an artifact rather than a long-lived branch (@max-sixty, #1009)</li>
</ul>
<h2 id="027--2022-09-17"><a class="header" href="#027--2022-09-17">0.2.7 — 2022-09-17</a></h2>
<p>0.2.7 is a fairly modest release, six weeks after 0.2.6. We have some more significant features, including a <code>union</code> operator and an overhaul of our type system, as open PRs which will follow in future releases.</p>
<p>We also have new features in the <a href="https://github.com/PRQL/prql-code">VS Code extension</a>, courtesy of @jiripospisil, including a live output panel.</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li><code>range_of_ranges</code> checks the Range end is smaller than its start (@shuozeli, #946)</li>
</ul>
<p><strong>文件</strong>：</p>
<ul>
<li>Improve various docs (@max-sixty, #974, #971, #972, #970, #925)</li>
<li>Add reference to EdgeDB’s blog post in our FAQ (@max-sixty, #922)</li>
<li>Fix typos (@kianmeng, #943)</li>
</ul>
<p><strong>整合</strong>：</p>
<ul>
<li>Add <code>prql-lib</code>, enabling language bindings with <code>go</code> (@sigxcpu76, #923)</li>
<li>Fix line numbers in JS exceptions (@charlie-sanders, #929)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li>Lock the version of the rust-toolchain, with auto-updates (@max-sixty, #926, #927)</li>
</ul>
<h2 id="026--2022-08-05"><a class="header" href="#026--2022-08-05">0.2.6 — 2022-08-05</a></h2>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Adjust <code>fmt</code> to only escape names when needed (@aljazerzen, #907)</li>
<li>Fix quoting on upper case <code>table</code> names (@max-sixty, #893)</li>
<li>Fix scoping of identical column names from multiple tables (@max-sixty, #908)</li>
<li>Fix parse error on newlines in a <code>table</code> (@sebastiantoh 🆕, #902)</li>
<li>Fix quoting of upper case table names (@max-sixty, #893)</li>
</ul>
<p><strong>文件</strong>：</p>
<ul>
<li>Add docs on Architecture (@aljazerzen, #904)</li>
<li>Add Changelog (@max-sixty, #890 #891)</li>
</ul>
<p><strong>內部變更</strong>：</p>
<ul>
<li>Start trial using Conventional Commits (@max-sixty, #889)</li>
<li>Add crates.io release workflow, docs (@max-sixty, #887)</li>
</ul>
<h2 id="025---2022-07-29"><a class="header" href="#025---2022-07-29">0.2.5 - 2022-07-29</a></h2>
<p>0.2.5 is a very small release following 0.2.4 yesterday. It includes:</p>
<ul>
<li>Add the ability to represent single brackets in an s-string, with two brackets (#752, @max-sixty)</li>
<li>Fix the “Copy to Clipboard” command in the Playground, for Firefox (#880, @mklopets)</li>
</ul>
<h2 id="024---2022-07-28"><a class="header" href="#024---2022-07-28">0.2.4 - 2022-07-28</a></h2>
<p>0.2.4 is a small release following 0.2.3 a few days ago. The 0.2.4 release includes:</p>
<ul>
<li>Enrich our CLI, adding commands to get different stages of the compilation process (@aljazerzen , #863)</li>
<li>Fix multiple <code>take n</code> statements in a query, leading to duplicate proxy columns in generated SQL (@charlie-sanders)</li>
<li>Fix BigQuery quoting of identifiers in <code>SELECT</code> statements (@max-sixty)</li>
<li>Some internal changes — reorganize top-level functions (@aljazerzen), add a workflow to track our Rust compilation time (@max-sixty), simplify our simple prql-to-sql tests (@max-sixty)</li>
</ul>
<p>Thanks to @ankane, <code>prql-compiler</code> is now available from homebrew core; <code>brew install prql-compiler</code><sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>.</p>
<h2 id="023---2022-07-24"><a class="header" href="#023---2022-07-24">0.2.3 - 2022-07-24</a></h2>
<p>A couple of weeks since the 0.2.2 release: we’ve squashed a few bugs, added some mid-sized features to the language, and made a bunch of internal improvements.</p>
<p>The 0.2.3 release includes:</p>
<ul>
<li>Allow for escaping otherwise-invalid identifiers (@aljazerzen &amp; @max-sixty)</li>
<li>Fix a bug around operator precedence (@max-sixty)</li>
<li>Add a section the book on the language bindings (@charlie-sanders)</li>
<li>Add tests for our <code>Display</code> representation while fixing some existing bugs. This is gradually becoming our code formatter (@arrizalamin)</li>
<li>Add a “copy to clipboard” button in the Playground (@mklopets)</li>
<li>Add lots of guidance to our <code>CONTRIBUTING.md</code> around our tests and process for merging (@max-sixty)</li>
<li>Add a <code>prql!</code> macro for parsing a prql query at compile time (@aljazerzen)</li>
<li>Add tests for <code>prql-js</code> (@charlie-sanders)</li>
<li>Add a <code>from_json</code> method for transforming json to a PRQL string (@arrizalamin)</li>
<li>Add a workflow to release <code>prql-java</code> to Maven (@doki23)</li>
<li>Enable running all tests from a PR by adding a <code>pr-run-all-tests</code> label (@max-sixty)</li>
<li>Have <code>cargo-release</code> to bump all crate &amp; npm versions (@max-sixty)</li>
<li>Update <code>prql-js</code> to use the bundler build of <code>prql-js</code> (@mklopets)</li>
</ul>
<p>As well as those contribution changes, thanks to those who’ve reported issues, such as @mklopets @huw @mm444 @ajfriend.</p>
<p>From here, we’re planning to continue squashing bugs (albeit more minor than those in this release), adding some features like <code>union</code>, while working on bigger issues such as type-inference.</p>
<p>We’re also going to document and modularize the compiler further. It’s important that we give more people an opportunity to contribute to the guts of PRQL, especially given the number and enthusiasm of contributions to project in general — and it’s not that easy to do so at the moment. While this is ongoing if anyone has something they’d like to work on in the more difficult parts of the compiler, let us know on GitHub or Discord, and we’d be happy to work together on it.</p>
<p>Thank you!</p>
<h2 id="022---2022-07-10"><a class="header" href="#022---2022-07-10">0.2.2 - 2022-07-10</a></h2>
<p>We’re a couple of weeks since our 0.2.0 release. Thanks for the surge in interest and contributions! 0.2.2 has some fixes &amp; some internal improvements:</p>
<ul>
<li>We now test against SQLite &amp; DuckDB on every commit, to ensure we’re producing correct SQL. (@aljazerzen)</li>
<li>We have the beginning of Java bindings! (@doki23)</li>
<li>Idents surrounded by backticks are passed through to SQL (@max-sixty)</li>
<li>More examples on homepage; e.g. <code>join</code> &amp; <code>window</code>, lots of small docs improvements</li>
<li>Automated releases to homebrew (@roG0d)</li>
<li><a href="https://github.com/PRQL/prql/tree/main/bindings/prql-js">prql-js</a> is now a single package for Node, browsers &amp; webpack (@charlie-sanders)</li>
<li>Parsing has some fixes, including <code>&gt;=</code> and leading underscores in idents (@mklopets)</li>
<li>Ranges receive correct syntax highlighting (@max-sixty)</li>
</ul>
<p>Thanks to Aljaž Mur Eržen @aljazerzen , George Roldugin @roldugin , Jasper McCulloch @Jaspooky , Jie Han @doki23 , Marko Klopets @mklopets , Maximilian Roos @max-sixty , Rodrigo Garcia @roG0d , Ryan Russell @ryanrussell , Steven Maude @StevenMaude , Charlie Sanders @charlie-sanders .</p>
<p>We’re planning to continue collecting bugs &amp; feature requests from users, as well as working on some of the bigger features, like type-inference.</p>
<p>For those interesting in joining, we also have a new <a href="https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md">Contributing page</a>.</p>
<h2 id="020---2022-06-27"><a class="header" href="#020---2022-06-27">0.2.0 - 2022-06-27</a></h2>
<p>🎉 🎉 <strong>After several months of building, PRQL is ready to use!</strong> 🎉 🎉</p>
<hr />
<p>How we got here:</p>
<p>At the end of January, we published a proposal of a better language for data transformation: PRQL. The reception was better than I could have hoped for — we were no. 2 on HackerNews for a day, and gained 2.5K GitHub stars over the next few days.</p>
<p>But man cannot live on GitHub Stars alone — we had to do the work to build it. So over the next several months, during many evenings &amp; weekends, a growing group of us gradually built the compiler, evolved the language, and wrote some integrations.</p>
<p>We want to double-down on the community and its roots in open source — it’s incredible that a few of us from all over the globe have collaborated on a project without ever having met. We decided early-on that PRQL would always be open-source and would never have a commercial product (despite lots of outside interest to fund a seed round!). Because languages are so deep in the stack, and the data stack has so many players, the best chance of building a great language is to build an open language.</p>
<hr />
<p>We still have a long way to go. While PRQL is usable, it has lots of missing features, and an incredible amount of unfulfilled potential, including a language server, cohesion with databases, and type inference. Over the coming weeks, we’d like to grow the number of intrepid users experimenting PRQL in their projects, prioritize features that will unblock them, and then start fulfilling PRQL’s potential by working through our <a href="https://prql-lang.org/roadmap/">roadmap</a>.</p>
<p>The best way to experience PRQL is to try it. Check out our <a href="https://prql-lang.org">website</a> and the <a href="https://prql-lang.org/playground">Playground</a>. Start using PRQL for your own projects in <a href="https://github.com/prql/dbt-prql">dbt</a>, <a href="https://pyprql.readthedocs.io/en/latest/magic_readme.html">Jupyter notebooks</a> and Prefect workflows.</p>
<p>Keep in touch with PRQL by following the project on <a href="https://twitter.com/prql_lang">Twitter</a>, joining us on <a href="https://discord.gg/eQcfaCmsNc">Discord</a>, starring the <a href="https://github.com/PRQL/prql">repo</a>.</p>
<p><a href="https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md">Contribute</a> to the project — we’re a really friendly community, whether you’re a recent SQL user or an advanced Rust programmer. We need bug reports, documentation tweaks &amp; feature requests — just as much as we need compiler improvements written in Rust.</p>
<hr />
<p>I especially want to give <a href="https://github.com/aljazerzen">Aljaž Mur Eržen</a> (@aljazerzen) the credit he deserves, who has contributed the majority of the difficult work of building out the compiler. Much credit also goes to <a href="https://github.com/charlie-sanders">Charlie Sanders</a> (@charlie-sanders), one of PRQL’s earliest supporters and the author of pyprql, and <a href="https://github.com/rbpatt2019">Ryan Patterson-Cross</a> (@rbpatt2019), who built the Jupyter integration among other Python contributions.</p>
<p>Other contributors who deserve a special mention include: @roG0d, @snth, @kwigley</p>
<hr />
<p>Thank you, and we look forward to your feedback!</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<pre><code>we still need to update docs and add a release workflow for this:
&lt;https://github.com/PRQL/prql/issues/866&gt;
</code></pre>
 <a href="#fr-1-1">↩</a></li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="target--version"><a class="header" href="#target--version">Target &amp; Version</a></h1>
<h2 id="target-dialect"><a class="header" href="#target-dialect">Target dialect</a></h2>
<p>PRQL allows specifying a target dialect at the top of the query, which allows PRQL to compile to a database-specific SQL flavor.</p>
<h3 id="範例-13"><a class="header" href="#範例-13">範例</a></h3>
<div class="comparison">
<div>
<h4 id="prql-121"><a class="header" href="#prql-121">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.postgres

from employees
sort age
take 10
</code></pre>
</div>
<div>
<h4 id="sql-118"><a class="header" href="#sql-118">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age
LIMIT
  10

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-122"><a class="header" href="#prql-122">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mssql

from employees
sort age
take 10
</code></pre>
</div>
<div>
<h4 id="sql-119"><a class="header" href="#sql-119">SQL</a></h4>
<pre><code class="language-sql">SELECT
  TOP (10) *
FROM
  employees
ORDER BY
  age

</code></pre>
</div>
</div>
<h2 id="dialects"><a class="header" href="#dialects">Dialects</a></h2>
<h3 id="supported"><a class="header" href="#supported">Supported</a></h3>
<p>Supported dialects support all PRQL language features where possible, are tested on every commit, and we’ll endeavor to fix bugs.</p>
<ul>
<li><code>sql.duckdb</code></li>
<li><code>sql.mysql</code></li>
<li><code>sql.postgres</code></li>
<li><code>sql.clickhouse</code></li>
<li><code>sql.generic</code> <sup><a name="to-footnote-1"><a href="project/target.html#footnote-1">1</a></a></sup></li>
<li><code>sql.sqlite</code></li>
</ul>
<h3 id="unsupported"><a class="header" href="#unsupported">Unsupported</a></h3>
<p>Unsupported dialects have implementations in the compiler, but are tested minimally or not at all, and may have gaps for some features.</p>
<p>We’re open to contributions to improve our coverage of these, and to adding additional dialects.</p>
<ul>
<li><code>sql.mssql</code></li>
<li><code>sql.ansi</code></li>
<li><code>sql.bigquery</code></li>
<li><code>sql.snowflake</code></li>
</ul>
<h2 id="priority-of-targets"><a class="header" href="#priority-of-targets">Priority of targets</a></h2>
<p>The compile target of a query is defined in the query’s header or as an argument to the compiler. option. The argument to the compiler takes precedence.</p>
<p>For example, the following shell example specifies <code>sql.generic</code> in the query and <code>sql.duckdb</code> in the <code>--target</code> option of the <code>prqlc compile</code> command. In this case, <code>sql.duckdb</code> takes precedence and the SQL output is based on the DuckDB dialect.</p>
<pre><code class="language-sh">echo 'prql target:sql.generic
      from foo' | prqlc compile --target sql.duckdb
</code></pre>
<p>To use the target described in the query, a special target <code>sql.any</code> can be specified in the compiler option.</p>
<pre><code class="language-sh">echo 'prql target:sql.generic
      from foo' | prqlc compile --target sql.any
</code></pre>
<h2 id="版本"><a class="header" href="#版本">版本</a></h2>
<p>PRQL allows specifying a version of the language in the PRQL header, like:</p>
<div class="comparison">
<div>
<h4 id="prql-123"><a class="header" href="#prql-123">PRQL</a></h4>
<pre><code class="language-prql">prql version:"0.9.5"

from employees
</code></pre>
</div>
<div>
<h4 id="sql-120"><a class="header" href="#sql-120">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees

</code></pre>
</div>
</div>
<p>This has two roles, one of which is implemented:</p>
<ul>
<li>The compiler will raise an error if the compiler is older than the query version. This prevents confusing errors when queries use newer features of the language but the compiler hasn’t yet been upgraded.</li>
<li>The compiler will compile for the major version of the query. This allows the language to evolve without breaking existing queries, or forcing multiple installations of the compiler. This isn’t yet implemented, but is a gating feature for PRQL 1.0.<p><hr/></li>
</ul>
<p><a name="footnote-1"><a href="project/target.html#to-footnote-1">1</a></a>: while there’s no “generic” DB to test <code>sql.generic</code> against, we still count it as supported.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="綁定"><a class="header" href="#綁定">綁定</a></h1>
<p>PRQL has bindings for many languages. These include:</p>
<p>We have three tiers of bindings:</p>
<ul>
<li>Supported</li>
<li>Unsupported</li>
<li>Nascent</li>
</ul>
<h2 id="supported-1"><a class="header" href="#supported-1">Supported</a></h2>
<p>Supported bindings require:</p>
<ul>
<li>A maintainer.</li>
<li>Implementations of the <a href="https://docs.rs/prql-compiler/latest/prql_compiler/#functions">core compile functions</a>.</li>
<li>Test coverage for these functions.</li>
<li>A published package to the language’s standard package repository.</li>
<li>A script in <code>Taskfile.yml</code> to bootstrap a development environment.</li>
<li>Any dev tools, such as a linter &amp; formatter, in pre-commit or MegaLinter.</li>
</ul>
<p>The currently supported bindings are:</p>
<ul>
<li><a href="project/bindings/./javascript.html">JavaScript</a></li>
<li><a href="project/bindings/./python.html">Python</a></li>
<li><a href="project/bindings/./r.html">R</a></li>
<li><a href="project/bindings/./rust.html">Rust</a></li>
</ul>
<p>Most of these are in the main PRQL repo, and we gate any changes to the compiler’s API on compatible changes to the bindings.</p>
<h2 id="unsupported-1"><a class="header" href="#unsupported-1">Unsupported</a></h2>
<p>Unsupported bindings work, but don’t fulfil all of the above criteria. We don’t gate changes to the compiler’s API. If they stop working, we’ll demote them to nascent.</p>
<ul>
<li><a href="project/bindings/./java.html">Java</a></li>
<li><a href="project/bindings/./elixir.html">Elixir</a></li>
<li><code>prql-lib</code>, the C bindings</li>
</ul>
<h2 id="nascent"><a class="header" href="#nascent">Nascent</a></h2>
<p>Nascent bindings are in development, and may not yet fully work.</p>
<ul>
<li><a href="project/bindings/./dotnet.html">.NET</a></li>
<li><a href="project/bindings/./php.html">PHP</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-dotnet"><a class="header" href="#prql-dotnet">prql-dotnet</a></h1>
<p><code>prql-net</code> offers PRQL bindings for .NET bindings as a <code>netstandard2.0</code> library.</p>
<p>It provides the <code>PrqlCompiler</code> class which contains the <code>ToJson</code> and <code>ToSql</code> static methods.</p>
<p>It’s still at an early stage, and isn’t published to NuGet. Contributions are welcome.</p>
<h2 id="安裝"><a class="header" href="#安裝">安裝</a></h2>
<p>Make sure that <code>libprql_lib.so</code> (Linux), <code>libprql_lib.dylib</code> (macOS) or <code>libprql_lib.dll</code> (Windows) is in your project’s <code>bin</code> directory together with <code>PrqlCompiler.dll</code> and the rest of your project’s compiled files. I.e. <code>{your_project}/bin/Debug/net7.0/</code>.</p>
<p>The <code>libprql_lib</code> library gets dynamically imported at runtime.</p>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<pre><code class="language-csharp">using Prql.Compiler;

var options = new PrqlCompilerOptions
{
    Format = false,
    SignatureComment = false,
};
var sql = PrqlCompiler.Compile("from employees", options);
Console.WriteLine(sql);
</code></pre>
<h1 id="todo"><a class="header" href="#todo">TODO</a></h1>
<p>This is currently at 0.1.0 because we’re waiting to update prql-lib for the latest API. When we’ve done that, we can match the version here with the broader PRQL version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-124"><a class="header" href="#prql-124">PRQL</a></h1>
<p><a href="https://prql-lang.org/">PRQL</a> bindings for Elixir.</p>
<h2 id="安裝-1"><a class="header" href="#安裝-1">安裝</a></h2>
<pre><code class="language-elixir">def deps do
  [
    {:prql, "~&gt; 0.1.0"}
  ]
end
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><code class="language-elixir">  iex&gt; PRQL.compile("from customers")
      {:ok, "SELECT\n  *\nFROM\n  customers\n\n-- Generated by PRQL compiler version 0.3.1 (https://prql-lang.org)\n"}


  iex&gt; PRQL.compile("from customers\ntake 10", dialect: :mssql)
  {:ok, "SELECT\n  TOP (10) *\nFROM\n  customers\n\n-- Generated by PRQL compiler version 0.3.1 (https://prql-lang.org)\n"}
</code></pre>
<h2 id="開發"><a class="header" href="#開發">開發</a></h2>
<p>We are in the early stages of developing Elixir bindings.</p>
<p>We’re using <code>Rustler</code> to provide Rust bindings for <code>prql-compiler</code>.</p>
<p>Currently using the bindings in an Elixir project requires compiling the Rust crate from this repo:</p>
<ul>
<li>Install dependencies with <code>mix deps.get</code></li>
<li>Compile project <code>mix compile</code></li>
<li>Run tests <code>mix test</code></li>
</ul>
<p>Future work includes publishing pre-compiled artifacts, so Elixir projects can run PRQL without needing a Rust toolchain.</p>
<h2 id="mac"><a class="header" href="#mac">Mac</a></h2>
<p>We currently don’t enable compilation for Mac. This is possible to enable, but causes some issues with cargo’s compilation cache. Briefly: it requires <code>RUSTFLAGS</code> to be set, and because of <a href="https://github.com/rust-lang/cargo/issues/8716">https://github.com/rust-lang/cargo/issues/8716</a> &amp; <a href="https://github.com/rust-lang/cargo/issues/8899">https://github.com/rust-lang/cargo/issues/8899</a>, any compilation of a different target will bust the cache.</p>
<p>The possible future workarounds include:</p>
<ul>
<li>Passing <code>--target=aarch64-apple-darwin</code> to every cargo call, which is inconvenient and can be difficult in some situations; e.g. Rust Analyzer. This disables passing <code>RUSTFLAGS</code> (I’m actually unclear why <code>prql-elixir</code> builds successfully in that case…)</li>
<li>Directing other cargo calls to different paths, such as <code>/target-ra</code> for Rust Analyzer and <code>/target-book</code> for the book building. But one <code>cargo build</code> from the terminal without either the <code>target</code> or <code>target_dir</code> specified will bust the cache!</li>
<li>Never compiling for other targets. But our standard tests run for <code>--target=wasm32-unknown-unknown</code>, so this requires refraining from using them.</li>
<li>Removing <code>prql-elixir</code> from our workspace, so that <code>cargo</code> commands in the PRQL workspace don’t require rust flags. This would work well, but means we need separate test coverage for this crate, which adds some weight to the tests.</li>
</ul>
<p>If <code>prql-elixir</code> becomes more used (for example, we start publishing to Hex, or Mac developers want to work on it), then we can re-enable and deal with the caching issues. We can also re-enable them if the <code>cargo</code> issue is resolved.</p>
<p>To test on Mac temporarily — for example if there’s an error in GHA and we’re on a Mac locally — apply a diff like this, and then run <code>cargo build</code> from the <code>prql-elixir</code> path, which will enable the local <a href="https://github.com/PRQL/prql/blob/main/bindings/prql-elixir/native/prql/.cargo/config.toml"><code>.cargo/config.toml</code></a>). (We could also make a feature like <code>elixir-mac</code> which enabled building on Mac).</p>
<pre><code class="language-diff">diff --git a/bindings/prql-elixir/native/prql/Cargo.toml b/bindings/prql-elixir/native/prql/Cargo.toml
index 7194ca4f..9c7240ff 100644
--- a/bindings/prql-elixir/native/prql/Cargo.toml
+++ b/bindings/prql-elixir/native/prql/Cargo.toml
@@ -19,5 +19,5 @@ path = "src/lib.rs"
 prql-compiler = {path = "../../../../crates/prql-compiler", default-features = false, version = "0.6.1"}

 # See Readme for details on Mac
-[target.'cfg(not(any(target_family="wasm", target_os = "macos")))'.dependencies]
+# [target.'cfg(not(any(target_family="wasm", target_os = "macos")))'.dependencies]
 rustler = "0.27.0"
diff --git a/bindings/prql-elixir/native/prql/src/lib.rs b/bindings/prql-elixir/native/prql/src/lib.rs
index 2c5c8f27..68e77217 100644
--- a/bindings/prql-elixir/native/prql/src/lib.rs
+++ b/bindings/prql-elixir/native/prql/src/lib.rs
@@ -1,5 +1,5 @@
 // See Readme for more information on Mac compiling
-#![cfg(not(target_os = "macos"))]
+// #![cfg(not(target_os = "macos"))]
 // These bindings aren't relevant on wasm
 #![cfg(not(target_family = "wasm"))]
 // TODO: unclear why we need this `allow`; it's required in `CompileOptions`,

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-java"><a class="header" href="#prql-java">prql-java</a></h1>
<p><code>prql-java</code> offers Java bindings to the <code>prql-compiler</code> Rust library. It exposes a Java native method <code>public static native String toSql(String query)</code>.</p>
<p>It’s still at an early stage, and currently requires compiling locally, and isn’t published to Maven. Contributions are welcome.</p>
<h2 id="安裝-2"><a class="header" href="#安裝-2">安裝</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.prqllang&lt;/groupId&gt;
    &lt;artifactId&gt;prql-java&lt;/artifactId&gt;
    &lt;version&gt;${PRQL_VERSION}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="用法-1"><a class="header" href="#用法-1">用法</a></h2>
<pre><code class="language-java">import org.prqllang.prql4j.PrqlCompiler;

class Main {
    public static void main(String[] args) {
        String sql = PrqlCompiler.toSql("from table");
        System.out.println(sql);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-js"><a class="header" href="#prql-js">prql-js</a></h1>
<p>JavaScript bindings for <a href="https://github.com/PRQL/prql/"><code>prql-compiler</code></a>.</p>
<h2 id="安裝-3"><a class="header" href="#安裝-3">安裝</a></h2>
<pre><code class="language-sh">npm install prql-js
</code></pre>
<h2 id="用法-2"><a class="header" href="#用法-2">用法</a></h2>
<p>Currently these functions are exposed</p>
<pre><code class="language-typescript">function compile(prql_query: string, options?: CompileOptions): string;

function prql_to_pl(prql_query: string): string;

function pl_to_rq(pl_json: string): string;

function rq_to_sql(rq_json: string): string;
</code></pre>
<h3 id="from-nodejs"><a class="header" href="#from-nodejs">From Node.js</a></h3>
<p>Direct usage</p>
<pre><code class="language-javascript">const prqljs = require("prql-js");

const sql = prqljs.compile(`from employees | select first_name`);
console.log(sql);
</code></pre>
<p>選項</p>
<pre><code class="language-javascript">const opts = new prql.CompileOptions();
opts.target = "sql.mssql";
opts.format = false;
opts.signature_comment = false;

const sql = prqljs.compile(`from employees | take 10`, opts);
console.log(sql);
</code></pre>
<p>Template literal</p>
<pre><code class="language-javascript">const prqljs = require("prql-js");
const prql = (string) =&gt; prqljs.compile(string[0] || "");

const sql = prql`from employees | select first_name`;
console.log(sql);
</code></pre>
<p>Template literal with newlines</p>
<pre><code class="language-javascript">const prqljs = require("prql-js");
const prql = (string) =&gt; prqljs.compile(string[0] || "");

const sql = prql`
    from employees
    select first_name
`;
console.log(sql);
</code></pre>
<h3 id="from-a-browser"><a class="header" href="#from-a-browser">From a browser</a></h3>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;script src="./node_modules/prql-js/dist/web/prql_js.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      const { compile } = wasm_bindgen;

      async function run() {
        await wasm_bindgen("./node_modules/prql-js/dist/web/prql_js_bg.wasm");
        const sql = compile("from employees | select first_name");

        console.log(sql);
      }

      run();
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="from-a-framework-or-a-bundler"><a class="header" href="#from-a-framework-or-a-bundler">From a framework or a bundler</a></h3>
<pre><code class="language-typescript">import compile from "prql-js/dist/bundler";

const sql = compile(`from employees | select first_name`);
console.log(sql);
</code></pre>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<p>Errors are returned as following object, serialized as a JSON array:</p>
<pre><code class="language-typescript">interface ErrorMessage {
  /// Message kind. Currently only Error is implemented.
  kind: "Error" | "Warning" | "Lint";
  /// Machine-readable identifier of the error
  code: string | null;
  /// Plain text of the error
  reason: string;
  /// A list of suggestions of how to fix the error
  hint: string | null;
  /// Character offset of error origin within a source file
  span: [number, number] | null;

  /// Annotated code, containing cause and hints.
  display: string | null;
  /// Line and column number of error origin within a source file
  location: SourceLocation | null;
}

/// Location within the source file.
/// Tuples contain:
/// - line number (0-based),
/// - column number within that line (0-based),
interface SourceLocation {
  start: [number, number];

  end: [number, number];
}
</code></pre>
<p>These errors can be caught as such:</p>
<pre><code class="language-javascript">try {
  const sql = prqlJs.compile(`from employees | foo first_name`);
} catch (error) {
  const errorMessages = JSON.parse(error.message).inner;

  console.log(errorMessages[0].display);
  console.log(errorMessages[0].location);
}
</code></pre>
<h2 id="開發-1"><a class="header" href="#開發-1">開發</a></h2>
<p>Build:</p>
<pre><code class="language-sh">npm run build
</code></pre>
<p>This builds Node, bundler and web packages in the <code>dist</code> path.</p>
<p>測試：</p>
<pre><code class="language-sh">npm test
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>This uses <a href="https://rustwasm.github.io/docs/wasm-pack/"><code>wasm-pack</code></a> to generate bindings<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>.</li>
<li>We’ve added an <code>npm</code> layer on top of the usual approach of just using <code>wasm-pack</code>, so we can distribute a single package with targets of <code>node</code>, <code>bundler</code> and <code>no-modules</code> — somewhat inverting the approach recommended by <code>wasm-pack</code>. The build instruction goes in a <code>build</code> script, rather than a <code>pack</code> script.</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<pre><code>Though we would be very open to other approaches, given wasm-pack does not
seem maintained, and we're eliding many of its features to build for three
targets. See &lt;https://github.com/PRQL/prql/issues/1836&gt; for more details.
</code></pre>
 <a href="#fr-1-1">↩</a></li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="prql-php"><a class="header" href="#prql-php">prql-php</a></h1>
<p><code>prql-php</code> offers PHP bindings to <code>prql-compiler</code> crate through FFI.</p>
<p>It provides the <code>Compiler</code> class which contains <code>compile</code>, <code>prqlToPL</code>, <code>plToRQ</code> and <code>rqToSQL</code> functions.</p>
<p>It’s still at an early stage, and isn’t published to Composer. Contributions are welcome.</p>
<h2 id="安裝-4"><a class="header" href="#安裝-4">安裝</a></h2>
<p>The <a href="https://www.php.net/manual/en/book.ffi.php">PHP FFI extension</a> needs to be enabled. Set <code>ffi.enable</code> in your php.ini configuration file to <code>"true"</code>.</p>
<h2 id="用法-3"><a class="header" href="#用法-3">用法</a></h2>
<pre><code class="language-php">&lt;?php

use Prql\Compiler\Compiler;

$prql = new Compiler();
$result = $prql-&gt;compile("from employees");

echo $result-&gt;output;
</code></pre>
<h2 id="開發-2"><a class="header" href="#開發-2">開發</a></h2>
<h3 id="environment"><a class="header" href="#environment">Environment</a></h3>
<p>A way to establish a dev environment with PHP, the ext-ffi extension and Composer is to use a <a href="https://github.com/loophp/nix-shell">nix flake</a>. After installing nix, enable experimental flakes feature:</p>
<pre><code>mkdir -p ~/.config/nix
echo "experimental-features = nix-command flakes" &gt;&gt; ~/.config/nix/nix.conf
</code></pre>
<p>Now you can spawn a shell from <code>prql-php/</code>:</p>
<pre><code>nix shell github:loophp/nix-shell#env-php81 --impure
</code></pre>
<p>This will pull-in ext-ffi extension, because it’s declared in <code>composer.json</code>.</p>
<h3 id="building"><a class="header" href="#building">Building</a></h3>
<p>There is a <code>task build-php</code> script that:</p>
<ul>
<li>runs cargo to build <code>libprql_lib</code>,</li>
<li>copies <code>libprql_lib.*</code> into <code>lib</code>,</li>
<li>copies <code>libprql_lib.h</code> into <code>lib</code>.</li>
</ul>
<h3 id="tests"><a class="header" href="#tests">Tests</a></h3>
<pre><code>task build-php
task test-php
</code></pre>
<h3 id="code-style"><a class="header" href="#code-style">Code style</a></h3>
<pre><code>./vendor/bin/phpcs --standard=PSR12 src tests
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-python"><a class="header" href="#prql-python">prql-python</a></h1>
<p><code>prql-python</code> offers Rust bindings to the <code>prql-compiler</code> Rust library. It exposes a Python method <code>compile(query: str) -&gt; str</code>.</p>
<p>This is consumed by <a href="https://github.com/prql/pyprql">pyprql</a> &amp; <a href="https://github.com/prql/dbt-prql">dbt-prql</a>.</p>
<p>The crate is not published to crates.io; only to PyPI at https://pypi.org/project/prql-python/.</p>
<h2 id="安裝-5"><a class="header" href="#安裝-5">安裝</a></h2>
<p><code>pip install prql-python</code></p>
<h2 id="用法-4"><a class="header" href="#用法-4">用法</a></h2>
<pre><code class="language-python">import prql_python as prql

prql_query = """
    from employees
    join salaries (==emp_id)
    group {employees.dept_id, employees.gender} (
      aggregate {
        avg_salary = average salaries.salary
      }
    )
"""

options = prql.CompileOptions(
    format=True, signature_comment=True, target="sql.postgres"
)

sql = prql.compile(prql_query)
sql_postgres = prql.compile(prql_query, options)
</code></pre>
<p>Relies on <a href="https://github.com/PyO3/pyo3">pyo3</a> for all the magic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="r-prqlr"><a class="header" href="#r-prqlr">R (prqlr)</a></h1>
<p>R bindings for <code>prql-compiler</code>.</p>
<p><code>prqlr</code> also includes <code>knitr</code> (R Markdown and Quarto) integration, which allows us to easily create documents with the PRQL conversion results embedded in.</p>
<p>Check out <a href="https://eitsupi.github.io/prqlr/">https://eitsupi.github.io/prqlr/</a> for more context.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/bindings/r.html#admonition-note"></a>
</div>
<div>
<p><code>prqlr</code> is generously maintained by <a href="https://github.com/eitsupi">@eitsupi</a> in the <a href="https://github.com/eitsupi/prqlr">eitsupi/prqlr</a> repo.</p>
</div>
</div>
<h2 id="安裝-6"><a class="header" href="#安裝-6">安裝</a></h2>
<pre><code class="language-r">install.packages("prqlr")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Please check the documentation of the <a href="https://docs.rs/prql-compiler/latest/prql_compiler/">prql-compiler crate</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整合"><a class="header" href="#整合">整合</a></h1>
<p>PRQL is building integrations with lots of external tools, including:</p>
<ul>
<li><a href="project/integrations/./jupyter.html">Jupyter</a></li>
<li><a href="project/integrations/./clickhouse.html">ClickHouse</a></li>
<li><a href="project/integrations/./duckdb.html">DuckDB</a></li>
<li><a href="project/integrations/./prefect.html">Prefect</a></li>
<li><a href="project/integrations/./vscode.html">VS Code</a></li>
<li><a href="project/integrations/./rill.html">Rill</a></li>
</ul>
<p>We also have a CLI, <a href="project/integrations/./prqlc-cli.html"><code>prqlc</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-compiler-cli--prqlc"><a class="header" href="#prql-compiler-cli--prqlc">PRQL compiler CLI — <code>prqlc</code></a></h1>
<p><code>prqlc</code> 是 PRQL 編譯器的 CLI。它是一個無相依項的二進位檔，可以將 PRQL 編譯為 SQL。</p>
<h2 id="用法-5"><a class="header" href="#用法-5">用法</a></h2>
<h3 id="prqlc-compile"><a class="header" href="#prqlc-compile"><code>prqlc compile</code></a></h3>
<p>This command works as a filter that compiles a PRQL string into an SQL string.</p>
<pre><code class="language-sh">$ echo 'from employees | filter has_dog | select salary' | prqlc compile

SELECT
  salary
FROM
  employees
WHERE
  has_dog
</code></pre>
<p>A PRQL query can be executed with CLI tools compatible with SQL,, such as <a href="https://duckdb.org/docs/api/cli.html">DuckDB CLI</a>.</p>
<pre><code class="language-sh">$ curl -fsL https://raw.githubusercontent.com/PRQL/prql/0.8.1/prql-compiler/tests/integration/data/chinook/albums.csv -o albums.csv
$ echo 'from `albums.csv` | take 3' | prqlc compile | duckdb
┌──────────┬───────────────────────────────────────┬───────────┐
│ album_id │                 title                 │ artist_id │
│  int64   │                varchar                │   int64   │
├──────────┼───────────────────────────────────────┼───────────┤
│        1 │ For Those About To Rock We Salute You │         1 │
│        2 │ Balls to the Wall                     │         2 │
│        3 │ Restless and Wild                     │         2 │
└──────────┴───────────────────────────────────────┴───────────┘
</code></pre>
<p>Executing this command without any argument will start interactive mode, allowing a PRQL query to be written interactively. In this mode, after writing PRQL and press <code>Ctrl-d</code> (Linux, macOS) or <code>Ctrl-z</code> (Windows) to display the compiled SQL.</p>
<pre><code class="language-sh">prqlc compile
</code></pre>
<p>Just like when using it as a filter, SQL string output can be passed to the DuckDB CLI and similar tools.</p>
<pre><code class="language-sh">$ prqlc compile | duckdb
Enter PRQL, then press ctrl-d to compile:

from `albums.csv`
take 3
┌──────────┬───────────────────────────────────────┬───────────┐
│ album_id │                 title                 │ artist_id │
│  int64   │                varchar                │   int64   │
├──────────┼───────────────────────────────────────┼───────────┤
│        1 │ For Those About To Rock We Salute You │         1 │
│        2 │ Balls to the Wall                     │         2 │
│        3 │ Restless and Wild                     │         2 │
└──────────┴───────────────────────────────────────┴───────────┘
</code></pre>
<h2 id="安裝-7"><a class="header" href="#安裝-7">安裝</a></h2>
<p><a href="https://repology.org/project/prqlc/versions"><img src="https://repology.org/badge/vertical-allrepos/prqlc.svg" alt="Packaging status" /></a></p>
<h3 id="via-homebrew-macos-linux"><a class="header" href="#via-homebrew-macos-linux">via Homebrew (macOS, Linux)</a></h3>
<pre><code class="language-sh">brew install prqlc
</code></pre>
<h3 id="via-winget-windows"><a class="header" href="#via-winget-windows">via winget (Windows)</a></h3>
<pre><code class="language-sh">winget install prqlc
</code></pre>
<h3 id="from-github-release-page"><a class="header" href="#from-github-release-page">From GitHub release page</a></h3>
<p>Precompiled binaries are available for Linux, macOS, and Windows on the <a href="https://github.com/PRQL/prql/releases">PRQL release page</a>.</p>
<h3 id="from-source"><a class="header" href="#from-source">From source</a></h3>
<pre><code class="language-sh"># From crates.io
cargo install prqlc
</code></pre>
<pre><code class="language-sh"># From a local PRQL repository
cargo install --path crates/prqlc
</code></pre>
<h3 id="shell-completions"><a class="header" href="#shell-completions">Shell completions</a></h3>
<p>The <code>prqlc shell-completion</code> command prints a shell completion script for supported shells, and saving the printed scripts to files makes for shells to load completions for each session.</p>
<h4 id="bash"><a class="header" href="#bash">Bash</a></h4>
<p>For Linux:</p>
<pre><code class="language-sh">prqlc shell-completion bash &gt;/etc/bash_completion.d/prqlc
</code></pre>
<p>For macOS:</p>
<pre><code class="language-sh">prqlc shell-completion bash &gt;/usr/local/etc/bash_completion.d/prqlc
</code></pre>
<h4 id="fish"><a class="header" href="#fish">fish</a></h4>
<pre><code class="language-sh">prqlc shell-completion fish &gt;~/.config/fish/completions/prqlc.fish
</code></pre>
<h4 id="powershell"><a class="header" href="#powershell">PowerShell</a></h4>
<pre><code class="language-powershell">mkdir -Path (Split-Path -Parent $profile) -ErrorAction SilentlyContinue
prqlc shell-completion powershell &gt;path/to/prqlc.ps1
echo 'Invoke-Expression -Command path/to/prqlc.ps1' &gt;&gt;$profile
</code></pre>
<h4 id="zsh"><a class="header" href="#zsh">zsh</a></h4>
<pre><code class="language-sh">prqlc shell-completion zsh &gt;"${fpath[1]}/_prqlc"
</code></pre>
<p>Ensure that the following lines are present in <code>~/.zshrc</code>:</p>
<pre><code class="language-sh">autoload -U compinit
compinit -i
</code></pre>
<h2 id="helpers"><a class="header" href="#helpers">Helpers</a></h2>
<p>Cheat sheets for <code>prqlc</code> are available on various websites and with various tools.</p>
<ul>
<li><a href="https://tldr.sh/"><code>tldr</code></a> (<a href="https://tldr.inbrowser.app/pages/common/prqlc">on the web</a>)</li>
<li><a href="https://github.com/srsudar/eg"><code>eg</code></a></li>
</ul>
<!-- Issues: #2034 cheat/cheatsheets, #2041 devhints.io -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="clickhouse"><a class="header" href="#clickhouse">ClickHouse</a></h1>
<p>PRQL works natively in ClickHouse. Check out the <a href="https://clickhouse.com/docs/en/guides/developer/alternative-query-languages">ClickHouse docs</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jupyter"><a class="header" href="#jupyter">Jupyter</a></h1>
<p><a href="https://pypi.org/project/pyprql/">pyprql</a> contains <code>pyprql.magic</code>, a thin wrapper of <a href="https://pypi.org/project/jupysql/"><code>JupySQL</code></a>’s SQL IPython magics. This allows us to run PRQL interactively on Jupyter/IPython.</p>
<p>Check out <a href="https://pyprql.readthedocs.io/">https://pyprql.readthedocs.io/</a> for more context.</p>
<h2 id="安裝-8"><a class="header" href="#安裝-8">安裝</a></h2>
<pre><code class="language-sh">pip install pyprql
</code></pre>
<h2 id="用法-6"><a class="header" href="#用法-6">用法</a></h2>
<p>When installing pyprql, the <a href="https://pypi.org/project/duckdb-engine/">duckdb-engine</a> package is also installed with it, so we can start using PRQL immediately to query CSV and Parquet files.</p>
<p>For example, running <a href="https://jupysql.ploomber.io/en/latest/quick-start.html">the example from the JupySQL documentation</a> on IPython:</p>
<pre><code class="language-python">In [1]: %load_ext pyprql.magic

In [2]: !curl -sL https://raw.githubusercontent.com/mwaskom/seaborn-data/master/penguins.csv -o penguins.csv

In [3]: %prql duckdb://

In [4]: %prql from `penguins.csv` | take 3
Out[4]:
  species     island  bill_length_mm  bill_depth_mm  flipper_length_mm  body_mass_g     sex
0  Adelie  Torgersen            39.1           18.7                181         3750    MALE
1  Adelie  Torgersen            39.5           17.4                186         3800  FEMALE
2  Adelie  Torgersen            40.3           18.0                195         3250  FEMALE

In [5]: %%prql
   ...: from `penguins.csv`
   ...: filter bill_length_mm &gt; 40
   ...: take 3
   ...:
   ...:
Out[5]:
  species     island  bill_length_mm  bill_depth_mm  flipper_length_mm  body_mass_g     sex
0  Adelie  Torgersen            40.3           18.0                195         3250  FEMALE
1  Adelie  Torgersen            42.0           20.2                190         4250    None
2  Adelie  Torgersen            41.1           17.6                182         3200  FEMALE
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="duckdb"><a class="header" href="#duckdb">DuckDB</a></h1>
<p>There’s an experimental <a href="https://duckdb.org/">DuckDB</a> extension from <strong><a href="https://github.com/ywelsch">@ywelsch</a></strong> at <a href="https://github.com/ywelsch/duckdb-prql">ywelsch/duckdb-prql</a>.</p>
<p>Check out the Readme for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefect"><a class="header" href="#prefect">Prefect</a></h1>
<p>Because <a href="https://www.prefect.io/">Prefect</a> is in native Python, it’s extremely easy to integrate with PRQL.</p>
<p>With a Postgres Task, replace:</p>
<pre><code class="language-python">PostgresExecute.run(..., query=sql)
</code></pre>
<p>…with…</p>
<pre><code class="language-python">PostgresExecute.run(..., query=prql_python.compile(prql))
</code></pre>
<p>We’re big fans of Prefect, and if there is anything that would make the integration easier, please open an issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-code-extension"><a class="header" href="#visual-studio-code-extension">Visual Studio Code extension</a></h1>
<p>PRQL has a Visual Studio Code extension that compiles a PRQL query in a VS Code editor and displays the resulting SQL code in a second pane on the side. This is very handy for editing, saving, and reusing PRQL queries in VS Code.</p>
<p>To install the VS Code extension, open VS Code and type <kbd>Ctrl</kbd>-<kbd>Shift</kbd>-<kbd>P</kbd> (<kbd>Cmd</kbd>-<kbd>Shift</kbd>-<kbd>P</kbd> on a Mac) and type <code>PRQL</code>. Install the extension as usual.</p>
<p><a href="https://github.com/PRQL/prql-vscode">Repo for the PRQL VS Code extension</a></p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=PRQL-lang.prql-vscode">Extension on VS Marketplace</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rill"><a class="header" href="#rill">Rill</a></h1>
<p>PRQL has had some work to integrate with Rill. See the <a href="https://github.com/PRQL/prql/issues?q=is%3Aissue+rill">Rill ssues</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文法語法標明"><a class="header" href="#文法語法標明">文法/語法標明</a></h1>
<p>PRQL contains multiple grammar definitions to enable tools to highlight PRQL code. These are all intended to provide as good an experience as the grammar supports. Please raise any shortcomings in a GitHub issue.</p>
<p>The definitions are somewhat scattered around the codebase; this page serves as an index.</p>
<ul>
<li>
<p><a href="https://ace.c9.io/">Ace</a> — supported. The grammar is upstream (<a href="https://github.com/ajaxorg/ace/blob/master/src/mode/prql_highlight_rules.js">prql_highlight_rules.js</a>). See the <a href="https://prql-lang.org/demos/ace-demo">demo</a>.</p>
</li>
<li>
<p><a href="https://lezer.codemirror.net/">Lezer</a> — used by CodeMirror editors. The PRQL file is at <a href="https://github.com/PRQL/prql/tree/main/grammars/prql-lezer/README.md"><code>grammars/prql-lezer/README.md</code></a>.</p>
</li>
<li>
<p><a href="https://handlebarsjs.com/">Handlebars</a> — currently duplicated:</p>
<ul>
<li>The book: <a href="https://github.com/PRQL/prql/blob/main/web/book/highlight-prql.js"><code>book/highlight-prql.js</code></a></li>
<li>The website (outside of the book &amp; playground): <a href="https://github.com/PRQL/prql/blob/main/web/book/highlight-prql.js"><code>website/themes/prql-theme/static/plugins/highlight/prql.js</code></a></li>
</ul>
</li>
<li>
<p><a href="https://macromates.com/manual/en/language_grammars">Textmate</a> — used by the VS Code extension. It’s in the <code>prql-vscode</code> repo in <a href="https://github.com/PRQL/prql-vscode/blob/main/syntaxes/prql.tmLanguage.json"><code>prql-vscode/syntaxes/prql.tmLanguage.json</code></a>.</p>
</li>
<li>
<p><a href="https://microsoft.github.io/monaco-editor/monarch.html">Monarch</a> — used by the Monaco editor, which we use for the Playground. The grammar is at <a href="https://github.com/PRQL/prql/blob/main/web/playground/src/workbench/prql-syntax.js"><code>playground/src/workbench/prql-syntax.js</code></a>.</p>
</li>
<li>
<p><a href="https://tree-sitter.github.io/tree-sitter">Tree-Sitter</a> — used by the neovim and helix. The grammar can be found at <a href="https://github.com/PRQL/tree-sitter-prql">https://github.com/PRQL/tree-sitter-prql</a>.</p>
</li>
</ul>
<hr />
<p>Since the <a href="https://elm-lang.org/">Elm</a> language coincidentally provides syntax highlighting suitable for PRQL, it may look better to mark PRQL code as Elm when the above definition files are not available.</p>
<p>For example, the following Markdown code block will be nicely highlighted on GitHub, Pandoc, and other Markdown renderers:</p>
<pre><code class="language-markdown">```elm
from employees
filter start_date &gt; @2021-01-01
```
</code></pre>
<p>We hope that in the future these renderers will recognize PRQL code blocks and have syntax highlighting applied, and we are tracking these with several issues.</p>
<ul>
<li>GitHub (Linguist): <a href="https://github.com/PRQL/prql/issues/1636">https://github.com/PRQL/prql/issues/1636</a></li>
<li>Pandoc (Kate): <a href="https://github.com/PRQL/prql/issues/2213">https://github.com/PRQL/prql/issues/2213</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>If you’re interested in joining the community to build a better SQL, here are ways to start:</p>
<ul>
<li>星標收藏<a href="https://github.com/PRQL/prql">儲存庫</a>。</li>
<li>Send a link to PRQL to a couple of people whose opinion you respect.</li>
<li>Subscribe to <a href="https://www.jessesquires.com/blog/2020/07/30/github-tip-watching-releases/">new releases</a> for updates.</li>
<li>在 <a href="https://twitter.com/prql_lang">Twitter</a> 上關注我們。</li>
<li>加入我們的 <a href="https://discord.gg/eQcfaCmsNc">Discord</a>。</li>
<li>Find an issue labeled <a href="https://github.com/prql/prql/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">Good First Issue</a> and start contributing to the code.</li>
<li>Join our <a href="https://github.com/PRQL/prql/issues/1083">fortnightly Developer Call</a>; (<a href="project/contributing/./fortnightly-dev-call.ics">iCal file</a>).</li>
</ul>
<p>PRQL is evolving from a project with lots of excitement into a project that folks are using in their work and integrating into their tools. We’re actively looking for collaborators to lead that growth with us.</p>
<h2 id="areas-for-larger-contributions"><a class="header" href="#areas-for-larger-contributions">Areas for larger contributions</a></h2>
<h3 id="編譯器"><a class="header" href="#編譯器">編譯器</a></h3>
<p>The compiler is written in Rust, and there’s enough to do such that any level of experience with Rust is sufficient.</p>
<p>We try to keep a few onboarding issues on hand under the <a href="https://github.com/PRQL/prql/labels/good%20first%20issue">“good first issue” label</a>. These have been screened to have sufficient context to get started (and we very much welcome questions where there’s some context missing).</p>
<p>To get started, check out the docs on <a href="project/contributing/./development.html">Development</a> and the <a href="https://github.com/PRQL/prql/blob/main/crates/prql-compiler/ARCHITECTURE.md">Compiler architecture</a></p>
<p>And if you have questions, there are lots of friendly people on the Discord who will patiently help you.</p>
<h3 id="bindings--integrations"><a class="header" href="#bindings--integrations">Bindings &amp; integrations</a></h3>
<p>For PRQL to be successful, it needs to be available for the languages &amp; tools that people already use.</p>
<ul>
<li>We currently have bindings to the PRQL compiler in a few different languages; many of these can be improved, documented, and packaged in a better way.</li>
<li>If you have experience with packaging in an ecosystem that doesn’t currently have bindings, then creating PRQL bindings for that language we don’t currently support would be valuable to the project.</li>
<li>If there’s a tool that you use yourself to run data queries which you think would benefit from a PRQL integration, suggest one to us or the tool. If it’s open-source, build &amp; share a prototype.</li>
</ul>
<p>Relevant issues are labeled <a href="https://github.com/PRQL/prql/labels/integrations">Integrations</a>.</p>
<h3 id="語言設計"><a class="header" href="#語言設計">語言設計</a></h3>
<p>We decide on new language features in GitHub issues, usually under <a href="https://github.com/PRQL/prql/issues?q=is%3Aopen+label%3Alanguage-design+sort%3Aupdated-desc">“language design” label</a>.</p>
<p>You can also contribute by:</p>
<ul>
<li>Finding instances where the compiler produces incorrect results, and post a bug report — feel free to use the <a href="https://prql-lang.org/playground">playground</a>.</li>
<li>Opening an issue / append to an existing issue with examples of queries that are difficult to express in PRQL — especially if more difficult than SQL.</li>
</ul>
<p>提供充足的範例來建議語言變更！（由於沒有範例的建議很難進行討論，因此請務必將建議建立在具體範例之上。）</p>
<h3 id="marketing"><a class="header" href="#marketing">Marketing</a></h3>
<ul>
<li>Improve our website. We have <a href="https://github.com/PRQL/prql/labels/web">a few issues open</a> on this front and are looking for anyone with at least some design skills.</li>
<li>Contribute towards the docs. Anything from shaping a whole section of the docs, to simply improving a confusing paragraph or fixing a typo.</li>
<li>Tell people about PRQL.</li>
<li>Find a group of users who would be interested in PRQL, help them get up to speed, help the project understand what they need.</li>
</ul>
<h2 id="核心團隊"><a class="header" href="#核心團隊">核心團隊</a></h2>
<p>If you have any questions or feedback and don’t receive a response on one of the general channels such as GitHub or Discord, feel free to reach out to:</p>
<ul>
<li><a href="https://github.com/aljazerzen"><strong>@aljazerzen</strong></a> — Aljaž Mur Eržen</li>
<li><a href="https://github.com/max-sixty"><strong>@max-sixty</strong></a> — Maximilian Roos</li>
<li><a href="https://github.com/eitsupi"><strong>@eitsupi</strong></a> — SHIMA Tatsuya</li>
<li><a href="https://github.com/snth"><strong>@snth</strong></a> — Tobias Brandt</li>
</ul>
<h3 id="核心團隊榮譽成員"><a class="header" href="#核心團隊榮譽成員">核心團隊榮譽成員</a></h3>
<p>Thank you to those who have previously served on the core team:</p>
<ul>
<li><a href="https://github.com/charlie-sanders"><strong>@charlie-sanders</strong></a> — Charlie Sanders</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="開發-3"><a class="header" href="#開發-3">開發</a></h1>
<h2 id="setting-up-an-initial-dev-environment"><a class="header" href="#setting-up-an-initial-dev-environment">Setting up an initial dev environment</a></h2>
<p>We can set up a local development environment sufficient for navigating, editing, and testing PRQL’s compiler code in two minutes:</p>
<ul>
<li>
<p>Install <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html"><code>rustup</code> &amp; <code>cargo</code></a>.</p>
</li>
<li>
<p>[Optional but highly recommended] Install <code>cargo-insta</code>, our testing framework:</p>
<pre><code class="language-sh">cargo install cargo-insta
</code></pre>
</li>
<li>
<p>That’s it! Running the unit tests for the <code>prql-compiler</code> crate after cloning the repo should complete successfully:</p>
<pre><code class="language-sh">cargo test -p prql-compiler --lib
</code></pre>
<p>…or, to run tests and update the test snapshots:</p>
<pre><code class="language-sh">cargo insta test --accept -p prql-compiler --lib
</code></pre>
<p>There’s more context on our tests in <a href="project/contributing/development.html#how-we-test">How we test</a> below.</p>
</li>
</ul>
<p>That’s sufficient for making an initial contribution to the compiler.</p>
<hr />
<h2 id="setting-up-a-full-dev-environment"><a class="header" href="#setting-up-a-full-dev-environment">Setting up a full dev environment</a></h2>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-info"></a>
</div>
<div>
<p>We really care about this process being easy, both because the project benefits from more contributors like you, and to reciprocate your future contribution. If something isn’t easy, please let us know in a GitHub Issue. We’ll enthusiastically help you, and use your feedback to improve the scripts &amp; instructions.</p>
</div>
</div>
<p>For more advanced development; for example compiling for wasm or previewing the website, we have two options:</p>
<h3 id="option-1-use-the-projects-task"><a class="header" href="#option-1-use-the-projects-task">Option 1: Use the project’s <code>task</code></a></h3>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-note"></a>
</div>
<div>
<p>This is tested on macOS, should work on amd64 Linux, but won’t work on others (include Windows), since it relies on <code>brew</code>.</p>
</div>
</div>
<ul>
<li>
<p><a href="https://taskfile.dev/installation/">Install Task</a>.</p>
</li>
<li>
<p>Then run the <code>setup-dev</code> task. This runs commands from our <a href="https://github.com/PRQL/prql/blob/main/Taskfile.yml">Taskfile.yml</a>, installing dependencies with <code>cargo</code>, <code>brew</code>, <code>npm</code> &amp; <code>pip</code>, and suggests some VS Code extensions.</p>
<pre><code class="language-sh">task setup-dev
</code></pre>
</li>
</ul>
<h3 id="option-2-install-tools-individually"><a class="header" href="#option-2-install-tools-individually">Option 2: Install tools individually</a></h3>
<ul>
<li>
<p>We’ll need <code>cargo-insta</code>, to update snapshot tests:</p>
<pre><code class="language-sh">cargo install cargo-insta
</code></pre>
</li>
<li>
<p>We’ll need Python, which most systems will have already. The easiest way to check is to try running the full tests:</p>
<pre><code class="language-sh">cargo test
</code></pre>
<p>…and if that doesn’t complete successfully, ensure we have Python &gt;= 3.7, to compile <code>prql-python</code>.</p>
</li>
<li>
<p>For more involved contributions, such as building the website, playground, book, or some release artifacts, we’ll need some additional tools. But we won’t need those immediately, and the error messages on what’s missing should be clear when we attempt those things. When we hit them, the <a href="https://github.com/PRQL/prql/blob/main/Taskfile.yml">Taskfile.yml</a> will be a good source to copy &amp; paste instructions from.</p>
</li>
</ul>
<h3 id="option-3-use-a-dev-container"><a class="header" href="#option-3-use-a-dev-container">Option 3: Use a <a href="https://containers.dev/">Dev Container</a></a></h3>
<p>This project has a <a href="https://github.com/PRQL/prql/blob/main/.devcontainer/devcontainer.json">devcontainer.json file</a> and a <a href="https://github.com/PRQL/prql/pkgs/container/prql-devcontainer-base">pre-built dev container base Docker image</a>.</p>
<p>Currently, the tools for Rust are already installed in the pre-built image, and, Node.js, Python and others are configured to be installed when build the container.</p>
<p>While there are a variety of tools that support Dev Containers, the focus here is on developing with VS Code in a container by <a href="https://docs.github.com/en/codespaces/overview">GitHub Codespaces</a> or <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers">VS Code Dev Containers extension</a>.</p>
<p>To use a Dev Container on a local computer with VS Code, install the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers">VS Code Dev Containers extension</a> and its system requirements. Then refer to the links above to get started.</p>
<hr />
<h2 id="contribution-workflow"><a class="header" href="#contribution-workflow">Contribution workflow</a></h2>
<p>We’re similar to most projects on GitHub — open a Pull Request with a suggested change!</p>
<h3 id="commits"><a class="header" href="#commits">Commits</a></h3>
<ul>
<li>If a change is user-facing, please add a line in <a href="https://github.com/PRQL/prql/blob/main/CHANGELOG.md"><strong><code>CHANGELOG.md</code></strong></a>, with <code>{message}, ({@contributor, #X})</code> where <code>X</code> is the PR number.
<ul>
<li>If there’s a missing entry, a follow-up PR containing just the changelog entry is welcome.</li>
</ul>
</li>
<li>We’re using <a href="https://www.conventionalcommits.org">Conventional Commits</a> message format, enforced through <a href="https://github.com/amannn/action-semantic-pull-request">action-semantic-pull-request</a>.</li>
</ul>
<h3 id="merges"><a class="header" href="#merges">Merges</a></h3>
<ul>
<li><strong>We merge any code that makes PRQL better</strong></li>
<li>A PR doesn’t need to be perfect to be merged; it doesn’t need to solve a big problem. It needs to:
<ul>
<li>be in the right direction,</li>
<li>make incremental progress,</li>
<li>be explicit on its current state, so others can continue the progress.</li>
</ul>
</li>
<li>That said, there are a few instances when we need to ensure we have some consensus before merging code — for example non-trivial changes to the language, or large refactorings to the library.</li>
<li>If you have merge permissions, and are reasonably confident that a PR is suitable to merge (whether or not you’re the author), feel free to merge.
<ul>
<li>If you don’t have merge permissions and have authored a few PRs, ask and ye shall receive.</li>
</ul>
</li>
<li>The primary way we ratchet the code quality is through automated tests.
<ul>
<li>This means PRs almost always need a test to demonstrate incremental progress.</li>
<li>If a change breaks functionality without breaking tests, our tests were probably insufficient.</li>
<li>If a change breaks existing tests (for example, changing an external API), that indicates we should be careful about merging a change, including soliciting others’ views.</li>
</ul>
</li>
<li>We use PR reviews to give general context, offer specific assistance, and collaborate on larger decisions.
<ul>
<li>Reviews around ‘nits’ like code formatting / idioms / etc are very welcome. But the norm is for them to be received as helpful advice, rather than as mandatory tasks to complete. Adding automated tests &amp; lints to automate these suggestions is welcome.</li>
<li>If you have merge permissions and would like a PR to be reviewed before it merges, that’s great — ask or assign a reviewer.</li>
<li>If a PR hasn’t received attention after a day, please feel free to ping the pull request.</li>
</ul>
</li>
<li>People may review a PR after it’s merged. As part of the understanding that we can merge quickly, contributors are expected to incorporate substantive feedback into a future PR.</li>
<li>We should revert quickly if the impact of a PR turns out not to be consistent with our expectations, or there isn’t as much consensus on a decision as we had hoped. It’s very easy to revert code and then re-revert when we’ve resolved the issue; it’s a sign of moving quickly. Other options which resolve issues immediately are also fine, such as commenting out an incorrect test or adding a quick fix for the underlying issue.</li>
</ul>
<h2 id="docs"><a class="header" href="#docs">Docs</a></h2>
<p>We’re very keen on contributions to improve our documentation.</p>
<p>This includes our docs in the book, on the website, in our code, or in a Readme. We also appreciate issues pointing out that our documentation was confusing, incorrect, or stale — if it’s confusing for you, it’s probably confusing for others.</p>
<p>Some principles for ensuring our docs remain maintainable:</p>
<ul>
<li>Docs should be as close as possible to the code. Doctests are ideal on this dimension — they’re literally very close to the code and they can’t drift apart since they’re tested on every commit. Or, for example, it’s better to add text to a <code>--help</code> message, rather than write a paragraph in the Readme explaining the CLI.</li>
<li>We should have some visualization of how to maintain docs when we add them. Docs have a habit of falling out of date — the folks reading them are often different from those writing them, they’re sparse from the code, generally not possible to test, and are rarely the by-product of other contributions. Docs that are concise &amp; specific are easier to maintain.</li>
<li>Docs should be specifically relevant to PRQL; anything else we can instead link to.</li>
</ul>
<p>If something doesn’t fit into one of these categories, there are still lots of ways of getting the word out there — a blog post / gist / etc. Let us know and we’re happy to link to it / tweet it.</p>
<h2 id="how-we-test"><a class="header" href="#how-we-test">How we test</a></h2>
<p>We use a pyramid of tests — we have fast, focused tests at the bottom of the pyramid, which give us low latency feedback when developing, and then slower, broader tests which ensure that we don’t miss anything as PRQL develops<sup><a name="to-footnote-1"><a href="project/contributing/development.html#footnote-1">1</a></a></sup>.</p>
<!-- markdownlint-disable MD053 -->
<div id="admonition-info-1" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-1-title">
<div class="admonition-title">
<div id="admonition-info-1-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-info-1"></a>
</div>
<div>
<p>If you’re making your first contribution, you don’t need to engage with all this — it’s fine to just make a change and push the results; the tests that run in GitHub will point you towards any errors, which can be then be run locally if needed. We’re always around to help out.</p>
</div>
</div>
<p>Our tests, from the bottom of the pyramid to the top:</p>
<ul>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/main/.pre-commit-config.yaml">Static checks</a></strong> — we run a few static checks to ensure the code stays healthy and consistent. They’re defined in <a href="https://github.com/PRQL/prql/blob/main/.pre-commit-config.yaml"><strong><code>.pre-commit-config.yaml</code></strong></a>, using <a href="https://pre-commit.com">pre-commit</a>. They can be run locally with</p>
<pre><code class="language-sh">task test-lint
# or
pre-commit run -a
</code></pre>
<p>The tests fix most of the issues they find themselves. Most of them also run on GitHub on every commit; any changes they make are added onto the branch automatically in an additional commit.</p>
<ul>
<li>Checking by <a href="https://megalinter.io/latest/">MegaLinter</a>, which includes more Linters, is also done automatically on GitHub. (experimental)</li>
</ul>
</li>
<li>
<p><strong>Unit tests &amp; inline insta snapshots</strong> — we rely on unit tests to rapidly check that our code basically works. We extensively use <a href="https://insta.rs/">Insta</a>, a snapshot testing tool which writes out the values generated by our code, making it fast &amp; simple to write and modify tests<sup><a name="to-footnote-2"><a href="project/contributing/development.html#footnote-2">2</a></a></sup></p>
<p>These are the fastest tests which run our code; they’re designed to run on every save while you’re developing. We include a <code>task</code> which does this:</p>
<pre><code class="language-sh">task test-rust-fast
# or
cargo insta test --accept -p prql-compiler --lib
# or, to run on every change:
task -w test-rust-fast
</code></pre>
</li>
</ul>
<!--
This is the previous doc. It has the advantage that it explains what it's doing, and is
easy to change (e.g. to run all packages). But because of
https://github.com/watchexec/watchexec/issues/371, the ignore behavior is unfortunately quite
inconsistent in watchexec. Let's revert back if it gets solved.

[^2]: For example, this is a command I frequently run:

    ```sh
    RUST_BACKTRACE=1 watchexec -e rs,toml,md -cr --ignore='target/**' -- cargo -q insta test --accept -p prql-compiler --lib
    ```

    Breaking this down:

    - `RUST_BACKTRACE=1` will print a full backtrace, including where an error
      value was created, for Rust tests which return `Result`s.
    - `watchexec -e rs,toml,md -cr --ignore='target/**' --` will run the
      subsequent command on any change to files with extensions which we are
      generally editing.
    - `cargo insta test --accept --` runs tests with `insta`, a snapshot
      library, and writes any results immediately. I rely on git to track
      changes, so I run with `--accept`, but YMMV.
    - `-p prql-compiler --lib` is passed to cargo by `insta`; `-p prql-compiler`
      tells it to only run the tests for `prql-compiler` rather than the other
      crates, and `--lib` to only run the unit tests rather than the integration
      tests, which are slower.
    - Note that we don't want to re-run on _any_ file changing, because we can
      get into a loop of writing snapshot files, triggering a change, writing a
      snapshot file, etc. -->
<ul>
<li>
<p><strong><a href="https://github.com/PRQL/prql/tree/main/web/book/tests/documentation">Documentation</a></strong> — we compile all examples from our documentation in the Website, README, and PRQL Book, to test that they produce the SQL we expect, and that changes to our code don’t cause any unexpected regressions. These are included in:</p>
<pre><code class="language-sh">cargo insta test --accept
</code></pre>
</li>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/main/crates/prql-compiler/tests/integration">Integration tests</a></strong> — we run tests with example queries against databases with actual data to ensure we’re producing correct SQL across our supported dialects. The in-process tests can be run locally with:</p>
<pre><code class="language-sh">task test-rust
# or
cargo insta test --accept --features=test-dbs
</code></pre>
<p>More details on running with external databases are in the <a href="https://github.com/PRQL/prql/tree/main/crates/prql-compiler/tests/integration">Readme</a>.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
</li>
</ul>
<p>Note</p>
  </div>
  <a class="admonition-anchor-link" href="project/contributing/development.html#admonition-note-1"></a>
  </div>
  <div>
<p>Integration tests use DuckDB, and so require a clang compiler to compile <a href="https://github.com/wangfenjin/duckdb-rs"><code>duckdb-rs</code></a>. Most development systems will have one, but the test command fails, install it with:</p>
<ul>
<li>
<p>On macOS, install xcode with <code>xcode-select --install</code></p>
</li>
<li>
<p>On Debian Linux, <code>apt-get update &amp;&amp; apt-get install clang</code></p>
</li>
<li>
<p>On Windows, <code>duckdb-rs</code> isn’t supported, so these tests are excluded</p>
</div>
</div>
</li>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/main/.github/workflows/tests.yaml">GitHub Actions on every commit</a></strong> — we run tests relevant to a PR’s changes in CI — for example changes to docs will attempt to build docs, changes to a binding will run that binding’s tests. The vast majority of changes trigger tests which run in less than five minutes, and we should be reassessing their scope if they take longer than that. Once these pass, a pull request can be merged.</p>
</li>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/c042eef48709e2c1af577161554fd09f14e67e0f/.github/workflows/pull-request.yaml#L124">GitHub Actions on merge</a></strong> — we run a wider set tests on every merge to main. This includes testing across OSs, all our language bindings, a measure of test code coverage, and some performance benchmarks.</p>
<p>If these tests fail after merging, we should revert the commit before fixing the test and then re-reverting.</p>
<p>Most of these will run locally with:</p>
<pre><code class="language-sh">task test-all
</code></pre>
</li>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/main/.github/workflows/nightly.yaml">GitHub Actions nightly</a></strong> — every night, we run tests that take longer, are less likely to fail, or are unrelated to code changes — such as security checks, bindings’ tests on multiple OSs, or expensive timing benchmarks.</p>
<p>We can run these tests before a merge by adding a label <code>pr-nightly</code> to the PR.</p>
</li>
</ul>
<p>The goal of our tests is to allow us to make changes quickly. If you find they’re making it more difficult for you to make changes, or there are missing tests that would give you the confidence to make changes faster, then please raise an issue.</p>
<hr />
<h2 id="網站"><a class="header" href="#網站">網站</a></h2>
<p>The website is published together with the book and the playground, and is automatically built and released on any push to the <code>web</code> branch.</p>
<p>The <code>web</code> branch points to the latest release plus any website-specific fixes. That way, the compiler behavior in the playground matches the latest release while allowing us to fix mistakes in the docs with a tighter loop than every release.</p>
<p>Fixes to the playground, book, or website should have a <code>pr-backport-web</code> label added to their PR — a bot will then open &amp; merge another PR onto the <code>web</code> branch once the initial branch merges.</p>
<p>The website components will run locally with:</p>
<pre><code class="language-sh"># Run the main website
task run-website
# Run the PRQL online book
task run-book
# Run the PRQL playground
task run-playground
</code></pre>
<hr />
<h2 id="releasing"><a class="header" href="#releasing">Releasing</a></h2>
<p>Currently we release in a semi-automated way:</p>
<ol>
<li>
<p>PR &amp; merge an updated <a href="https://github.com/PRQL/prql/blob/main/CHANGELOG.md">Changelog</a>. GitHub will produce a draft version at <a href="https://github.com/PRQL/prql/releases/new">https://github.com/PRQL/prql/releases/new</a>, including “New Contributors”.</p>
<p>We can use this script to generate the first line:</p>
<pre><code class="language-sh">echo "This release has $(git rev-list --count $(git rev-list --tags --max-count=1)..) commits from $(git shortlog --summary $(git rev-list --tags --max-count=1).. | wc -l | tr -d '[:space:]') contributors. Selected changes:"
</code></pre>
</li>
<li>
<p>If the current version is correct, then skip ahead. But if the version needs to be changed — for example, we had planned on a patch release, but instead require a minor release — then run <code>cargo release version $version -x &amp;&amp; cargo release replace -x</code> to bump the version and PR the resulting commit.</p>
</li>
<li>
<p>After merging, go to <a href="https://github.com/PRQL/prql/releases/new">Draft a new release</a><sup><a name="to-footnote-3"><a href="project/contributing/development.html#footnote-3">3</a></a></sup>, copy the changelog entry into the release description<sup><a name="to-footnote-4"><a href="project/contributing/development.html#footnote-4">4</a></a></sup>, enter the tag to be created, and hit “Publish”.</p>
</li>
<li>
<p>From there, both the tag and release is created and all packages are published automatically based on our <a href="https://github.com/PRQL/prql/blob/main/.github/workflows/release.yaml">release workflow</a>.</p>
</li>
<li>
<p>Run <code>cargo release version patch -x --no-confirm &amp;&amp; cargo release replace -x --no-confirm</code> to bump the versions and add a new Changelog section; then PR the resulting commit.</p>
</li>
<li>
<p>Check whether there are <a href="https://github.com/PRQL/prql/milestones">milestones</a> that need to be pushed out.</p>
</li>
</ol>
<p>We may make this more automated in future; e.g. automatic changelog creation.<p><hr/></p>
<p><a name="footnote-1"><a href="project/contributing/development.html#to-footnote-1">1</a></a>: Our approach is very consistent with <strong><a href="https://github.com/matklad">@matklad</a></strong>’s advice, in his excellent blog post <a href="https://matklad.github.io//2021/05/31/how-to-test.html">How to Test</a>.</p>
<p><a name="footnote-2"><a href="project/contributing/development.html#to-footnote-2">2</a></a>: <a href="https://github.com/PRQL/prql/blob/0.2.2/prql-compiler/src/parser.rs#L580-L605">Here’s an example of an insta test</a> — note that only the initial line of each test is written by us; the remainder is filled in by insta.</p>
<p><a name="footnote-3"><a href="project/contributing/development.html#to-footnote-3">3</a></a>: Only maintainers have access to this page.</p>
<p><a name="footnote-4"><a href="project/contributing/development.html#to-footnote-4">4</a></a>: Unfortunately GitHub’s markdown parser interprets linebreaks as newlines. I haven’t found a better way of editing the markdown to look reasonable than manually editing the text.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="語言設計-1"><a class="header" href="#語言設計-1">語言設計</a></h1>
<p>In a way PRQL is just a transpiler to SQL. This can cause its language design to gravitate toward thinking about PRQL features in terms of how they translate to SQL.</p>
<pre><code>PRQL feature -&gt; SQL feature -&gt; relational result
</code></pre>
<p>This is flawed because:</p>
<ul>
<li>it does not model interactions between features well,</li>
<li>SQL behavior can sometimes be misleading (the order of a subquery will not persist in the parent query) or even differs between dialects (set operations).</li>
</ul>
<p>Instead, we should think of PRQL features in terms of how they affect PRQL expressions, which in most cases means how they affect relations.</p>
<pre><code>PRQL feature -&gt; relation
                   |
                   v
PRQL feature -&gt; relation
                   |
                   v
PRQL feature -&gt; relation
                   |
                   v
            relational result
</code></pre>
<p>Thinking about SQL comes in only at the last step when relation (or rather relational expression) is translated to an SQL expression.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="highlight-prql.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
