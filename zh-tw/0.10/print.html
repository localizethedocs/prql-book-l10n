<!DOCTYPE HTML>
<html lang="zh_TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PRQL language book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="Modern language for transforming data â€” a simple, powerful, pipelined SQL replacement">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="comparison-table.css">
        <link rel="stylesheet" href="mdbook-admonish.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PRQL language book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/PRQL/prql" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>PRQL project documentation.</p>
<h2 id="tutorial"><a class="header" href="#tutorial"><a href="./tutorial/relations.html">Tutorial</a></a></h2>
<p>A friendly &amp; accessible guide for learning PRQL. It has a gradual increase of difficulty and requires only basic understanding of programming languages. Knowledge of SQL is beneficial, because of many comparisons to SQL, but it is not required.</p>
<!-- TODO: add a time estimate, "learn PRQL in 15 minutes" -->
<h2 id="language-reference"><a class="header" href="#language-reference"><a href="./reference/syntax/">Language reference</a></a></h2>
<p>é—œæ–¼ PRQL èªè¨€çš„æ·±å…¥è³‡è¨Šã€‚åŒ…å«èªè¨€è¨­è¨ˆæ±ºç­–çš„ç†æ“šï¼Œä»¥åŠèªè¨€å„éƒ¨åˆ†çš„æ­£å¼è¦ç¯„ã€‚</p>
<h2 id="how-do-i"><a class="header" href="#how-do-i"><a href="./how-do-i/distinct.html">How do I?</a></a></h2>
<p>Frequently asked questions and small guides on how to use the language.</p>
<h2 id="project"><a class="header" href="#project"><a href="./project/changelog.html">Project</a></a></h2>
<p>é—œæ–¼å°ˆæ¡ˆã€å·¥å…·èˆ‡é–‹ç™¼çš„ä¸€èˆ¬è³‡è¨Šã€‚</p>
<ul>
<li><a href="./project/changelog.html">Changelog</a></li>
<li><a href="./project/target.html">Target &amp; version</a></li>
<li><a href="./project/bindings/">Bindings</a></li>
<li><a href="./project/integrations/">Integrations</a></li>
<li><a href="./project/contributing/">Contributing to PRQL</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é—œä¿‚"><a class="header" href="#é—œä¿‚">é—œä¿‚</a></h1>
<p>PRQL is designed on top of <em>relational algebra</em>, which is the established data model used by modern SQL databases. A <em>relation</em> has a rigid mathematical definition, which can be simplified to â€œa table of dataâ€. For example, the <code>invoices</code> table from the Chinook database (<a href="https://github.com/lerocha/chinook-database">https://github.com/lerocha/chinook-database</a>) looks like this:</p>
<div class="table-wrapper"><table><thead><tr><th>invoice_id</th><th>customer_id</th><th>billing_city</th><th style="text-align: center"><em>other columns</em></th><th>total</th></tr></thead><tbody>
<tr><td>1</td><td>2</td><td>Stuttgart</td><td style="text-align: center">â€¦</td><td>1.98</td></tr>
<tr><td>2</td><td>4</td><td>Oslo</td><td style="text-align: center">â€¦</td><td>3.96</td></tr>
<tr><td>3</td><td>8</td><td>Brussels</td><td style="text-align: center">â€¦</td><td>5.94</td></tr>
<tr><td>4</td><td>14</td><td>Edmonton</td><td style="text-align: center">â€¦</td><td>8.91</td></tr>
<tr><td>5</td><td>23</td><td>Boston</td><td style="text-align: center">â€¦</td><td>13.86</td></tr>
<tr><td>6</td><td>37</td><td>Frankfurt</td><td style="text-align: center">â€¦</td><td>0.99</td></tr>
</tbody></table>
</div>
<p>A relation is composed of rows. Each row in a relation contains a value for each of the relationâ€™s columns. Each column in a relation has an unique name and a designated data type. The table above is a relation, and has columns named <code>invoice_id</code>and <code>customer_id</code> each with a data type of â€œinteger numberâ€, a <code>billing_city</code> column with a data type of â€œtextâ€, several other columns, and a <code>total</code> column that contains floating-point numbers.</p>
<h2 id="æŸ¥è©¢"><a class="header" href="#æŸ¥è©¢">æŸ¥è©¢</a></h2>
<p>PRQL çš„ä¸»è¦ç›®çš„æ˜¯å»ºç«‹æŸ¥è©¢ï¼Œä»¥çµåˆå’Œè½‰æ›ä¾†è‡ªé—œä¿‚ï¼ˆå¦‚ä¸Šé¢çš„ <code>invoices</code> è¡¨ï¼‰çš„è³‡æ–™ã€‚ä»¥ä¸‹æ˜¯æœ€åŸºæœ¬çš„æŸ¥è©¢ï¼š</p>
<pre><code class="language-prql no-eval">from invoices
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="tutorial/relations.html#admonition-note"></a>
</div>
<div>
<p>Try each of these examples here in the <a href="https://prql-lang.org/playground/">Playground.</a> Enter the query on the left-hand side, and click <strong>output.arrow</strong> in the right-hand side to see the result.</p>
</div>
</div>
<p>The result of the query above is not terribly interesting, itâ€™s just the same relation as before.</p>
<h3 id="select-è®Šæ›"><a class="header" href="#select-è®Šæ›"><code>select</code> è®Šæ›</a></h3>
<p><code>select</code> å‡½å¼åŸºæ–¼åˆ—è¡¨é¸æ“‡è¦é€šéçš„åˆ—ï¼Œä¸¦æ¨æ£„æ‰€æœ‰å…¶ä»–åˆ—ã€‚å½¢å¼ä¸Šï¼Œè©²åˆ—è¡¨æ˜¯ä»¥ <code>{ ... }</code> åŒ…è£¹çš„é€—è™Ÿåˆ†éš”è¡¨é”å¼çš„ <em>å…ƒçµ„</em>ã€‚</p>
<p>å‡è¨­æˆ‘å€‘åªéœ€è¦ <code>order_id</code> å’Œ <code>total</code> åˆ—ã€‚ä½¿ç”¨ <code>select</code> ä¾†é¸æ“‡è¦é€šéçš„åˆ—ã€‚<em>ï¼ˆåœ¨ <a href="https://prql-lang.org/playground/">Playground</a> ä¸­è©¦è©¦çœ‹ã€‚ï¼‰</em></p>
<pre><code class="language-prql no-eval">from invoices
select { order_id, total }
</code></pre>
<p>æˆ‘å€‘å¯ä»¥åœ¨ä¸€è¡Œæˆ–å¤šè¡Œä¸Šå¯«å…¥å…ƒçµ„ä¸­çš„é …ç›®ï¼šå°¾éƒ¨é€—è™Ÿè¢«å¿½ç•¥ã€‚æ­¤å¤–ï¼Œæˆ‘å€‘å¯ä»¥å°‡ä»»ä½•è¡¨é”å¼æŒ‡æ´¾çµ¦ <em>è®Šæ•¸</em>ï¼Œè©²è®Šæ•¸æˆç‚º SQL è¼¸å‡ºä¸­çµæœåˆ—çš„åç¨±ã€‚</p>
<pre><code class="language-prql no-eval">from invoices
select {
  OrderID = invoice_id,
  Total = total,
}
</code></pre>
<p>é€™æ˜¯èˆ‡ä¸Šé¢ç›¸åŒçš„æŸ¥è©¢ï¼Œæ”¹å¯«åœ¨å¤šè¡Œä¸Šï¼Œä¸¦å°‡ <code>OrderID</code> å’Œ <code>Total</code> åç¨±æŒ‡æ´¾çµ¦åˆ—ã€‚</p>
<p>ä¸€æ—¦æˆ‘å€‘ <code>select</code> æŸäº›åˆ—ï¼Œå¾ŒçºŒè®Šæ›å°‡åªèƒ½è¨ªå•åœ¨å…ƒçµ„ä¸­å‘½åçš„é‚£äº›åˆ—ã€‚</p>
<h3 id="derive-è®Šæ›"><a class="header" href="#derive-è®Šæ›"><code>derive</code> è®Šæ›</a></h3>
<p>To add columns to a relation, we can use <code>derive</code> function. Letâ€™s define a new column for Value Added Tax, set at 19% of the invoice total.</p>
<pre><code class="language-prql no-eval">from invoices
derive { VAT = total * 0.19 }
</code></pre>
<!-- todo: make sure that the new column is unnamed -->
<p>æ–°åˆ—çš„å€¼å¯ä»¥æ˜¯å¸¸æ•¸ï¼ˆä¾‹å¦‚æ•¸å­—æˆ–å­—ä¸²ï¼‰ï¼Œä¹Ÿå¯ä»¥å¾ç¾æœ‰åˆ—çš„å€¼è¨ˆç®—å¾—å‡ºã€‚æ³¨æ„æ–°åˆ—è¢«æŒ‡æ´¾åç¨± <code>VAT</code>ã€‚</p>
<h3 id="join-è®Šæ›"><a class="header" href="#join-è®Šæ›"><code>join</code> è®Šæ›</a></h3>
<p>The <code>join</code> transform also adds columns to the relation by combining the rows from two relations â€œside by sideâ€. To determine which rows from each relation should be joined, <code>join</code> has match criteria, written in <code>( ... )</code>.</p>
<pre><code class="language-prql no-eval">from invoices
join customers ( ==customer_id )
</code></pre>
<p>This example â€œconnectsâ€ the customer information from the <code>customers</code> relation with the information from the <code>invoices</code> relation, using identical values of the <code>customer_id</code> column from each relation to match the rows.</p>
<p>It is frequently useful to assign an alias to both relations being joined together so that each relationâ€™s columns can be referred to uniquely.</p>
<pre><code class="language-prql no-eval">from inv=invoices
join cust=customers ( ==customer_id )
</code></pre>
<p>åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œåˆ¥å <code>inv</code> ä»£è¡¨ <code>invoices</code> é—œä¿‚ï¼Œ<code>cust</code> ä»£è¡¨ <code>customers</code> é—œä¿‚ã€‚ç„¶å¾Œå¯ä»¥æ˜ç¢ºåœ°åƒè€ƒ <code>inv.billing_city</code> å’Œ <code>cust.last_name</code>ã€‚</p>
<h3 id="æ‘˜è¦"><a class="header" href="#æ‘˜è¦">æ‘˜è¦</a></h3>
<p>PRQL manipulates relations (tables) of data. The <code>derive</code>, <code>select</code>, and <code>join</code> transforms change the number of columns in a table. The first two never affect the number of rows in a table. <code>join</code> may change the number of rows, depending on the variation chosen.</p>
<p>é€™å€‹æœ€å¾Œçš„ç¤ºä¾‹å°‡ä¸Šè¿°å…§å®¹çµ„åˆæˆä¸€å€‹å–®ä¸€æŸ¥è©¢ã€‚å®ƒèªªæ˜äº† <em>ç®¡é“</em> - PRQL çš„åŸºç¤ã€‚æˆ‘å€‘åªæ˜¯åœ¨æŸ¥è©¢æœ«å°¾æ–°å¢æ–°çš„è¡Œï¼ˆè®Šæ›ï¼‰ã€‚æ¯å€‹è®Šæ›ä¿®æ”¹ç”±ä¸Šè¿°èªå¥ç”¢ç”Ÿçš„é—œä¿‚ï¼Œä»¥ç”¢ç”Ÿæ‰€éœ€çš„çµæœã€‚</p>
<pre><code class="language-prql no-eval">from inv=invoices
join cust=customers (==customer_id)
derive { VAT = inv.total * 0.19 }
select {
  OrderID = inv.invoice_id,
  CustomerName = cust.last_name,
  Total = inv.total,
  VAT,
}
</code></pre>
<!-- PRQL uses the data from... _Where does our data come from? Do we use some canonical version?_ -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç¯©é¸è¡Œ"><a class="header" href="#ç¯©é¸è¡Œ">ç¯©é¸è¡Œ</a></h1>
<p>åœ¨å‰ä¸€é ï¼Œæˆ‘å€‘å­¸åˆ°äº† <code>select</code>ã€<code>derive</code> å’Œ <code>join</code> å¦‚ä½•æ”¹è®Šè¡¨çš„åˆ—ã€‚</p>
<p>ç¾åœ¨æˆ‘å€‘å°‡æ¢ç´¢å¦‚ä½•ä½¿ç”¨ <code>filter</code> å’Œ <code>take</code> æ“ä½œè¡¨çš„è¡Œã€‚</p>
<h3 id="filter-è®Šæ›"><a class="header" href="#filter-è®Šæ›"><code>filter</code> è®Šæ›</a></h3>
<p><code>filter</code> è®Šæ›æ ¹æ“šå€¼é¸æ“‡è¦é€šéçš„è¡Œï¼š</p>
<pre><code class="language-prql no-eval">from invoices
filter billing_city == "Berlin"
</code></pre>
<p>çµæœè¡¨åŒ…å«ä¾†è‡ªæŸæ—çš„æ‰€æœ‰è¡Œã€‚</p>
<p>PRQL å°‡å–®å€‹ <code>filter</code> è®Šæ›è½‰æ›ç‚ºä½¿ç”¨é©ç•¶çš„ SQL <code>WHERE</code> æˆ– <code>HAVING</code> å‘½ä»¤ï¼Œå–æ±ºæ–¼å®ƒåœ¨ç®¡é“ä¸­å‡ºç¾çš„ä½ç½®ã€‚</p>
<h3 id="take-è®Šæ›"><a class="header" href="#take-è®Šæ›"><code>take</code> è®Šæ›</a></h3>
<p><code>take</code> è®Šæ›æ ¹æ“šè¡Œåœ¨è¡¨ä¸­çš„ä½ç½®é¸æ“‡è¦é€šéçš„è¡Œã€‚æ‰€é¸è¡Œçš„é›†åˆå¯ä»¥ç”¨å…©ç¨®æ–¹å¼æŒ‡å®šï¼š</p>
<ul>
<li>ä¸€å€‹ç´”æ•¸å­— <code>x</code>ï¼Œå°‡é¸æ“‡å‰ <code>x</code> è¡Œï¼Œæˆ–</li>
<li>è¡Œçš„åŒ…å«ç¯„åœ <code>start..end</code>ã€‚</li>
</ul>
<pre><code class="language-prql no-eval">from invoices
take 4
</code></pre>
<pre><code class="language-prql no-eval">from invoices
take 4..7
</code></pre>
<p>ç•¶ç„¶ï¼Œå¯ä»¥å°‡æ‰€æœ‰é€™äº›è®Šæ›çµ„åˆåˆ°ä¸€å€‹ç®¡é“ä¸­ï¼š</p>
<pre><code class="language-prql no-eval">from invoices

# retain only rows for orders from Berlin
filter billing_city == "Berlin"

# skip first 10 rows and take the next 10
take 11..20

# take only first 3 rows of *that* result
take 3
</code></pre>
<p>åœ¨æœ€å¾Œæˆ‘å€‘åšäº†ä¸€äº›æœ‰é»å¥‡æ€ªçš„äº‹æƒ…ï¼šé¦–å…ˆæˆ‘å€‘å–äº†è¡Œ <code>11..20</code>ï¼Œç„¶å¾Œå¾è©²çµæœä¸­å–å‰ 3 è¡Œã€‚</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="tutorial/filtering.html#admonition-note"></a>
</div>
<div>
<p>Note that a single transform <code>take 11..13</code> would have produced the same SQL. The example serves an example of how PRQL allows fast data exploration by â€œstackingâ€ transforms in the pipeline, reducing the cognitive burden of how a new transform with the previous query.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="èšåˆ"><a class="header" href="#èšåˆ">èšåˆ</a></h1>
<p>A key feature of analytics is reducing many values down to some summary. This act is called â€œaggregationâ€ and always includes a function â€” for example, <code>average</code> or <code>sum</code> â€” that reduces values in the table to a single row.</p>
<h3 id="aggregate-è®Šæ›"><a class="header" href="#aggregate-è®Šæ›"><code>aggregate</code> è®Šæ›</a></h3>
<p>The <code>aggregate</code> transform takes a tuple to create one or more new columns that â€œdistill downâ€ data from all the rows.</p>
<pre><code class="language-prql no-eval">from invoices
aggregate { sum_of_orders = sum total }
</code></pre>
<p>ä¸Šé¢çš„æŸ¥è©¢è¨ˆç®— <code>invoices</code> è¡¨æ‰€æœ‰è¡Œçš„ <code>total</code> åˆ—çš„ç¸½å’Œï¼Œä»¥ç”¢ç”Ÿå–®ä¸€å€¼ã€‚</p>
<p>ç•¶å…ƒçµ„ä¸­åŒ…å«ä¸€å€‹æˆ–å¤šå€‹èšåˆè¡¨é”å¼æ™‚ï¼Œ<code>aggregate</code> å¯ä»¥ä¸€æ¬¡ç”¢ç”Ÿå¤šå€‹æ‘˜è¦ã€‚<code>aggregate</code> æœƒæ¨æ£„å…ƒçµ„ä¸­ä¸å­˜åœ¨çš„æ‰€æœ‰åˆ—ã€‚</p>
<pre><code class="language-prql no-eval">from invoices
aggregate {
    num_orders = count this,
    sum_of_orders = sum total,
}
</code></pre>
<p>åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œçµæœæ˜¯æœ‰å…©åˆ—çš„å–®ä¸€è¡Œã€‚<code>count</code> å‡½å¼é¡¯ç¤ºå‚³å…¥çš„è¡¨ä¸­çš„è¡Œæ•¸ï¼›<code>sum</code> å‡½å¼å°‡æ‰€æœ‰è¡Œçš„ <code>total</code> åˆ—çš„å€¼ç›¸åŠ ã€‚</p>
<h2 id="åˆ†çµ„"><a class="header" href="#åˆ†çµ„">åˆ†çµ„</a></h2>
<p>å‡è¨­æˆ‘å€‘æƒ³è¦ç”¢ç”Ÿè¡¨ä¸­ <em>æ¯å€‹åŸå¸‚</em> ç™¼ç¥¨çš„æ‘˜è¦ã€‚æˆ‘å€‘å¯ä»¥ç‚ºæ¯å€‹åŸå¸‚å»ºç«‹ä¸€å€‹æŸ¥è©¢ï¼Œä¸¦èšåˆå…¶è¡Œï¼š</p>
<pre><code class="language-prql no-eval">from albums
filter billing_city == "Oslo"
aggregate { sum_of_orders = sum total }
</code></pre>
<p>ä½†æˆ‘å€‘éœ€è¦ç‚ºæ¯å€‹åŸå¸‚åšé€™ç¨®æ“ä½œï¼š<code>London</code>ã€<code>Frankfurt</code> ç­‰ã€‚ç•¶ç„¶é€™æ˜¯é‡è¤‡çš„ï¼ˆä¸”ä»¤äººå­å€¦çš„ï¼‰ä¸”å®¹æ˜“å‡ºéŒ¯ï¼ˆå› ç‚ºæˆ‘å€‘éœ€è¦æ‰‹å‹•è¼¸å…¥æ¯å€‹ <code>billing_city</code>ï¼‰ã€‚æ­¤å¤–ï¼Œæˆ‘å€‘éœ€è¦åœ¨é–‹å§‹å‰å»ºç«‹æ¯å€‹ <code>billing_city</code> çš„åˆ—è¡¨ã€‚</p>
<h3 id="group-è®Šæ›"><a class="header" href="#group-è®Šæ›"><code>group</code> è®Šæ›</a></h3>
<p>The <code>group</code> transform separates the table into groups (say, those having the same city) using information thatâ€™s already in the table. It then applies a transform to each group, and combines the results back together:</p>
<pre><code class="language-prql no-eval">from invoices
group billing_city (
    aggregate {
        num_orders = count this,
        sum_of_orders = sum total,
    }
)
</code></pre>
<p>ç†Ÿæ‚‰ SQL çš„äººå¯èƒ½å·²ç¶“æ³¨æ„åˆ°ï¼Œæˆ‘å€‘å‰›æ‰å°‡èšåˆèˆ‡åˆ†çµ„åˆ†é›¢äº†ã€‚</p>
<p>é›–ç„¶é€™äº›æ“ä½œåœ¨ SQL ä¸­æ˜¯ç›¸é—œçš„ï¼Œä½† PRQL ä½¿å¾—å¯ä»¥ç›´æ¥å°‡ <code>group</code> å’Œ <code>aggregate</code>åˆ†é–‹ä½¿ç”¨ï¼ŒåŒæ™‚èˆ‡å…¶ä»–è®Šæ›å‡½å¼çµåˆï¼Œä¾‹å¦‚ï¼š</p>
<pre><code class="language-prql no-eval">from invoices
group billing_city (
    take 2
)
</code></pre>
<p>This code collects the first two rows for each cityâ€™s <code>group</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-read-files"><a class="header" href="#how-do-i-read-files">How do I: read files?</a></h1>
<p>There are a couple of functions mainly designed for DuckDB:</p>
<div class="comparison">
<div>
<h4 id="prql"><a class="header" href="#prql">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.duckdb

from (read_parquet "artists.parquet")
join (read_csv "albums.csv") (==track_id)
</code></pre>
</div>
<div>
<h4 id="sql"><a class="header" href="#sql">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *
  FROM
    read_parquet('artists.parquet')
),
table_1 AS (
  SELECT
    *
  FROM
    read_csv_auto('albums.csv')
)
SELECT
  table_0.*,
  table_1.*
FROM
  table_0
  JOIN table_1 ON table_0.track_id = table_1.track_id

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="how-do-i/read-files.html#admonition-note"></a>
</div>
<div>
<p>These donâ€™t currently have all the DuckDB options. If those would be helpful, please log an issue and itâ€™s a fairly easy addition.</p>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="how-do-i/read-files.html#admonition-info"></a>
</div>
<div>
<p>We may be able to reduce the boilerplate <code>WITH table_x AS SELECT * FROM...</code> in future versions.</p>
</div>
</div>
<p>When specifying file names directly in the <code>FROM</code> clause without using functions, which is allowed in DuckDB, enclose the file names in backticks <code>``</code> as follows:</p>
<div class="comparison">
<div>
<h4 id="prql-1"><a class="header" href="#prql-1">PRQL</a></h4>
<pre><code class="language-prql">from `artists.parquet`
</code></pre>
</div>
<div>
<h4 id="sql-1"><a class="header" href="#sql-1">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  "artists.parquet"

</code></pre>
</div>
</div>
<h2 id="å¦è«‹åƒè¦‹"><a class="header" href="#å¦è«‹åƒè¦‹">å¦è«‹åƒè¦‹</a></h2>
<ul>
<li><a href="how-do-i/../project/target.html">Target and Version</a></li>
<li><a href="how-do-i/./relation-literals.html">How do I: create ad-hoc relations?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-remove-duplicates"><a class="header" href="#how-do-i-remove-duplicates">How do I: remove duplicates?</a></h1>
<p>PRQL doesnâ€™t have a specific <code>distinct</code> keyword. Instead duplicate tuples in a relation can be removed by using <code>group</code> and <code>take 1</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-2"><a class="header" href="#prql-2">PRQL</a></h4>
<pre><code class="language-prql">from employees
select department
group employees.* (
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-2"><a class="header" href="#sql-2">SQL</a></h4>
<pre><code class="language-sql">SELECT
  DISTINCT department
FROM
  employees

</code></pre>
</div>
</div>
<p>This also works with a wildcard:</p>
<div class="comparison">
<div>
<h4 id="prql-3"><a class="header" href="#prql-3">PRQL</a></h4>
<pre><code class="language-prql">from employees
group employees.* (take 1)
</code></pre>
</div>
<div>
<h4 id="sql-3"><a class="header" href="#sql-3">SQL</a></h4>
<pre><code class="language-sql">SELECT
  DISTINCT *
FROM
  employees

</code></pre>
</div>
</div>
<h2 id="remove-duplicates-from-each-group"><a class="header" href="#remove-duplicates-from-each-group">Remove duplicates from each group?</a></h2>
<p>To <a href="https://stackoverflow.com/questions/3800551/select-first-row-in-each-group-by-group">select a single row from each group</a> <code>group</code> can be combined with <code>sort</code> and <code>take</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-4"><a class="header" href="#prql-4">PRQL</a></h4>
<pre><code class="language-prql"># youngest employee from each department
from employees
group department (
  sort age
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-4"><a class="header" href="#sql-4">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    ROW_NUMBER() OVER (
      PARTITION BY department
      ORDER BY
        age
    ) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  _expr_0 &lt;= 1

</code></pre>
</div>
</div>
<p>Note that we canâ€™t always compile to <code>DISTINCT</code>; when the columns in the <code>group</code> arenâ€™t all the available columns, we need to use a window function:</p>
<div class="comparison">
<div>
<h4 id="prql-5"><a class="header" href="#prql-5">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {first_name, last_name} (take 1)
</code></pre>
</div>
<div>
<h4 id="sql-5"><a class="header" href="#sql-5">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    ROW_NUMBER() OVER (PARTITION BY first_name, last_name) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  _expr_0 &lt;= 1

</code></pre>
</div>
</div>
<!-- TODO: uncomment when the bug is fixed -->
<!-- When compiling to Postgres or DuckDB dialect, such queries will be compiled to
`DISTINCT ON`, which is
[the most performant option](https://stackoverflow.com/a/7630564).
<pre><code class="language-prql">prql target:sql.postgres

from employees
group department (
  sort age
  take 1
)
``` --&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-create-ad-hoc-relations"><a class="header" href="#how-do-i-create-ad-hoc-relations">How do I: create ad-hoc relations?</a></h1>
<p>Itâ€™s often useful to make a small inline relation, for example when exploring how a database will evaluate an expression, or for a small lookup table. This can be quite verbose in SQL.</p>
<p>PRQL offers two approaches â€”Â array literals, and a <code>from_text</code> transform.</p>
<h2 id="array-literals"><a class="header" href="#array-literals">Array literals</a></h2>
<p>Because relations (aka a table) in PRQL are just arrays of tuples, they can be expressed with array and tuple syntax:</p>
<div class="comparison">
<div>
<h4 id="prql-6"><a class="header" href="#prql-6">PRQL</a></h4>
<pre><code class="language-prql">from [
  {a=5, b=false},
  {a=6, b=true},
]
filter b == true
select a
</code></pre>
</div>
<div>
<h4 id="sql-6"><a class="header" href="#sql-6">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    5 AS a,
    false AS b
  UNION
  ALL
  SELECT
    6 AS a,
    true AS b
)
SELECT
  a
FROM
  table_0
WHERE
  b = true

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-7"><a class="header" href="#prql-7">PRQL</a></h4>
<pre><code class="language-prql">let my_artists = [
  {artist="Miles Davis"},
  {artist="Marvin Gaye"},
  {artist="James Brown"},
]

from artists
join my_artists (==artist)
join albums (==artist_id)
select {artists.artist_id, albums.title}
</code></pre>
</div>
<div>
<h4 id="sql-7"><a class="header" href="#sql-7">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    'Miles Davis' AS artist
  UNION
  ALL
  SELECT
    'Marvin Gaye' AS artist
  UNION
  ALL
  SELECT
    'James Brown' AS artist
),
my_artists AS (
  SELECT
    artist
  FROM
    table_0
)
SELECT
  artists.artist_id,
  albums.title
FROM
  artists
  JOIN my_artists ON artists.artist = my_artists.artist
  JOIN albums ON artists.artist_id = albums.artist_id

</code></pre>
</div>
</div>
<h2 id="from_text"><a class="header" href="#from_text"><code>from_text</code></a></h2>
<p><code>from_text</code> takes a string in a common format, and converts it to table. It accepts a few formats:</p>
<ul>
<li>
<p><code>format:csv</code> parses CSV (default),</p>
</li>
<li>
<p><code>format:json</code> parses either:</p>
<ul>
<li>
<p>an array of objects each of which represents a row, or</p>
</li>
<li>
<p>an object with fields <code>columns</code> &amp; <code>data</code>, where <code>columns</code> take an array of column names and <code>data</code> takes an array of arrays.</p>
</li>
</ul>
</li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-8"><a class="header" href="#prql-8">PRQL</a></h4>
<pre><code class="language-prql">from_text """
a,b,c
1,2,3
4,5,6
"""
derive {
    d = b + c,
    answer = 20 * 2 + 2,
}
</code></pre>
</div>
<div>
<h4 id="sql-8"><a class="header" href="#sql-8">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    '1' AS a,
    '2' AS b,
    '3' AS c
  UNION
  ALL
  SELECT
    '4' AS a,
    '5' AS b,
    '6' AS c
)
SELECT
  a,
  b,
  c,
  b + c AS d,
  20 * 2 + 2 AS answer
FROM
  table_0

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-9"><a class="header" href="#prql-9">PRQL</a></h4>
<pre><code class="language-prql">from_text format:json """
[
    {"a": 1, "m": "5"},
    {"a": 4, "n": "6"}
]
"""
</code></pre>
</div>
<div>
<h4 id="sql-9"><a class="header" href="#sql-9">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    1 AS a,
    '5' AS m
  UNION
  ALL
  SELECT
    4 AS a,
    NULL AS m
)
SELECT
  a,
  m
FROM
  table_0

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-10"><a class="header" href="#prql-10">PRQL</a></h4>
<pre><code class="language-prql">from_text format:json """
{
    "columns": ["a", "b", "c"],
    "data": [
        [1, "x", false],
        [4, "y", null]
    ]
}
"""
</code></pre>
</div>
<div>
<h4 id="sql-10"><a class="header" href="#sql-10">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    1 AS a,
    'x' AS b,
    false AS c
  UNION
  ALL
  SELECT
    4 AS a,
    'y' AS b,
    NULL AS c
)
SELECT
  a,
  b,
  c
FROM
  table_0

</code></pre>
</div>
</div>
<h2 id="å¦è«‹åƒè¦‹-1"><a class="header" href="#å¦è«‹åƒè¦‹-1">å¦è«‹åƒè¦‹</a></h2>
<ul>
<li><a href="how-do-i/./read-files.html">How do I: read files?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="èªæ³•"><a class="header" href="#èªæ³•">èªæ³•</a></h1>
<p>PRQL èªæ³•æ‘˜è¦ï¼š</p>
<!-- markdownlint-disable MD033 â€” the `|` characters need to be escaped, and surrounded with tags rather than backticks   -->
<!-- I can't seem to get "Quoted identifies" to work without a space between the backticks. VS Code will preview ` `` ` correctly, but not mdbook -->
<!-- TODO: assigns links to select, aliases to join, potentially we should have explicit sections for them?  -->
<div class="table-wrapper"><table><thead><tr><th>èªæ³•</th><th>ç”¨æ³•</th><th>ç¯„ä¾‹</th></tr></thead><tbody>
<tr><td><code>|</code></td><td><a href="reference/syntax/./function-calls.html">ç®¡é“</a></td><td><code>from employees | select first_name</code></td></tr>
<tr><td><code>=</code></td><td><a href="reference/syntax/./tuples.html">Assigns</a></td><td><code>from e = employees</code> <br> <code>derive total = (sum salary)</code></td></tr>
<tr><td><code>:</code></td><td><a href="reference/syntax/../declarations/functions.html">å…·åå¼•æ•¸å’Œåƒæ•¸</a></td><td><code>interp low:0 1600 sat_score</code></td></tr>
<tr><td><code>{}</code></td><td><a href="reference/syntax/./tuples.html">å€¼çµ„</a></td><td><code>{id, false, total = 3}</code></td></tr>
<tr><td><code>[]</code></td><td><a href="reference/syntax/./arrays.html">é™£åˆ—</a></td><td><code>[1, 4, 3, 4]</code></td></tr>
<tr><td><code>!</code>,<code>&amp;&amp;</code>,<code>==</code>,<code>+</code></td><td><a href="reference/syntax/./operators.html">é‹ç®—å­</a></td><td><code>filter a == b + c || d &gt;= e</code></td></tr>
<tr><td><code>()</code></td><td><a href="reference/syntax/./operators.html#parentheses">æ‹¬è™Ÿ</a></td><td><code>derive celsius = (fht - 32) / 1.8</code></td></tr>
<tr><td><code>\</code></td><td><a href="reference/syntax/./operators.html#wrapping-lines">æ›è¡Œ</a></td><td><code>1 + 2 + 3 +</code><br><code>\ 4 + 5</code></td></tr>
<tr><td><code>1</code>ã€<code>100_000</code>ã€<code>5e10</code></td><td><a href="reference/syntax/./literals.html#numbers">æ•¸å­—</a></td><td><code>derive { huge = 5e10 * 10_000 }</code></td></tr>
<tr><td><code>''</code>ã€<code>""</code></td><td><a href="reference/syntax/./literals.html#strings">å­—ä¸²</a></td><td><code>derive name = 'Mary'</code></td></tr>
<tr><td><code>true</code>ã€<code>false</code></td><td><a href="reference/syntax/./literals.html#booleans">å¸ƒæ—å€¼</a></td><td><code>derive { Col1 = true }</code></td></tr>
<tr><td><code>null</code></td><td><a href="reference/syntax/./literals.html#null">Null</a></td><td><code>filter ( name != null )</code></td></tr>
<tr><td><code>@</code></td><td><a href="reference/syntax/./literals.html#date-and-time">æ—¥æœŸå’Œæ™‚é–“</a></td><td><code>@2021-01-01</code></td></tr>
<tr><td><code>` `</code></td><td><a href="reference/syntax/./keywords.html#quoting">å¼•ç”¨çš„è­˜åˆ¥ç¬¦è™Ÿ</a></td><td><code>select `first name` </code></td></tr>
<tr><td><code>#</code></td><td><a href="reference/syntax/./comments.html">è¨»é‡‹</a></td><td><code># A comment</code></td></tr>
<tr><td><code>==</code></td><td><a href="reference/syntax/../stdlib/transforms/join.html#self-equality-operator"><code>join</code> ä¸­çš„è‡ªç›¸ç­‰</a></td><td><code>join s=salaries (==id)</code></td></tr>
<tr><td><code>-&gt;</code></td><td><a href="reference/syntax/../declarations/functions.html">å‡½å¼å®šç¾©</a></td><td><code>let add = a b -&gt; a + b</code></td></tr>
<tr><td><code>=&gt;</code></td><td><a href="reference/syntax/./case.html">Case èªå¥</a></td><td><code>case [a==1 =&gt; c, a==2 =&gt; d]</code></td></tr>
<tr><td><code>+</code>ã€<code>-</code></td><td><a href="reference/syntax/../stdlib/transforms/sort.html">æ’åºé †åº</a></td><td><code>sort {-amount, +date}</code></td></tr>
<tr><td><code>??</code></td><td><a href="reference/syntax/./operators.html#coalesce">åˆä½µ</a></td><td><code>amount ?? 0</code></td></tr>
</tbody></table>
</div><!-- markdownlint-enable MD033 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="å­—é¢å€¼"><a class="header" href="#å­—é¢å€¼">å­—é¢å€¼</a></h1>
<p>å­—é¢å€¼æ˜¯ä¸€å€‹å¸¸æ•¸å€¼è¡¨é”å¼ï¼Œæ¯ç¨®è³‡æ–™å‹åˆ¥éƒ½æœ‰ç‰¹æ®Šçš„èªæ³•è¦å‰‡ã€‚</p>
<h2 id="æ•¸å­—"><a class="header" href="#æ•¸å­—">æ•¸å­—</a></h2>
<p>æ•¸å­—å­—é¢å€¼å¯ä»¥åŒ…å«æ•¸å­—å­—å…ƒä»¥åŠå¥è™Ÿã€åº•ç·šå’Œå­—å…ƒ <code>e</code>ã€‚</p>
<p>å¦‚æœæ•¸å­—å­—é¢å€¼åŒ…å«é»æˆ–å­—å…ƒ <code>e</code>ï¼Œå‰‡å°‡å…¶è¦–ç‚ºæµ®é»æ•¸ï¼ˆæˆ–ç¨±ç‚º <em>float</em>ï¼‰ï¼Œå¦å‰‡å°‡å…¶è¦–ç‚ºæ•´æ•¸ã€‚</p>
<p>Character <code>e</code> denotes <a href="https://en.wikipedia.org/wiki/Scientific_notation">â€œscientific notationâ€</a>, where the number after <code>e</code> is the exponent in 10-base.</p>
<p>åº•ç·šè¢«å¿½ç•¥ï¼Œæ‰€ä»¥å®ƒå€‘å¯ä»¥æ”¾åœ¨ä»»æ„ä½ç½®ï¼Œä½†å»ºè­°å°‡å®ƒå€‘ç”¨ä½œåƒä½åˆ†éš”ç¬¦ã€‚</p>
<p>æ•´æ•¸ä¹Ÿå¯ä»¥ä½¿ç”¨åå…­é€²ä½ã€å…«é€²ä½æˆ–äºŒé€²ä½è¡¨ç¤ºæ³•åˆ†åˆ¥ç”¨é€™äº›å‰ç¶´è¡¨ç¤ºï¼š<code>0x</code>ã€<code>0o</code> æˆ– <code>0b</code>ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-11"><a class="header" href="#prql-11">PRQL</a></h4>
<pre><code class="language-prql">from numbers
select {
    small = 1.000_000_1,
    big = 5_000_000,
    huge = 5e9,
    binary = 0x0011,
    hex = 0x80,
    octal = 0o777,
}
</code></pre>
</div>
<div>
<h4 id="sql-11"><a class="header" href="#sql-11">SQL</a></h4>
<pre><code class="language-sql">SELECT
  1.0000001 AS small,
  5000000 AS big,
  5000000000.0 AS huge,
  17 AS binary,
  128 AS hex,
  511 AS octal
FROM
  numbers

</code></pre>
</div>
</div>
<h2 id="å­—ä¸²"><a class="header" href="#å­—ä¸²">å­—ä¸²</a></h2>
<p>PRQL æ”¯æ´å­—ä¸²å­—é¢å€¼å’Œå¤šç¨®å…¶ä»–å­—ä¸²æ ¼å¼ã€‚å¦‚éœ€è©³ç´°è³‡è¨Šï¼Œè«‹åƒé–±<a href="reference/syntax/./strings.html">å­—ä¸²</a>é é¢ã€‚</p>
<h2 id="å¸ƒæ—å€¼"><a class="header" href="#å¸ƒæ—å€¼">å¸ƒæ—å€¼</a></h2>
<p>å¸ƒæ—å€¼å¯ä»¥ç”¨ <code>true</code> æˆ– <code>false</code> é—œéµå­—è¡¨ç¤ºã€‚</p>
<h2 id="ç©ºå€¼"><a class="header" href="#ç©ºå€¼">ç©ºå€¼</a></h2>
<p>ç©ºå€¼å¯ä»¥ç”¨ <code>null</code> é—œéµå­—è¡¨ç¤ºã€‚å¦è«‹åƒé–± <a href="reference/syntax/../spec/null.html">PRQL å¦‚ä½•è™•ç†ç©ºå€¼</a>çš„è¨è«–ã€‚</p>
<h2 id="æ—¥æœŸå’Œæ™‚é–“"><a class="header" href="#æ—¥æœŸå’Œæ™‚é–“">æ—¥æœŸå’Œæ™‚é–“</a></h2>
<p>æ—¥æœŸå’Œæ™‚é–“å­—é¢å€¼ç”¨å­—å…ƒ <code>@</code> è¡¨ç¤ºï¼Œå¾Œé¢è·Ÿè‘—ç·¨ç¢¼æ—¥æœŸå’Œæ™‚é–“çš„å­—ä¸²ã€‚</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/literals.html#admonition-note"></a>
</div>
<div>
<p>PRQLâ€™s notation is designed to be less verbose than SQLâ€™s <code>TIMESTAMP '2004-10-19 10:23:54'</code> and more explicit than SQLâ€™s implicit option that just uses a string <code>'2004-10-19 10:23:54'</code>.</p>
</div>
</div>
<h3 id="æ—¥æœŸ"><a class="header" href="#æ—¥æœŸ">æ—¥æœŸ</a></h3>
<p>æ—¥æœŸç”± <code>@{yyyy-mm-dd}</code> è¡¨ç¤º â€” <code>@</code> å¾Œé¢è·Ÿè‘—æ—¥æœŸæ ¼å¼ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-12"><a class="header" href="#prql-12">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive age_at_year_end = (@2022-12-31 - dob)
</code></pre>
</div>
<div>
<h4 id="sql-12"><a class="header" href="#sql-12">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  DATE '2022-12-31' - dob AS age_at_year_end
FROM
  employees

</code></pre>
</div>
</div>
<h3 id="æ™‚é–“"><a class="header" href="#æ™‚é–“">æ™‚é–“</a></h3>
<p>æ™‚é–“ç”± <code>@{HH:mm:ss.SSSÂ±Z}</code> è¡¨ç¤ºï¼Œä»»ä½•æœªæä¾›çš„éƒ¨åˆ†é è¨­ç‚ºé›¶ã€‚é€™åŒ…æ‹¬ç”± <code>+HH:mm</code>ã€<code>-HH:mm</code> æˆ– <code>Z</code> è¡¨ç¤ºçš„æ™‚å€ã€‚é€™ç¬¦åˆ ISO8601 æ™‚é–“æ ¼å¼ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-13"><a class="header" href="#prql-13">PRQL</a></h4>
<pre><code class="language-prql">from orders
derive should_have_shipped_today = (order_time &lt; @08:30)
</code></pre>
</div>
<div>
<h4 id="sql-13"><a class="header" href="#sql-13">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  order_time &lt; TIME '08:30' AS should_have_shipped_today
FROM
  orders

</code></pre>
</div>
</div>
<h3 id="æ™‚é–“æˆ³è¨˜"><a class="header" href="#æ™‚é–“æˆ³è¨˜">æ™‚é–“æˆ³è¨˜</a></h3>
<p>""æ™‚é–“æˆ³è¨˜ç”± <code>@{yyyy-mm-ddTHH:mm:ss.SSSÂ±Z}</code> / <code>@{date}T{time}</code> è¡¨ç¤ºï¼Œä»»ä½•æœªæä¾›çš„æ™‚é–“éƒ¨åˆ†è¢«å››æ¨äº”å…¥ç‚ºé›¶ï¼ŒåŒ…æ‹¬ç”± <code>+HH:mm</code>ã€<code>-HH:mm</code> æˆ– <code>Z</code>ï¼ˆ<code>:</code> æ˜¯å¯é¸çš„ï¼‰è¡¨ç¤ºçš„æ™‚å€ã€‚é€™æ˜¯ <code>@</code> å¾Œé¢è·Ÿè‘— ISO8601 æ—¥æœŸæ™‚é–“æ ¼å¼ï¼Œè©²æ ¼å¼ä½¿ç”¨ <code>T</code> åˆ†éš”æ—¥æœŸå’Œæ™‚é–“ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-14"><a class="header" href="#prql-14">PRQL</a></h4>
<pre><code class="language-prql">from commits
derive first_prql_commit = @2020-01-01T13:19:55-08:00
derive first_prql_commit_utc = @2020-01-02T21:19:55Z
</code></pre>
</div>
<div>
<h4 id="sql-14"><a class="header" href="#sql-14">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  TIMESTAMP '2020-01-01T13:19:55-0800' AS first_prql_commit,
  TIMESTAMP '2020-01-02T21:19:55Z' AS first_prql_commit_utc
FROM
  commits

</code></pre>
</div>
</div>
<h3 id="æŒçºŒæ™‚é–“"><a class="header" href="#æŒçºŒæ™‚é–“">æŒçºŒæ™‚é–“</a></h3>
<p>æŒçºŒæ™‚é–“ç”± <code>{N}{periods}</code> è¡¨ç¤ºï¼Œä¾‹å¦‚ <code>2years</code> æˆ– <code>10minutes</code>ï¼Œä¸­é–“æ²’æœ‰ç©ºæ ¼ã€‚</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/literals.html#admonition-note-1"></a>
</div>
<div>
<p>These arenâ€™t the same as ISO8601, because we evaluated <code>P3Y6M4DT12H30M5S</code> to be difficult to understand, but we could support a simplified form if thereâ€™s demand for it. We donâ€™t currently support compound expressions, for example <code>2years10months</code>, but most DBs will allow <code>2years + 10months</code>. Please raise an issue if this is inconvenient.</p>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-15"><a class="header" href="#prql-15">PRQL</a></h4>
<pre><code class="language-prql">from projects
derive first_check_in = start + 10days
</code></pre>
</div>
<div>
<h4 id="sql-15"><a class="header" href="#sql-15">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  start + INTERVAL 10 DAY AS first_check_in
FROM
  projects

</code></pre>
</div>
</div>
<h3 id="ç¯„ä¾‹"><a class="header" href="#ç¯„ä¾‹">ç¯„ä¾‹</a></h3>
<p>Hereâ€™s a larger list of date and time examples:</p>
<ul>
<li><code>@20221231</code> ç„¡æ•ˆ â€” å®ƒå¿…é ˆåŒ…å«å®Œæ•´çš„æ¨™é»ç¬¦è™Ÿï¼ˆ<code>-</code> å’Œ <code>:</code>ï¼‰ï¼Œ</li>
<li><code>@2022-12-31</code> æ˜¯æ—¥æœŸ</li>
<li><code>@2022-12</code> or <code>@2022</code> are invalid â€” SQL canâ€™t express a month, only a date</li>
<li><code>@16:54:32.123456</code> æ˜¯æ™‚é–“</li>
<li><code>@16:54:32</code>ã€<code>@16:54</code>ã€<code>@16</code> éƒ½æ˜¯å…è¨±çš„ï¼Œåˆ†åˆ¥è¡¨ç¤º <code>@16:54:32.000000</code>ã€<code>@16:54:00.000000</code>ã€<code>@16:00:00.000000</code></li>
<li><code>@2022-12-31T16:54:32.123456</code> æ˜¯æ²’æœ‰æ™‚å€çš„æ™‚é–“æˆ³è¨˜</li>
<li><code>@2022-12-31T16:54:32.123456Z</code> æ˜¯ UTC æ™‚å€çš„æ™‚é–“æˆ³è¨˜</li>
<li><code>@2022-12-31T16:54+02</code> æ˜¯ UTC+2 æ™‚å€çš„æ™‚é–“æˆ³è¨˜</li>
<li><code>@2022-12-31T16:54+02:00</code> å’Œ <code>@2022-12-31T16:54+02</code> æ˜¯ UTC+2 æ™‚å€çš„æ—¥æœŸæ™‚é–“</li>
<li><code>@16:54+02</code> ç„¡æ•ˆ â€” æ™‚é–“ç¸½æ˜¯æœ¬åœ°çš„ï¼Œæ‰€ä»¥å®ƒä¸èƒ½æœ‰æ™‚å€</li>
<li><code>@2022-12-31+02</code> ç„¡æ•ˆ â€” æ—¥æœŸç¸½æ˜¯æœ¬åœ°çš„ï¼Œæ‰€ä»¥å®ƒä¸èƒ½æœ‰æ™‚å€</li>
</ul>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/literals.html#admonition-note-2"></a>
</div>
<div>
<p>Currently prql-compiler does not parse or validate any of the datetime strings and will pass them to the database engine without adjustment. This might be refined in the future to aid in compatibility across databases. Weâ€™ll always support the canonical <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO8601</a> format described above.</p>
</div>
</div>
<h3 id="è·¯ç·šåœ–"><a class="header" href="#è·¯ç·šåœ–">è·¯ç·šåœ–</a></h3>
<p>æ—¥æœŸæ™‚é–“ï¼ˆä½œç‚ºèˆ‡æ™‚é–“æˆ³è¨˜ä¸åŒçš„è³‡æ–™å‹åˆ¥ï¼‰å—æŸäº›è³‡æ–™åº«æ”¯æ´ï¼ˆä¾‹å¦‚ MySqlã€BigQueryï¼‰ã€‚é€šéæ·»åŠ å‹åˆ¥è½‰æ›ï¼Œé€™äº›å¯ä»¥é€šéå°‡æ™‚é–“æˆ³è¨˜è½‰æ›ç‚ºæ—¥æœŸæ™‚é–“ä¾†è¡¨ç¤ºï¼š</p>
<pre><code class="language-prql no-eval">derive pi_day = @2017-03-14T15:09:26.535898&lt;datetime&gt;
</code></pre>
<p>ä»¥ä¸‹æ˜¯æˆ‘å€‘å¯ä»¥æ·»åŠ çš„ä¸€äº›ç¯„ä¾‹ï¼š</p>
<ul>
<li><code>@2022-12-31T16:54&lt;datetime&gt;</code> is datetime without timezone</li>
<li><code>@2022-12-31&lt;datetime&gt;</code> is forbidden â€” datetime must specify time</li>
<li><code>@16:54&lt;datetime&gt;</code> is forbidden â€” datetime must specify date</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å­—ä¸²-1"><a class="header" href="#å­—ä¸²-1">å­—ä¸²</a></h1>
<p>å­—ä¸²å­—é¢å€¼å¯ä»¥ä½¿ç”¨ä»»ä½•åŒ¹é…çš„å¥‡æ•¸å€‹å–®å¼•è™Ÿæˆ–é›™å¼•è™Ÿï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-16"><a class="header" href="#prql-16">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive {
  single        =   'hello world',
  double        =   "hello world",
  double_triple = """hello world""",
}
</code></pre>
</div>
<div>
<h4 id="sql-16"><a class="header" href="#sql-16">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  'hello world' AS single,
  'hello world' AS double,
  'hello world' AS double_triple
FROM
  artists

</code></pre>
</div>
</div>
<h2 id="å¼•ç”¨å’Œè½‰ç¾©å­—å…ƒ"><a class="header" href="#å¼•ç”¨å’Œè½‰ç¾©å­—å…ƒ">å¼•ç”¨å’Œè½‰ç¾©å­—å…ƒ</a></h2>
<p>To quote a string containing quote characters, use the â€œotherâ€ type of quote, or use the escape character <code>\</code>, or use more quotes.</p>
<div class="comparison">
<div>
<h4 id="prql-17"><a class="header" href="#prql-17">PRQL</a></h4>
<pre><code class="language-prql">from artists
select {
  other   = '"hello world"',
  escaped = "\"hello world\"",
  triple  = """I said "hello world"!""",
}
</code></pre>
</div>
<div>
<h4 id="sql-17"><a class="header" href="#sql-17">SQL</a></h4>
<pre><code class="language-sql">SELECT
  '"hello world"' AS other,
  '"hello world"' AS escaped,
  'I said "hello world"!' AS triple
FROM
  artists

</code></pre>
</div>
</div>
<p>å­—ä¸²å¯ä»¥åŒ…å« <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">JSON æ¨™æº–</a>å®šç¾©çš„ä»»ä½•è½‰ç¾©å­—å…ƒåºåˆ—ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-18"><a class="header" href="#prql-18">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive escapes = "\tXYZ\n \\ "                            # tab (\t), "XYZ", newline (\n), " ", \, " "
derive world = "\u{0048}\u{0065}\u{006C}\u{006C}\u{006F}" # "Hello"
derive hex = "\x48\x65\x6C\x6C\x6F"                       # "Hello"
derive turtle = "\u{01F422}"                              # "ğŸ¢"
</code></pre>
</div>
<div>
<h4 id="sql-18"><a class="header" href="#sql-18">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  '	XYZ
 \ ' AS escapes,
  'Hello' AS world,
  'Hello' AS hex,
  'ğŸ¢' AS turtle
FROM
  artists

</code></pre>
</div>
</div>
<h2 id="å…¶ä»–å­—ä¸²æ ¼å¼"><a class="header" href="#å…¶ä»–å­—ä¸²æ ¼å¼">å…¶ä»–å­—ä¸²æ ¼å¼</a></h2>
<ul>
<li><a href="reference/syntax/./f-strings.html"><strong>F-å­—ä¸²</strong></a> - å¾ä¸€çµ„æ¬„ä½æˆ–å€¼å»ºç«‹æ–°å­—ä¸²ã€‚</li>
<li><a href="reference/syntax/./r-strings.html"><strong>R-å­—ä¸²</strong></a> - ä¸å«ä»»ä½•å½¢å¼è½‰ç¾©çš„å­—ä¸²çš„åŸå§‹å­—å…ƒã€‚</li>
<li><a href="reference/syntax/./s-strings.html"><strong>S-strings</strong></a> - Insert SQL statements directly into the query. Use when PRQL doesnâ€™t have an equivalent facility.</li>
</ul>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/strings.html#admonition-warning"></a>
</div>
<div>
<p>Currently PRQL allows multiline strings with either a single character or multiple character quotes. This may change for strings using a single character quote in future versions.</p>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/strings.html#admonition-note"></a>
</div>
<div>
<p>These escape rules specify how PRQL interprets escape characters when compiling strings to SQL, not necessarily how the database will interpret the string. Dialects interpret escape characters differently, and PRQL doesnâ€™t currently account for these differences. Please open issues with any difficulties in the current implementation.</p>
</div>
</div>
<h2 id="è½‰ç¾©åºåˆ—"><a class="header" href="#è½‰ç¾©åºåˆ—">è½‰ç¾©åºåˆ—</a></h2>
<p>é™¤éå­˜åœ¨ <code>r</code> å‰ç¶´ï¼Œå¦å‰‡å­—ä¸²å­—é¢å€¼ä¸­çš„è½‰ç¾©åºåˆ—å°‡æŒ‰ç…§é¡ä¼¼æ–¼æ¨™æº– C æ‰€ä½¿ç”¨çš„è¦å‰‡é€²è¡Œè§£é‡‹ã€‚å…¬èªçš„è½‰ç¾©åºåˆ—æ˜¯ï¼š</p>
<div class="table-wrapper"><table><thead><tr><th>è½‰ç¾©åºåˆ—</th><th>æ„ç¾©</th></tr></thead><tbody>
<tr><td><code>\\</code></td><td>åæ–œç·šï¼ˆï¼‰</td></tr>
<tr><td><code>\'</code></td><td>Single quote (â€™)</td></tr>
<tr><td><code>\"</code></td><td>Double quote (â€œ)</td></tr>
<tr><td><code>\b</code></td><td>é€€æ ¼</td></tr>
<tr><td><code>\f</code></td><td>åˆ†é ç¬¦</td></tr>
<tr><td><code>\n</code></td><td>ASCII æ›è¡Œç¬¦ (LF)</td></tr>
<tr><td><code>\r</code></td><td>ASCII å›è»Šç¬¦ (CR)</td></tr>
<tr><td><code>\t</code></td><td>ASCII æ°´å¹³è£½è¡¨ç¬¦ (TAB)</td></tr>
<tr><td><code>\xhh</code></td><td>åå…­é€²ä½å€¼ç‚º hh çš„å­—å…ƒ</td></tr>
<tr><td><code>\u{xxxx}</code></td><td>åå…­é€²ä½å€¼ç‚º xxxx çš„å­—å…ƒ</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="f-å­—ä¸²"><a class="header" href="#f-å­—ä¸²">F-å­—ä¸²</a></h1>
<p>F-strings are a readable approach to building new strings from existing strings &amp; variables.</p>
<div class="comparison">
<div>
<h4 id="prql-19"><a class="header" href="#prql-19">PRQL</a></h4>
<pre><code class="language-prql">from employees
select full_name = f"{first_name} {last_name}"
</code></pre>
</div>
<div>
<h4 id="sql-19"><a class="header" href="#sql-19">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS full_name
FROM
  employees

</code></pre>
</div>
</div>
<p>This can be much easier to read for longer strings, relative to the SQL approach:</p>
<div class="comparison">
<div>
<h4 id="prql-20"><a class="header" href="#prql-20">PRQL</a></h4>
<pre><code class="language-prql">from web
select url = f"http{tls}://www.{domain}.{tld}/{page}"
</code></pre>
</div>
<div>
<h4 id="sql-20"><a class="header" href="#sql-20">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(
    'http',
    tls,
    '://www.',
    domain,
    '.',
    tld,
    '/',
    page
  ) AS url
FROM
  web

</code></pre>
</div>
</div>
<p>Note that currently interpolations can only contain plain variable names and not whole expression like Python, so this wonâ€™t work:</p>
<div class="comparison">
<div>
<h4 id="prql-21"><a class="header" href="#prql-21">PRQL</a></h4>
<pre><code class="language-prql">from tracks
select length_str = f"{length_seconds / 60} minutes"
</code></pre>
</div>
<div>
<h4 id="error"><a class="header" href="#error">Error</a></h4>
<pre><code class="hljs language-undefined">Error:
   â•­â”€[:2:37]
   â”‚
 2 â”‚ select length_str = f&quot;{length_seconds / 60} minutes&quot;
   â”‚                                     â”¬
   â”‚                                     â•°â”€â”€ unexpected end of input while parsing interpolated string
â”€â”€â”€â•¯
</code></pre>
</div>
</div>
<h2 id="è·¯ç·šåœ–-1"><a class="header" href="#è·¯ç·šåœ–-1">è·¯ç·šåœ–</a></h2>
<p>In the future, f-strings may incorporate string formatting such as datetimes, numbers, and padding. If thereâ€™s a feature that would be helpful, please <a href="https://github.com/PRQL/prql/issues/new/">post an issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="r-å­—ä¸²"><a class="header" href="#r-å­—ä¸²">R-å­—ä¸²</a></h1>
<p>R-strings handle escape characters without special treatment:</p>
<div class="comparison">
<div>
<h4 id="prql-22"><a class="header" href="#prql-22">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive normal_string =  "\\\t"   #  two characters - \ and tab (\t)
derive raw_string    = r"\\\t"   # four characters - \, \, \, and t
</code></pre>
</div>
<div>
<h4 id="sql-21"><a class="header" href="#sql-21">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  '\	' AS normal_string,
  '\\\t' AS raw_string
FROM
  artists

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="s-å­—ä¸²"><a class="header" href="#s-å­—ä¸²">S-å­—ä¸²</a></h1>
<p>An s-string inserts SQL directly, as an escape hatch when thereâ€™s something that PRQL doesnâ€™t yet implement. For example, thereâ€™s a <code>version()</code> function in PostgreSQL that returns the PostgreSQL version, so if we want to use that, we use an s-string:</p>
<div class="comparison">
<div>
<h4 id="prql-23"><a class="header" href="#prql-23">PRQL</a></h4>
<pre><code class="language-prql">from my_table
select db_version = s"version()"
</code></pre>
</div>
<div>
<h4 id="sql-22"><a class="header" href="#sql-22">SQL</a></h4>
<pre><code class="language-sql">SELECT
  version() AS db_version
FROM
  my_table

</code></pre>
</div>
</div>
<p>Embed a column name in an s-string using braces. For example, PRQLâ€™s standard library defines the <code>average</code> function as:</p>
<pre><code class="language-prql no-eval">let average = column -&gt; s"AVG({column})"
</code></pre>
<p>So this compiles using the function:</p>
<div class="comparison">
<div>
<h4 id="prql-24"><a class="header" href="#prql-24">PRQL</a></h4>
<pre><code class="language-prql">from employees
aggregate {average salary}
</code></pre>
</div>
<div>
<h4 id="sql-23"><a class="header" href="#sql-23">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary)
FROM
  employees

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/s-strings.html#admonition-note"></a>
</div>
<div>
<p>Because S-string contents are SQL, double-quotes (<code>"</code>) will denote a <em>column name</em>. To avoid that, use single-quotes (<code>'</code>) around the SQL string, and adjust the quotes of the S-string. For example, instead of <code>s'CONCAT("hello", "world")'</code> use <code>s"CONCAT('hello', 'world')"</code></p>
</div>
</div>
<p>Hereâ€™s an example of a more involved use of an s-string:</p>
<div class="comparison">
<div>
<h4 id="prql-25"><a class="header" href="#prql-25">PRQL</a></h4>
<pre><code class="language-prql">from de=dept_emp
join s=salaries side:left (s.emp_no == de.emp_no &amp;&amp; s"""
  ({s.from_date}, {s.to_date})
  OVERLAPS
  ({de.from_date}, {de.to_date})
""")
</code></pre>
</div>
<div>
<h4 id="sql-24"><a class="header" href="#sql-24">SQL</a></h4>
<pre><code class="language-sql">SELECT
  de.*,
  s.*
FROM
  dept_emp AS de
  LEFT JOIN salaries AS s ON s.emp_no = de.emp_no
  AND (s.from_date, s.to_date) OVERLAPS (de.from_date, de.to_date)

</code></pre>
</div>
</div>
<p>For those who have used Python, s-strings are similar to Pythonâ€™s f-strings, but the result is SQL code, rather than a string literal. For example, a Python f-string of <code>f"average({col})"</code> would produce <code>"average(salary)"</code>, with quotes; while in PRQL, <code>s"average({col})"</code> produces <code>average(salary)</code>, without quotes.</p>
<p>Note that interpolations can only contain plain variable names and not whole expression like Python.</p>
<p>We can also use s-strings to produce a full table:</p>
<div class="comparison">
<div>
<h4 id="prql-26"><a class="header" href="#prql-26">PRQL</a></h4>
<pre><code class="language-prql">from s"SELECT DISTINCT ON first_name, id, age FROM employees ORDER BY age ASC"
join s = s"SELECT * FROM salaries" (==id)
</code></pre>
</div>
<div>
<h4 id="sql-25"><a class="header" href="#sql-25">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    DISTINCT ON first_name,
    id,
    age
  FROM
    employees
  ORDER BY
    age ASC
),
table_1 AS (
  SELECT
    *
  FROM
    salaries
)
SELECT
  table_0.*,
  table_1.*
FROM
  table_0
  JOIN table_1 ON table_0.id = table_1.id

</code></pre>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/s-strings.html#admonition-note-1"></a>
</div>
<div>
<p>S-strings in user code are intended as an escape hatch for an unimplemented feature. If we often need s-strings to express something, thatâ€™s a sign we should implement it in PRQL or PRQLâ€™s stdlib. If you often require an s-string, <a href="https://github.com/PRQL/prql/issues/new/choose">submit an issue with your use case</a>.</p>
</div>
</div>
<h2 id="braces"><a class="header" href="#braces">Braces</a></h2>
<p>To output braces from an s-string, use double braces:</p>
<div class="comparison">
<div>
<h4 id="prql-27"><a class="header" href="#prql-27">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  has_valid_title = s"regexp_contains(title, '([a-z0-9]*-){{2,}}')"
}
</code></pre>
</div>
<div>
<h4 id="sql-26"><a class="header" href="#sql-26">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  regexp_contains(title, '([a-z0-9]*-){2,}') AS has_valid_title
FROM
  employees

</code></pre>
</div>
</div>
<h2 id="precedence-within-s-strings"><a class="header" href="#precedence-within-s-strings">Precedence within s-strings</a></h2>
<p>Variables in s-strings are inserted into the SQL source as-is, which means we may get surprising behavior when the variable has multiple terms and the s-string isnâ€™t parenthesized.</p>
<p>In this toy example, the expression <code>salary + benefits / 365</code> gets precedence wrong. The generated SQL code is as if we had written <code>salary + (benefits / 365)</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-28"><a class="header" href="#prql-28">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = salary + benefits,
  daily_rate = s"{gross_salary} / 365"
}
</code></pre>
</div>
<div>
<h4 id="sql-27"><a class="header" href="#sql-27">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + benefits AS gross_salary,
  salary + benefits / 365 AS daily_rate
FROM
  employees

</code></pre>
</div>
</div>
<p>Instead, the numerator <code>{gross_salary}</code> must be encased in parentheses:</p>
<div class="comparison">
<div>
<h4 id="prql-29"><a class="header" href="#prql-29">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = salary + benefits,
  daily_rate = s"({gross_salary}) / 365"
}
</code></pre>
</div>
<div>
<h4 id="sql-28"><a class="header" href="#sql-28">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + benefits AS gross_salary,
  (salary + benefits) / 365 AS daily_rate
FROM
  employees

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å€¼çµ„"><a class="header" href="#å€¼çµ„">å€¼çµ„</a></h1>
<p>å€¼çµ„æ˜¯ä¸€å€‹å®¹å™¨å‹åˆ¥ï¼Œç”±å¤šå€‹æ¬„ä½çµ„æˆã€‚æ¯å€‹æ¬„ä½å¯ä»¥æœ‰ä¸åŒçš„å‹åˆ¥ã€‚æ¬„ä½çš„æ•¸é‡å’Œå‹åˆ¥å¿…é ˆåœ¨ç·¨è­¯æ™‚å·²çŸ¥ã€‚</p>
<p>å€¼çµ„ç”± <code>{}</code> è¡¨ç¤ºã€‚å®ƒå¯ä»¥è·¨è¶Šå¤šè¡Œã€‚æ¬„ä½å¯ä»¥åˆ†é…åç¨±ã€‚æ¬„ä½ç”±é€—è™Ÿåˆ†éš”ï¼Œå°¾éƒ¨é€—è™Ÿæ˜¯å¯é¸çš„ã€‚</p>
<pre><code class="language-prql no-eval">let var1 = {x = 1, y = 2}

let var2 = {           # Span multiple lines
  a = x,
  b = y                # Optional trailing comma
}

let var3 = {
  c,                   # Individual item
  d = b,               # Assignment
}
</code></pre>
<p>å€¼çµ„æ˜¯è¡¨æ ¼è¡Œçš„å‹åˆ¥ï¼Œé€™æ„å‘³è‘—è¨±å¤šè½‰æ›éƒ½æœŸæœ›å®ƒå€‘ã€‚å¤§å¤šæ•¸è½‰æ›ä¹Ÿå¯ä»¥æ¡ç”¨å–®å€‹æ¬„ä½ï¼Œè©²æ¬„ä½å°‡è¢«è½‰æ›ç‚ºå€¼çµ„ã€‚é€™äº›æ˜¯ç­‰æ•ˆçš„ï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-30"><a class="header" href="#prql-30">PRQL</a></h4>
<pre><code class="language-prql">from employees
select {first_name}
</code></pre>
</div>
<div>
<h4 id="sql-29"><a class="header" href="#sql-29">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-31"><a class="header" href="#prql-31">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-30"><a class="header" href="#sql-30">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/tuples.html#admonition-note"></a>
</div>
<div>
<p>Prior to <code>0.9.0</code>, tuples were previously named Lists, and represented with <code>[]</code> syntax. There may still be references to the old naming.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é™£åˆ—"><a class="header" href="#é™£åˆ—">é™£åˆ—</a></h1>
<p>é™£åˆ—æ˜¯ä¸€å€‹å®¹å™¨å‹åˆ¥ï¼Œç”±å¤šå€‹é …ç›®çµ„æˆã€‚æ‰€æœ‰é …ç›®å¿…é ˆæ˜¯ç›¸åŒå‹åˆ¥ã€‚æ¬„ä½æ•¸é‡å¯ä»¥è®ŠåŒ–ã€‚</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/arrays.html#admonition-warning"></a>
</div>
<div>
<p>This page is a stub.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è­˜åˆ¥ç¬¦èˆ‡é—œéµå­—"><a class="header" href="#è­˜åˆ¥ç¬¦èˆ‡é—œéµå­—">è­˜åˆ¥ç¬¦èˆ‡é—œéµå­—</a></h1>
<p>Identifiers can contain alphanumeric characters and <code>_</code> and must not start with a number. They can be chained together with the <code>.</code> indirection operator, used to retrieve a tuple from a field or a variable from a module.</p>
<pre><code class="language-prql no-eval">hello

_h3llo

hello.world
</code></pre>
<h2 id="this-å’Œ-that"><a class="header" href="#this-å’Œ-that"><code>this</code> å’Œ <code>that</code></a></h2>
<p><code>this</code> æŒ‡çš„æ˜¯ç›®å‰çš„é—œè¯ï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-32"><a class="header" href="#prql-32">PRQL</a></h4>
<pre><code class="language-prql">from invoices
aggregate (
    count this
)
</code></pre>
</div>
<div>
<h4 id="sql-31"><a class="header" href="#sql-31">SQL</a></h4>
<pre><code class="language-sql">SELECT
  COUNT(*)
FROM
  invoices

</code></pre>
</div>
</div>
<p>åœ¨ <a href="reference/syntax/../stdlib/transforms/join.html"><code>join</code></a> ä¸­ï¼Œ<code>that</code> æŒ‡çš„æ˜¯å¦ä¸€å€‹è¡¨æ ¼ï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-33"><a class="header" href="#prql-33">PRQL</a></h4>
<pre><code class="language-prql">from invoices
join tracks (this.track_id==that.id)
</code></pre>
</div>
<div>
<h4 id="sql-32"><a class="header" href="#sql-32">SQL</a></h4>
<pre><code class="language-sql">SELECT
  invoices.*,
  tracks.*
FROM
  invoices
  JOIN tracks ON invoices.track_id = tracks.id

</code></pre>
</div>
</div>
<p><code>this</code> can also be used to remove any column ambiguity. For example, currently using a bare <code>time</code> as a column name will fail, because itâ€™s also a type:</p>
<div class="comparison">
<div>
<h4 id="prql-34"><a class="header" href="#prql-34">PRQL</a></h4>
<pre><code class="language-prql">from invoices
derive t = time
</code></pre>
</div>
<div>
<h4 id="error-1"><a class="header" href="#error-1">Error</a></h4>
<pre><code class="hljs language-undefined">Error:
   â•­â”€[:2:12]
   â”‚
 2 â”‚ derive t = time
   â”‚            â”€â”€â”¬â”€
   â”‚              â•°â”€â”€â”€ expected a value, but found a type
â”€â”€â”€â•¯
</code></pre>
</div>
</div>
<p>ä½†æœ‰äº† <code>this.time</code>ï¼Œæˆ‘å€‘å¯ä»¥ç§»é™¤æ­§ç¾©ï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-35"><a class="header" href="#prql-35">PRQL</a></h4>
<pre><code class="language-prql">from invoices
derive t = this.time
</code></pre>
</div>
<div>
<h4 id="sql-33"><a class="header" href="#sql-33">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  time AS t
FROM
  invoices

</code></pre>
</div>
</div>
<h2 id="å¼•è¿°"><a class="header" href="#å¼•è¿°">å¼•è¿°</a></h2>
<p>ç‚ºäº†ä½¿ç”¨å…¶ä»–æ–¹å¼ç„¡æ•ˆçš„å­—å…ƒï¼Œè­˜åˆ¥ç¬¦å¯ä»¥ç”¨åå¼•è™Ÿæ‹¬èµ·ä¾†ã€‚</p>
<p>ç·¨è­¯ç‚º SQL æ™‚ï¼Œé€™äº›è­˜åˆ¥ç¬¦å°‡ä½¿ç”¨æ–¹è¨€ç‰¹å®šçš„å¼•è™Ÿå’Œå¼•è¿°è¦å‰‡ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-36"><a class="header" href="#prql-36">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mysql
from employees
select `first name`
</code></pre>
</div>
<div>
<h4 id="sql-34"><a class="header" href="#sql-34">SQL</a></h4>
<pre><code class="language-sql">SELECT
  `first name`
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-37"><a class="header" href="#prql-37">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.postgres
from employees
select `first name`
</code></pre>
</div>
<div>
<h4 id="sql-35"><a class="header" href="#sql-35">SQL</a></h4>
<pre><code class="language-sql">SELECT
  "first name"
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-38"><a class="header" href="#prql-38">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.bigquery

from `project-foo.dataset.table`
join `project-bar.dataset.table` (==col_bax)
</code></pre>
</div>
<div>
<h4 id="sql-36"><a class="header" href="#sql-36">SQL</a></h4>
<pre><code class="language-sql">SELECT
  `project-foo.dataset.table`.*,
  `project-bar.dataset.table`.*
FROM
  `project-foo.dataset.table`
  JOIN `project-bar.dataset.table` ON `project-foo.dataset.table`.col_bax = `project-bar.dataset.table`.col_bax

</code></pre>
</div>
</div>
<h2 id="ç¶±è¦å’Œè³‡æ–™åº«åç¨±"><a class="header" href="#ç¶±è¦å’Œè³‡æ–™åº«åç¨±">ç¶±è¦å’Œè³‡æ–™åº«åç¨±</a></h2>
<p>è³‡æ–™åº«è¡¨æ ¼çš„è­˜åˆ¥ç¬¦å¯ä»¥åŠ ä¸Šç¶±è¦å’Œè³‡æ–™åº«åç¨±çš„å‰ç¶´ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-39"><a class="header" href="#prql-39">PRQL</a></h4>
<pre><code class="language-prql">from my_database.chinook.albums
</code></pre>
</div>
<div>
<h4 id="sql-37"><a class="header" href="#sql-37">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  my_database.chinook.albums

</code></pre>
</div>
</div>
<p>è«‹æ³¨æ„ï¼Œä»¥ä¸‹æ‰€æœ‰è­˜åˆ¥ç¬¦éƒ½å°‡è¢«è¦–ç‚ºå–®ç¨çš„è¡¨æ ¼å®šç¾©ï¼š<code>tracks</code>ã€<code>public.tracks</code>ã€<code>my_database.public.tracks</code>ã€‚</p>
<h2 id="é—œéµå­—"><a class="header" href="#é—œéµå­—">é—œéµå­—</a></h2>
<p>PRQL ä½¿ç”¨äº†ä»¥ä¸‹é—œéµå­—ï¼š</p>
<ul>
<li><strong><code>prql</code></strong> - query header <a href="reference/syntax/../../project/target.html"><em>moreâ€¦</em></a></li>
<li><strong><code>let</code></strong> - variable definition <a href="reference/syntax/../declarations/variables.html"><em>moreâ€¦</em></a></li>
<li><strong><code>into</code></strong> - variable definition <a href="reference/syntax/../declarations/variables.html"><em>moreâ€¦</em></a></li>
<li><strong><code>case</code></strong> - flow control <a href="reference/syntax/../syntax/case.html"><em>moreâ€¦</em></a></li>
<li><strong><code>type</code></strong> - å‹åˆ¥å®£å‘Š</li>
<li><strong><code>func</code></strong> - explicit function declaration <a href="reference/syntax/../declarations/functions.html"><em>moreâ€¦</em></a></li>
<li><strong><code>module</code></strong> - å…§éƒ¨ä½¿ç”¨</li>
<li><strong><code>internal</code></strong> - å…§éƒ¨ä½¿ç”¨</li>
<li><strong><code>true</code></strong> - boolean <a href="reference/syntax/./literals.html#booleans"><em>moreâ€¦</em></a></li>
<li><strong><code>false</code></strong> - boolean <a href="reference/syntax/./literals.html#booleans"><em>moreâ€¦</em></a></li>
<li><strong><code>null</code></strong> - NULL <a href="reference/syntax/./literals.html#null"><em>moreâ€¦</em></a></li>
</ul>
<p>é—œéµå­—å¯ä»¥ç”¨ä½œè­˜åˆ¥ç¬¦ï¼ˆæ¬„ä½æˆ–è®Šæ•¸ï¼‰ï¼Œç•¶è¢«åå¼•è™Ÿæ‹¬èµ·ä¾†æ™‚ï¼š<code>`case`</code>ã€‚</p>
<p>è½‰æ›æ˜¯ <code>std</code> å‘½åç©ºé–“ä¸­çš„æ™®é€šå‡½å¼ï¼Œä¸æ˜¯é—œéµå­—ã€‚ä¹Ÿå°±æ˜¯èªªï¼Œ<code>std.from</code> èˆ‡ <code>from</code> æ˜¯ç›¸åŒçš„å‡½å¼ã€‚åœ¨ä¸‹é¢çš„ç¯„ä¾‹ä¸­ï¼Œç”¢ç”Ÿçš„æŸ¥è©¢èˆ‡æ²’æœ‰ <code>std.</code> å‘½åç©ºé–“æ™‚ç›¸åŒï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-40"><a class="header" href="#prql-40">PRQL</a></h4>
<pre><code class="language-prql">std.from my_table
std.select {from = my_table.a, take = my_table.b}
std.take 3
</code></pre>
</div>
<div>
<h4 id="sql-38"><a class="header" href="#sql-38">SQL</a></h4>
<pre><code class="language-sql">SELECT
  a AS "from",
  b AS take
FROM
  my_table
LIMIT
  3

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å‡½å¼å‘¼å«"><a class="header" href="#å‡½å¼å‘¼å«">å‡½å¼å‘¼å«</a></h1>
<h2 id="ç°¡å–®"><a class="header" href="#ç°¡å–®">ç°¡å–®</a></h2>
<p>PRQL å’Œå¤§å¤šæ•¸å…¶ä»–ç¨‹å¼èªè¨€ä¹‹é–“çš„å€åˆ¥æ˜¯å‡½å¼å‘¼å«èªæ³•ã€‚å®ƒç”±å‡½å¼åç¨±çµ„æˆï¼Œå¾Œé¢è·Ÿè‘—ä»¥ç©ºæ ¼åˆ†éš”çš„å¼•æ•¸ã€‚</p>
<pre><code class="language-prql no-eval">function_name arg1 arg2 arg3
</code></pre>
<p>å¦‚æœå…¶ä¸­ä¸€å€‹å¼•æ•¸ä¹Ÿæ˜¯å‡½å¼å‘¼å«ï¼Œå®ƒå¿…é ˆç”¨æ‹¬è™Ÿæ‹¬èµ·ä¾†ï¼Œé€™æ¨£æˆ‘å€‘æ‰èƒ½çŸ¥é“å…§éƒ¨å‡½å¼çš„å¼•æ•¸åœ¨å“ªè£¡çµæŸï¼Œå¤–éƒ¨å‡½å¼çš„å¼•æ•¸åœ¨å“ªè£¡é–‹å§‹ã€‚</p>
<pre><code class="language-prql no-eval">outer_func arg_1 (inner_func arg_a, arg_b) arg_2
</code></pre>
<p>å‡½å¼åç¨±å¿…é ˆæŒ‡å‘å‡½å¼è®Šæ•¸ï¼Œè©²è®Šæ•¸è¦éº¼åœ¨<a href="reference/syntax/../stdlib/">æ¨™æº–å‡½å¼åº«</a>ä¸­<a href="reference/syntax/../declarations/functions.html">å·²è¢«å®£å‘Š</a>ï¼Œè¦éº¼åœ¨å…¶ä»–æŸå€‹æ¨¡çµ„ä¸­ã€‚</p>
<p>å‡½å¼å‘¼å«ä¹Ÿå¯ä»¥ä½¿ç”¨ <code>:</code> ç¬¦è™ŸæŒ‡å®šå…·ååƒæ•¸ï¼š</p>
<pre><code class="language-prql no-eval">function_name arg1 named_param:arg2 arg3
</code></pre>
<h2 id="ç®¡é“"><a class="header" href="#ç®¡é“">ç®¡é“</a></h2>
<p>æœ‰å¦ä¸€ç¨®å‘¼å«å‡½å¼çš„æ–¹å¼ï¼šä½¿ç”¨ç®¡é“ã€‚ç„¡è«–ç®¡é“æ˜¯ç”±ç®¡é“ç¬¦è™Ÿ <code>|</code> é‚„æ˜¯æ–°è¡Œåˆ†éš”ï¼Œç®¡é“ç›¸ç•¶æ–¼å°‡æ¯å€‹å‡½å¼ä½œç‚ºä¸‹ä¸€å€‹å‡½å¼çš„æœ€å¾Œä¸€å€‹å¼•æ•¸æ‡‰ç”¨ã€‚</p>
<pre><code class="language-prql no-eval">a | foo 3 | bar 'hello' 'world' | baz
</code></pre>
<p>â€¦ is equivalent to â€¦</p>
<pre><code class="language-prql no-eval">baz (bar 'hello' 'world' (foo 3 a))
</code></pre>
<!--
TODO: this should be a part of the tutorial


As you may have noticed, transforms are regular functions too!

```prql
from employees
filter age > 50
sort name
```

... is equivalent to ...

```prql
from employees | filter age > 50 | sort name
```

... is equivalent to ...

```prql
filter age > 50 (from employees) | sort name
```

... is equivalent to ...

```prql
sort name (filter age > 50 (from employees))
```

As you can see, the first example with pipeline notation is much easier to
comprehend, compared to the last one with the regular function call notation.
This is why it is recommended to use pipelines for nested function calls that
are 3 or more levels deep.

-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç®¡é“-1"><a class="header" href="#ç®¡é“-1">ç®¡é“</a></h1>
<p>ç®¡é“æ˜¯çµ„æˆç®¡é“çš„<a href="reference/syntax/../stdlib/transforms/">è½‰æ›</a>ä¹‹é–“çš„é€£æ¥ã€‚ç®¡é“å‰çš„è½‰æ›æ‰€ç”¢ç”Ÿçš„é—œè¯ç”¨ä½œç®¡é“å¾Œè½‰æ›çš„è¼¸å…¥ã€‚ç®¡é“å¯ä»¥ç”¨æ›è¡Œç¬¦æˆ–ç®¡é“å­—å…ƒ (<code>|</code>) è¡¨ç¤ºã€‚</p>
<p>ä¾‹å¦‚ï¼Œé€™è£¡ <code>filter</code> è½‰æ›å° <code>from employees</code>ï¼ˆé€™åªæ˜¯ <code>employees</code> è¡¨æ ¼ï¼‰çš„çµæœé€²è¡Œæ“ä½œï¼Œ<code>select</code> è½‰æ›å° <code>filter</code> è½‰æ›çš„çµæœé€²è¡Œæ“ä½œã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-41"><a class="header" href="#prql-41">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter department == "Product"
select {first_name, last_name}
</code></pre>
</div>
<div>
<h4 id="sql-39"><a class="header" href="#sql-39">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees
WHERE
  department = 'Product'

</code></pre>
</div>
</div>
<p>In the place of a line break, itâ€™s also possible to use the <code>|</code> character to pipe results between transforms, such that this is equivalent:</p>
<div class="comparison">
<div>
<h4 id="prql-42"><a class="header" href="#prql-42">PRQL</a></h4>
<pre><code class="language-prql">from employees | filter department == "Product" | select {first_name, last_name}
</code></pre>
</div>
<div>
<h4 id="sql-40"><a class="header" href="#sql-40">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees
WHERE
  department = 'Product'

</code></pre>
</div>
</div>
<p>In almost all situations, a line break acts as a pipe. But there are a few exceptions where a line break doesnâ€™t create a pipeline:</p>
<ul>
<li>within a tuple</li>
<li>within an array</li>
<li>when the following line is a new statement, which starts with a keyword of <code>func</code>, <code>let</code> or <code>from</code></li>
<li>Within a <a href="reference/syntax/./operators.html#wrapping-lines">line wrap</a></li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-43"><a class="header" href="#prql-43">PRQL</a></h4>
<pre><code class="language-prql">from [        # Line break OK in an array
  {a=2, b=3}
]
derive {      # Line break OK in a tuple
  c = 2 * a,
}
</code></pre>
</div>
<div>
<h4 id="sql-41"><a class="header" href="#sql-41">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    2 AS a,
    3 AS b
)
SELECT
  a,
  b,
  2 * a AS c
FROM
  table_0

</code></pre>
</div>
</div>
<h2 id="inner-transforms"><a class="header" href="#inner-transforms">Inner Transforms</a></h2>
<!-- TODO: I don't think this really fits here -->
<p>Parentheses are also used for transforms (such as <code>group</code> and <code>window</code>) that pass their result to an â€œinner transformâ€. The example below applies the <code>aggregate</code> pipeline to each group of unique <code>title</code> and <code>country</code> values:</p>
<div class="comparison">
<div>
<h4 id="prql-44"><a class="header" href="#prql-44">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {title, country} (
  aggregate {
    average salary,
    ct = count salary,
  }
)
</code></pre>
</div>
<div>
<h4 id="sql-42"><a class="header" href="#sql-42">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é‹ç®—å­"><a class="header" href="#é‹ç®—å­">é‹ç®—å­</a></h1>
<p>è¡¨é”å¼å¯ä»¥ç”± <em>å‡½å¼å‘¼å«</em> å’Œ <em>é‹ç®—</em> çµ„æˆï¼Œä¾‹å¦‚ <code>2 + 3</code> æˆ– <code>((1 + x) * -y)</code>ã€‚åœ¨ä¸‹æ–¹çš„ç¯„ä¾‹ä¸­ï¼Œè«‹æ³¨æ„ä½¿ç”¨è¡¨é”å¼è¨ˆç®—åˆ¥å <code>circumference</code> å’Œåœ¨ <code>filter</code> è½‰æ›ä¸­çš„ç”¨æ³•ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-45"><a class="header" href="#prql-45">PRQL</a></h4>
<pre><code class="language-prql">from foo
select {
  circumference = diameter * 3.14159,
  color,
}
filter circumference &gt; 10 &amp;&amp; color != "red"
</code></pre>
</div>
<div>
<h4 id="sql-43"><a class="header" href="#sql-43">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    diameter * 3.14159 AS circumference,
    color
  FROM
    foo
)
SELECT
  circumference,
  color
FROM
  table_0
WHERE
  circumference &gt; 10
  AND color &lt;&gt; 'red'

</code></pre>
</div>
</div>
<h2 id="é‹ç®—å­å„ªå…ˆç´š"><a class="header" href="#é‹ç®—å­å„ªå…ˆç´š">é‹ç®—å­å„ªå…ˆç´š</a></h2>
<p>æ­¤è¡¨é¡¯ç¤ºé‹ç®—å­å„ªå…ˆç´šã€‚ä½¿ç”¨æ‹¬è™Ÿ <code>()</code> å„ªå…ˆé †åºæ’åˆ—é‹ç®—å’Œå‡½å¼å‘¼å«ï¼ˆåƒé–±ä¸‹é¢çš„è¨è«–ã€‚ï¼‰</p>
<!-- markdownlint-disable MD033 â€” the `|` characters need to be escaped, and surrounded with tags rather than backticks   -->
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">ç¾¤çµ„</th><th>é‹ç®—å­</th><th style="text-align: center">å„ªå…ˆç´š</th><th style="text-align: center">çµåˆæ€§</th></tr></thead><tbody>
<tr><td style="text-align: right">æ‹¬è™Ÿ</td><td><code>()</code></td><td style="text-align: center">0</td><td style="text-align: center">è¦‹ä¸‹æ–‡</td></tr>
<tr><td style="text-align: right">è­˜åˆ¥ç¬¦é»</td><td><code>.</code></td><td style="text-align: center">1</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: right">ä¸€å…ƒ</td><td><code>-</code> <code>+</code> <code>!</code> <code>==</code></td><td style="text-align: center">2</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: right">ç¯„åœ</td><td><code>..</code></td><td style="text-align: center">3</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: right">ä¹˜æ³•</td><td><code>*</code> <code>/</code> <code>//</code> <code>%</code></td><td style="text-align: center">4</td><td style="text-align: center">å·¦è‡³å³</td></tr>
<tr><td style="text-align: right">åŠ æ³•</td><td><code>+</code> <code>-</code></td><td style="text-align: center">5</td><td style="text-align: center">å·¦è‡³å³</td></tr>
<tr><td style="text-align: right">æ¯”è¼ƒ</td><td><code>==</code> <code>!=</code> <code>&lt;=</code> <code>&gt;=</code> <code>&lt;</code> <code>&gt;</code></td><td style="text-align: center">6</td><td style="text-align: center">å·¦è‡³å³</td></tr>
<tr><td style="text-align: right">åˆä½µ</td><td><code>??</code></td><td style="text-align: center">7</td><td style="text-align: center">å·¦è‡³å³</td></tr>
<tr><td style="text-align: right">ä¸”</td><td><code>&amp;&amp;</code></td><td style="text-align: center">8</td><td style="text-align: center">å·¦è‡³å³</td></tr>
<tr><td style="text-align: right">æˆ–</td><td><code>|&lt;/code&gt;</td><td style="text-align: center">9</td><td style="text-align: center">å·¦è‡³å³</td></tr>
<tr><td style="text-align: right">å‡½å¼å‘¼å«</td><td></td><td style="text-align: center">10</td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<h2 id="é™¤æ³•å’Œæ•´æ•¸é™¤æ³•"><a class="header" href="#é™¤æ³•å’Œæ•´æ•¸é™¤æ³•">é™¤æ³•å’Œæ•´æ•¸é™¤æ³•</a></h2>
<p><code>/</code> é‹ç®—å­åŸ·è¡Œç¸½æ˜¯è¿”å›æµ®é»å€¼çš„é™¤æ³•ï¼Œè€Œ <code>//</code> é‹ç®—å­åŸ·è¡Œæ•´æ•¸é™¤æ³•ï¼ˆæˆªæ–·é™¤æ³•ï¼‰ï¼Œç¸½æ˜¯è¿”å›æ•´æ•¸å€¼ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-46"><a class="header" href="#prql-46">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.sqlite

from [
  {a = 5, b = 2},
  {a = 5, b = -2},
]
select {
  div_out = a / b,
  int_div_out = a // b,
}
</code></pre>
</div>
<div>
<h4 id="sql-44"><a class="header" href="#sql-44">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    5 AS a,
    2 AS b
  UNION
  ALL
  SELECT
    5 AS a,
    -2 AS b
)
SELECT
  (a * 1.0 / b) AS div_out,
  ROUND(ABS(a / b) - 0.5) * SIGN(a) * SIGN(b) AS int_div_out
FROM
  table_0

</code></pre>
</div>
</div>
<h2 id="åˆä½µ"><a class="header" href="#åˆä½µ">åˆä½µ</a></h2>
<p>æˆ‘å€‘å¯ä»¥ä½¿ç”¨ <code>??</code> é‹ç®—å­åˆä½µå€¼ã€‚åˆä½µæœƒå–ç¬¬ä¸€å€‹å€¼ï¼Œæˆ–è€…å¦‚æœè©²å€¼ç‚ºç©ºï¼Œå‰‡å–ç¬¬äºŒå€‹å€¼ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-47"><a class="header" href="#prql-47">PRQL</a></h4>
<pre><code class="language-prql">from orders
derive amount ?? 0
</code></pre>
</div>
<div>
<h4 id="sql-45"><a class="header" href="#sql-45">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  COALESCE(amount, 0)
FROM
  orders

</code></pre>
</div>
</div>
<h2 id="å¸¸è¦è¡¨é”å¼"><a class="header" href="#å¸¸è¦è¡¨é”å¼">å¸¸è¦è¡¨é”å¼</a></h2>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/operators.html#admonition-note"></a>
</div>
<div>
<p>This is currently experimental</p>
</div>
</div>
<p>è¦åŸ·è¡Œå€åˆ†å¤§å°å¯«çš„å¸¸è¦è¡¨é”å¼æœç´¢ï¼Œè«‹ä½¿ç”¨ <code>~=</code> é‹ç®—å­ã€‚é€™é€šå¸¸ç·¨è­¯ç‚º <code>REGEXP</code>ï¼Œå„˜ç®¡å› æ–¹è¨€è€Œç•°ã€‚å¸¸è¦è¡¨é”å¼æœç´¢æ„å‘³è‘—è¦åŒ¹é…ç¢ºåˆ‡çš„å€¼ï¼Œé–‹å§‹å’ŒçµæŸéœ€è¦ç”¨ <code>^foo$</code> éŒ¨å®šã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-48"><a class="header" href="#prql-48">PRQL</a></h4>
<pre><code class="language-prql">from tracks
filter (name ~= "Love")
</code></pre>
</div>
<div>
<h4 id="sql-46"><a class="header" href="#sql-46">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP(name, 'Love')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-49"><a class="header" href="#prql-49">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.duckdb

from artists
filter (name ~= "Love.*You")
</code></pre>
</div>
<div>
<h4 id="sql-47"><a class="header" href="#sql-47">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  artists
WHERE
  REGEXP_MATCHES(name, 'Love.*You')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-50"><a class="header" href="#prql-50">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.bigquery

from tracks
filter (name ~= "\\bLove\\b")
</code></pre>
</div>
<div>
<h4 id="sql-48"><a class="header" href="#sql-48">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP_CONTAINS(name, '\bLove\b')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-51"><a class="header" href="#prql-51">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.postgres

from tracks
filter (name ~= "\\(I Can't Help\\) Falling")
</code></pre>
</div>
<div>
<h4 id="sql-49"><a class="header" href="#sql-49">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  name ~ '\(I Can''t Help\) Falling'

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-52"><a class="header" href="#prql-52">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mysql

from tracks
filter (name ~= "With You")
</code></pre>
</div>
<div>
<h4 id="sql-50"><a class="header" href="#sql-50">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP_LIKE(name, 'With You', 'c')

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-53"><a class="header" href="#prql-53">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.sqlite

from tracks
filter (name ~= "But Why Isn't Your Syntax More Similar\\?")
</code></pre>
</div>
<div>
<h4 id="sql-51"><a class="header" href="#sql-51">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  name REGEXP 'But Why Isn''t Your Syntax More Similar\?'

</code></pre>
</div>
</div>
<h2 id="æ‹¬è™Ÿ"><a class="header" href="#æ‹¬è™Ÿ">æ‹¬è™Ÿ</a></h2>
<p>PRQL ä½¿ç”¨æ‹¬è™Ÿ <code>()</code> æœ‰å¹¾å€‹ç›®çš„ï¼š</p>
<ul>
<li>
<p>æ‹¬è™Ÿå°æ“ä½œæ•¸é€²è¡Œåˆ†çµ„ä»¥æ§åˆ¶è©•ä¼°é †åºï¼Œä¾‹å¦‚ï¼š<code>((1 + x) * y)</code></p>
</li>
<li>
<p>æ‹¬è™Ÿç”¨æ–¼åˆ†éš”å‡½å¼å¼•æ•¸çš„æ¸›è™Ÿï¼Œä¾‹å¦‚ï¼š<code>add (-1) (-3)</code></p>
</li>
<li>
<p>""æ‹¬è™Ÿç”¨æ–¼åˆ†éš”åŒ…å«ç®¡é“çš„åµŒå¥—å‡½å¼å‘¼å«ï¼Œå¯ä»¥æ˜¯ <code>|</code> ç¬¦è™Ÿæˆ–æ–°è¡Œã€‚"åµŒå¥—"æ˜¯æŒ‡åœ¨è½‰æ›ä¸­ï¼›å³ä¸åƒ…åƒ…æ˜¯ä¸»ç®¡é“ï¼Œä¾‹å¦‚ï¼š<code>(column-name | in 0..20)</code></p>
</li>
<li>
<p>Parentheses wrap a function call that is part of a larger expression, for example: <code>round 0 (sum distance)</code></p>
</li>
</ul>
<p>æ‹¬è™Ÿå°æ–¼ä¸åŒ…å«å‡½å¼å‘¼å«çš„è¡¨é”å¼<strong>ä¸æ˜¯</strong>å¿…éœ€çš„ï¼Œä¾‹å¦‚ï¼š<code>foo + bar</code>ã€‚</p>
<p>Hereâ€™s a set of examples of these rules:</p>
<div class="comparison">
<div>
<h4 id="prql-54"><a class="header" href="#prql-54">PRQL</a></h4>
<pre><code class="language-prql">from employees
# Requires parentheses, because it contains a pipe
derive is_proximate = (distance | in 0..20)
# Requires parentheses, because it's a function call
derive total_distance = (sum distance)
# `??` doesn't require parentheses, as it's not a function call
derive min_capped_distance = (min distance ?? 5)
# No parentheses needed, because no function call
derive travel_time = distance / 40
# No inner parentheses needed around `1+1` because no function call
derive distance_rounded_2_dp = (round 1+1 distance)
derive {
  # Requires parentheses, because it contains a pipe
  is_far = (distance | in 100..),
  # The left value of the range requires parentheses,
  # because of the minus sign
  is_negative = (distance | in (-100..0)),
  # ...this is equivalent
  is_negative = (distance | in (-100)..0),
  # _Technically_, this doesn't require parentheses, because it's
  # the RHS of an assignment in a tuple
  # (this is especially confusing)
  average_distance = average distance,
}
# Requires parentheses because of the minus sign
sort (-distance)
# A tuple is fine too
sort {-distance}
</code></pre>
</div>
<div>
<h4 id="sql-52"><a class="header" href="#sql-52">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  distance BETWEEN 0 AND 20 AS is_proximate,
  SUM(distance) OVER () AS total_distance,
  MIN(COALESCE(distance, 5)) OVER () AS min_capped_distance,
  distance / 40 AS travel_time,
  ROUND(distance, 1 + 1) AS distance_rounded_2_dp,
  distance &gt;= 100 AS is_far,
  distance BETWEEN -100 AND 0,
  distance BETWEEN -100 AND 0 AS is_negative,
  AVG(distance) OVER () AS average_distance
FROM
  employees
ORDER BY
  distance DESC

</code></pre>
</div>
</div>
<p>ä¾‹å¦‚ï¼Œä¸‹é¢çš„ä»£ç¢¼ç‰‡æ®µç”¢ç”ŸéŒ¯èª¤ï¼Œå› ç‚º <code>sum</code> å‡½å¼å‘¼å«ä¸åœ¨å…ƒçµ„ä¸­ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-55"><a class="header" href="#prql-55">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive total_distance = sum distance
</code></pre>
</div>
<div>
<h4 id="error-2"><a class="header" href="#error-2">Error</a></h4>
<pre><code class="hljs language-undefined">Error:
   â•­â”€[:2:29]
   â”‚
 2 â”‚ derive total_distance = sum distance
   â”‚                             â”€â”€â”€â”€â”¬â”€â”€â”€
   â”‚                                 â•°â”€â”€â”€â”€â”€ Unknown name `distance`
â”€â”€â”€â•¯
</code></pre>
</div>
</div>
<p>â€¦while with parentheses, it works at expected:</p>
<div class="comparison">
<div>
<h4 id="prql-56"><a class="header" href="#prql-56">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive other_distance = (sum distance)
</code></pre>
</div>
<div>
<h4 id="sql-53"><a class="header" href="#sql-53">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  SUM(distance) OVER () AS other_distance
FROM
  employees

</code></pre>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/operators.html#admonition-note-1"></a>
</div>
<div>
<p>Weâ€™re continuing to think whether these rules can be more intuitive. Weâ€™re also planning to make the error messages much better, so the compiler can help out.</p>
</div>
</div>
<h2 id="æ›è¡Œ"><a class="header" href="#æ›è¡Œ">æ›è¡Œ</a></h2>
<p>PRQL ä¸­çš„æ›è¡Œæœ‰èªç¾©å«ç¾©ï¼Œæ‰€ä»¥è¦å°‡å–®å€‹é‚è¼¯è¡Œæ›è¡Œç‚ºå¤šå€‹ç‰©ç†è¡Œï¼Œæˆ‘å€‘å¯ä»¥åœ¨å¾ŒçºŒç‰©ç†è¡Œçš„é–‹å§‹è™•ä½¿ç”¨ <code>\</code>ï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-57"><a class="header" href="#prql-57">PRQL</a></h4>
<pre><code class="language-prql">from artists
select is_europe =
\ country == "DE"
\ || country == "FR"
\ || country == "ES"
</code></pre>
</div>
<div>
<h4 id="sql-54"><a class="header" href="#sql-54">SQL</a></h4>
<pre><code class="language-sql">SELECT
  country = 'DE'
  OR country = 'FR'
  OR country = 'ES' AS is_europe
FROM
  artists

</code></pre>
</div>
</div>
<p>Wrapping will â€œjump overâ€ empty lines or lines with comments. For example, the <code>select</code> here is only one logical line:</p>
<div class="comparison">
<div>
<h4 id="prql-58"><a class="header" href="#prql-58">PRQL</a></h4>
<pre><code class="language-prql">from tracks
# This would be a really long line without being able to split it:
select listening_time_years = (spotify_plays + apple_music_plays + pandora_plays)
# We can toggle between lines when developing:
# \ * length_seconds
\ * length_s
#   min  hour day  year
\ / 60 / 60 / 24 / 365
</code></pre>
</div>
<div>
<h4 id="sql-55"><a class="header" href="#sql-55">SQL</a></h4>
<pre><code class="language-sql">SELECT
  (
    spotify_plays + apple_music_plays + pandora_plays
  ) * length_s / 60 / 60 / 24 / 365 AS listening_time_years
FROM
  tracks

</code></pre>
</div>
</div>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/operators.html#admonition-info"></a>
</div>
<div>
<p>Note that PRQL differs from most languages, which use a <code>\</code> at the <em>end</em> of the preceding line. Because PRQL aims to be friendly for data exploration, we want to make it possible to comment out any line, including the final line, without breaking the query. This requires all lines after the first to be structured similarly, and for the character to be at the start of each following line.</p>
</div>
</div>
<p>æœ‰é—œæ›è¡Œçš„æ›´å¤šè©³ç´°è³‡è¨Šï¼Œè«‹åƒé–± <a href="reference/syntax/./pipes.html">Pipes</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æƒ…æ³"><a class="header" href="#æƒ…æ³">æƒ…æ³</a></h1>
<p>æœå°‹ç¬¬ä¸€å€‹è©•ä¼°ç‚º <code>true</code> çš„æ¢ä»¶ä¸¦è¿”å›å…¶é—œè¯å€¼ã€‚å¦‚æœæ²’æœ‰æ¢ä»¶ç¬¦åˆï¼Œå‰‡è¿”å› <code>null</code>ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-59"><a class="header" href="#prql-59">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive distance = case [
  city == "Calgary" =&gt; 0,
  city == "Edmonton" =&gt; 300,
]
</code></pre>
</div>
<div>
<h4 id="sql-56"><a class="header" href="#sql-56">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  CASE
    WHEN city = 'Calgary' THEN 0
    WHEN city = 'Edmonton' THEN 300
    ELSE NULL
  END AS distance
FROM
  employees

</code></pre>
</div>
</div>
<p>è¦è¨­å®šé è¨­å€¼ï¼Œå¯ä»¥ä½¿ç”¨ <code>true</code> æ¢ä»¶ï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-60"><a class="header" href="#prql-60">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive distance = case [
  city == "Calgary" =&gt; 0,
  city == "Edmonton" =&gt; 300,
  true =&gt; "Unknown",
]
</code></pre>
</div>
<div>
<h4 id="sql-57"><a class="header" href="#sql-57">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  CASE
    WHEN city = 'Calgary' THEN 0
    WHEN city = 'Edmonton' THEN 300
    ELSE 'Unknown'
  END AS distance
FROM
  employees

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç¯„åœ"><a class="header" href="#ç¯„åœ">ç¯„åœ</a></h1>
<p>ç¯„åœ <code>start..end</code> è¡¨ç¤º <code>start</code> å’Œ <code>end</code> ä¹‹é–“çš„ä¸€çµ„å€¼ï¼ˆå«æ‹¬ï¼Œå¤§æ–¼ç­‰æ–¼ <code>start</code> ä¸”å°æ–¼ç­‰æ–¼ <code>end</code>ï¼‰ã€‚</p>
<p>è‹¥è¦è¡¨ç¤ºåœ¨ä¸€å´é–‹æ”¾çš„ç¯„åœï¼Œå¯ä»¥çœç•¥ <code>start</code> æˆ– <code>end</code>ã€‚</p>
<p>ç¯„åœå¯ä»¥åœ¨ <code>in</code> å‡½å¼çš„ç¯©é¸å™¨ä¸­ä½¿ç”¨ï¼Œå…·æœ‰ä»»ä½•å‹åˆ¥çš„å­—é¢å€¼ï¼ŒåŒ…æ‹¬æ—¥æœŸï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-61"><a class="header" href="#prql-61">PRQL</a></h4>
<pre><code class="language-prql">from events
filter (created_at | in @1776-07-04..@1787-09-17)
filter (magnitude | in 50..100)
derive is_northern = (latitude | in 0..)
</code></pre>
</div>
<div>
<h4 id="sql-58"><a class="header" href="#sql-58">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  latitude &gt;= 0 AS is_northern
FROM
  events
WHERE
  created_at BETWEEN DATE '1776-07-04' AND DATE '1787-09-17'
  AND magnitude BETWEEN 50 AND 100

</code></pre>
</div>
</div>
<p>ç¯„åœä¹Ÿå¯ä»¥åœ¨ <code>take</code> ä¸­ä½¿ç”¨ï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-62"><a class="header" href="#prql-62">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort {-value, created_at}
take 101..110
</code></pre>
</div>
<div>
<h4 id="sql-59"><a class="header" href="#sql-59">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  orders
ORDER BY
  value DESC,
  created_at
LIMIT
  10 OFFSET 100

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/syntax/ranges.html#admonition-note"></a>
</div>
<div>
<p>Half-open ranges are generally less intuitive to read than a simple <code>&gt;=</code> or <code>&lt;=</code> operator.</p>
</div>
</div>
<h2 id="å¦è«‹åƒè¦‹-2"><a class="header" href="#å¦è«‹åƒè¦‹-2">å¦è«‹åƒè¦‹</a></h2>
<ul>
<li><a href="reference/syntax/../stdlib/transforms/take.html">take è®Šæ›</a></li>
</ul>
<h2 id="è·¯ç·šåœ–-2"><a class="header" href="#è·¯ç·šåœ–-2">è·¯ç·šåœ–</a></h2>
<p>Weâ€™d like to use ranges for other types, such as whether an object is in an array or list literal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¨»é‡‹"><a class="header" href="#è¨»é‡‹">è¨»é‡‹</a></h1>
<p>å­—å…ƒ <code>#</code> è¡¨ç¤ºè¨»é‡‹åˆ°è¡Œçš„çµå°¾ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-63"><a class="header" href="#prql-63">PRQL</a></h4>
<pre><code class="language-prql">from employees  # Comment 1
# Comment 2
aggregate {average salary}
</code></pre>
</div>
<div>
<h4 id="sql-60"><a class="header" href="#sql-60">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary)
FROM
  employees

</code></pre>
</div>
</div>
<p>Thereâ€™s no distinct multiline comment syntax.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="åƒæ•¸"><a class="header" href="#åƒæ•¸">åƒæ•¸</a></h1>
<p>åƒæ•¸æ˜¯æŸ¥è©¢ç·¨è­¯å¾Œæä¾›çš„å€¼çš„ä½”ä½ç¬¦ã€‚</p>
<p>å®ƒä½¿ç”¨ä»¥ä¸‹èªæ³•ï¼š<code>$id</code>ï¼Œå…¶ä¸­ <code>id</code> æ˜¯ä»»æ„è‹±æ•¸å­—å…ƒå­—ä¸²ã€‚</p>
<p>å¤§å¤šæ•¸è³‡æ–™åº«å¼•æ“åªæ”¯æ´æ•¸å­—ä½ç½®åƒæ•¸ IDï¼ˆä¾‹å¦‚ <code>$3</code>ï¼‰ã€‚</p>
<div class="comparison">
<div>
<h4 id="prql-64"><a class="header" href="#prql-64">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter id == $1
</code></pre>
</div>
<div>
<h4 id="sql-61"><a class="header" href="#sql-61">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  id = $1

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Variables assign a name to an expression (letâ€™s call it <code>x</code>). The name can then be used in any expression, acting as a substitute for the expression <code>x</code>.</p>
<p>Syntactically, variables can take 3 forms.</p>
<ul>
<li>
<p><code>let</code> declares the name before the expression.</p>
<pre><code class="language-prql no-eval">let my_name = x
</code></pre>
</li>
<li>
<p><code>into</code> declares the name after the expression. This form is useful for quick pipeline splitting and conforms with the â€œflow from top to bottomâ€ rule of pipelines.</p>
<pre><code class="language-prql no-eval">x
into my_name
</code></pre>
</li>
<li>
<p>implicit name, does not declare a name at all, but uses name <code>main</code> as the default. This is practical, as <code>main</code> is the variable that is compiled as the main relational query by default.</p>
<pre><code class="language-prql no-eval">x
</code></pre>
<p>â€¦ is equivalent to:</p>
<pre><code>let main = x
</code></pre>
</li>
</ul>
<p>When compiling to SQL, relational variables are compiled to Common Table Expressions (or sub-queries in some cases).</p>
<div class="comparison">
<div>
<h4 id="prql-65"><a class="header" href="#prql-65">PRQL</a></h4>
<pre><code class="language-prql">let top_50 = (
  from employees
  sort salary
  take 50
  aggregate {total_salary = sum salary}
)

from top_50      # Starts a new pipeline
</code></pre>
</div>
<div>
<h4 id="sql-62"><a class="header" href="#sql-62">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    salary
  FROM
    employees
  ORDER BY
    salary
  LIMIT
    50
), top_50 AS (
  SELECT
    COALESCE(SUM(salary), 0) AS total_salary
  FROM
    table_0
)
SELECT
  total_salary
FROM
  top_50

</code></pre>
</div>
</div>
<pre><code class="language-prqls">from employees
take 50
into first_50

from first_50
</code></pre>
<p>Variables can be assigned an s-string containing the whole SQL query <a href="reference/declarations/../syntax/s-strings.html">s-string</a>, enabling us to use features which PRQL doesnâ€™t yet support.</p>
<div class="comparison">
<div>
<h4 id="prql-66"><a class="header" href="#prql-66">PRQL</a></h4>
<pre><code class="language-prql">let grouping = s"""
  SELECT SUM(a)
  FROM tbl
  GROUP BY
    GROUPING SETS
    ((b, c, d), (d), (b, d))
"""

from grouping
</code></pre>
</div>
<div>
<h4 id="sql-63"><a class="header" href="#sql-63">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    SUM(a)
  FROM
    tbl
  GROUP BY
    GROUPING SETS ((b, c, d), (d), (b, d))
)
SELECT
  *
FROM
  table_0

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å‡½å¼"><a class="header" href="#å‡½å¼">å‡½å¼</a></h1>
<!--
TODOs:
- Examples are a bit artificial â€” the interp is just "divide by 100" in one case!  -->
<p>Functions have two types of parameters:</p>
<ol>
<li>Positional parameters, which require an argument.</li>
<li>Named parameters, which optionally take an argument, otherwise using their default value.</li>
</ol>
<p>So this function is named <code>fahrenheit_to_celsius</code> and has one parameter <code>temp</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-67"><a class="header" href="#prql-67">PRQL</a></h4>
<pre><code class="language-prql">let fahrenheit_to_celsius = temp -&gt; (temp - 32) / 1.8

from cities
derive temp_c = (fahrenheit_to_celsius temp_f)
</code></pre>
</div>
<div>
<h4 id="sql-64"><a class="header" href="#sql-64">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (temp_f - 32) / 1.8 AS temp_c
FROM
  cities

</code></pre>
</div>
</div>
<p>This function is named <code>interp</code>, and has two positional parameters named <code>high</code> and <code>x</code>, and one named parameter named <code>low</code> which takes a default argument of <code>0</code>. It calculates the proportion of the distance that <code>x</code> is between <code>low</code> and <code>high</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-68"><a class="header" href="#prql-68">PRQL</a></h4>
<pre><code class="language-prql">let interp = low:0 high x -&gt; (x - low) / (high - low)

from students
derive {
  sat_proportion_1 = (interp 1600 sat_score),
  sat_proportion_2 = (interp low:0 1600 sat_score),
}
</code></pre>
</div>
<div>
<h4 id="sql-65"><a class="header" href="#sql-65">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_1,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_2
FROM
  students

</code></pre>
</div>
</div>
<h2 id="piping-values-into-functions"><a class="header" href="#piping-values-into-functions">Piping values into functions</a></h2>
<p>Consistent with the principles of PRQL, itâ€™s possible to pipe values into functions, which makes composing many functions more readable. When piping a value into a function, the value is passed as an argument to the final positional parameter of the function. Hereâ€™s the same result as the examples above with an alternative construction:</p>
<div class="comparison">
<div>
<h4 id="prql-69"><a class="header" href="#prql-69">PRQL</a></h4>
<pre><code class="language-prql">let interp = low:0 high x -&gt; (x - low) / (high - low)

from students
derive {
  sat_proportion_1 = (sat_score | interp 1600),
  sat_proportion_2 = (sat_score | interp low:0 1600),
}
</code></pre>
</div>
<div>
<h4 id="sql-66"><a class="header" href="#sql-66">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_1,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_2
FROM
  students

</code></pre>
</div>
</div>
<p>ä¸”</p>
<div class="comparison">
<div>
<h4 id="prql-70"><a class="header" href="#prql-70">PRQL</a></h4>
<pre><code class="language-prql">let fahrenheit_to_celsius = temp -&gt; (temp - 32) / 1.8

from cities
derive temp_c = (temp_f | fahrenheit_to_celsius)
</code></pre>
</div>
<div>
<h4 id="sql-67"><a class="header" href="#sql-67">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  (temp_f - 32) / 1.8 AS temp_c
FROM
  cities

</code></pre>
</div>
</div>
<p>We can combine a chain of functions, which makes logic more readable:</p>
<div class="comparison">
<div>
<h4 id="prql-71"><a class="header" href="#prql-71">PRQL</a></h4>
<pre><code class="language-prql">let fahrenheit_to_celsius = temp -&gt; (temp - 32) / 1.8
let interp = low:0 high x -&gt; (x - low) / (high - low)

from kettles
derive boiling_proportion = (temp_c | fahrenheit_to_celsius | interp 100)
</code></pre>
</div>
<div>
<h4 id="sql-68"><a class="header" href="#sql-68">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  ((temp_c - 32) / 1.8 - 0) / (100 - 0) AS boiling_proportion
FROM
  kettles

</code></pre>
</div>
</div>
<h3 id="late-binding"><a class="header" href="#late-binding">Late binding</a></h3>
<p>Functions can bind to any variable that is in scope when the function is executed. For example, here <code>cost_total</code> refers to the column thatâ€™s introduced in the <code>from</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-72"><a class="header" href="#prql-72">PRQL</a></h4>
<pre><code class="language-prql">let cost_share = cost -&gt; cost / cost_total

from costs
select {materials, labor, overhead, cost_total}
derive {
  materials_share = (cost_share materials),
  labor_share = (cost_share labor),
  overhead_share = (cost_share overhead),
}
</code></pre>
</div>
<div>
<h4 id="sql-69"><a class="header" href="#sql-69">SQL</a></h4>
<pre><code class="language-sql">SELECT
  materials,
  labor,
  overhead,
  cost_total,
  materials / cost_total AS materials_share,
  labor / cost_total AS labor_share,
  overhead / cost_total AS overhead_share
FROM
  costs

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ¨™æº–åº«"><a class="header" href="#æ¨™æº–åº«">æ¨™æº–åº«</a></h1>
<p>The standard library currently contains commonly used functions that are used in SQL. Itâ€™s not yet as broad as weâ€™d like, and weâ€™re very open to expanding it.</p>
<p>Currently s-strings are an escape-hatch for any function that isnâ€™t in our standard library. If we find ourselves using them for something frequently, raise an issue and weâ€™ll add it to the stdlib.</p>
<p>Hereâ€™s the source of the current <a href="https://github.com/PRQL/prql/blob/main/prqlc/prql-compiler/src/semantic/std.prql">PRQL <code>std</code></a>:</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/index.html#admonition-note"></a>
</div>
<div>
<p>PRQL 0.9.0 has started supporting different DB implementations for standard library functions. The source is the <a href="https://github.com/PRQL/prql/blob/main/prqlc/prql-compiler/src/sql/std.sql.prql"><code>std.sql</code></a>.</p>
</div>
</div>
<pre><code class="language-prql no-eval"># The PRQL standard library defines the following functions and transforms.
# The definitions are whitespace insensitive, and have this form:
#
# ```
# let my_func = param1 param2 ...  -&gt; &lt;return_type&gt; body_expr
# ```
#
# Where:
#   * `my_func` is the name of the function
#   * `param1` is the first parameter optionally followed by a type in "&lt; ... &gt;"
#   * `param2` etc. follow the same pattern as param1
#   * `&lt;return_type&gt;` is the type of result wrapped in "&lt; ... &gt;"
#   * `body_expr` defines the function body that creates the result.
#     It can be PRQL code or `internal ...` to indicate internal compiler code.

# Operators

let mul = left right -&gt; &lt;int || float&gt; internal std.mul
let div_i = left right -&gt; &lt;int || float&gt; internal std.div_i
let div_f = left right -&gt; &lt;int || float&gt; internal std.div_f
let mod = left right -&gt; &lt;int || float&gt; internal std.mod
let add = left&lt;int || float || timestamp || date&gt; right&lt;int || float || timestamp || date&gt; -&gt; &lt;int || float || timestamp || date&gt; internal std.add
let sub = left&lt;int || float || timestamp || date&gt; right&lt;int || float || timestamp || date&gt; -&gt; &lt;int || float || timestamp || date&gt; internal std.sub
let eq = left right -&gt; &lt;bool&gt; internal std.eq
let ne = left right -&gt; &lt;bool&gt; internal std.ne
let gt = left right -&gt; &lt;bool&gt; internal std.gt
let lt = left right -&gt; &lt;bool&gt; internal std.lt
let gte = left right -&gt; &lt;bool&gt; internal std.gte
let lte = left right -&gt; &lt;bool&gt; internal std.lte
let and = left&lt;bool&gt; right&lt;bool&gt; -&gt; &lt;bool&gt; internal std.and
let or = left&lt;bool&gt; right&lt;bool&gt; -&gt; &lt;bool&gt; internal std.or
let coalesce = left right -&gt; internal std.coalesce
let regex_search = text pattern -&gt; &lt;bool&gt; internal std.regex_search

let neg = expr&lt;int || float&gt; -&gt; &lt;int || float&gt; internal std.neg
let not = expr&lt;bool&gt; -&gt; &lt;bool&gt; internal std.not

# Types

## Type primitives
type int = int
type float = float
type bool = bool
type text = text
type date = date
type time = time
type timestamp = timestamp
type `func` = func
type anytype = anytype

## Generic array
# TODO: an array of anything, not just nulls
type array = [anytype]

## Scalar
type scalar = int || float || bool || text || date || time || timestamp || null
type tuple = {anytype..}

## Range
type range = {start = scalar, end = scalar}

## Relation (an array of tuples)
type relation = [tuple]

## Transform
type transform = func relation -&gt; relation

# Functions

## Relational transforms
let from = func
  `default_db.source` &lt;relation&gt;
  -&gt; &lt;relation&gt; internal from

let select = func
  columns &lt;scalar || tuple&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal select

let filter = func
  condition &lt;bool&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal filter

let derive = func
  columns &lt;scalar || tuple&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal derive

let aggregate = func
  columns &lt;scalar || tuple&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal aggregate

let sort = func
  by &lt;scalar || tuple&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal sort

let take = func
  expr &lt;anytype&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal take

let join = func
  `default_db.with` &lt;relation&gt;
  condition &lt;bool&gt;
  `noresolve.side`:inner
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal join

let group = func
  by&lt;scalar || tuple&gt;
  pipeline &lt;transform&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal group

let window = func
  rows:0..0
  range:0..0
  expanding &lt;bool&gt;:false
  rolling &lt;int&gt;:0
  pipeline &lt;transform&gt;
  tbl &lt;relation&gt;
  -&gt; &lt;relation&gt; internal window

let append = `default_db.bottom`&lt;relation&gt; top&lt;relation&gt; -&gt; &lt;relation&gt; internal append
let intersect = `default_db.bottom`&lt;relation&gt; top&lt;relation&gt; -&gt; &lt;relation&gt; (
  t = top
  join (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b.*)))
  select t.*
)
let remove = `default_db.bottom`&lt;relation&gt; top&lt;relation&gt; -&gt; &lt;relation&gt; (
  t = top
  join side:left (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b.*)))
  filter (tuple_every (tuple_map _is_null b.*))
  select t.*
)
let loop = func
  pipeline &lt;transform&gt;
  top &lt;relation&gt;
  -&gt; &lt;relation&gt; internal loop

## Aggregate functions
# These return either a scalar when used within `aggregate`, or a column when used anywhere else.

let min = column &lt;array&gt; -&gt; &lt;int || float || null&gt; internal std.min

let max = column &lt;array&gt; -&gt; &lt;int || float || null&gt; internal std.max

let sum = column &lt;array&gt; -&gt; &lt;int || float&gt; internal std.sum

let average = column &lt;array&gt; -&gt; &lt;float || null&gt; internal std.average

let stddev = column &lt;array&gt; -&gt; &lt;float || null&gt; internal std.stddev

let all = column &lt;array&gt; -&gt; &lt;bool&gt; internal std.all

let any = column &lt;array&gt; -&gt; &lt;bool&gt; internal std.any

let concat_array = column &lt;array&gt; -&gt; &lt;text&gt; internal std.concat_array

# Counts number of items in the column.
# Note that the count will include null values.
let count = column&lt;array&gt; -&gt; &lt;int&gt; internal std.count

# Deprecated in favour of filterning input to the [std.count] function (not yet implemented).
@{deprecated}
let count_distinct = column &lt;array&gt; -&gt; internal std.count_distinct

## Window functions
let lag =   offset &lt;int&gt;    column &lt;array&gt; -&gt; internal std.lag
let lead =  offset &lt;int&gt;    column &lt;array&gt; -&gt; internal std.lead
let first      = column &lt;array&gt; -&gt; internal std.first
let last       = column &lt;array&gt; -&gt; internal std.last
let rank       = column &lt;array&gt; -&gt; internal std.rank
let rank_dense = column &lt;array&gt; -&gt; internal std.rank_dense
let row_number = column &lt;array&gt; -&gt; internal std.row_number

## Misc functions
let round = n_digits column -&gt; &lt;scalar&gt; internal std.round
let as = `noresolve.type` column -&gt; &lt;scalar&gt; internal std.as
let in = pattern value -&gt; &lt;bool&gt; internal in

## Tuple functions
let tuple_every = func list -&gt; &lt;bool&gt; internal tuple_every
let tuple_map = func fn &lt;func&gt; list -&gt; internal tuple_map
let tuple_zip = func a b -&gt; internal tuple_zip
let _eq = func a -&gt; internal _eq
let _is_null = func a -&gt; _param.a == null

## Misc
let from_text = input&lt;text&gt; `noresolve.format`:csv -&gt; &lt;relation&gt; internal from_text

## String functions
let lower = column -&gt; &lt;text&gt; internal std.lower
let upper = column -&gt; &lt;text&gt; internal std.upper

## File-reading functions, primarily for DuckDB
let read_parquet = source&lt;text&gt; -&gt; &lt;relation&gt; internal std.read_parquet
let read_csv = source&lt;text&gt; -&gt; &lt;relation&gt; internal std.read_csv


## PRQL compiler functions

let prql_version = -&gt; &lt;text&gt; internal prql_version
</code></pre>
<p>ä»¥ä¸‹æ˜¯å¹¾å€‹ç¤ºä¾‹ï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-73"><a class="header" href="#prql-73">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = (salary + payroll_tax | as int),
  gross_salary_rounded = (gross_salary | round 0),
  time = s"NOW()",  # an s-string, given no `now` function exists in PRQL
}
</code></pre>
</div>
<div>
<h4 id="sql-70"><a class="header" href="#sql-70">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  CAST(salary + payroll_tax AS int) AS gross_salary,
  ROUND(CAST(salary + payroll_tax AS int), 0) AS gross_salary_rounded,
  NOW() AS time
FROM
  employees

</code></pre>
</div>
</div>
<p>ä¸åŒå¯¦ç¾çš„é™¤æ³•å’Œæ•´æ•¸é™¤æ³•çš„ç¤ºä¾‹ï¼š</p>
<div class="comparison">
<div>
<h4 id="prql-74"><a class="header" href="#prql-74">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.sqlite

from [{x = 13, y = 5}]
select {
  quotient = x / y,
  int_quotient = x // y,
}
</code></pre>
</div>
<div>
<h4 id="sql-71"><a class="header" href="#sql-71">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    13 AS x,
    5 AS y
)
SELECT
  (x * 1.0 / y) AS quotient,
  ROUND(ABS(x / y) - 0.5) * SIGN(x) * SIGN(y) AS int_quotient
FROM
  table_0

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-75"><a class="header" href="#prql-75">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mysql

from [{x = 13, y = 5}]
select {
  quotient = x / y,
  int_quotient = x // y,
}
</code></pre>
</div>
<div>
<h4 id="sql-72"><a class="header" href="#sql-72">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    13 AS x,
    5 AS y
)
SELECT
  (x / y) AS quotient,
  (x DIV y) AS int_quotient
FROM
  table_0

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è®Šæ›"><a class="header" href="#è®Šæ›">è®Šæ›</a></h1>
<p>Transforms are functions that take a relation and produce a relation.</p>
<p>Usually they are chained together into a pipeline, which resembles an SQL query.</p>
<p>Transforms were designed with a focus on modularity, so each of them is fulfilling a specific purpose and has defined invariants (properties of the relation that are left unaffected). Thatâ€™s often referred to as â€œorthogonalityâ€ and its goal is to keep transform functions composable by minimizing interference of their effects. Additionally, it also keeps the number of transforms low.</p>
<p>For example, <code>select</code> and <code>derive</code> will not change the number of rows, while <code>filter</code> and <code>take</code> will not change the number of columns.</p>
<p>In SQL, we can see this lack of invariant when an aggregation function is used in the <code>SELECT</code> clause. Before, the number of rows was kept constant, but introduction of an aggregation function caused the whole statement to produce only one row (per group).</p>
<p>These are the currently available transforms:</p>
<div class="table-wrapper"><table><thead><tr><th>Transform</th><th>Purpose</th><th>SQL Equivalent</th></tr></thead><tbody>
<tr><td><code>from</code></td><td><a href="reference/stdlib/transforms/./from.html">Start from a table</a></td><td><code>FROM</code></td></tr>
<tr><td><code>derive</code></td><td><a href="reference/stdlib/transforms/./derive.html">Compute new columns</a></td><td><code>SELECT *, ... AS ...</code></td></tr>
<tr><td><code>select</code></td><td><a href="reference/stdlib/transforms/./select.html">Pick &amp; compute columns</a></td><td><code>SELECT ... AS ...</code></td></tr>
<tr><td><code>filter</code></td><td><a href="reference/stdlib/transforms/./filter.html">Pick rows based on their values</a></td><td><code>WHERE</code>, <code>HAVING</code>,<code>QUALIFY</code></td></tr>
<tr><td><code>sort</code></td><td><a href="reference/stdlib/transforms/./sort.html">Order rows based on the values of columns</a></td><td><code>ORDER BY</code></td></tr>
<tr><td><code>join</code></td><td><a href="reference/stdlib/transforms/./join.html">Add columns from another table, matching rows based on a condition</a></td><td><code>JOIN</code></td></tr>
<tr><td><code>take</code></td><td><a href="reference/stdlib/transforms/./take.html">Pick rows based on their position</a></td><td><code>TOP</code>, <code>LIMIT</code>, <code>OFFSET</code></td></tr>
<tr><td><code>group</code></td><td><a href="reference/stdlib/transforms/./group.html">Partition rows into groups and applies a pipeline to each of them</a></td><td><code>GROUP BY</code>, <code>PARTITION BY</code></td></tr>
<tr><td><code>aggregate</code></td><td><a href="reference/stdlib/transforms/./aggregate.html">Summarize many rows into one row</a></td><td><code>SELECT foo(...)</code></td></tr>
<tr><td><code>window</code></td><td><a href="reference/stdlib/transforms/./window.html">Apply a pipeline to overlapping segments of rows</a></td><td><code>OVER</code>, <code>ROWS</code>, <code>RANGE</code></td></tr>
<tr><td><code>loop</code></td><td><a href="reference/stdlib/transforms/./loop.html">Iteratively apply a function to a relation until itâ€™s empty</a></td><td><code>WITH RECURSIVE ...</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="èšåˆ-1"><a class="header" href="#èšåˆ-1">èšåˆ</a></h1>
<p>Summarizes many rows into one row.</p>
<p>When applied:</p>
<ul>
<li>without <code>group</code>, it produces one row from the whole table,</li>
<li>within a <code>group</code> pipeline, it produces one row from each group.</li>
</ul>
<pre><code class="language-prql no-eval">aggregate {expression or assign operations}
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/aggregate.html#admonition-note"></a>
</div>
<div>
<p>Currently, all declared aggregation functions are <code>min</code>, <code>max</code>, <code>count</code>, <code>average</code>, <code>stddev</code>, <code>avg</code>, <code>sum</code> and <code>count_distinct</code>. We are in the process of filling out <a href="reference/stdlib/transforms/../">std lib</a>.</p>
</div>
</div>
<h2 id="ç¯„ä¾‹-1"><a class="header" href="#ç¯„ä¾‹-1">ç¯„ä¾‹</a></h2>
<div class="comparison">
<div>
<h4 id="prql-76"><a class="header" href="#prql-76">PRQL</a></h4>
<pre><code class="language-prql">from employees
aggregate {
  average salary,
  ct = count salary
}
</code></pre>
</div>
<div>
<h4 id="sql-73"><a class="header" href="#sql-73">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-77"><a class="header" href="#prql-77">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {title, country} (
  aggregate {
    average salary,
    ct = count salary,
  }
)
</code></pre>
</div>
<div>
<h4 id="sql-74"><a class="header" href="#sql-74">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country

</code></pre>
</div>
</div>
<h2 id="aggregate-is-required"><a class="header" href="#aggregate-is-required">Aggregate is required</a></h2>
<p>Unlike in SQL, using an aggregation function in <code>derive</code> or <code>select</code> (or any other transform except <code>aggregate</code>) will not trigger aggregation. By default, PRQL will interpret such attempts functions as window functions:</p>
<div class="comparison">
<div>
<h4 id="prql-78"><a class="header" href="#prql-78">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {avg_sal = average salary}
</code></pre>
</div>
<div>
<h4 id="sql-75"><a class="header" href="#sql-75">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  AVG(salary) OVER () AS avg_sal
FROM
  employees

</code></pre>
</div>
</div>
<p>This ensures that <code>derive</code> does not manipulate the number of rows, but only ever adds a column. For more information, see <a href="reference/stdlib/transforms/./window.html">window transform</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é™„åŠ "><a class="header" href="#é™„åŠ ">é™„åŠ </a></h1>
<p>Concatenates two tables together.</p>
<p>Equivalent to <code>UNION ALL</code> in SQL. The number of rows is always the sum of the number of rows from the two input tables. To replicate <code>UNION DISTINCT</code>, see <a href="reference/stdlib/transforms/append.html#set-operations">set operations</a>.</p>
<div class="comparison">
<div>
<h4 id="prql-79"><a class="header" href="#prql-79">PRQL</a></h4>
<pre><code class="language-prql">from employees_1
append employees_2
</code></pre>
</div>
<div>
<h4 id="sql-76"><a class="header" href="#sql-76">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees_1
UNION
ALL
SELECT
  *
FROM
  employees_2

</code></pre>
</div>
</div>
<h2 id="remove"><a class="header" href="#remove">Remove</a></h2>
<blockquote>
<p><em>experimental</em></p>
</blockquote>
<p>Removes rows that appear in another relation, like <code>EXCEPT ALL</code>. Duplicate rows are removed one-for-one.</p>
<div class="comparison">
<div>
<h4 id="prql-80"><a class="header" href="#prql-80">PRQL</a></h4>
<pre><code class="language-prql">from employees_1
remove employees_2
</code></pre>
</div>
<div>
<h4 id="sql-77"><a class="header" href="#sql-77">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees_1 AS t
EXCEPT
  ALL
SELECT
  *
FROM
  employees_2 AS b

</code></pre>
</div>
</div>
<h2 id="intersection"><a class="header" href="#intersection">Intersection</a></h2>
<blockquote>
<p><em>experimental</em></p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-81"><a class="header" href="#prql-81">PRQL</a></h4>
<pre><code class="language-prql">from employees_1
intersect employees_2
</code></pre>
</div>
<div>
<h4 id="sql-78"><a class="header" href="#sql-78">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees_1 AS t
INTERSECT
ALL
SELECT
  *
FROM
  employees_2 AS b

</code></pre>
</div>
</div>
<h2 id="set-operations"><a class="header" href="#set-operations">Set operations</a></h2>
<blockquote>
<p><em>experimental</em></p>
</blockquote>
<p>To imitate set operations i.e. (<code>UNION</code>, <code>EXCEPT</code> and <code>INTERSECT</code>), you can use the following functions:</p>
<pre><code class="language-prql no-eval">let distinct = rel -&gt; (from t = _param.rel | group {t.*} (take 1))
let union = `default_db.bottom` top -&gt; (top | append bottom | distinct)
let except = `default_db.bottom` top -&gt; (top | distinct | remove bottom)
let intersect_distinct = `default_db.bottom` top -&gt; (top | intersect bottom | distinct)
</code></pre>
<p>Donâ€™t mind the <code>default_db.</code> and <code>noop</code>, these are compiler implementation detail for now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¡ç”Ÿ"><a class="header" href="#è¡ç”Ÿ">è¡ç”Ÿ</a></h1>
<p>è¨ˆç®—ä¸€å€‹æˆ–å¤šå€‹æ–°æ¬„ä½ã€‚</p>
<pre><code class="language-prql no-eval">derive {
  name = expression,
  # or
  column,
}
</code></pre>
<h2 id="ç¯„ä¾‹-2"><a class="header" href="#ç¯„ä¾‹-2">ç¯„ä¾‹</a></h2>
<div class="comparison">
<div>
<h4 id="prql-82"><a class="header" href="#prql-82">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive gross_salary = salary + payroll_tax
</code></pre>
</div>
<div>
<h4 id="sql-79"><a class="header" href="#sql-79">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + payroll_tax AS gross_salary
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-83"><a class="header" href="#prql-83">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {
  gross_salary = salary + payroll_tax,
  gross_cost = gross_salary + benefits_cost
}
</code></pre>
</div>
<div>
<h4 id="sql-80"><a class="header" href="#sql-80">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  salary + payroll_tax AS gross_salary,
  salary + payroll_tax + benefits_cost AS gross_cost
FROM
  employees

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç¯©é¸"><a class="header" href="#ç¯©é¸">ç¯©é¸</a></h1>
<p>Picks rows based on their values.</p>
<pre><code class="language-prql no-eval">filter boolean_expression
</code></pre>
<h2 id="ç¯„ä¾‹-3"><a class="header" href="#ç¯„ä¾‹-3">ç¯„ä¾‹</a></h2>
<div class="comparison">
<div>
<h4 id="prql-84"><a class="header" href="#prql-84">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter age &gt; 25
</code></pre>
</div>
<div>
<h4 id="sql-81"><a class="header" href="#sql-81">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  age &gt; 25

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-85"><a class="header" href="#prql-85">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter (age &gt; 25 || department != "IT")
</code></pre>
</div>
<div>
<h4 id="sql-82"><a class="header" href="#sql-82">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  age &gt; 25
  OR department &lt;&gt; 'IT'

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-86"><a class="header" href="#prql-86">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter (age | in 25..40)
</code></pre>
</div>
<div>
<h4 id="sql-83"><a class="header" href="#sql-83">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  age BETWEEN 25 AND 40

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å¾"><a class="header" href="#å¾">å¾</a></h1>
<p>Specifies a data source.</p>
<div class="comparison">
<div>
<h4 id="prql-87"><a class="header" href="#prql-87">PRQL</a></h4>
<pre><code class="language-prql">from artists
</code></pre>
</div>
<div>
<h4 id="sql-84"><a class="header" href="#sql-84">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  artists

</code></pre>
</div>
</div>
<p>To introduce an alias, use an assign expression:</p>
<div class="comparison">
<div>
<h4 id="prql-88"><a class="header" href="#prql-88">PRQL</a></h4>
<pre><code class="language-prql">from e = employees
select e.first_name
</code></pre>
</div>
<div>
<h4 id="sql-85"><a class="header" href="#sql-85">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees AS e

</code></pre>
</div>
</div>
<p>Table names containing spaces or special characters <a href="reference/stdlib/transforms/../../syntax/keywords.html#quoting">need to be contained within backticks</a>:</p>
<div class="comparison">
<div>
<h4 id="prql-89"><a class="header" href="#prql-89">PRQL</a></h4>
<pre><code class="language-prql">from `artist tracks`
</code></pre>
</div>
<div>
<h4 id="sql-86"><a class="header" href="#sql-86">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  "artist tracks"

</code></pre>
</div>
</div>
<p><code>default_db.tablename</code> can be used if the table name matches a function from the standard library.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/from.html#admonition-note"></a>
</div>
<div>
<p>We realize this is an awkward workaround. Track &amp; ğŸ‘ <a href="https://github.com/PRQL/prql/issues/3271">#3271</a> for resolving this.</p>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-90"><a class="header" href="#prql-90">PRQL</a></h4>
<pre><code class="language-prql">default_db.group  # in place of `from group`
take 1
</code></pre>
</div>
<div>
<h4 id="sql-87"><a class="header" href="#sql-87">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  "group"
LIMIT
  1

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç¾¤çµ„"><a class="header" href="#ç¾¤çµ„">ç¾¤çµ„</a></h1>
<p>Partitions the rows into groups and applies a pipeline to each of the groups.</p>
<pre><code class="language-prql no-eval">group {key_columns} (pipeline)
</code></pre>
<p>The partitioning of groups are determined by the <code>key_column</code>s (first argument).</p>
<p>The most conventional use of <code>group</code> is with <code>aggregate</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-91"><a class="header" href="#prql-91">PRQL</a></h4>
<pre><code class="language-prql">from employees
group {title, country} (
  aggregate {
    average salary,
    ct = count salary
  }
)
</code></pre>
</div>
<div>
<h4 id="sql-88"><a class="header" href="#sql-88">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country

</code></pre>
</div>
</div>
<p>In concept, a transform in context of a <code>group</code> does the same transformation to the group as it would to the table â€” for example finding the employee who joined first across the whole table:</p>
<div class="comparison">
<div>
<h4 id="prql-92"><a class="header" href="#prql-92">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort join_date
take 1
</code></pre>
</div>
<div>
<h4 id="sql-89"><a class="header" href="#sql-89">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  join_date
LIMIT
  1

</code></pre>
</div>
</div>
<p>To find the employee who joined first in each department, itâ€™s exactly the same pipeline, but within a <code>group</code> expression:</p>
<div class="comparison">
<div>
<h4 id="prql-93"><a class="header" href="#prql-93">PRQL</a></h4>
<pre><code class="language-prql">from employees
group role (
  sort join_date  # taken from above
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-90"><a class="header" href="#sql-90">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    ROW_NUMBER() OVER (
      PARTITION BY role
      ORDER BY
        join_date
    ) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  _expr_0 &lt;= 1

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¯æ¥"><a class="header" href="#è¯æ¥">è¯æ¥</a></h1>
<p>Adds columns from another table, matching rows based on a condition.</p>
<pre><code class="language-prql no-eval">join side:{inner|left|right|full} table (condition)
</code></pre>
<h2 id="åƒæ•¸-1"><a class="header" href="#åƒæ•¸-1">åƒæ•¸</a></h2>
<ul>
<li><code>side</code> specifies which rows to include, defaulting to <code>inner</code>.</li>
<li><em>table</em> - a reference to a relation, possibly including an alias, e.g. <code>a=artists</code></li>
<li><em>condition</em> - a boolean condition
<ul>
<li>If the condition evaluates to true for a given row, the row will be joined</li>
<li>If name is the same from both tables, it can be expressed with only <code>(==col)</code>.</li>
</ul>
</li>
</ul>
<h2 id="ç¯„ä¾‹-4"><a class="header" href="#ç¯„ä¾‹-4">ç¯„ä¾‹</a></h2>
<div class="comparison">
<div>
<h4 id="prql-94"><a class="header" href="#prql-94">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:left positions (employees.id==positions.employee_id)
</code></pre>
</div>
<div>
<h4 id="sql-91"><a class="header" href="#sql-91">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*
FROM
  employees
  LEFT JOIN positions ON employees.id = positions.employee_id

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-95"><a class="header" href="#prql-95">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:left p=positions (employees.id==p.employee_id)
</code></pre>
</div>
<div>
<h4 id="sql-92"><a class="header" href="#sql-92">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  p.*
FROM
  employees
  LEFT JOIN positions AS p ON employees.id = p.employee_id

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-96"><a class="header" href="#prql-96">PRQL</a></h4>
<pre><code class="language-prql">from tracks
join side:left artists (
  # This adds a `country` condition, as an alternative to filtering
  artists.id==tracks.artist_id &amp;&amp; artists.country=='UK'
)
</code></pre>
</div>
<div>
<h4 id="sql-93"><a class="header" href="#sql-93">SQL</a></h4>
<pre><code class="language-sql">SELECT
  tracks.*,
  artists.*
FROM
  tracks
  LEFT JOIN artists ON artists.id = tracks.artist_id
  AND artists.country = 'UK'

</code></pre>
</div>
</div>
<p><a href="reference/stdlib/transforms/../../syntax/keywords.html#this--that"><code>this</code> &amp; <code>that</code></a> can be used to refer to the current &amp; other table respectively:</p>
<div class="comparison">
<div>
<h4 id="prql-97"><a class="header" href="#prql-97">PRQL</a></h4>
<pre><code class="language-prql">from tracks
join side:inner artists (
  this.id==that.artist_id
)
</code></pre>
</div>
<div>
<h4 id="sql-94"><a class="header" href="#sql-94">SQL</a></h4>
<pre><code class="language-sql">SELECT
  tracks.*,
  artists.*
FROM
  tracks
  JOIN artists ON tracks.id = artists.artist_id

</code></pre>
</div>
</div>
<h2 id="self-equality-operator"><a class="header" href="#self-equality-operator">Self equality operator</a></h2>
<p>If the join conditions are of form <code>left.x == right.x</code>, we can use â€œself equality operatorâ€:</p>
<div class="comparison">
<div>
<h4 id="prql-98"><a class="header" href="#prql-98">PRQL</a></h4>
<pre><code class="language-prql">from employees
join positions (==emp_no)
</code></pre>
</div>
<div>
<h4 id="sql-95"><a class="header" href="#sql-95">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*
FROM
  employees
  JOIN positions ON employees.emp_no = positions.emp_no

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å¾ªç’°"><a class="header" href="#å¾ªç’°">å¾ªç’°</a></h1>
<blockquote>
<p><em>Experimental</em></p>
</blockquote>
<pre><code class="language-prql no-eval">loop {step_function} {initial_relation}
</code></pre>
<p>Iteratively applies <code>step</code> function to <code>initial</code> relation until the <code>step</code> returns an empty table. Returns a relation that contains rows of initial relation and all intermediate relations.</p>
<p>This behavior could be expressed with following pseudo-code:</p>
<pre><code class="language-python">def loop(step, initial):
    result = []
    current = initial
    while current is not empty:
        result = append(result, current)
        current = step(current)

    return result
</code></pre>
<h2 id="ç¯„ä¾‹-5"><a class="header" href="#ç¯„ä¾‹-5">ç¯„ä¾‹</a></h2>
<div class="comparison">
<div>
<h4 id="prql-99"><a class="header" href="#prql-99">PRQL</a></h4>
<pre><code class="language-prql">from [{n = 1}]
loop (
    filter n&lt;4
    select n = n+1
)

# returns [1, 2, 3, 4]
</code></pre>
</div>
<div>
<h4 id="sql-96"><a class="header" href="#sql-96">SQL</a></h4>
<pre><code class="language-sql">WITH RECURSIVE table_0 AS (
  SELECT
    1 AS n
),
table_1 AS (
  SELECT
    n
  FROM
    table_0
  UNION
  ALL
  SELECT
    n + 1
  FROM
    table_1
  WHERE
    n &lt; 4
)
SELECT
  n
FROM
  table_1 AS table_2

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/loop.html#admonition-note"></a>
</div>
<div>
<p>The behavior of <code>WITH RECURSIVE</code> may depend on the database configuration in MySQL. The compiler assumes the behavior described by the <a href="https://www.postgresql.org/docs/15/queries-with.html#QUERIES-WITH-RECURSIVE">Postgres documentation</a> and will not produce correct results for <a href="https://dev.mysql.com/doc/refman/8.0/en/with.html#common-table-expressions-recursive">alternative configurations of MySQL</a>.</p>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/loop.html#admonition-note-1"></a>
</div>
<div>
<p>Currently, <code>loop</code> may produce references to the recursive CTE in sub-queries, which is not supported by some database engines, e.g. SQLite. For now, we suggest step functions are kept simple enough to fit into a single SELECT statement.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é¸æ“‡"><a class="header" href="#é¸æ“‡">é¸æ“‡</a></h1>
<p>Picks and computes columns.</p>
<pre><code class="language-prql no-eval">select {
  name = expression,
  # or
  column,
}
# or
select !{column}
</code></pre>
<h2 id="ç¯„ä¾‹-6"><a class="header" href="#ç¯„ä¾‹-6">ç¯„ä¾‹</a></h2>
<div class="comparison">
<div>
<h4 id="prql-100"><a class="header" href="#prql-100">PRQL</a></h4>
<pre><code class="language-prql">from employees
select name = f"{first_name} {last_name}"
</code></pre>
</div>
<div>
<h4 id="sql-97"><a class="header" href="#sql-97">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS name
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-101"><a class="header" href="#prql-101">PRQL</a></h4>
<pre><code class="language-prql">from employees
select {
  name = f"{first_name} {last_name}",
  age_eoy = dob - @2022-12-31,
}
</code></pre>
</div>
<div>
<h4 id="sql-98"><a class="header" href="#sql-98">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS name,
  dob - DATE '2022-12-31' AS age_eoy
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-102"><a class="header" href="#prql-102">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-99"><a class="header" href="#sql-99">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-103"><a class="header" href="#prql-103">PRQL</a></h4>
<pre><code class="language-prql">from e=employees
select {e.first_name, e.last_name}
</code></pre>
</div>
<div>
<h4 id="sql-100"><a class="header" href="#sql-100">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees AS e

</code></pre>
</div>
</div>
<h3 id="excluding-columns"><a class="header" href="#excluding-columns">Excluding columns</a></h3>
<p>We can use <code>!</code> to exclude a list of columns. This can operate in two ways:</p>
<ul>
<li>We use <code>SELECT * EXCLUDE</code> / <code>SELECT * EXCEPT</code> for the columns supplied to <code>select !{}</code> in dialects which support it.</li>
<li>Otherwise, the columns must have been defined prior in the query (unless all of a tableâ€™s columns are excluded); for example in another <code>select</code> or a <code>group</code> transform. In this case, we evaluate and specify the columns that should be included in the output SQL.</li>
</ul>
<p>Some examples:</p>
<div class="comparison">
<div>
<h4 id="prql-104"><a class="header" href="#prql-104">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.bigquery
from tracks
select !{milliseconds, bytes}
</code></pre>
</div>
<div>
<h4 id="sql-101"><a class="header" href="#sql-101">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
EXCEPT
  (milliseconds, bytes)
FROM
  tracks

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-105"><a class="header" href="#prql-105">PRQL</a></h4>
<pre><code class="language-prql">from tracks
select {track_id, title, composer, bytes}
select !{title, composer}
</code></pre>
</div>
<div>
<h4 id="sql-102"><a class="header" href="#sql-102">SQL</a></h4>
<pre><code class="language-sql">SELECT
  track_id,
  bytes
FROM
  tracks

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-106"><a class="header" href="#prql-106">PRQL</a></h4>
<pre><code class="language-prql">from artists
derive nick = name
select !{artists.*}
</code></pre>
</div>
<div>
<h4 id="sql-103"><a class="header" href="#sql-103">SQL</a></h4>
<pre><code class="language-sql">SELECT
  name AS nick
FROM
  artists

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ’åº"><a class="header" href="#æ’åº">æ’åº</a></h1>
<p>Order rows based on the values of one or more expressions (generally columns).</p>
<pre><code class="language-prql no-eval">sort {(+|-) column}
</code></pre>
<h2 id="åƒæ•¸-2"><a class="header" href="#åƒæ•¸-2">åƒæ•¸</a></h2>
<ul>
<li>One expression or a tuple of expressions to sort by</li>
<li>Each expression can be prefixed with:
<ul>
<li><code>+</code>, for ascending order, the default</li>
<li><code>-</code>, for descending order</li>
</ul>
</li>
<li>When using prefixes, even a single expression needs to be in a tuple or parentheses. (Otherwise, <code>sort -foo</code> is parsed as a subtraction between <code>sort</code> and <code>foo</code>.)</li>
</ul>
<h2 id="ç¯„ä¾‹-7"><a class="header" href="#ç¯„ä¾‹-7">ç¯„ä¾‹</a></h2>
<div class="comparison">
<div>
<h4 id="prql-107"><a class="header" href="#prql-107">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort age
</code></pre>
</div>
<div>
<h4 id="sql-104"><a class="header" href="#sql-104">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-108"><a class="header" href="#prql-108">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort {-age}
</code></pre>
</div>
<div>
<h4 id="sql-105"><a class="header" href="#sql-105">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age DESC

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-109"><a class="header" href="#prql-109">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort {age, -tenure, +salary}
</code></pre>
</div>
<div>
<h4 id="sql-106"><a class="header" href="#sql-106">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age,
  tenure DESC,
  salary

</code></pre>
</div>
</div>
<p>We can also use expressions:</p>
<div class="comparison">
<div>
<h4 id="prql-110"><a class="header" href="#prql-110">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort {s"substr({first_name}, 2, 5)"}
</code></pre>
</div>
<div>
<h4 id="sql-107"><a class="header" href="#sql-107">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    substr(first_name, 2, 5) AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
ORDER BY
  _expr_0

</code></pre>
</div>
</div>
<h2 id="ordering-guarantees"><a class="header" href="#ordering-guarantees">Ordering guarantees</a></h2>
<p>Ordering is persistent through a pipeline in PRQL. For example:</p>
<div class="comparison">
<div>
<h4 id="prql-111"><a class="header" href="#prql-111">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort tenure
join locations (==employee_id)
</code></pre>
</div>
<div>
<h4 id="sql-108"><a class="header" href="#sql-108">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  locations.*
FROM
  employees
  JOIN locations ON employees.employee_id = locations.employee_id
ORDER BY
  employees.tenure

</code></pre>
</div>
</div>
<p>Here, PRQL pushes the <code>sort</code> down the pipeline, compiling the <code>ORDER BY</code> to the <em>end</em> of the query. Consequently, most relation transforms retain the row order.</p>
<p>The explicit semantics are:</p>
<ul>
<li><code>sort</code> introduces a new order,</li>
<li><code>group</code> resets the order,</li>
<li><code>join</code> retains the order of the left relation,</li>
<li>database tables donâ€™t have a known order.</li>
</ul>
<p>Comparatively, in SQL, relations possess no order, being orderable solely within the context of the query result, <code>LIMIT</code> statement, or window function. The lack of inherent order can result in an unexpected reshuffling of a previously ordered relation from a <code>JOIN</code> or windowing operation.</p>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="reference/stdlib/transforms/sort.html#admonition-info"></a>
</div>
<div>
<p>To be precise â€” in PRQL, a relation is an <em>array of tuples</em> and not a set or a bag. The persistent nature of this order remains intact through sub-queries and intermediate table definitions.</p>
</div>
</div>
<p>For instance, an SQL query such as:</p>
<pre><code class="language-sql">WITH albums_sorted AS (
  SELECT *
  FROM albums
  ORDER BY title
)
SELECT *
FROM albums_sorted
JOIN artists USING (artist_id)
</code></pre>
<p>â€¦doesnâ€™t guarantee any row order (indeed â€” even without the <code>JOIN</code>, the SQL standard doesnâ€™t guarantee an order, although most implementations will respect it).</p>
<!-- We rolling this back. Waiting on the outcome of https://github.com/PRQL/prql/issues/2622 -->
<!-- ## Nulls

PRQL defaults to `NULLS LAST` when compiling to SQL. Because databases have
different defaults, the compiler emits this for all targets for which it's not a
default<sup><a name="to-footnote-1">[1](#footnote-1)</a></sup>.

The main benefit of this approach is that `take 42` will select non-null values
for both ascending and descending sorts, which is generally what is wanted.

There isn't currently a way to change this for a query, but if that would be
helpful, please raise an issue.

Note how DuckDB doesn't require a `NULLS LAST`, unlike the generic targets
above:

```prql
prql target:sql.duckdb

from artists
sort artist_id
take 42
```

```admonish info
Check out [DuckDB #7174](https://github.com/duckdb/duckdb/pull/7174) for a survey of various databases' implementations.
```
<p><hr/>


<a name="footnote-1">[1](#to-footnote-1)</a>: except for MSSQL, which doesn't support this<div style="break-before: page; page-break-before: always;"></div><h1 id="å–"><a class="header" href="#å–">å–</a></h1>
<p>Picks rows based on their position.</p>
<pre><code class="language-prql no-eval">take (n|range)
</code></pre>
<p>See <a href="reference/stdlib/transforms/../../syntax/ranges.html">Ranges</a> for more details on how ranges work.</p>
<h2 id="ç¯„ä¾‹-8"><a class="header" href="#ç¯„ä¾‹-8">ç¯„ä¾‹</a></h2>
<div class="comparison">
<div>
<h4 id="prql-112"><a class="header" href="#prql-112">PRQL</a></h4>
<pre><code class="language-prql">from employees
take 10
</code></pre>
</div>
<div>
<h4 id="sql-109"><a class="header" href="#sql-109">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
LIMIT
  10

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-113"><a class="header" href="#prql-113">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort {-value, created_at}
take 101..110
</code></pre>
</div>
<div>
<h4 id="sql-110"><a class="header" href="#sql-110">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  orders
ORDER BY
  value DESC,
  created_at
LIMIT
  10 OFFSET 100

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¦–çª—"><a class="header" href="#è¦–çª—">è¦–çª—</a></h1>
<p>Applies a pipeline to segments of rows, producing one output value for every input value.</p>
<pre><code class="language-prql no-eval">window rows:(range) range:(range) expanding:false rolling:0 (pipeline)
</code></pre>
<p>For each row, the segment over which the pipeline is applied is determined by one of:</p>
<ul>
<li><code>rows</code>, which takes a range of rows relative to the current row position.
<ul>
<li><code>0</code> references the current row.</li>
</ul>
</li>
<li><code>range</code>, which takes a range of values relative to current row value.</li>
</ul>
<p>The bounds of the range are inclusive. If a bound is omitted, the segment will extend until the edge of the table or group.</p>
<p>For ease of use, there are two flags that override <code>rows</code> or <code>range</code>:</p>
<ul>
<li><code>expanding:true</code> is an alias for <code>rows:..0</code>. A sum using this window is also known as â€œcumulative sumâ€.</li>
<li><code>rolling:n</code> is an alias for <code>rows:(-n+1)..0</code>, where <code>n</code> is an integer. This will include <code>n</code> last values, including current row. An average using this window is also knows as a Simple Moving Average.</li>
</ul>
<p>Some examples:</p>
<div class="table-wrapper"><table><thead><tr><th>è¡¨é”å¼</th><th>æ„ç¾©</th></tr></thead><tbody>
<tr><td><code>rows:0..2</code></td><td>current row plus two following</td></tr>
<tr><td><code>rows:-2..0</code></td><td>two preceding rows plus current row</td></tr>
<tr><td><code>rolling:3</code></td><td>(same as previous)</td></tr>
<tr><td><code>rows:-2..4</code></td><td>two preceding rows plus current row plus four following rows</td></tr>
<tr><td><code>rows:..0</code></td><td>all rows from the start of the table up to &amp; including current row</td></tr>
<tr><td><code>expanding:true</code></td><td>(same as previous)</td></tr>
<tr><td><code>rows:0..</code></td><td>current row and all following rows until the end of the table</td></tr>
<tr><td><code>rows:..</code></td><td>all rows, which same as not having window at all</td></tr>
</tbody></table>
</div>
<h2 id="ç¯„ä¾‹-9"><a class="header" href="#ç¯„ä¾‹-9">ç¯„ä¾‹</a></h2>
<div class="comparison">
<div>
<h4 id="prql-114"><a class="header" href="#prql-114">PRQL</a></h4>
<pre><code class="language-prql">from employees
group employee_id (
  sort month
  window rolling:12 (
    derive {trail_12_m_comp = sum paycheck}
  )
)
</code></pre>
</div>
<div>
<h4 id="sql-111"><a class="header" href="#sql-111">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  SUM(paycheck) OVER (
    PARTITION BY employee_id
    ORDER BY
      month ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
  ) AS trail_12_m_comp
FROM
  employees

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-115"><a class="header" href="#prql-115">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort day
window rows:-3..3 (
  derive {centered_weekly_average = average value}
)
group {order_month} (
  sort day
  window expanding:true (
    derive {monthly_running_total = sum value}
  )
)
</code></pre>
</div>
<div>
<h4 id="sql-112"><a class="header" href="#sql-112">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  AVG(value) OVER (
    ORDER BY
      day ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING
  ) AS centered_weekly_average,
  SUM(value) OVER (
    PARTITION BY order_month
    ORDER BY
      day ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) AS monthly_running_total
FROM
  orders

</code></pre>
</div>
</div>
<p>Rows vs Range:</p>
<div class="comparison">
<div>
<h4 id="prql-116"><a class="header" href="#prql-116">PRQL</a></h4>
<pre><code class="language-prql">from [
  {time_id=1, value=15},
  {time_id=2, value=11},
  {time_id=3, value=16},
  {time_id=4, value=9},
  {time_id=7, value=20},
  {time_id=8, value=22},
]
window rows:-2..0 (
  sort time_id
  derive {sma3rows = average value}
)
window range:-2..0 (
  sort time_id
  derive {sma3range = average value}
)
</code></pre>
</div>
<div>
<h4 id="sql-113"><a class="header" href="#sql-113">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    1 AS time_id,
    15 AS value
  UNION
  ALL
  SELECT
    2 AS time_id,
    11 AS value
  UNION
  ALL
  SELECT
    3 AS time_id,
    16 AS value
  UNION
  ALL
  SELECT
    4 AS time_id,
    9 AS value
  UNION
  ALL
  SELECT
    7 AS time_id,
    20 AS value
  UNION
  ALL
  SELECT
    8 AS time_id,
    22 AS value
)
SELECT
  time_id,
  value,
  AVG(value) OVER (
    ORDER BY
      time_id ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
  ) AS sma3rows,
  AVG(value) OVER (
    ORDER BY
      time_id RANGE BETWEEN 2 PRECEDING AND CURRENT ROW
  ) AS sma3range
FROM
  table_0
ORDER BY
  time_id

</code></pre>
</div>
</div>
<div class="table-wrapper"><table><thead><tr><th>time_id</th><th>value</th><th>sma3rows</th><th>sma3range</th></tr></thead><tbody>
<tr><td>1</td><td>15</td><td>15</td><td>15</td></tr>
<tr><td>2</td><td>11</td><td>13</td><td>13</td></tr>
<tr><td>3</td><td>16</td><td>14</td><td>14</td></tr>
<tr><td>4</td><td>9</td><td>12</td><td>12</td></tr>
<tr><td>7</td><td>20</td><td>15</td><td>20</td></tr>
<tr><td>8</td><td>22</td><td>17</td><td>21</td></tr>
</tbody></table>
</div>
<p>We can see that rows having <code>time_id</code> of 5 and 6 are missing in example data; we can say there are gaps in our time series data.</p>
<p>When computing SMA 3 for the fifth row (<code>time_id==7</code>) then:</p>
<ul>
<li>â€œrowsâ€ will compute average on 3 rows (<code>time_id</code> in <code>3, 4, 7</code>)</li>
<li>â€œrangeâ€ will compute average on single row only (<code>time_id==7</code>)</li>
</ul>
<p>When computing SMA 3 for the sixth row (<code>time_id==8</code>) then:</p>
<ul>
<li>â€œrowsâ€ will compute average on 3 rows (<code>time_id</code> in <code>4, 7, 8</code>)</li>
<li>â€œrangeâ€ will compute average on 2 rows (<code>time_id</code> in <code>7, 8</code>)</li>
</ul>
<p>We can observe that â€œrowsâ€ ignores the content of the <code>time_id</code>, only uses its order; we can say its window operates on physical rows. On the other hand â€œrangeâ€ looks at the content of the <code>time_id</code> and based on the content decides how many rows fits into window; we can say window operates on logical rows.</p>
<h2 id="windowing-by-default"><a class="header" href="#windowing-by-default">Windowing by default</a></h2>
<p>If you use window functions without <code>window</code> transform, they will be applied to the whole table. Unlike in SQL, they will remain window functions and will not trigger aggregation.</p>
<div class="comparison">
<div>
<h4 id="prql-117"><a class="header" href="#prql-117">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort age
derive {rnk = rank age}
</code></pre>
</div>
<div>
<h4 id="sql-114"><a class="header" href="#sql-114">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  RANK() OVER (
    ORDER BY
      age
  ) AS rnk
FROM
  employees
ORDER BY
  age

</code></pre>
</div>
</div>
<p>You can also only apply <code>group</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-118"><a class="header" href="#prql-118">PRQL</a></h4>
<pre><code class="language-prql">from employees
group department (
  sort age
  derive {rnk = rank age}
)
</code></pre>
</div>
<div>
<h4 id="sql-115"><a class="header" href="#sql-115">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *,
  RANK() OVER (
    PARTITION BY department
    ORDER BY
      age
  ) AS rnk
FROM
  employees

</code></pre>
</div>
</div>
<h2 id="window-functions-as-first-class-citizens"><a class="header" href="#window-functions-as-first-class-citizens">Window functions as first class citizens</a></h2>
<p>There are no limitations on where windowed expressions can be used:</p>
<div class="comparison">
<div>
<h4 id="prql-119"><a class="header" href="#prql-119">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter salary &lt; (average salary)
</code></pre>
</div>
<div>
<h4 id="sql-116"><a class="header" href="#sql-116">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    *,
    AVG(salary) OVER () AS _expr_0
  FROM
    employees
)
SELECT
  *
FROM
  table_0
WHERE
  salary &lt; _expr_0

</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¦ç¯„"><a class="header" href="#è¦ç¯„">è¦ç¯„</a></h1>
<p>This chapter explains PRQLâ€™s semantics: how expressions are interpreted and their meaning. Itâ€™s intended for advanced users and compiler contributors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-è™•ç†"><a class="header" href="#null-è™•ç†">Null è™•ç†</a></h1>
<p>SQL has an unconventional way of handling <code>NULL</code> values, since it treats them as unknown values. As a result, in SQL:</p>
<ul>
<li><code>NULL</code> is not a value indicating a missing entry, but a placeholder for anything possible,</li>
<li><code>NULL = NULL</code> evaluates to <code>NULL</code>, since one cannot know if one unknown is equal to another unknown,</li>
<li><code>NULL &lt;&gt; NULL</code> evaluates to <code>NULL</code>, using same logic,</li>
<li>to check if a value is <code>NULL</code>, SQL introduces <code>IS NULL</code> and <code>IS NOT NULL</code> operators,</li>
<li><code>DISTINCT column</code> may return multiple <code>NULL</code> values.</li>
</ul>
<p>For more information, check out the <a href="https://www.postgresql.org/docs/current/functions-comparison.html">Postgres documentation</a>.</p>
<p>PRQL, on the other hand, treats <code>null</code> as a value, which means that:</p>
<ul>
<li><code>null == null</code> evaluates to <code>true</code>,</li>
<li><code>null != null</code> evaluates to <code>false</code>,</li>
<li>distinct column cannot contain multiple <code>null</code> values.</li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-120"><a class="header" href="#prql-120">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter first_name == null
filter null != last_name
</code></pre>
</div>
<div>
<h4 id="sql-117"><a class="header" href="#sql-117">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
WHERE
  first_name IS NULL
  AND last_name IS NOT NULL

</code></pre>
</div>
</div>
<p>Note that PRQL doesnâ€™t change how <code>NULL</code> is compared between columns, for example in joins. (PRQL compiles to SQL and so canâ€™t change the behavior of the database).</p>
<p>For more context or to provide feedback check out the discussion on <a href="https://github.com/PRQL/prql/issues/99">issue #99</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="åç¨±è§£æ"><a class="header" href="#åç¨±è§£æ">åç¨±è§£æ</a></h1>
<p>Because PRQL primarily handles relational data, it has specialized scoping rules for referencing columns.</p>
<h2 id="scopes"><a class="header" href="#scopes">Scopes</a></h2>
<p>In PRQLâ€™s compiler, a scope is the collection of all names one can reference from a specific point in the program.</p>
<p>In PRQL, names in the scope are composed from namespace and variable name which are separated by a dot, similar to SQL. Namespaces can contain many dots, but variable names cannot.</p>
<div id="admonition-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-title">
<div class="admonition-title">
<div id="admonition-example-title">
<p>ç¯„ä¾‹</p>
</div>
<a class="admonition-anchor-link" href="reference/spec/name-resolution.html#admonition-example"></a>
</div>
<div>
<p>Name <code>my_table.some_column</code> is a variable <code>some_column</code> from namespace <code>my_table</code>.</p>
<p>Name <code>foo.bar.baz</code> is a variable <code>baz</code> from namespace <code>foo.bar</code>.</p>
</div>
</div>
<p>When processing a query, a scope is maintained and updated for each point in the query.</p>
<p>It start with only namespace <code>std</code>, which is the standard library. It contains common functions like <code>sum</code> or <code>count</code>, along with all transform functions such as <code>derive</code> and <code>group</code>.</p>
<p>In pipelines (or rather in transform functions), scope is also injected with namespaces of tables which may have been referenced with <code>from</code> or <code>join</code> transforms. These namespaces contain simply all the columns of the table and possibly a wildcard variable, which matches any variable (see the algorithm below). Within transforms, there is also a special namespace that does not have a name. It is called a <em>â€œframeâ€</em> and it contains columns of the current table the transform is operating on.</p>
<h2 id="resolving"><a class="header" href="#resolving">Resolving</a></h2>
<p>For each ident we want to resolve, we search the scopeâ€™s items in order. One of three things can happen:</p>
<ul>
<li>
<p>Scope contains an exact match, e.g. a name that matches in namespace and the variable name.</p>
</li>
<li>
<p>Scope does not contain an exact match, but the ident did not specify a namespace, so we can match a namespace that contains a <code>*</code> wildcard. If thereâ€™s a single namespace, the matched namespace is also updated to contain this new variable name.</p>
</li>
<li>
<p>Otherwise, the nothing is matched and an error is raised.</p>
</li>
</ul>
<h2 id="ç¿»è­¯ç‚º-sql"><a class="header" href="#ç¿»è­¯ç‚º-sql">ç¿»è­¯ç‚º SQL</a></h2>
<p>When translating into an SQL statement which references only one table, there is no need to reference column names with table prefix.</p>
<div class="comparison">
<div>
<h4 id="prql-121"><a class="header" href="#prql-121">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-118"><a class="header" href="#sql-118">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees

</code></pre>
</div>
</div>
<p>But when there are multiple tables and we donâ€™t have complete knowledge of all table columns, a column without a prefix (i.e. <code>first_name</code>) may actually reside in multiple tables. Because of this, we have to use table prefixes for all column names.</p>
<div class="comparison">
<div>
<h4 id="prql-122"><a class="header" href="#prql-122">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive {first_name, dept_id}
join d=departments (==dept_id)
select {first_name, d.title}
</code></pre>
</div>
<div>
<h4 id="sql-119"><a class="header" href="#sql-119">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.first_name,
  d.title
FROM
  employees
  JOIN departments AS d ON employees.dept_id = d.dept_id

</code></pre>
</div>
</div>
<p>As you can see, <code>employees.first_name</code> now needs table prefix, to prevent conflicts with potential column with the same name in <code>departments</code> table. Similarly, <code>d.title</code> needs the table prefix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ¨¡çµ„"><a class="header" href="#æ¨¡çµ„">æ¨¡çµ„</a></h1>
<blockquote>
<p>This is a technical document. For a â€œhow to useâ€ or a TLDR; skip to the <a href="reference/spec/modules.html#example">Example</a> section.</p>
</blockquote>
<p>Design goals:</p>
<ol>
<li>
<p>Allow importing declarations from other files.</p>
</li>
<li>
<p>Have namespaces for things like <code>std</code>.</p>
</li>
<li>
<p>Have a hierarchical structure so we can represent files in directories.</p>
</li>
<li>
<p>Have an unambiguous module structure within a project.</p>
</li>
</ol>
<h2 id="å®šç¾©"><a class="header" href="#å®šç¾©">å®šç¾©</a></h2>
<p>A module is a namespace that contains declarations. A module is itself a declaration, which means that it can contain nested child modules.</p>
<p>This means that modules form a <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">tree graph</a>, which we call â€œthe module structureâ€.</p>
<p>For the sake of this document, we will express the module structure with <code>module</code> keyword and a code block encased in curly braces:</p>
<pre><code>module my_playlists {
    let bangers = ... # a declaration

    module soundtracks {
        let movie_albums = ... # another declaration
    }
}
</code></pre>
<blockquote>
<p>The syntax <code>module name { ...decls... }</code> is not part of PRQL language, with the objection that it is unnecessary as it only adds more ways of defining modules. If a significant upside of this syntax is found, it may be added in the future.</p>
</blockquote>
<h2 id="åç¨±è§£æ-1"><a class="header" href="#åç¨±è§£æ-1">åç¨±è§£æ</a></h2>
<p>Any declarations within a module can be referenced from the outside of the module:</p>
<pre><code class="language-prql no-eval"># using module structure declared above
module my_playlists

let great_tracks = my_playlists.bangers

let movie_scores = my_playlists.soundtracks.movie_albums
</code></pre>
<p>Identifiers are resolved relative to current module.</p>
<pre><code class="language-prql no-eval">module my_playlists {
    module soundtracks {
        let movie_albums = (from albums | filter id == 3)
    }

    from soundtracks.movie_albums
}
from my_playlists.soundtracks.movie_albums
</code></pre>
<p>If an identifier cannot be resolved relative to the current module, it tries to resolve relative to the parent module. This is repeated, stepping up the module hierarchy until a match is found or root of the module structure is reached.</p>
<pre><code class="language-prql no-eval">module my_playlists {
    let decl_1 = ...

    module soundtracks {
        let decl_2 = ...
    }

    module upbeat_rock {
        let decl_3 = ...

        from decl_1 | join soundtracks.decl2 | join decl_3
    }
}
</code></pre>
<h2 id="main-var-declaration"><a class="header" href="#main-var-declaration">Main var declaration</a></h2>
<p>The final variable declaration in a module can omit the leading <code>let main =</code> and acquire an implicit name main.</p>
<pre><code>module my_playlists {
    let bangers = (from tracks | take 10)

    from playlists | take 10
}

let album_titles = my_playlists.main
</code></pre>
<p>When a module is referenced as a value, the <code>main</code> variable is used instead. This is especially useful when referring to a module which is to be compiled to RQ (and later SQL).</p>
<pre><code># last line from previous example could thus be shortened to:
let album_titles = my_playlists
</code></pre>
<h2 id="file-importing"><a class="header" href="#file-importing">File importing</a></h2>
<blockquote>
<p>This section is under discussion. Current implementation plans do not include <code>module</code> declarations, but loading of all files under the compilation path.</p>
</blockquote>
<p>To include PRQL source code from other files, we can use the following syntax:</p>
<pre><code>module my_playlists
</code></pre>
<p>This loads either <code>./my_playlists.prql</code> (a leaf module) or <code>./my_playlists/_my_playlists.prql</code> (a directory module) and uses its contents as module <code>my_playlists</code>. If none or both of the files are present, a compilation error is raised.</p>
<p>Only directory modules can contain module declarations. If a leaf module contains a module declaration, a compilation error is raised, suggesting the leaf module to be converted into a directory module. This is a step toward any module structure having a single â€œnormalizedâ€ representation in the file system. Such normalization is desired because it restrains the possible file system layouts to a comprehensible and predictable layout, while not sacrificing any functionality.</p>
<p>Described importing rules donâ€™t achieve this â€œsingle normalized representationâ€ in full, since any leaf modules could be replaced by a directory module with zero submodules, without any semantic changes. Restricting directory modules to have at least one sub-module would not improve approachability enough to justify adding this restriction.</p>
<p>For example, the following module structure is annotated with files names in which the modules would reside:</p>
<pre><code class="language-prql no-eval">
module my_project {
    # _my_project.prql

    module sales {
        # sales.prql
    }

    module projections {
        # projections/_projections.prql

        module year_2023 {
            # projections/year_2023.prql
        }

        module year_2024 {
            # projections/year_2024.prql
        }
    }
}
</code></pre>
<p>If module <code>my_project.sales</code> wants to add a submodule <code>util</code>, it has to be converted to a directory modules. This means that it has to be moved to <code>sales/_sales.prql</code>. The new module would reside in <code>sales/util.prql</code>.</p>
<p>The annotated layout is not the only possible layout for this module structure, since any of the modules <code>sales</code>, <code>year_2023</code> or <code>year_2024</code> could be converted into a directory module with zero sub-modules.</p>
<p>Point 4 of design goals means that each declaration within a project has a single fully-qualified name within this project. This is ensured by strict rules regarding importing files and the fact that the module structure is a tree.</p>
<h2 id="declaration-order"><a class="header" href="#declaration-order">Declaration order</a></h2>
<p>The order of declarations in a module holds no semantic value, except the â€œlast <code>main</code> variableâ€.</p>
<p>References between modules can be cyclic.</p>
<pre><code>module mod_a {
    let decl_a_1 = ...
    let decl_a_2 = (from mod_b.decl_b | take 10)
}
module mod_b {
    let decl_b = (from mod_a.decl_a | take 10)
}
</code></pre>
<p>References between variable declarations cannot be cyclic.</p>
<pre><code>let decl_a = (from decl_b)
let decl_b = (from decl_a) # error: cyclic reference
</code></pre>
<pre><code>module mod_a {
    let decl_a = (from mod_b.decl_b)
}
module mod_b {
    let decl_b = (from mod_a.decl_a) # error: cyclic reference
}
</code></pre>
<h2 id="compiler-interface"><a class="header" href="#compiler-interface">Compiler interface</a></h2>
<p><code>prql-compiler</code> provides two interfaces for compiling files.</p>
<p><strong>Multi-file interface</strong> requires three arguments:</p>
<ul>
<li>path to the file containing the module which is the root of the module structure,</li>
<li>identifier of the pipeline that should be compiled to RQ (this can also be an identifier of a module that has a <code>main</code> pipeline) and,</li>
<li>a â€œfile loaderâ€, which can load files on-demand.</li>
</ul>
<p>The path to the root module can be automatically detected by searching for <code>.prql</code> files starting with <code>_</code> in the current working directory.</p>
<p>Example prqlc usage:</p>
<pre><code>$ prqlc compile _project.prql sales.projections.orders_2024
$ prqlc compile sales.projections.orders_2024
</code></pre>
<p><strong>Single-file interface</strong> requires a single argument; the PRQL source. Any attempts to load modules in this mode result in compilation errors. This interface is needed, for example, when integrating the compiler with a database connector (i.e. JDBC) where no other files can be loaded.</p>
<h2 id="built-in-module-structure"><a class="header" href="#built-in-module-structure">Built-in module structure</a></h2>
<blockquote>
<p>Work In Progress</p>
</blockquote>
<pre><code># root module of every project
module project {
	module std {
		let sum = a -&gt; ...
		let mean = a -&gt; ...
	}

	module default_db {
		# all inferred tables and defined CTEs
	}

	let main = (
		from t = tracks
		select [track_id, title]
	)
}
</code></pre>
<h2 id="ç¯„ä¾‹-10"><a class="header" href="#ç¯„ä¾‹-10">ç¯„ä¾‹</a></h2>
<p>This is an example project, where each of code block is a separate file.</p>
<pre><code># _project.prql

module employees
module sales
module util
</code></pre>
<pre><code># employees.prql

let employees = (...)

let salaries = (...)

let departments = (...)
</code></pre>
<pre><code># sales/_sales.prql

module orders
module projections

let revenue_by_source = (...)
</code></pre>
<pre><code># sales/orders.prql

let current_year = (...)

let archived = (...)

let by_employee = (from orders | join employees.employees ...)
</code></pre>
<pre><code># sales/projections.prql

let orders_2023 = (from orders.current_year | append orders.archived)

let orders_2024 = (...)
</code></pre>
<pre><code># util.prql

let pretty_print_num = col -&gt; (...)
</code></pre>
<hr />
<p>Sources:</p>
<ul>
<li><a href="https://matklad.github.io/2021/11/27/notes-on-module-system.html">Notes On Module System</a>, by @matklad.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å‹åˆ¥ç³»çµ±"><a class="header" href="#å‹åˆ¥ç³»çµ±">å‹åˆ¥ç³»çµ±</a></h1>
<blockquote>
<p>The type system determines the allowed values of a term.</p>
<p>â€“ Wikipedia</p>
</blockquote>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>Each of the SQL DBMSs has their own type system. Thanks to SQL standard, they are very similar, but have key differences. For example, SQLite does not have a type for date or time or timestamps, but it has functions for handling date and time that take ISO 8601 strings or integers that represent Unix timestamps. So it does support most of what is possible to do with dates in other dialects, even though it stores data with a different physical layout and uses different functions to achieve that.</p>
<p>PRQLâ€™s task is to define common description of <em>data formats</em>, just as how it already defines common <em>data transformations</em>.</p>
<p>We believe this should best be done in two steps:</p>
<ol>
<li>
<p>Define PRQLâ€™s Type System (PTS), following principles we think a relational language should have (and not focus on what existing SQL DBMSs have).</p>
</li>
<li>
<p>Define a mapping between SQL Type System (STS) and PTS, for each of the DBMSs. Ideally weâ€™d want that to be a bijection, so each type in PTS would be represented by a single type in STS and vice-versa. Unfortunately this is not entirely possible, as shown below.</p>
</li>
</ol>
<p>In practical terms, we want for a user to be able to:</p>
<ul>
<li>
<p>â€¦ express types of their database with PRQL (map their STS into PTS). In some cases, we can allow to say â€œyour database is not representable with PRQL, change it or use only a subset of itâ€. An example of what we donâ€™t want to support are arrays with arbitrary indexes in Postgres (i.e. 2-based index for arrays).</p>
<p>This task of mapping to PTS could be automated by LSP server, by introspecting userâ€™s SQL database and generating PRQL source.</p>
</li>
<li>
<p>â€¦ express their SQL queries in PRQL. Again, using mapping from STS to PTS, one should be able to express any SQL operation in PRQL.</p>
<p>For example, translate MSSQL <code>DATEDIFF</code> to subtraction operator <code>-</code> in PRQL.</p>
<p>For now, this mapping is manual, but should be documented and may be automated.</p>
</li>
<li>
<p>â€¦ use any PRQL feature in their database. Here we are mapping back from PTS into STS. Note that STS may have changed to a different dialect.</p>
<p>For example, translate PRQLâ€™s datetime operations to use TEXT in SQLite.</p>
<p>As of now, prql-compiler already does a good job of automatically doing this mapping.</p>
</li>
</ul>
<p>Example of the mapping between PTS and two STSs:</p>
<div class="table-wrapper"><table><thead><tr><th>PTS</th><th>STS Postgres</th><th>STS SQLite</th></tr></thead><tbody>
<tr><td>int32</td><td>integer</td><td>INTEGER</td></tr>
<tr><td>int64</td><td>bigint</td><td>INTEGER</td></tr>
<tr><td>timestamp</td><td>timestamp</td><td>TEXT</td></tr>
</tbody></table>
</div>
<h2 id="principles"><a class="header" href="#principles">Principles</a></h2>
<p><strong>Algebraic types</strong> - have a way of expressing sum and product types. In Rust, sum would be an enum and product would be tuple or a struct. In SQL, product would be a row, since it can contain different types, all at once. Sum would be harder to express, see (this post)[https://www.parsonsmatt.org/2019/03/19/sum_types_in_sql.html ].</p>
<p>The value proposition here is that algebraic types give a lot modeling flexibility, all while being conceptually simple.</p>
<p><strong>Composable</strong> - as with transformation, weâ€™d want types to compose together.</p>
<p>Using Python, JavaScript, C++ or Rust, one could define many different data structures that would correspond to our idea of â€œrelationâ€. Most of them would be an object/struct that has column names and types and then a generic array of arrays for rows.</p>
<p>PRQLâ€™s type system should also be able to express relations as composed from primitive types, but have only one idiomatic way of doing so.</p>
<p>In practice this means that builtin types include only primitives (int, text, bool, float), tuple (for product), enum (for sum) and array (for repeating).</p>
<p>An SQL row would translate to tuple, and a relation would translate to an array of tuples.</p>
<p>I would also strive for the type system to be minimal - donâ€™t differentiate between tuples, objects and structs. Choose one and stick to it.</p>
<p><strong>Type constraints</strong> - constrain a type with a predicate. For example, have a type of <code>int64</code>s that are equal or greater than 10. Postgres <a href="https://news.ycombinator.com/item?id=34835063">does support this</a>. The primary value of using constrained types would not be validation (as it is used in linked article), but when matching the type.</p>
<p>Say, for example, that we have a pipeline like this:</p>
<pre><code>derive color = switch [x =&gt; 'red', true =&gt; 'green']
derive is_red = switch [color == 'red' =&gt; true, color == 'green' =&gt; false]
</code></pre>
<p>It should be possible to infer that <code>color</code> is of type <code>text</code>, but only when equal to <code>'red'</code> or <code>'green'</code>. This means that the second switch covers all possible cases and <code>is_red</code> cannot be <code>null</code>.</p>
<h2 id="theory"><a class="header" href="#theory">Theory</a></h2>
<blockquote>
<p>For any undefined terms used in this section, refer to set theory and mathematical definitions in general.</p>
</blockquote>
<p>A â€œtype of a variableâ€ is a â€œset of all possible values of that variableâ€. This means that terms â€œtypeâ€ and â€œsetâ€ are equivalent in this context.</p>
<p>Types (sets) can be expressions. For example, a union of two types is a type itself. This means a type expression is equivalent to any other expression whose type is a â€œset of setsâ€.</p>
<p>So letâ€™s introduce a â€œsetâ€ as a PRQL expression construct (alongside existing idents, literals, ranges and so on). For now, it does not need any special syntax. Because sets are normal expressions, existing syntax can be repurposed to define operations on sets:</p>
<ul>
<li>
<p>Binary operation <code>or</code> of two sets represents a union of those two sets:</p>
<pre><code>let number = int or float
</code></pre>
<p>With algebraic types, this is named â€œa sum typeâ€.</p>
</li>
<li>
<p>Literals can be coerced into a singleton set (i.e. <code>false</code> is converted into a set with only one element <code>false</code>):</p>
<pre><code>let int_or_null = int or null
</code></pre>
</li>
<li>
<p>A list of set expressions can be coerced into a set of tuples, where entries of the tuples correspond to elements of the set expressions in the list:</p>
<pre><code>let my_row = [id = int, bool, name = str]
</code></pre>
</li>
<li>
<p>An array of set expressions with exactly one entry can be coerced into a set of arrays of that set expression:</p>
<pre><code>let array_of_int = {int} # proposed syntax for arrays
</code></pre>
</li>
<li>
<p>A function that takes set as params and returns a set is converted into a set of functions.</p>
<pre><code>let floor_signature = (float -&gt; int)
# using a proposed syntax for lambda functions
</code></pre>
</li>
</ul>
<p>Module <code>std</code> defines built-in sets <code>int</code>, <code>float</code>, <code>bool</code>, <code>text</code> and <code>set</code>. Other built-in sets will be added in the future.</p>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type annotations</a></h2>
<p>Letâ€™s extend the syntax for declaration of variable <code>a</code>, whose value can be computed by evaluating <code>x</code>, with a type annotation:</p>
<pre><code>let a &lt;t&gt; = x
</code></pre>
<p>This extended syntax applies following assertions:</p>
<ul>
<li><code>t</code> can be evaluated statically (at compile time),</li>
<li><code>t</code> can be coerced into a set,</li>
<li>value of <code>x</code> (and <code>a</code>) must be an element of <code>t</code>. This assertion must be possible to evaluate statically.</li>
</ul>
<p>Similar rules apply to type annotations of return types of functions and function parameter definitions.</p>
<h2 id="type-definitions"><a class="header" href="#type-definitions">Type definitions</a></h2>
<p>As shown, types can be defined by defining expressions and coercing them to set expressions by using <code>&lt; &gt;</code>.</p>
<p>But similar to how both <code>func</code> and <code>let</code> can be used to define functions (when we introduce lambda function syntax), letâ€™s also introduce syntactic sugar for type definitions:</p>
<pre><code># these two are equivalent
let my_type &lt;set&gt; = set_expr
type my_type = set_expr
</code></pre>
<h2 id="container-types"><a class="header" href="#container-types">Container types</a></h2>
<blockquote>
<p>Terminology is under discussion</p>
</blockquote>
<p><strong>Tuple</strong> is the only product type in PTS. It contains n ordered fields, where n is known at compile-time. Each field has a type itself and an optional name. Fields are not necessarily of the same type.</p>
<p>In other languages, similar constructs are named record, struct, tuple, named tuple or (data)class.</p>
<p><strong>Array</strong> is a container type that contains n ordered fields, where n is not known at compile-time. All fields are of the same type and cannot be named.</p>
<p><strong>Relation</strong> is an array of tuples.</p>
<p>The first argument of transforms <code>select</code> and <code>derive</code> contains a known number of entries, which can be of different types. Thus, it is a tuple.</p>
<pre><code>select [1.4, false, "foo"]
</code></pre>
<h2 id="physical-layout"><a class="header" href="#physical-layout">Physical layout</a></h2>
<p><em>Logical type</em> is user-facing the notion of a type that is the building block of the type system.</p>
<p><em>Physical layout</em> is the underlying memory layout of the data represented by a variable.</p>
<p>In many programming languages, physical layout of a logical type is dependent on the target platform. Similarly, physical layout of a PRQL logical type is dependent on representation of that type in the target STS.</p>
<pre><code>PTS logical type  ---&gt;  STS logical type  ---&gt; STS physical layout
</code></pre>
<p>Note that STS types do not have a single physical layout. Postgres has a logical (pseudo)type <code>anyelement</code>, which is a super type of any data type. It can be used as a function parameter type, but does not have a single physical layout so it cannot be used in a column declaration.</p>
<p>For now, PRQL does not define physical layouts of any type. It is not needed since PRQL is not used for DDL (see section â€œBuilt-in primitivesâ€) or does not support raw access to underlying memory.</p>
<p>As a consequence, results of a PRQL query cannot be robustly compared across DBMSs, since the physical layout of the result will vary.</p>
<p>In the future, PRQL may define a common physical layout of types, probably using Apache Arrow.</p>
<!-- ## Enums

```
# user-defined enum
type open
type pending
type closed
type status = open or pending or closed
``` -->
<h2 id="ç¯„ä¾‹-11"><a class="header" href="#ç¯„ä¾‹-11">ç¯„ä¾‹</a></h2>
<pre><code>type my_relation = {[
	id = int,
	title = text,
	age = int
]}

type invoices = {[
    invoice_id = int64,
    issued_at = timestamp,
    labels = {text}

    #[repr(json)]
    items = [{
        article_id = int64,
        count = int16 where x -&gt; x &gt;= 1,
    }],
    paid_by_user_id = int64 or null,
    status = status,
]}
</code></pre>
<h2 id="é™„éŒ„"><a class="header" href="#é™„éŒ„">é™„éŒ„</a></h2>
<h3 id="built-in-primitives"><a class="header" href="#built-in-primitives">Built-in primitives</a></h3>
<p>This document mentions <code>int32</code> and <code>int64</code> as distinct types, but there is no need for that in the initial implementation. The built-in <code>int</code> can associate with all operations on integers and translate PRQL to valid SQL regardless of the size of the integer. Later, <code>int</code> cam be replaced by:</p>
<pre><code>type int = int8 || int16 || int32 || int64
</code></pre>
<p>The general rule for â€œwhen to make a distinction between typesâ€ would be â€œas soon as the types carry different information and we find an operation that would be expressed differentlyâ€. In this example, that would require some operation on <code>int32</code> to have different syntax than same operation over <code>int64</code>.</p>
<p>We can have such relaxed rule because PRQL is not aiming to be a Data Definition Language and does not have to bother with exact physical layout of types.</p>
<h3 id="type-representations"><a class="header" href="#type-representations">Type representations</a></h3>
<p>There are cases where a PTS type has multiple possible and valid representations in some STSs.</p>
<p>For such cases, weâ€™d want to support the use of alternative representations for storing data, but also application of any function that is defined for the original type.</p>
<p>Using SQLite as an example again, users may have some temporal data stored as INTEGER unix timestamp and some as TEXT that contains ISO 8601 without timezone. From the userâ€™s perspective, both of these types are <code>timestamp</code>s and should be declared as such. But when compiling operations over these types to SQL, the compiler should consider their different representations in STS. For example a difference between two timestamps <code>timestamp - timestamp</code> can be translated to a normal int subtraction for INTEGER repr, but must apply SQLiteâ€™s function <code>unixepoch</code> when dealing with TEXT repr.</p>
<p>Table declarations should therefore support annotations that give hints about which representation is used:</p>
<pre><code>table foo {
    #[repr(text)]
    created_at: timestamp,
}
</code></pre>
<p>A similar example is an â€œarray of strings typeâ€ in PTS that could be represented by a <code>text[]</code> (if DBMS supports arrays) or <code>json</code> or itâ€™s variant <code>jsonb</code> in Postgres. Again, the representation would affect operators: in Postgres, arrays would be accessed with <code>my_array[1]</code> and json arrays would use <code>my_json_array -&gt; 1</code>. This example may not be applicable, if we decide that we want a separate JSON type in PST.</p>
<h3 id="rq-functions-targets-and-reprs"><a class="header" href="#rq-functions-targets-and-reprs">RQ functions, targets and reprs</a></h3>
<blockquote>
<p>This part is talks about technical implementations, not the language itself</p>
</blockquote>
<h4 id="idea"><a class="header" href="#idea">Idea</a></h4>
<p>RQ contains a single node kind for expressing operations and functions: BuiltInFunction (may be renamed in the future).</p>
<p>It is a bottleneck that we can leverage when trying to affect how an operator or a function interacts with different type representations on different targets.</p>
<p>Idea is to implement the BuiltInFunction multiple times and annotate it with it intended target and parameter representation. Then we can teach the compiler to pick the appropriate function implementation that suit current repr and compilation target.</p>
<h4 id="specifics"><a class="header" href="#specifics">Specifics</a></h4>
<p>RQ specification is an interface that contains functions, identified by name (i.e. <code>std.int8.add</code>). These functions have typed parameters and a return value. If an RQ function call does not match the function declaration in number or in types of the parameters, this is considered an invalid RQ AST.</p>
<p>We provide multiple implementations for each RQ function. They are annotated with a target (i.e. <code>#[target(sql.sqlite)]</code>) and have their params annotated with type reprs (i.e. <code>#[repr(int)]</code>).</p>
<pre><code># using a made-up syntax

#[target(sql.sqlite)]
func std.int8.add
    #[repr(int8)] x
    #[repr(int8)] y
    -&gt; s"{x} + {y}"
</code></pre>
<p>Each RQ type has one canonical repr that serves as the reference implementation for other reprs and indicates the amount of contained data (i.e. 1 bit, 8 bits, 64 bits).</p>
<h4 id="ç¯„ä¾‹-12"><a class="header" href="#ç¯„ä¾‹-12">ç¯„ä¾‹</a></h4>
<p>Letâ€™s say for example, that weâ€™d want to support 8bit integer arithmetic, and that weâ€™d want the result of <code>127 + 1</code> to be <code>-128</code> (ideally weâ€™d handle this better, but bear with me for the sake of the example). Because some RDBMSs donâ€™t support 8bit numbers and do all their integer computation with 64bit numbers (SQLite), we need to implement an alternative type representation for that target.</p>
<p>The logical type <code>int8</code> could have the following two reprs:</p>
<ul>
<li>canonical <code>repr_int8</code> that contains 8 bits in twoâ€™s complement, covering integer values in range -128 to 127 (inclusive),</li>
<li><code>repr_int64</code> that contains 64 bits of data, but is using only the values that are also covered by <code>repr_int8</code>.</li>
</ul>
<p>Now weâ€™d implement function <code>std.int8.add</code> for each of the reprs. Letâ€™s assume that the <code>int8</code> implementation is straightforward and that databases donâ€™t just change the data type when a number overflows. The impl for <code>int64</code> requires a CASE statement that checks if the value would overflow and subtact 256 in that case.</p>
<p>The goal here is that the results of the two impls are equivalent. To validate that, we also need a way to convert between the reprs, or another <code>to_string</code> function, implemented for both reprs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-è®Šæ›´æ—¥èªŒ"><a class="header" href="#prql-è®Šæ›´æ—¥èªŒ">PRQL è®Šæ›´æ—¥èªŒ</a></h1>
<h2 id="0101--2023-11-14"><a class="header" href="#0101--2023-11-14">0.10.1 â€” 2023-11-14</a></h2>
<p>0.10.1 is a small release containing some internal fixes of the compiler.</p>
<p>This release has 36 commits from 7 contributors. Selected changes:</p>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>The <code>std.sql.read_csv</code> function and the <code>std.sql.read_parquet</code> function supports the <code>sql.glaredb</code> target. (@eitsupi, #3749)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Fix the bug of compiling to <code>DISTINCT ON</code> when <code>take 1</code> is used with <code>group by</code> for the targets <code>sql.clickhouse</code>, <code>sql.duckdb</code> and <code>sql.postgres</code>. (@aljazerzen, #3792)</li>
</ul>
<p><strong>æ•´åˆ</strong>ï¼š</p>
<ul>
<li>Enable integration tests for GlareDB. (@eitsupi, #3749)</li>
<li><a href="https://github.com/trapd00r/LS_COLORS">trapd00r/LS_COLORS</a>, a collection of LS_COLORS definitions colorizes <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://github.com/sharkdp/vivid">vivid</a>, a themeable LS_COLORS generator colorizes <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://github.com/athityakumar/colorls">colorls</a>, displays <code>.prql</code> files with a database icon. (@vanillajonathan)</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=mightbesimon.emoji-icons">Emoji File Icons</a>, a VS Code extension displays <code>.prql</code> files with a database emoji icon. (@vanillajonathan)</li>
<li><a href="https://eza.rocks/">eza</a>, a modern ls replacement colorizes <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://github.com/lsd-rs/lsd">lsd</a>, next gen ls command displays <code>.prql</code> files with a database icon. (@vanillajonathan)</li>
</ul>
<h2 id="0100--2023-10-26"><a class="header" href="#0100--2023-10-26">0.10.0 â€” 2023-10-26</a></h2>
<p>0.10.0 contains lots of small improvements, including support for new types of literal notation, support for <code>read_*</code> functions in more dialects, playground improvements, and a better Lezer grammar (which weâ€™re planning on using for a Jupyter extension).</p>
<p>This release has 155 commits from 9 contributors. Selected changes:</p>
<p><strong>èªè¨€</strong>ï¼š</p>
<ul>
<li><em>Breaking:</em> Case syntax now uses brackets <code>[]</code> rather than braces <code>{}</code>. To convert previous PRQL queries to this new syntax simply change <code>case { ... }</code> to <code>case [ ... ]</code>. (@AaronMoat, #3517)</li>
</ul>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li><em>Breaking</em>: The <code>std.sql.read_csv</code> function is now compiled to <code>read_csv</code> by default. Please set the target <code>sql.duckdb</code> to use the DuckDBâ€™s <code>read_csv_auto</code> function as previously. (@eitsupi, #3599)</li>
<li><em>Breaking</em>: The <code>std.every</code> function is renamed to <code>std.all</code> (@aljazerzen, #3703)</li>
<li>The <code>std.sql.read_csv</code> function and the <code>std.sql.read_parquet</code> function supports the <code>sql.clickhouse</code> target. (@eitsupi, #1533)</li>
<li>Add <code>std.prql_version</code> function to return PRQL version (@hulxv, #3533)</li>
<li>A new type <code>anytype</code> is added. (@aljazerzen, #3703)</li>
<li>Add support for hex escape sequences in strings. Example <code>"Hello \x51"</code>. (@vanillajonathan, #3568)</li>
<li>Add support for long Unicode escape sequences. Example <code>"Hello \u{01F422}"</code>. (@vanillajonathan, #3569)</li>
<li>Add support for binary numerical notation. Example <code>filter status == 0b1111000011110000</code>. (@vanillajonathan, #3661)</li>
<li>Add support for hexadecimal numerical notation. Example <code>filter status == 0xff</code>. (@vanillajonathan, #3654)</li>
<li>Add support for octal numerical notation. Example <code>filter status == 0o777</code>. (@vanillajonathan, #3672)</li>
<li>New compile target <code>sql.glaredb</code> for <a href="https://docs.glaredb.com/">GlareDB</a> and integration tests for it (However, there is a bug in the test and it is currently not running). (@universalmind303, @scsmithr, @eitsupi, #3669)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>
<p>Allow cmd-/ (Mac) or ctrl-/ (Windows) to toggle comments in the playground editor (@AaronMoat, #3522)</p>
</li>
<li>
<p>Limit maximum height of the playground editorâ€™s error panel to avoid taking over whole screen (@AaronMoat, #3524)</p>
</li>
<li>
<p>The playground now uses <a href="https://vitejs.dev/">Vite</a> (@vanillajonathan).</p>
</li>
</ul>
<p><strong>æ•´åˆ</strong>ï¼š</p>
<ul>
<li>Add a CLI command <code>prqlc collect</code> to collect a projectâ€™s modules into a single file (@aljazerzen, #3739)</li>
<li>Add a CLI command <code>prqlc debug expand-pl</code> to parse &amp; and expand into PL without resolving (@aljazerzen, #3739)</li>
<li>Bump <code>prqlc</code>â€™s MSRV to 1.70.0 (@eitsupi, #3521)</li>
<li><a href="https://pygments.org/">Pygments</a>, a syntax highlighting library now has syntax highlighting for PRQL. (@vanillajonathan, #3564)</li>
<li><a href="https://github.com/alecthomas/chroma">chroma</a>, a syntax highlighting library written in Go and used by the static website generator <a href="https://gohugo.io/">Hugo</a>. (@vanillajonathan, #3597)</li>
<li><a href="https://github.com/boyter/scc">scc</a>, a source lines of code counter now has support for <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://github.com/JoaoDanielRufino/gcloc">gcloc</a> a source lines of code counter now has support for <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://github.com/AlDanial/cloc">cloc</a> a source lines of code counter now has support for <code>.prql</code> files. (@AlDanial)</li>
<li><a href="https://github.com/hhatto/gocloc">gocloc</a> a source lines of code counter now has support for <code>.prql</code> files. (@vanillajonathan)</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=quarto.quarto">The Quarto VS Code extension</a> supports editing PRQL code blocks (<a href="https://prql-lang.org/book/project/bindings/r.html"><code>prqlr</code></a> is required to render Quarto Markdown with PRQL code blocks). (@jjallaire)</li>
</ul>
<p><strong>Internal</strong>:</p>
<ul>
<li>Rename some of the internal crates, and refactored their paths in the repo. (@aljazerzen, #3683).</li>
<li>Add a <code>justfile</code> for developers who prefer that above our <code>Taskfile.yml</code> (@aljazerzen, #3681)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@hulxv, with #3533</li>
<li>@AaronMoat, with #3522</li>
<li>@jangorecki, with #3634</li>
</ul>
<h2 id="095--2023-09-16"><a class="header" href="#095--2023-09-16">0.9.5 â€” 2023-09-16</a></h2>
<p>0.9.5 adds a line-wrapping character, fixes a few bugs, and improves our CI. The release has 77 commits from 8 contributors. Selected changes are below.</p>
<p>Look out for some conference talks coming up over the next few weeks, including <a href="https://qconsf.com/presentation/oct2023/prql-simple-powerful-pipelined-sql-replacement">QCon SF on Oct 2</a> and <a href="https://www.data2day.de/veranstaltung-21353-0-prql-a-modern-language-for-data-transformation.html">date2day on Oct 12</a>.</p>
<p><strong>èªè¨€</strong>ï¼š</p>
<ul>
<li>
<p>A new line-wrapping character, for lines that are long and we want to break up into multiple physical lines. This is slightly different from from many languages â€”Â itâ€™s on the subsequent line:</p>
<pre><code class="language-prql no-eval">from artists
select is_europe =
\ country == "DE"
\ || country == "FR"
\ || country == "ES"
</code></pre>
<p>This allows for easily commenting out physical lines while maintaining a correct logical line; for example:</p>
<pre><code class="language-diff">from artists
select is_europe =
\ country == "DE"
\ || country == "FR"
\ || country == "FR"
-\ || country == "ES"
+#\ || country == "ES"
</code></pre>
<p>(@max-sixty, #3408)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>
<p>Fix stack overflow on very long queries in Windows debug builds (@max-sixty, #2908)</p>
</li>
<li>
<p>Fix panic when unresolved lineage appears in group or window (@davidot, #3266)</p>
</li>
<li>
<p>Fix a corner-case in handling precedence, and remove unneeded parentheses in some outputs (@max-sixty, #3472)</p>
</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Compiler panics are now printed to the console (@max-sixty, #3446)</li>
</ul>
<p><strong>æ•´åˆ</strong>ï¼š</p>
<ul>
<li><a href="https://ace.c9.io/">Ace</a>, the JavaScript code editor now has syntax highlighting for PRQL. (@vanillajonathan, #3493)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li>Simplify &amp; speed up lexer (@max-sixty, #3426, #3418)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@davidot, with #3450</li>
</ul>
<h2 id="094--2023-08-24"><a class="header" href="#094--2023-08-24">0.9.4 â€”Â 2023-08-24</a></h2>
<p>0.9.4 is a small release with some improvements and bug fixes in the compiler and <code>prqlc</code>. And, the documentation and CI are continually being improved.</p>
<p>This release has 110 commits from 9 contributors. Selected changes:</p>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>Strings can be delimited with any odd number of quote characters. The logic for lexing quotes is now simpler and slightly faster. Escapes in single-quote-delimited strings escape single-quotes rather than double-quotes. (@max-sixty, #3274)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>S-strings within double braces now parse correctly (@max-sixty, #3265)</li>
</ul>
<p><strong>æ–‡ä»¶</strong>ï¼š</p>
<ul>
<li>New docs for strings (@max-sixty, #3281)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Improve syntax highlighting for numbers in the book &amp; website (@max-sixty, #3261)</li>
<li>Add ClickHouse integration to docs (@max-sixty, #3251)</li>
</ul>
<p><strong>æ•´åˆ</strong>ï¼š</p>
<ul>
<li><code>prqlc</code> no longer displays a prompt when piping a query into its stdin (@max-sixty, #3248).</li>
<li>Add a minimal example for use <code>prql-lib</code> with Zig (@vanillajonathan, #3372)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li>
<p>Overhaul our CI to run a cohesive set of tests depending on the specific changes in the PR, and elide all others. This cuts CI latency to less than three minutes for most changes, and enables GitHubâ€™s auto-merge to wait for all relevant tests. It also reduces the CI time on merging to main, by moving some tests to only run on specific path changes or on our nightly run.</p>
<p>We now have one label we can add to PRs to run more tests â€”Â <code>pr-nightly</code>. (@max-sixty, #3317 &amp; others).</p>
</li>
<li>
<p>Auto-merge PRs for backports or pre-commit updates (@max-sixty, #3246)</p>
</li>
<li>
<p>Add a workflow to create an issue when the scheduled nightly workflow fails (@max-sixty, #3304)</p>
</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@FinnRG, with #3292</li>
<li>@sitiom, with #3353</li>
</ul>
<h2 id="093--2023-08-02"><a class="header" href="#093--2023-08-02">0.9.3 â€”Â 2023-08-02</a></h2>
<p>0.9.3 is a small release, with mostly documentation, internal, and CI changes.</p>
<p>This release has 85 commits from 10 contributors.</p>
<p>Weâ€™d like to welcome @not-my-profile as someone who has helped with lots of internal refactoring in the past couple of weeks.</p>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@vthriller, with #3171</li>
<li>@postmeback, with #3216</li>
</ul>
<h2 id="092--2023-07-25"><a class="header" href="#092--2023-07-25">0.9.2 â€” 2023-07-25</a></h2>
<p>0.9.2 is a hotfix release to fix an issue in the 0.9.0 &amp; 0.9.1 release pipelines.</p>
<h2 id="091--2023-07-25"><a class="header" href="#091--2023-07-25">0.9.1 â€” 2023-07-25</a></h2>
<p>0.9.1 is a hotfix release to fix an issue in the 0.9.0 release pipeline.</p>
<h2 id="090--2023-07-24"><a class="header" href="#090--2023-07-24">0.9.0 â€” 2023-07-24</a></h2>
<p>0.9.0 is probably PRQLâ€™s biggest ever release. We have dialect-specific standard-libraries, a regex operator, an initial implementation of multiple-file projects &amp; modules, lots of bug fixes, and many many internal changes.</p>
<p>Weâ€™ve made a few backward incompatible syntax changes. Most queries will work with a simple find/replace; see below for details.</p>
<p>The release has 421 commits from 12 contributors.</p>
<p>A small selection of the changes:</p>
<p><strong>èªè¨€</strong>ï¼š</p>
<ul>
<li>
<p>The major breaking change is a new syntax for lists, which have been renamed to <em>tuples</em>, and are now represented with braces <code>{}</code> rather than brackets <code>[]</code>.</p>
<p>To convert previous PRQL queries to this new syntax simply change <code>[ ... ]</code> to <code>{ ... }</code>.</p>
<p>We made the syntax change to incorporate arrays. Almost every major language uses <code>[]</code> for arrays. We are adopting that convention â€” arrays use <code>[]</code>, tuples will use <code>{}</code>. (Though we recognize that <code>{}</code> for tuples is also rare (Hi, Erlang!), but didnâ€™t want to further load parentheses with meaning.)</p>
<p>Arrays are conceptually similar to columns â€” their elements have a single type. Array syntax canâ€™t contain assignments.</p>
<p>As part of this, weâ€™ve also formalized tuples as containing both individual items (<code>select {foo, baz}</code>), and assignments (<code>select {foo=bar, baz=fuz}</code>).</p>
</li>
<li>
<p>Some significant changes regarding SQL dialects:</p>
<ul>
<li>Operators and functions can be defined on per-dialect basis. (@aljazerzen, #2681)</li>
<li><em>Breaking</em>: The <code>sql.duckdb</code> target supports DuckDB 0.8 (@eitsupi, #2810).</li>
<li><em>Breaking</em>: The <code>sql.hive</code> target is removed (@eitsupi, #2837).</li>
</ul>
</li>
<li>
<p>New arithmetic operators. These compile to different function or operator depending on the target.</p>
<ul>
<li>
<p><em>Breaking</em>: Operator <code>/</code> now always performs floating division (@aljazerzen, #2684). See the <a href="https://prql-lang.org/book/reference/syntax/operators.html#division-and-integer-division">Division docs</a> for details.</p>
</li>
<li>
<p>Truncated integer division operator <code>//</code> (@aljazerzen, #2684). See the <a href="https://prql-lang.org/book/reference/syntax/operators.html#division-and-integer-division">Division docs</a> for details.</p>
</li>
<li>
<p>Regex search operator <code>~=</code> (@max-sixty, #2458). An example:</p>
<pre><code class="language-prql no-eval">from tracks
filter (name ~= "Love")
</code></pre>
<p>â€¦compiles to;</p>
<pre><code class="language-sql">SELECT
  *
FROM
  tracks
WHERE
  REGEXP(name, 'Love')
</code></pre>
<p>â€¦though the exact form differs by dialect; see the <a href="https://prql-lang.org/book/reference/syntax/operators.html#regex">Regex docs</a> for more details.</p>
</li>
</ul>
</li>
<li>
<p>New aggregation functions: <code>every</code>, <code>any</code>, <code>average</code>, and <code>concat_array</code>. <em>Breaking:</em> Remove <code>avg</code> in favor of <code>average</code>.</p>
</li>
<li>
<p><em>Breaking:</em> Weâ€™ve changed our function declaration syntax to match other declarations. Functions were one of the first language constructs in PRQL, and since then weâ€™ve added normal declarations thereâ€™s no compelling reason for functions to be different.</p>
<pre><code class="language-prql no-eval">let add = a b -&gt; a + b
</code></pre>
<p>Previously, this was:</p>
<pre><code class="language-prql no-eval">func add a b -&gt; a + b
</code></pre>
</li>
<li>
<p>Experimental modules, which allow importing declarations from other files. Docs are forthcoming.</p>
</li>
<li>
<p>Relation literals create a relation (a â€œtableâ€) as an <em>array</em> of <em>tuples</em>. This example demonstrates the new syntax for arrays <code>[]</code> and tuples <code>{}</code>. (@aljazerzen, #2605)</p>
<pre><code class="language-prql no-eval">from [{a=5, b=false}, {a=6, b=true}]
filter b == true
select a
</code></pre>
</li>
<li>
<p><code>this</code> can be used to refer to the current pipeline, for situations where plain column name would be ambiguous:</p>
<pre><code class="language-prql no-eval">from x
derive sum = my_column
select this.sum   # does not conflict with `std.sum`
</code></pre>
<p>Within a <code>join</code> transform, there is also a reference to the right relation: <code>that</code>.</p>
</li>
<li>
<p><em>Breaking:</em> functions <code>count</code>, <code>rank</code> and <code>row_number</code> now require an argument of the array to operate on. In most cases you can directly replace <code>count</code> with <code>count this</code>. The <code>non_null</code> argument of <code>count</code> has been removed.</p>
</li>
</ul>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>
<p>Weâ€™ve changed how we handle colors.</p>
<p><code>Options::color</code> is deprecated and has no effect. Code which consumes <code>prql_compiler::compile</code> should instead accept the output with colors and use a library such as <code>anstream</code> to handle the presentation of colors. To ensure minimal disruption, <code>prql_compiler</code> will currently strip color codes when a standard environment variable such as <code>CLI_COLOR=0</code> is set or when it detects <code>stderr</code> is not a TTY.</p>
<p>We now use the <a href="https://github.com/rust-cli/anstyle"><code>anstream</code></a> library in <code>prqlc</code> &amp; <code>prql-compiler</code>.</p>
<p>(@max-sixty, #2773)</p>
</li>
<li>
<p><code>prqlc</code> can now show backtraces when the standard backtrace env var (<code>RUST_BACKTRACE</code>) is active. (@max-sixty, #2751)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Numbers expressed with scientific notation â€”Â <code>1e9</code> â€” are now handled correctly by the compiler (@max-sixty, #2865).</li>
</ul>
<p><strong>æ•´åˆ</strong>ï¼š</p>
<ul>
<li>prql-python now provides type hints (@philpep, #2912)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li>
<p>Annotations in PRQL. These have limited support but are currently used to specify binding strengths. Theyâ€™re modeled after Rustâ€™s annotations, but with <code>@</code> syntax, more similar to traditional decorators. (#2729)</p>
<pre><code class="language-prql no-eval">@{binding_strength=11}
let mod = l r -&gt; s"{l} % {r}"
</code></pre>
</li>
<li>
<p>Remove BigQueryâ€™s special handling of quoted identifiers, now that our module system handles its semantics (@max-sixty, #2609).</p>
</li>
<li>
<p>ClickHouse is tested in CI (@eitsupi, #2815).</p>
</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@maxmcd, with #2533</li>
<li>@khoa165, with #2876</li>
<li>@philpep, with #2912</li>
<li>@not-my-profile, with #2971</li>
</ul>
<h2 id="081--2023-04-29"><a class="header" href="#081--2023-04-29">0.8.1 â€” 2023-04-29</a></h2>
<p>0.8.1 is a small release with a new <code>list-targets</code> command in <code>prqlc</code>, some documentation improvements, and some internal improvements.</p>
<p>This release has 41 commits from 8 contributors.</p>
<p>From the broader perspective of the project, weâ€™re increasing the relative prioritization of it being easy for folks to actually use PRQL â€” either with existing tools, or a tool weâ€™d build. Weâ€™ll be thinking about &amp; discussing the best way to do that over the next few weeks.</p>
<h2 id="080--2023-04-14"><a class="header" href="#080--2023-04-14">0.8.0 â€” 2023-04-14</a></h2>
<p>0.8.0 renames the <code>and</code> &amp; <code>or</code> operators to <code>&amp;&amp;</code> &amp; <code>||</code> respectively, reorganizes the Syntax section in the book, and introduces <code>read_parquet</code> &amp; <code>read_csv</code> functions for reading files with DuckDB.</p>
<p>This release has 38 commits from 8 contributors. Selected changes:</p>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>
<p>Rename <code>and</code> to <code>&amp;&amp;</code> and <code>or</code> to <code>||</code>. Operators which are symbols are now consistently infix, while â€œwordsâ€ are now consistently functions (@aljazerzen, #2422).</p>
</li>
<li>
<p>New functions <code>read_parquet</code> and <code>read_csv</code>, which mirror the DuckDB functions, instructing the database to read from files (@max-sixty, #2409).</p>
</li>
</ul>
<h2 id="071--2023-04-03"><a class="header" href="#071--2023-04-03">0.7.1 â€” 2023-04-03</a></h2>
<p>0.7.1 is a hotfix release to fix <code>prql-js</code>â€™s <code>npm install</code> behavior when being installed as a dependency.</p>
<p>This release has 17 commits from 4 contributors.</p>
<h2 id="070--2023-04-01"><a class="header" href="#070--2023-04-01">0.7.0 â€” 2023-04-01</a></h2>
<p>0.7.0 is a fairly small release in terms of new features, with lots of internal improvements, such as integration tests with a whole range of DBs, a blog post on Pi day, RFCs for a type system, and more robust language bindings.</p>
<p>Thereâ€™s a very small breaking change to the rust API, hence the minor version bump.</p>
<p>Hereâ€™s our April 2023 Update, from our <a href="https://github.com/PRQL/prql/blob/main/README.md">Readme</a>:</p>
<blockquote>
<h3 id="april-2023-update"><a class="header" href="#april-2023-update">April 2023 update</a></h3>
<p>PRQL is being actively developed by a growing community. Itâ€™s ready to use by the intrepid, either as part of one of our supported extensions, or within your own tools, using one of our supported language bindings.</p>
<p>PRQL still has some minor bugs and some missing features, and probably is only ready to be rolled out to non-technical teams for fairly simple queries.</p>
<p>Hereâ€™s our current <a href="https://prql-lang.org/roadmap/">Roadmap</a> and our <a href="https://github.com/PRQL/prql/milestones">Milestones.</a></p>
<p>Our immediate focus for the code is on:</p>
<ul>
<li>Building out the next few big features, including <a href="https://github.com/PRQL/prql/pull/1964">types</a> and <a href="https://github.com/PRQL/prql/pull/2129">modules</a>.</li>
<li>Ensuring our supported features feel extremely robust; resolving any <a href="https://github.com/PRQL/prql/issues?q=is%3Aissue+is%3Aopen+label%3Abug+label%3Apriority">priority bugs</a>.</li>
</ul>
<p>Weâ€™re also spending time thinking about:</p>
<ul>
<li>Making it really easy to start using PRQL. Weâ€™re doing that by building integrations with tools that folks already use; for example our VS Code extension &amp; Jupyter integration. If there are tools youâ€™re familiar with that you think would be open to integrating with PRQL, please let us know in an issue.</li>
<li>Making it easier to contribute to the compiler. We have a wide group of contributors to the project, but contributions to the compiler itself are quite concentrated. Weâ€™re keen to expand this; <a href="https://github.com/PRQL/prql/issues/1840">#1840</a> for feedback.</li>
</ul>
</blockquote>
<hr />
<p>The release has 131 commits from 10 contributors. Particular credit goes to to @eitsupi &amp; @jelenkee, who have made significant contributions, and @vanillajonathan, whose prolific contribution include our growing language bindings.</p>
<p>A small selection of the changes:</p>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li><code>prqlc compile</code> adds <code>--color</code> &amp; <code>--include-signature-comment</code> options. (@max-sixty, #2267)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Added the PRQL snippets from the book to the <a href="https://prql-lang.org/playground/">Playground</a> (@jelenkee, #2197)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li><em>Breaking</em>: The <code>compile</code> functionâ€™s <code>Options</code> now includes a <code>color</code> member, which determines whether error messages use ANSI color codes. This is technically a breaking change to the API. (@max-sixty, #2251)</li>
<li>The <code>Error</code> struct now exposes the <code>MessageKind</code> enum. (@vanillajonathan, #2307)</li>
<li>Integration tests run in CI with DuckDB, SQLite, PostgreSQL, MySQL and SQL Server (@jelenkee, #2286)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@k-nut, with #2294</li>
</ul>
<h2 id="061--2023-03-12"><a class="header" href="#061--2023-03-12">0.6.1 â€” 2023-03-12</a></h2>
<p>0.6.1 is a small release containing an internal refactoring and improved bindings for C, PHP &amp; .NET.</p>
<p>This release has 54 commits from 6 contributors. Selected changes:</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>No longer incorrectly compile to <code>DISTINCT</code> when a <code>take 1</code> refers to a different set of columns than are in the <code>group</code>. (@max-sixty, with thanks to @cottrell, #2109)</li>
<li>The version specification of the dependency Chumsky was bumped from <code>0.9.0</code> to <code>0.9.2</code>. <code>0.9.0</code> has a bug that causes an infinite loop. (@eitsupi, #2110)</li>
</ul>
<p><strong>æ–‡ä»¶</strong>ï¼š</p>
<ul>
<li>Add a policy for which bindings are supported / unsupported / nascent. See <a href="https://prql-lang.org/book/project/bindings/index.html">https://prql-lang.org/book/project/bindings/index.html</a> for more details (@max-sixty, #2062) (@max-sixty, #2062)</li>
</ul>
<p><strong>æ•´åˆ</strong>ï¼š</p>
<ul>
<li>[prql-lib] Added C++ header file. (@vanillajonathan, #2126)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li>Many of the items that were in the root of the repo have been aggregated into <code>web</code> &amp; <code>bindings</code>, simplifying the repoâ€™s structure. Thereâ€™s also <code>grammars</code> &amp; <code>packages</code> (@max-sixty, #2135, #2117, #2121).</li>
</ul>
<h2 id="060--2023-03-08"><a class="header" href="#060--2023-03-08">0.6.0 â€” 2023-03-08</a></h2>
<p>0.6.0 introduces a rewritten parser, giving us the ability to dramatically improve error messages, renames <code>switch</code> to <code>case</code> and includes lots of minor improvements and fixes. It also introduces <code>loop</code>, which compiles to <code>WITH RECURSIVE</code>, as a highly experimental feature.</p>
<p>There are a few cases of breaking changes, including switching <code>switch</code> to <code>case</code>, in case thatâ€™s confusing. There are also some minor parsing changes outlined below.</p>
<p>This release has 108 commits from 11 contributors. Selected changes:</p>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>
<p>Add a (highly experimental) <code>loop</code> language feature, which translates to <code>WITH RECURSIVE</code>. We expect changes and refinements in upcoming releases. (#1642, @aljazerzen)</p>
</li>
<li>
<p>Rename the experimental <code>switch</code> function to <code>case</code> given it more closely matches the traditional semantics of <code>case</code>. (@max-sixty, #2036)</p>
</li>
<li>
<p>Change the <code>case</code> syntax to use <code>=&gt;</code> instead of <code>-&gt;</code> to distinguish it from function syntax.</p>
</li>
<li>
<p>Convert parser from pest to Chumsky (@aljazerzen, #1818)</p>
<ul>
<li>Improved error messages, and the potential to make even better in the future. Many of these improvements come from error recovery.</li>
<li>String escapes (<code>\n \t</code>).</li>
<li>Raw strings that donâ€™t escape backslashes.</li>
<li>String interpolations can only contain identifiers and not any expression.</li>
<li>Operator associativity has been changed from right-to-left to left-to-right to be more similar to other conventional languages.</li>
<li><code>and</code> now has a higher precedence than <code>or</code> (of same reason as the previous point).</li>
<li>Dates, times and timestamps have stricter parsing rules.</li>
<li><code>let</code>, <code>func</code>, <code>prql</code>, <code>case</code> are now treated as keywords.</li>
<li>Float literals without fraction part are not allowed anymore (<code>1.</code>).</li>
</ul>
</li>
<li>
<p>Add a <code>--format</code> option to <code>prqlc parse</code> which can return the AST in YAML (@max-sixty, #1962)</p>
</li>
<li>
<p>Add a new subcommand <code>prqlc jinja</code>. (@aljazerzen, #1722)</p>
</li>
<li>
<p><em>Breaking</em>: prql-compiler no longer passes text containing <code>{{</code> &amp; <code>}}</code> through to the output. (@aljazerzen, #1722)</p>
<p>For example, the following PRQL query</p>
<pre><code class="language-prql no-eval">from {{foo}}
</code></pre>
<p>was compiled to the following SQL previously, but now it raises an error.</p>
<pre><code class="language-sql">SELECT
  *
FROM
  {{ foo }}
</code></pre>
<p>This pass-through feature existed for integration with dbt.</p>
<p>Weâ€™re again considering how to best integrate with dbt, and this change is based on the idea that the jinja macro should run before the PRQL compiler.</p>
<p>If youâ€™re interested in dbt integration, subscribe or ğŸ‘ to <a href="https://github.com/dbt-labs/dbt-core/pull/5982">https://github.com/dbt-labs/dbt-core/pull/5982</a>.</p>
</li>
<li>
<p>A new compile target <code>"sql.any"</code>. When <code>"sql.any"</code> is used as the target of the compile functionâ€™s option, the target contained in the query header will be used. (@aljazerzen, #1995)</p>
</li>
<li>
<p>Support for SQL parameters with similar syntax (#1957, @aljazerzen)</p>
</li>
<li>
<p>Allow <code>:</code> to be elided in timezones, such as <code>0800</code> in <code>@2020-01-01T13:19:55-0800</code> (@max-sixty, #1991).</p>
</li>
<li>
<p>Add <code>std.upper</code> and <code>std.lower</code> functions for changing string casing (@Jelenkee, #2019).</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li><code>prqlc compile</code> returns a non-zero exit code for invalid queries. (@max-sixty, #1924)</li>
<li>Identifiers can contain any alphabetic unicode characters (@max-sixty, #2003)</li>
</ul>
<p><strong>æ–‡ä»¶</strong>ï¼š</p>
<ul>
<li>Operator precedence (@aljazerzen, #1818)</li>
<li>Error messages for invalid queries are displayed in the book (@max-sixty, #2015)</li>
</ul>
<p><strong>æ•´åˆ</strong>ï¼š</p>
<ul>
<li>[prql-php] Added PHP bindings. (@vanillajonathan, #1860)</li>
<li>[prql-dotnet] Added .NET bindings. (@vanillajonathan, #1917)</li>
<li>[prql-lib] Added C header file. (@vanillajonathan, #1879)</li>
<li>Added a workflow building a <code>.deb</code> on each release. (Note that itâ€™s not yet published on each release). (@vanillajonathan, #1883)</li>
<li>Added a workflow building a <code>.rpm</code> on each release. (Note that itâ€™s not yet published on each release). (@vanillajonathan, #1918)</li>
<li>Added a workflow building a Snap package on each release. (@vanillajonathan, #1881)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li>Test that the output of our nascent autoformatter can be successfully compiled into SQL. Failing examples are now clearly labeled. (@max-sixty, #2016)</li>
<li>Definition files have been added to configure <a href="https://containers.dev/">Dev Containers</a> for Rust development environment. (@eitsupi, #1893, #2025, #2028)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@linux-china, with #1971</li>
<li>@Jelenkee, with #2019</li>
</ul>
<h2 id="052--2023-02-18"><a class="header" href="#052--2023-02-18">0.5.2 â€” 2023-02-18</a></h2>
<p>0.5.2 is a tiny release to fix an build issue in yesterdayâ€™s <code>prql-js</code> 0.5.1 release.</p>
<p>This release has 7 commits from 2 contributors.</p>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@matthias-Q, with #1873</li>
</ul>
<h2 id="051--2023-02-17"><a class="header" href="#051--2023-02-17">0.5.1 â€” 2023-02-17</a></h2>
<p>0.5.1 contains a few fixes, and another change to how bindings handle default target / dialects.</p>
<p>This release has 53 commits from 7 contributors. Selected changes:</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Delegate dividing literal integers to the DB. Previously integer division was executed during PRQL compilation, which could be confusing given that behavior is different across DBs. Other arithmetic operations are still executed during compilation. (@max-sixty, #1747)</li>
</ul>
<p><strong>æ–‡ä»¶</strong>ï¼š</p>
<ul>
<li>Add docs on the <code>from_text</code> transform (@max-sixty, #1756)</li>
</ul>
<p><strong>æ•´åˆ</strong>ï¼š</p>
<ul>
<li>[prql-js] Default compile target changed from <code>Sql(Generic)</code> to <code>Sql(None)</code>. (@eitsupi, #1856)</li>
<li>[prql-python] Compilation options can now be specified from Python. (@eitsupi, #1807)</li>
<li>[prql-python] Default compile target changed from <code>Sql(Generic)</code> to <code>Sql(None)</code>. (@eitsupi, #1861)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@vanillajonathan, with #1766</li>
</ul>
<h2 id="050--2023-02-08"><a class="header" href="#050--2023-02-08">0.5.0 â€” 2023-02-08</a></h2>
<p>0.5.0 contains a few fixes, some improvements to bindings, lots of docs improvements, and some work on forthcoming features. It contains one breaking change in the compilerâ€™s <code>Options</code> interface.</p>
<p>This release has 74 commits from 12 contributors. Selected changes:</p>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>
<p>Change public API to use target instead of dialect in preparation for feature work (@aljazerzen, #1684)</p>
</li>
<li>
<p><code>prqlc watch</code> command which watches filesystem for changes and compiles .prql files to .sql (@aljazerzen, #1708)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Support double brackets in s-strings which arenâ€™t symmetric (@max-sixty, #1650)</li>
<li>Support Postgresâ€™s Interval syntax (@max-sixty, #1649)</li>
<li>Fixed tests for <code>prql-elixir</code> with MacOS (@kasvith, #1707)</li>
</ul>
<p><strong>æ–‡ä»¶</strong>ï¼š</p>
<ul>
<li>Add a documentation test for prql-compiler, update prql-compiler README, and include the README in the prql book section for Rust bindings. The code examples in the README are included and tested as doctests in the prql-compiler (@nkicg6, #1679)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li>Add tests for all PRQL website examples to prql-python to ensure compiled results match expected SQL (@nkicg6, #1719)</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@ruslandoga, with #1628</li>
<li>@RalfNorthman, with #1632</li>
<li>@nicot, with #1662</li>
</ul>
<h2 id="042--2023-01-25"><a class="header" href="#042--2023-01-25">0.4.2 â€” 2023-01-25</a></h2>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>
<p>New <code>from_text format-arg string-arg</code> function that supports JSON and CSV formats. <em>format-arg</em> can be <code>format:csv</code> or <code>format:json</code>. <em>string-arg</em> can be a string in any format. (@aljazerzen &amp; @snth, #1514)</p>
<pre><code class="language-prql no-eval">from_text format:csv """
a,b,c
1,2,3
4,5,6
"""
</code></pre>
<pre><code class="language-prql no-eval">from_text format:json '''
    [{"a": 1, "b": "x", "c": false }, {"a": 4, "b": "y", "c": null }]
'''
</code></pre>
<pre><code class="language-prql no-eval">from_text format:json '''{
    "columns": ["a", "b", "c"],
    "data": [
        [1, "x", false],
        [4, "y", null]
    ]
}'''
</code></pre>
<p>For now, the argument is limited to string constants.</p>
</li>
</ul>
<p><strong>Fixes</strong></p>
<ul>
<li>Export constructor for SQLCompileOptions (@bcho, #1621)</li>
<li>Remove backticks in count_distinct (@aljazerzen, #1611)</li>
</ul>
<p><strong>New Contributors</strong></p>
<ul>
<li>@1Kinoti, with #1596</li>
<li>@veenaamb, with #1614</li>
</ul>
<h2 id="041--2023-01-18"><a class="header" href="#041--2023-01-18">0.4.1 â€” 2023-01-18</a></h2>
<p>0.4.1 comes a few days after 0.4.0, with a couple of features and the release of <code>prqlc</code>, the CLI crate.</p>
<p>0.4.1 has 35 commits from 6 contributors.</p>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>
<p>Inferred column names include the relation name (@aljazerzen, #1550):</p>
<pre><code class="language-prql no-eval">from albums
select title # name used to be inferred as title only
select albums.title # so using albums was not possible here
</code></pre>
</li>
<li>
<p>Quoted identifiers such as <code>dir/*.parquet</code> are passed through to SQL. (@max-sixty, #1516).</p>
</li>
<li>
<p>The CLI is installed with <code>cargo install prqlc</code>. The binary was renamed in 0.4.0 but required an additional <code>--features</code> flag, which has been removed in favor of this new crate (@max-sixty &amp; @aljazerzen, #1549).</p>
</li>
</ul>
<p><strong>New Contributors</strong>:</p>
<ul>
<li>@fool1280, with #1554</li>
<li>@nkicg6, with #1567</li>
</ul>
<h2 id="040--2023-01-15"><a class="header" href="#040--2023-01-15">0.4.0 â€” 2023-01-15</a></h2>
<p>0.4.0 brings lots of new features including <code>case</code>, <code>select ![]</code> and numbers with underscores. We have initial (unpublished) bindings to Elixir. And thereâ€™s the usual improvements to fixes &amp; documentation (only a minority are listed below in this release).</p>
<p>0.4.0 also has some breaking changes: <code>table</code> is <code>let</code>, <code>dialect</code> is renamed to <code>target</code>, and the compilerâ€™s API has changed. Full details below.</p>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>
<p>Defining a temporary table is now expressed as <code>let</code> rather than <code>table</code> (@aljazerzen, #1315). See the <a href="https://prql-lang.org/book/reference/declarations/variables.html">tables docs</a> for details.</p>
</li>
<li>
<p><em>Experimental:</em> The <a href="https://prql-lang.org/book/reference/syntax/case.html"><code>case</code></a> function sets a variable to a value based on one of several expressions (@aljazerzen, #1278).</p>
<pre><code class="language-prql no-eval">derive var = case [
  score &lt;= 10 -&gt; "low",
  score &lt;= 30 -&gt; "medium",
  score &lt;= 70 -&gt; "high",
  true -&gt; "very high",
]
</code></pre>
<p>â€¦compiles to:</p>
<pre><code class="language-sql">SELECT
  *,
  CASE
    WHEN score &lt;= 10 THEN 'low'
    WHEN score &lt;= 30 THEN 'medium'
    WHEN score &lt;= 70 THEN 'high'
    ELSE 'very high'
  END AS var
FROM
  bar
</code></pre>
<p>Check out the <a href="https://prql-lang.org/book/reference/syntax/case.html"><code>case</code> docs</a> for more details.</p>
</li>
<li>
<p><em>Experimental:</em> Columns can be excluded by name with <code>select</code> (@aljazerzen, #1329)</p>
<pre><code class="language-prql no-eval">from albums
select ![title, composer]
</code></pre>
</li>
<li>
<p><em>Experimental:</em> <code>append</code> transform, equivalent to <code>UNION ALL</code> in SQL. (@aljazerzen, #894)</p>
<pre><code class="language-prql no-eval">from employees
append managers
</code></pre>
<p>Check out the <a href="https://prql-lang.org/book/reference/stdlib/transforms/append.html"><code>append</code> docs</a> for more details.</p>
</li>
<li>
<p>Numbers can contain underscores, which can make reading long numbers easier (@max-sixty, #1467):</p>
<pre><code class="language-prql no-eval">from numbers
select {
    small = 1.000_000_1,
    big = 5_000_000,
}
</code></pre>
</li>
<li>
<p>The SQL output contains a comment with the PRQL compiler version (@aljazerzen, #1322)</p>
</li>
<li>
<p><code>dialect</code> is renamed to <code>target</code>, and its values are prefixed with <code>sql.</code> (@max-sixty, #1388); for example:</p>
<pre><code class="language-prql no-eval">prql target:sql.bigquery  # previously was `dialect:bigquery`

from employees
</code></pre>
<p>This gives us the flexibility to target other languages than SQL in the long term.</p>
</li>
<li>
<p>Tables definitions can contain a bare s-string (@max-sixty, #1422), which enables us to include a full CTE of SQL, for example:</p>
<pre><code class="language-prql no-eval">let grouping = s"""
  SELECT SUM(a)
  FROM tbl
  GROUP BY
    GROUPING SETS
    ((b, c, d), (d), (b, d))
"""
</code></pre>
</li>
<li>
<p>Ranges supplied to <code>in</code> can be half-open (@aljazerzen, #1330).</p>
</li>
<li>
<p>The crateâ€™s external API has changed to allow for compiling to intermediate representation. This also affects bindings. See <a href="https://docs.rs/prql-compiler/latest/prql_compiler/"><code>prql-compiler</code> docs</a> for more details.</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<p>[This release, the changelog only contains a subset of fixes]</p>
<ul>
<li>Allow interpolations in table s-strings (@aljazerzen, #1337)</li>
</ul>
<p><strong>æ–‡ä»¶</strong>ï¼š</p>
<p>[This release, the changelog only contains a subset of documentation improvements]</p>
<ul>
<li>Add docs on aliases in <a href="https://prql-lang.org/book/reference/stdlib/transforms/select.html">Select</a></li>
<li>Add JS template literal and multiline example (@BCsabaEngine, #1432)</li>
<li>JS template literal and multiline example (@BCsabaEngine, #1432)</li>
<li>Improve prql-compiler docs &amp; examples (@aljazerzen, #1515)</li>
<li>Fix string highlighting in book (@max-sixty, #1264)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>The playground allows querying some sample data. As before, the result updates on every keystroke. (@aljazerzen, #1305)</li>
</ul>
<p><strong>æ•´åˆ</strong>ï¼š</p>
<p>[This release, the changelog only contains a subset of integration improvements]</p>
<ul>
<li>Added Elixir integration exposing PRQL functions as NIFs (#1500, @kasvith)</li>
<li>Exposed Elixir flavor with exceptions (#1513, @kasvith)</li>
<li>Rename <code>prql-compiler</code> binary to <code>prqlc</code> (@aljazerzen #1515)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<p>[This release, the changelog only contains a subset of internal changes]</p>
<ul>
<li>Add parsing for negative select (@max-sixty, #1317)</li>
<li>Allow for additional builtin functions (@aljazerzen, #1325)</li>
<li>Add an automated check for typos (@max-sixty, #1421)</li>
<li>Add tasks for running playground &amp; book (@max-sixty, #1265)</li>
<li>Add tasks for running tests on every file change (@max-sixty, #1380)</li>
</ul>
<p><strong>New contributors</strong>:</p>
<ul>
<li>@EArazli, with #1359</li>
<li>@boramalper, with #1362</li>
<li>@allurefx, with #1377</li>
<li>@bcho, with #1375</li>
<li>@JettChenT, with #1385</li>
<li>@BlurrechDev, with #1411</li>
<li>@BCsabaEngine, with #1432</li>
<li>@kasvith, with #1500</li>
</ul>
<h2 id="031---2022-12-03"><a class="header" href="#031---2022-12-03">0.3.1 - 2022-12-03</a></h2>
<p>0.3.1 brings a couple of small improvements and fixes.</p>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>
<p>Support for using s-strings for <code>from</code> (#1197, @aljazerzen)</p>
<pre><code class="language-prql no-eval">from s"SELECT * FROM employees WHERE foo &gt; 5"
</code></pre>
</li>
<li>
<p>Helpful error message when referencing a table in an s-string (#1203, @aljazerzen)</p>
</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Multiple columns with same name created (#1211, @aljazerzen)</li>
<li>Renaming via select breaks preceding sorting (#1204, @aljazerzen)</li>
<li>Same column gets selected multiple times (#1186, @mklopets)</li>
</ul>
<p><strong>Internal</strong>:</p>
<ul>
<li>Update Github Actions and Workflows to current version numbers (and avoid using Node 12)</li>
</ul>
<h2 id="030--2022-11-29"><a class="header" href="#030--2022-11-29">0.3.0 â€” 2022-11-29</a></h2>
<p>ğŸ‰ 0.3.0 is the biggest ever change in PRQLâ€™s compiler, rewriting much of the internals: the compiler now has a semantic understanding of expressions, including resolving names &amp; building a DAG of column lineage ğŸ‰.</p>
<p>While the immediate changes to the language are modest â€”Â some long-running bugs are fixed â€” this unlocks the development of many of the projectâ€™s long-term priorities, such as type-checking &amp; auto-complete. And it simplifies the building of our next language features, such as match-case expressions, unions &amp; table expressions.</p>
<p>@aljazerzen has (mostly single-handedly) done this work over the past few months. The project owes him immense appreciation.</p>
<p><strong>Breaking changes</strong>:</p>
<p>Weâ€™ve had to make some modest breaking changes for 0.3:</p>
<ul>
<li>
<p><em>Pipelines must start with <code>from</code></em>. For example, a pipeline with only <code>derive foo = 5</code>, with no <code>from</code> transform, is no longer valid. Depending on demand for this feature, it would be possible to add this back.</p>
</li>
<li>
<p><em>Shared column names now require <code>==</code> in a join</em>. The existing approach is ambiguous to the compiler â€” <code>id</code> in the following example could be a boolean column.</p>
<pre><code class="language-diff">from employees
-join positions [id]
+join positions [==id]
</code></pre>
</li>
<li>
<p><em>Table references containing periods must be surrounded by backticks</em>. For example, when referencing a schema name:</p>
<pre><code class="language-diff">-from public.sometable
+from `public.sometable`
</code></pre>
</li>
</ul>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>Change self equality op to <code>==</code> (#1176, @aljazerzen)</li>
<li>Add logging (@aljazerzen)</li>
<li>Add clickhouse dialect (#1090, @max-sixty)</li>
<li>Allow namespaces &amp; tables to contain <code>.</code> (#1079, @aljazerzen)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Deduplicate column appearing in <code>SELECT</code> multiple times (#1186, @aljazerzen)</li>
<li>Fix uppercase table names (#1184, @aljazerzen)</li>
<li>Omit table name when only one ident in SELECT (#1094, @aljazerzen)</li>
</ul>
<p><strong>æ–‡ä»¶</strong>ï¼š</p>
<ul>
<li>Add chapter on semanticsâ€™ internals (@aljazerzen, #1028)</li>
<li>Add note about nesting variables in s-strings (@max-sixty, #1163)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li>Flatten group and window (#1120, @aljazerzen)</li>
<li>Split ast into expr and stmt (@aljazerzen)</li>
<li>Refactor associativity (#1156, @aljazerzen)</li>
<li>Rename Ident constructor to <code>from_name</code> (#1084, @aljazerzen)</li>
<li>Refactor rq folding (#1177, @aljazerzen)</li>
<li>Add tests for reported bugs fixes in semantic (#1174, @aljazerzen)</li>
<li>Bump duckdb from 0.5.0 to 0.6.0 (#1132)</li>
<li>Bump once_cell from 1.15.0 to 1.16.0 (#1101)</li>
<li>Bump pest from 2.4.0 to 2.5.0 (#1161)</li>
<li>Bump pest_derive from 2.4.0 to 2.5.0 (#1179)</li>
<li>Bump sqlparser from 0.25.0 to 0.27.0 (#1131)</li>
<li>Bump trash from 2.1.5 to 3.0.0 (#1178)</li>
</ul>
<h2 id="0211--2022-11-20"><a class="header" href="#0211--2022-11-20">0.2.11 â€” 2022-11-20</a></h2>
<p>0.2.11 contains a few helpful fixes.</p>
<p>Work continues on our <code>semantic</code> refactor â€” look out for 0.3.0 soon! Many thanks to @aljazerzen for his continued contributions to this.</p>
<p>Note: 0.2.10 was skipped due to this maintainerâ€™s inability to read his own docs on bumping versionsâ€¦</p>
<p><strong>åŠŸèƒ½</strong>ï¼š</p>
<ul>
<li>Detect when compiler version is behind query version (@MarinPostma, #1058)</li>
<li>Add <code>__version__</code> to prql-python package (@max-sixty, #1034)</li>
</ul>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Fix nesting of expressions with equal binding strength and left associativity, such as <code>a - (b - c)</code> (@max-sixty, #1136)</li>
<li>Retain floats without significant digits as floats (@max-sixty, #1141)</li>
</ul>
<p><strong>æ–‡ä»¶</strong>ï¼š</p>
<ul>
<li>Add documentation of <code>prqlr</code> bindings (@eitsupi, #1091)</li>
<li>Add a â€˜Why PRQLâ€™ section to the website (@max-sixty, #1098)</li>
<li>Add @snth to core-devs (@max-sixty, #1050)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li>Use workspace versioning (@max-sixty, #1065)</li>
</ul>
<h2 id="029--2022-10-14"><a class="header" href="#029--2022-10-14">0.2.9 â€” 2022-10-14</a></h2>
<p>0.2.9 is a small release containing a bug fix for empty strings.</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Fix parsing of empty strings (@aljazerzen, #1024)</li>
</ul>
<h2 id="028--2022-10-10"><a class="header" href="#028--2022-10-10">0.2.8 â€” 2022-10-10</a></h2>
<p>0.2.8 is another modest release with some fixes, doc improvements, bindings improvements, and lots of internal changes. Note that one of the fixes causes the behavior of <code>round</code> and <code>cast</code> to change slightly â€” though itâ€™s handled as a fix rather than a breaking change in semantic versioning.</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li>
<p>Change order of the <code>round</code> &amp; <code>cast</code> function parameters to have the column last; for example <code>round 2 foo_col</code> / <code>cast int foo</code>. This is consistent with other functions, and makes piping possible:</p>
<pre><code class="language-prql no-eval">derive [
  gross_salary = (salary + payroll_tax | as int),
  gross_salary_rounded = (gross_salary | round 0),
]
</code></pre>
</li>
</ul>
<p><strong>æ–‡ä»¶</strong>ï¼š</p>
<ul>
<li>Split <code>DEVELOPMENT.md</code> from <code>CONTRIBUTING.md</code> (@richb-hanover, #1010)</li>
<li>Make s-strings more prominent in website intro (@max-sixty, #982)</li>
</ul>
<p><strong>Web</strong>:</p>
<ul>
<li>Add GitHub star count to website (@max-sixty, #990)</li>
</ul>
<p><strong>æ•´åˆ</strong>ï¼š</p>
<ul>
<li>Expose a shortened error message, in particular for the VS Code extension (@aljazerzen, #1005)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li>Specify 1.60.0 as minimum Rust version (@max-sixty, #1011)</li>
<li>Remove old <code>wee-alloc</code> code (@max-sixty, #1013)</li>
<li>Upgrade clap to version 4 (@aj-bagwell, #1004)</li>
<li>Improve book-building script in Taskfile (@max-sixty, #989)</li>
<li>Publish website using an artifact rather than a long-lived branch (@max-sixty, #1009)</li>
</ul>
<h2 id="027--2022-09-17"><a class="header" href="#027--2022-09-17">0.2.7 â€” 2022-09-17</a></h2>
<p>0.2.7 is a fairly modest release, six weeks after 0.2.6. We have some more significant features, including a <code>union</code> operator and an overhaul of our type system, as open PRs which will follow in future releases.</p>
<p>We also have new features in the <a href="https://github.com/PRQL/prql-code">VS Code extension</a>, courtesy of @jiripospisil, including a live output panel.</p>
<p><strong>Fixes</strong>:</p>
<ul>
<li><code>range_of_ranges</code> checks the Range end is smaller than its start (@shuozeli, #946)</li>
</ul>
<p><strong>æ–‡ä»¶</strong>ï¼š</p>
<ul>
<li>Improve various docs (@max-sixty, #974, #971, #972, #970, #925)</li>
<li>Add reference to EdgeDBâ€™s blog post in our FAQ (@max-sixty, #922)</li>
<li>Fix typos (@kianmeng, #943)</li>
</ul>
<p><strong>æ•´åˆ</strong>ï¼š</p>
<ul>
<li>Add <code>prql-lib</code>, enabling language bindings with <code>go</code> (@sigxcpu76, #923)</li>
<li>Fix line numbers in JS exceptions (@charlie-sanders, #929)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li>Lock the version of the rust-toolchain, with auto-updates (@max-sixty, #926, #927)</li>
</ul>
<h2 id="026--2022-08-05"><a class="header" href="#026--2022-08-05">0.2.6 â€”Â 2022-08-05</a></h2>
<p><strong>Fixes</strong>:</p>
<ul>
<li>Adjust <code>fmt</code> to only escape names when needed (@aljazerzen, #907)</li>
<li>Fix quoting on upper case <code>table</code> names (@max-sixty, #893)</li>
<li>Fix scoping of identical column names from multiple tables (@max-sixty, #908)</li>
<li>Fix parse error on newlines in a <code>table</code> (@sebastiantoh ğŸ†•, #902)</li>
<li>Fix quoting of upper case table names (@max-sixty, #893)</li>
</ul>
<p><strong>æ–‡ä»¶</strong>ï¼š</p>
<ul>
<li>Add docs on Architecture (@aljazerzen, #904)</li>
<li>Add Changelog (@max-sixty, #890 #891)</li>
</ul>
<p><strong>å…§éƒ¨è®Šæ›´</strong>ï¼š</p>
<ul>
<li>Start trial using Conventional Commits (@max-sixty, #889)</li>
<li>Add crates.io release workflow, docs (@max-sixty, #887)</li>
</ul>
<h2 id="025---2022-07-29"><a class="header" href="#025---2022-07-29">0.2.5 - 2022-07-29</a></h2>
<p>0.2.5 is a very small release following 0.2.4 yesterday. It includes:</p>
<ul>
<li>Add the ability to represent single brackets in an s-string, with two brackets (#752, @max-sixty)</li>
<li>Fix the â€œCopy to Clipboardâ€ command in the Playground, for Firefox (#880, @mklopets)</li>
</ul>
<h2 id="024---2022-07-28"><a class="header" href="#024---2022-07-28">0.2.4 - 2022-07-28</a></h2>
<p>0.2.4 is a small release following 0.2.3 a few days ago. The 0.2.4 release includes:</p>
<ul>
<li>Enrich our CLI, adding commands to get different stages of the compilation process (@aljazerzen , #863)</li>
<li>Fix multiple <code>take n</code> statements in a query, leading to duplicate proxy columns in generated SQL (@charlie-sanders)</li>
<li>Fix BigQuery quoting of identifiers in <code>SELECT</code> statements (@max-sixty)</li>
<li>Some internal changes â€” reorganize top-level functions (@aljazerzen), add a workflow to track our Rust compilation time (@max-sixty), simplify our simple prql-to-sql tests (@max-sixty)</li>
</ul>
<p>Thanks to @ankane, <code>prql-compiler</code> is now available from homebrew core; <code>brew install prql-compiler</code><sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>.</p>
<h2 id="023---2022-07-24"><a class="header" href="#023---2022-07-24">0.2.3 - 2022-07-24</a></h2>
<p>A couple of weeks since the 0.2.2 release: weâ€™ve squashed a few bugs, added some mid-sized features to the language, and made a bunch of internal improvements.</p>
<p>The 0.2.3 release includes:</p>
<ul>
<li>Allow for escaping otherwise-invalid identifiers (@aljazerzen &amp; @max-sixty)</li>
<li>Fix a bug around operator precedence (@max-sixty)</li>
<li>Add a section the book on the language bindings (@charlie-sanders)</li>
<li>Add tests for our <code>Display</code> representation while fixing some existing bugs. This is gradually becoming our code formatter (@arrizalamin)</li>
<li>Add a â€œcopy to clipboardâ€ button in the Playground (@mklopets)</li>
<li>Add lots of guidance to our <code>CONTRIBUTING.md</code> around our tests and process for merging (@max-sixty)</li>
<li>Add a <code>prql!</code> macro for parsing a prql query at compile time (@aljazerzen)</li>
<li>Add tests for <code>prql-js</code> (@charlie-sanders)</li>
<li>Add a <code>from_json</code> method for transforming json to a PRQL string (@arrizalamin)</li>
<li>Add a workflow to release <code>prql-java</code> to Maven (@doki23)</li>
<li>Enable running all tests from a PR by adding a <code>pr-run-all-tests</code> label (@max-sixty)</li>
<li>Have <code>cargo-release</code> to bump all crate &amp; npm versions (@max-sixty)</li>
<li>Update <code>prql-js</code> to use the bundler build of <code>prql-js</code> (@mklopets)</li>
</ul>
<p>As well as those contribution changes, thanks to those whoâ€™ve reported issues, such as @mklopets @huw @mm444 @ajfriend.</p>
<p>From here, weâ€™re planning to continue squashing bugs (albeit more minor than those in this release), adding some features like <code>union</code>, while working on bigger issues such as type-inference.</p>
<p>Weâ€™re also going to document and modularize the compiler further. Itâ€™s important that we give more people an opportunity to contribute to the guts of PRQL, especially given the number and enthusiasm of contributions to project in general â€” and itâ€™s not that easy to do so at the moment. While this is ongoing if anyone has something theyâ€™d like to work on in the more difficult parts of the compiler, let us know on GitHub or Discord, and weâ€™d be happy to work together on it.</p>
<p>Thank you!</p>
<h2 id="022---2022-07-10"><a class="header" href="#022---2022-07-10">0.2.2 - 2022-07-10</a></h2>
<p>Weâ€™re a couple of weeks since our 0.2.0 release. Thanks for the surge in interest and contributions! 0.2.2 has some fixes &amp; some internal improvements:</p>
<ul>
<li>We now test against SQLite &amp; DuckDB on every commit, to ensure weâ€™re producing correct SQL. (@aljazerzen)</li>
<li>We have the beginning of Java bindings! (@doki23)</li>
<li>Idents surrounded by backticks are passed through to SQL (@max-sixty)</li>
<li>More examples on homepage; e.g. <code>join</code> &amp; <code>window</code>, lots of small docs improvements</li>
<li>Automated releases to homebrew (@roG0d)</li>
<li><a href="https://github.com/PRQL/prql/tree/main/prqlc/bindings/js">prql-js</a> is now a single package for Node, browsers &amp; webpack (@charlie-sanders)</li>
<li>Parsing has some fixes, including <code>&gt;=</code> and leading underscores in idents (@mklopets)</li>
<li>Ranges receive correct syntax highlighting (@max-sixty)</li>
</ul>
<p>Thanks to AljaÅ¾ Mur ErÅ¾en @aljazerzen , George Roldugin @roldugin , Jasper McCulloch @Jaspooky , Jie Han @doki23 , Marko Klopets @mklopets , Maximilian Roos @max-sixty , Rodrigo Garcia @roG0d , Ryan Russell @ryanrussell , Steven Maude @StevenMaude , Charlie Sanders @charlie-sanders .</p>
<p>Weâ€™re planning to continue collecting bugs &amp; feature requests from users, as well as working on some of the bigger features, like type-inference.</p>
<p>For those interesting in joining, we also have a new <a href="https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md">Contributing page</a>.</p>
<h2 id="020---2022-06-27"><a class="header" href="#020---2022-06-27">0.2.0 - 2022-06-27</a></h2>
<p>ğŸ‰ ğŸ‰ <strong>After several months of building, PRQL is ready to use!</strong> ğŸ‰ ğŸ‰</p>
<hr />
<p>How we got here:</p>
<p>At the end of January, we published a proposal of a better language for data transformation: PRQL. The reception was better than I could have hoped for â€” we were no. 2 on HackerNews for a day, and gained 2.5K GitHub stars over the next few days.</p>
<p>But man cannot live on GitHub Stars alone â€” we had to do the work to build it. So over the next several months, during many evenings &amp; weekends, a growing group of us gradually built the compiler, evolved the language, and wrote some integrations.</p>
<p>We want to double-down on the community and its roots in open source â€” itâ€™s incredible that a few of us from all over the globe have collaborated on a project without ever having met. We decided early-on that PRQL would always be open-source and would never have a commercial product (despite lots of outside interest to fund a seed round!). Because languages are so deep in the stack, and the data stack has so many players, the best chance of building a great language is to build an open language.</p>
<hr />
<p>We still have a long way to go. While PRQL is usable, it has lots of missing features, and an incredible amount of unfulfilled potential, including a language server, cohesion with databases, and type inference. Over the coming weeks, weâ€™d like to grow the number of intrepid users experimenting PRQL in their projects, prioritize features that will unblock them, and then start fulfilling PRQLâ€™s potential by working through our <a href="https://prql-lang.org/roadmap/">roadmap</a>.</p>
<p>The best way to experience PRQL is to try it. Check out our <a href="https://prql-lang.org">website</a> and the <a href="https://prql-lang.org/playground">Playground</a>. Start using PRQL for your own projects in <a href="https://github.com/prql/dbt-prql">dbt</a>, <a href="https://pyprql.readthedocs.io/en/latest/magic_readme.html">Jupyter notebooks</a> and Prefect workflows.</p>
<p>Keep in touch with PRQL by following the project on <a href="https://twitter.com/prql_lang">Twitter</a>, joining us on <a href="https://discord.gg/eQcfaCmsNc">Discord</a>, starring the <a href="https://github.com/PRQL/prql">repo</a>.</p>
<p><a href="https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md">Contribute</a> to the project â€” weâ€™re a really friendly community, whether youâ€™re a recent SQL user or an advanced Rust programmer. We need bug reports, documentation tweaks &amp; feature requests â€” just as much as we need compiler improvements written in Rust.</p>
<hr />
<p>I especially want to give <a href="https://github.com/aljazerzen">AljaÅ¾ Mur ErÅ¾en</a> (@aljazerzen) the credit he deserves, who has contributed the majority of the difficult work of building out the compiler. Much credit also goes to <a href="https://github.com/charlie-sanders">Charlie Sanders</a> (@charlie-sanders), one of PRQLâ€™s earliest supporters and the author of pyprql, and <a href="https://github.com/rbpatt2019">Ryan Patterson-Cross</a> (@rbpatt2019), who built the Jupyter integration among other Python contributions.</p>
<p>Other contributors who deserve a special mention include: @roG0d, @snth, @kwigley</p>
<hr />
<p>Thank you, and we look forward to your feedback!</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<pre><code>we still need to update docs and add a release workflow for this:
&lt;https://github.com/PRQL/prql/issues/866&gt;
</code></pre>
 <a href="#fr-1-1">â†©</a></li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="target--version"><a class="header" href="#target--version">Target &amp; Version</a></h1>
<h2 id="target-dialect"><a class="header" href="#target-dialect">Target dialect</a></h2>
<p>PRQL allows specifying a target dialect at the top of the query, which allows PRQL to compile to a database-specific SQL flavor.</p>
<h3 id="ç¯„ä¾‹-13"><a class="header" href="#ç¯„ä¾‹-13">ç¯„ä¾‹</a></h3>
<div class="comparison">
<div>
<h4 id="prql-123"><a class="header" href="#prql-123">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.postgres

from employees
sort age
take 10
</code></pre>
</div>
<div>
<h4 id="sql-120"><a class="header" href="#sql-120">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees
ORDER BY
  age
LIMIT
  10

</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-124"><a class="header" href="#prql-124">PRQL</a></h4>
<pre><code class="language-prql">prql target:sql.mssql

from employees
sort age
take 10
</code></pre>
</div>
<div>
<h4 id="sql-121"><a class="header" href="#sql-121">SQL</a></h4>
<pre><code class="language-sql">SELECT
  TOP (10) *
FROM
  employees
ORDER BY
  age

</code></pre>
</div>
</div>
<h2 id="dialects"><a class="header" href="#dialects">Dialects</a></h2>
<h3 id="supported"><a class="header" href="#supported">Supported</a></h3>
<p>Supported dialects support all PRQL language features where possible, are tested on every commit, and weâ€™ll endeavor to fix bugs.</p>
<ul>
<li><code>sql.clickhouse</code></li>
<li><code>sql.duckdb</code></li>
<li><code>sql.generic</code> <sup><a name="to-footnote-1"><a href="project/target.html#footnote-1">1</a></a></sup></li>
<li><code>sql.glaredb</code></li>
<li><code>sql.mysql</code></li>
<li><code>sql.postgres</code></li>
<li><code>sql.sqlite</code></li>
</ul>
<h3 id="unsupported"><a class="header" href="#unsupported">Unsupported</a></h3>
<p>Unsupported dialects have implementations in the compiler, but are tested minimally or not at all, and may have gaps for some features.</p>
<p>Weâ€™re open to contributions to improve our coverage of these, and to adding additional dialects.</p>
<ul>
<li><code>sql.mssql</code></li>
<li><code>sql.ansi</code></li>
<li><code>sql.bigquery</code></li>
<li><code>sql.snowflake</code></li>
</ul>
<h2 id="priority-of-targets"><a class="header" href="#priority-of-targets">Priority of targets</a></h2>
<p>The compile target of a query is defined in the queryâ€™s header or as an argument to the compiler. option. The argument to the compiler takes precedence.</p>
<p>For example, the following shell example specifies <code>sql.generic</code> in the query and <code>sql.duckdb</code> in the <code>--target</code> option of the <code>prqlc compile</code> command. In this case, <code>sql.duckdb</code> takes precedence and the SQL output is based on the DuckDB dialect.</p>
<pre><code class="language-sh">echo 'prql target:sql.generic
      from foo' | prqlc compile --target sql.duckdb
</code></pre>
<p>To use the target described in the query, a special target <code>sql.any</code> can be specified in the compiler option.</p>
<pre><code class="language-sh">echo 'prql target:sql.generic
      from foo' | prqlc compile --target sql.any
</code></pre>
<h2 id="ç‰ˆæœ¬"><a class="header" href="#ç‰ˆæœ¬">ç‰ˆæœ¬</a></h2>
<p>PRQL allows specifying a version of the language in the PRQL header, like:</p>
<div class="comparison">
<div>
<h4 id="prql-125"><a class="header" href="#prql-125">PRQL</a></h4>
<pre><code class="language-prql">prql version:"0.10.1"

from employees
</code></pre>
</div>
<div>
<h4 id="sql-122"><a class="header" href="#sql-122">SQL</a></h4>
<pre><code class="language-sql">SELECT
  *
FROM
  employees

</code></pre>
</div>
</div>
<p>This has two roles, one of which is implemented:</p>
<ul>
<li>The compiler will raise an error if the compiler is older than the query version. This prevents confusing errors when queries use newer features of the language but the compiler hasnâ€™t yet been upgraded.</li>
<li>The compiler will compile for the major version of the query. This allows the language to evolve without breaking existing queries, or forcing multiple installations of the compiler. This isnâ€™t yet implemented, but is a gating feature for PRQL 1.0.</li>
</ul>
<p>The version of the compiler currently in use can be called using the special function <code>std.prql_version</code> in PRQL.</p>
<div class="comparison">
<div>
<h4 id="prql-126"><a class="header" href="#prql-126">PRQL</a></h4>
<pre><code class="language-prql">[{version = prql_version}]
</code></pre>
</div>
<div>
<h4 id="sql-123"><a class="header" href="#sql-123">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    '0.10.1' AS version
)
SELECT
  version
FROM
  table_0

</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/target.html#admonition-note"></a>
</div>
<div>
<p>This function <code>std.prql_version</code> may be replaced in the future by something like <code>prql.version</code>.</p>
</div>
</div>
<p><hr/>
<p><a name="footnote-1"><a href="project/target.html#to-footnote-1">1</a></a>: while thereâ€™s no â€œgenericâ€ DB to test <code>sql.generic</code> against, we still count it as supported.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç¶å®š"><a class="header" href="#ç¶å®š">ç¶å®š</a></h1>
<p>PRQL has bindings for many languages. These include:</p>
<p>We have three tiers of bindings:</p>
<ul>
<li>Supported</li>
<li>Unsupported</li>
<li>Nascent</li>
</ul>
<h2 id="supported-1"><a class="header" href="#supported-1">Supported</a></h2>
<p>Supported bindings require:</p>
<ul>
<li>A maintainer.</li>
<li>Implementations of the <a href="https://docs.rs/prql-compiler/latest/prql_compiler/#functions">core compile functions</a>.</li>
<li>Test coverage for these functions.</li>
<li>A published package to the languageâ€™s standard package repository.</li>
<li>A script in <code>Taskfile.yml</code> to bootstrap a development environment.</li>
<li>Any dev tools, such as a linter &amp; formatter, in pre-commit or MegaLinter.</li>
</ul>
<p>The currently supported bindings are:</p>
<ul>
<li><a href="project/bindings/./javascript.html">JavaScript</a></li>
<li><a href="project/bindings/./python.html">Python</a></li>
<li><a href="project/bindings/./r.html">R</a></li>
<li><a href="project/bindings/./rust.html">Rust</a></li>
</ul>
<p>Most of these are in the main PRQL repo, and we gate any changes to the compilerâ€™s API on compatible changes to the bindings.</p>
<h2 id="unsupported-1"><a class="header" href="#unsupported-1">Unsupported</a></h2>
<p>Unsupported bindings work, but donâ€™t fulfil all of the above criteria. We donâ€™t gate changes to the compilerâ€™s API. If they stop working, weâ€™ll demote them to nascent.</p>
<ul>
<li><a href="project/bindings/./java.html">Java</a></li>
<li><a href="project/bindings/./elixir.html">Elixir</a></li>
<li><code>prqlc-clib</code>, the C bindings</li>
</ul>
<h2 id="nascent"><a class="header" href="#nascent">Nascent</a></h2>
<p>Nascent bindings are in development, and may not yet fully work.</p>
<ul>
<li><a href="project/bindings/./dotnet.html">.NET</a></li>
<li><a href="project/bindings/./php.html">PHP</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-dotnet"><a class="header" href="#prql-dotnet">prql-dotnet</a></h1>
<p><code>prql-net</code> offers PRQL bindings for .NET bindings as a <code>netstandard2.0</code> library.</p>
<p>It provides the <code>PrqlCompiler</code> class which contains the <code>ToJson</code> and <code>ToSql</code> static methods.</p>
<p>Itâ€™s still at an early stage, and isnâ€™t published to NuGet. Contributions are welcome.</p>
<h2 id="å®‰è£"><a class="header" href="#å®‰è£">å®‰è£</a></h2>
<p>Make sure that <code>libprqlc.so</code> (Linux), <code>libprqlc.dylib</code> (macOS) or <code>libprqlc.dll</code> (Windows) is in your projectâ€™s <code>bin</code> directory together with <code>PrqlCompiler.dll</code> and the rest of your projectâ€™s compiled files. I.e. <code>{your_project}/bin/Debug/net7.0/</code>.</p>
<p>The <code>libprqlc</code> library gets dynamically imported at runtime.</p>
<h2 id="ç”¨æ³•"><a class="header" href="#ç”¨æ³•">ç”¨æ³•</a></h2>
<pre><code class="language-csharp">using Prql.Compiler;

var options = new PrqlCompilerOptions
{
    Format = false,
    SignatureComment = false,
};
var sql = PrqlCompiler.Compile("from employees", options);
Console.WriteLine(sql);
</code></pre>
<h1 id="todo"><a class="header" href="#todo">TODO</a></h1>
<p>This is currently at 0.1.0 because weâ€™re waiting to update prqlc-clib for the latest API. When weâ€™ve done that, we can match the version here with the broader PRQL version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-127"><a class="header" href="#prql-127">PRQL</a></h1>
<p><a href="https://prql-lang.org/">PRQL</a> bindings for Elixir.</p>
<h2 id="å®‰è£-1"><a class="header" href="#å®‰è£-1">å®‰è£</a></h2>
<pre><code class="language-elixir">def deps do
  [
    {:prql, "~&gt; 0.1.0"}
  ]
end
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><code class="language-elixir">  iex&gt; PRQL.compile("from customers")
      {:ok, "SELECT\n  *\nFROM\n  customers\n\n-- Generated by PRQL compiler version 0.3.1 (https://prql-lang.org)\n"}


  iex&gt; PRQL.compile("from customers\ntake 10", dialect: :mssql)
  {:ok, "SELECT\n  TOP (10) *\nFROM\n  customers\n\n-- Generated by PRQL compiler version 0.3.1 (https://prql-lang.org)\n"}
</code></pre>
<h2 id="é–‹ç™¼"><a class="header" href="#é–‹ç™¼">é–‹ç™¼</a></h2>
<p>We are in the early stages of developing Elixir bindings.</p>
<p>Weâ€™re using <code>Rustler</code> to provide Rust bindings for <code>prql-compiler</code>.</p>
<p>Currently using the bindings in an Elixir project requires compiling the Rust crate from this repo:</p>
<ul>
<li>Install dependencies with <code>mix deps.get</code></li>
<li>Compile project <code>mix compile</code></li>
<li>Run tests <code>mix test</code></li>
</ul>
<p>Future work includes publishing pre-compiled artifacts, so Elixir projects can run PRQL without needing a Rust toolchain.</p>
<h2 id="mac"><a class="header" href="#mac">Mac</a></h2>
<p>We currently donâ€™t enable compilation for Mac. This is possible to enable, but causes some issues with cargoâ€™s compilation cache. Briefly: it requires <code>RUSTFLAGS</code> to be set, and because of <a href="https://github.com/rust-lang/cargo/issues/8716">https://github.com/rust-lang/cargo/issues/8716</a> &amp; <a href="https://github.com/rust-lang/cargo/issues/8899">https://github.com/rust-lang/cargo/issues/8899</a>, any compilation of a different target will bust the cache.</p>
<p>The possible future workarounds include:</p>
<ul>
<li>Passing <code>--target=aarch64-apple-darwin</code> to every cargo call, which is inconvenient and can be difficult in some situations; e.g. Rust Analyzer. This disables passing <code>RUSTFLAGS</code> (Iâ€™m actually unclear why <code>prql-elixir</code> builds successfully in that caseâ€¦)</li>
<li>Directing other cargo calls to different paths, such as <code>/target-ra</code> for Rust Analyzer and <code>/target-book</code> for the book building. But one <code>cargo build</code> from the terminal without either the <code>target</code> or <code>target_dir</code> specified will bust the cache!</li>
<li>Never compiling for other targets. But our standard tests run for <code>--target=wasm32-unknown-unknown</code>, so this requires refraining from using them.</li>
<li>Removing <code>prql-elixir</code> from our workspace, so that <code>cargo</code> commands in the PRQL workspace donâ€™t require rust flags. This would work well, but means we need separate test coverage for this crate, which adds some weight to the tests.</li>
</ul>
<p>If <code>prql-elixir</code> becomes more used (for example, we start publishing to Hex, or Mac developers want to work on it), then we can re-enable and deal with the caching issues. We can also re-enable them if the <code>cargo</code> issue is resolved.</p>
<p>To test on Mac temporarily â€”Â for example if thereâ€™s an error in GHA and weâ€™re on a Mac locally â€” apply a diff like this, and then run <code>cargo build</code> from the <code>prql-elixir</code> path, which will enable the local <a href="https://github.com/PRQL/prql/blob/main/prqlc/bindings/elixir/native/prql/.cargo/config.toml"><code>.cargo/config.toml</code></a>). (We could also make a feature like <code>elixir-mac</code> which enabled building on Mac).</p>
<pre><code class="language-diff">diff --git a/prqlc/bindings/elixir/native/prql/Cargo.toml b/prqlc/bindings/elixir/native/prql/Cargo.toml
index 7194ca4f..9c7240ff 100644
--- a/prqlc/bindings/elixir/native/prql/Cargo.toml
+++ b/prqlc/bindings/elixir/native/prql/Cargo.toml
@@ -19,5 +19,5 @@ path = "src/lib.rs"
 prql-compiler = {path = "../../../../prql-compiler", default-features = false, version = "0.6.1"}

 # See Readme for details on Mac
-[target.'cfg(not(any(target_family="wasm", target_os = "macos")))'.dependencies]
+# [target.'cfg(not(any(target_family="wasm", target_os = "macos")))'.dependencies]
 rustler = "0.27.0"
diff --git a/prqlc/bindings/elixir/native/prql/src/lib.rs b/prqlc/bindings/elixir/native/prql/src/lib.rs
index 2c5c8f27..68e77217 100644
--- a/prqlc/bindings/elixir/native/prql/src/lib.rs
+++ b/prqlc/bindings/elixir/native/prql/src/lib.rs
@@ -1,5 +1,5 @@
 // See Readme for more information on Mac compiling
-#![cfg(not(target_os = "macos"))]
+// #![cfg(not(target_os = "macos"))]
 // These bindings aren't relevant on wasm
 #![cfg(not(target_family = "wasm"))]
 // TODO: unclear why we need this `allow`; it's required in `CompileOptions`,

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-java"><a class="header" href="#prql-java">prql-java</a></h1>
<p><code>prql-java</code> offers Java bindings to the <code>prql-compiler</code> Rust library. It exposes a Java native method <code>public static native String toSql(String query)</code>.</p>
<p>Itâ€™s still at an early stage, and currently requires compiling locally, and isnâ€™t published to Maven. Contributions are welcome.</p>
<h2 id="å®‰è£-2"><a class="header" href="#å®‰è£-2">å®‰è£</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.prqllang&lt;/groupId&gt;
    &lt;artifactId&gt;prql-java&lt;/artifactId&gt;
    &lt;version&gt;${PRQL_VERSION}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="ç”¨æ³•-1"><a class="header" href="#ç”¨æ³•-1">ç”¨æ³•</a></h2>
<pre><code class="language-java">import org.prqllang.prql4j.PrqlCompiler;

class Main {
    public static void main(String[] args) {
        String sql = PrqlCompiler.toSql("from table");
        System.out.println(sql);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-js"><a class="header" href="#prql-js">prql-js</a></h1>
<p>JavaScript bindings for <a href="https://github.com/PRQL/prql/"><code>prql-compiler</code></a>.</p>
<h2 id="å®‰è£-3"><a class="header" href="#å®‰è£-3">å®‰è£</a></h2>
<pre><code class="language-sh">npm install prql-js
</code></pre>
<h2 id="ç”¨æ³•-2"><a class="header" href="#ç”¨æ³•-2">ç”¨æ³•</a></h2>
<p>Currently these functions are exposed</p>
<pre><code class="language-typescript">function compile(prql_query: string, options?: CompileOptions): string;

function prql_to_pl(prql_query: string): string;

function pl_to_rq(pl_json: string): string;

function rq_to_sql(rq_json: string): string;
</code></pre>
<h3 id="from-nodejs"><a class="header" href="#from-nodejs">From Node.js</a></h3>
<p>Direct usage</p>
<pre><code class="language-javascript">const prqljs = require("prql-js");

const sql = prqljs.compile(`from employees | select first_name`);
console.log(sql);
</code></pre>
<p>é¸é …</p>
<pre><code class="language-javascript">const opts = new prql.CompileOptions();
opts.target = "sql.mssql";
opts.format = false;
opts.signature_comment = false;

const sql = prqljs.compile(`from employees | take 10`, opts);
console.log(sql);
</code></pre>
<p>Template literal</p>
<pre><code class="language-javascript">const prqljs = require("prql-js");
const prql = (string) =&gt; prqljs.compile(string[0] || "");

const sql = prql`from employees | select first_name`;
console.log(sql);
</code></pre>
<p>Template literal with newlines</p>
<pre><code class="language-javascript">const prqljs = require("prql-js");
const prql = (string) =&gt; prqljs.compile(string[0] || "");

const sql = prql`
    from employees
    select first_name
`;
console.log(sql);
</code></pre>
<h3 id="from-a-browser"><a class="header" href="#from-a-browser">From a browser</a></h3>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;script src="./node_modules/prql-js/dist/web/prql_js.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      const { compile } = wasm_bindgen;

      async function run() {
        await wasm_bindgen("./node_modules/prql-js/dist/web/prql_js_bg.wasm");
        const sql = compile("from employees | select first_name");

        console.log(sql);
      }

      run();
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="from-a-framework-or-a-bundler"><a class="header" href="#from-a-framework-or-a-bundler">From a framework or a bundler</a></h3>
<pre><code class="language-typescript">import compile from "prql-js/dist/bundler";

const sql = compile(`from employees | select first_name`);
console.log(sql);
</code></pre>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<p>Errors are returned as following object, serialized as a JSON array:</p>
<pre><code class="language-typescript">interface ErrorMessage {
  /// Message kind. Currently only Error is implemented.
  kind: "Error" | "Warning" | "Lint";
  /// Machine-readable identifier of the error
  code: string | null;
  /// Plain text of the error
  reason: string;
  /// A list of suggestions of how to fix the error
  hint: string | null;
  /// Character offset of error origin within a source file
  span: [number, number] | null;

  /// Annotated code, containing cause and hints.
  display: string | null;
  /// Line and column number of error origin within a source file
  location: SourceLocation | null;
}

/// Location within the source file.
/// Tuples contain:
/// - line number (0-based),
/// - column number within that line (0-based),
interface SourceLocation {
  start: [number, number];

  end: [number, number];
}
</code></pre>
<p>These errors can be caught as such:</p>
<pre><code class="language-javascript">try {
  const sql = prqlJs.compile(`from employees | foo first_name`);
} catch (error) {
  const errorMessages = JSON.parse(error.message).inner;

  console.log(errorMessages[0].display);
  console.log(errorMessages[0].location);
}
</code></pre>
<h2 id="é–‹ç™¼-1"><a class="header" href="#é–‹ç™¼-1">é–‹ç™¼</a></h2>
<p>Build:</p>
<pre><code class="language-sh">npm run build
</code></pre>
<p>This builds Node, bundler and web packages in the <code>dist</code> path.</p>
<p>æ¸¬è©¦ï¼š</p>
<pre><code class="language-sh">npm test
</code></pre>
<p>By default the <code>wasm</code> binaries are optimized on each run, even if the underlying code hasnâ€™t changed, which can be slow. For a lower-latency dev loop, pass <code>--profile=dev</code> to <code>npm install</code> for a faster, less optimized build.</p>
<pre><code class="language-sh">npm install prql-js --profile=dev
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>This uses <a href="https://rustwasm.github.io/docs/wasm-pack/"><code>wasm-pack</code></a> to generate bindings<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>.</li>
<li>Weâ€™ve added an <code>npm</code> layer on top of the usual approach of just using <code>wasm-pack</code>, so we can distribute a single package with targets of <code>node</code>, <code>bundler</code> and <code>no-modules</code> â€” somewhat inverting the approach recommended by <code>wasm-pack</code>. The build instruction goes in a <code>build</code> script, rather than a <code>pack</code> script.</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<pre><code>Though we would be very open to other approaches, given wasm-pack does not
seem maintained, and we're eliding many of its features to build for three
targets. See &lt;https://github.com/PRQL/prql/issues/1836&gt; for more details.
</code></pre>
 <a href="#fr-1-1">â†©</a></li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="prql-php"><a class="header" href="#prql-php">prql-php</a></h1>
<p><code>prql-php</code> offers PHP bindings to <code>prql-compiler</code> crate through FFI.</p>
<p>It provides the <code>Compiler</code> class which contains <code>compile</code>, <code>prqlToPL</code>, <code>plToRQ</code> and <code>rqToSQL</code> functions.</p>
<p>Itâ€™s still at an early stage, and isnâ€™t published to Composer. Contributions are welcome.</p>
<h2 id="å®‰è£-4"><a class="header" href="#å®‰è£-4">å®‰è£</a></h2>
<p>The <a href="https://www.php.net/manual/en/book.ffi.php">PHP FFI extension</a> needs to be enabled. Set <code>ffi.enable</code> in your php.ini configuration file to <code>"true"</code>.</p>
<h2 id="ç”¨æ³•-3"><a class="header" href="#ç”¨æ³•-3">ç”¨æ³•</a></h2>
<pre><code class="language-php">&lt;?php

use Prql\Compiler\Compiler;

$prql = new Compiler();
$result = $prql-&gt;compile("from employees");

echo $result-&gt;output;
</code></pre>
<h2 id="é–‹ç™¼-2"><a class="header" href="#é–‹ç™¼-2">é–‹ç™¼</a></h2>
<h3 id="environment"><a class="header" href="#environment">Environment</a></h3>
<p>A way to establish a dev environment with PHP, the ext-ffi extension and Composer is to use a <a href="https://github.com/loophp/nix-shell">nix flake</a>. After installing nix, enable experimental flakes feature:</p>
<pre><code>mkdir -p ~/.config/nix
echo "experimental-features = nix-command flakes" &gt;&gt; ~/.config/nix/nix.conf
</code></pre>
<p>Now you can spawn a shell from <code>prql-php/</code>:</p>
<pre><code>nix shell github:loophp/nix-shell#env-php81 --impure
</code></pre>
<p>This will pull-in ext-ffi extension, because itâ€™s declared in <code>composer.json</code>.</p>
<h3 id="building"><a class="header" href="#building">Building</a></h3>
<p>There is a <code>task build-php</code> script that:</p>
<ul>
<li>runs cargo to build <code>libprqlc</code>,</li>
<li>copies <code>libprqlc.*</code> into <code>lib</code>,</li>
<li>copies <code>libprqlc.h</code> into <code>lib</code>.</li>
</ul>
<h3 id="tests"><a class="header" href="#tests">Tests</a></h3>
<pre><code>task build-php
task test-php
</code></pre>
<h3 id="code-style"><a class="header" href="#code-style">Code style</a></h3>
<pre><code>./vendor/bin/phpcs --standard=PSR12 src tests
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-python"><a class="header" href="#prql-python">prql-python</a></h1>
<p><code>prql-python</code> offers Rust bindings to the <code>prql-compiler</code> Rust library. It exposes a Python method <code>compile(query: str) -&gt; str</code>.</p>
<p>This is consumed by <a href="https://github.com/prql/pyprql">pyprql</a> &amp; <a href="https://github.com/prql/dbt-prql">dbt-prql</a>.</p>
<p>The crate is not published to crates.io; only to PyPI at https://pypi.org/project/prql-python/.</p>
<h2 id="å®‰è£-5"><a class="header" href="#å®‰è£-5">å®‰è£</a></h2>
<p><code>pip install prql-python</code></p>
<h2 id="ç”¨æ³•-4"><a class="header" href="#ç”¨æ³•-4">ç”¨æ³•</a></h2>
<pre><code class="language-python">import prql_python as prql

prql_query = """
    from employees
    join salaries (==emp_id)
    group {employees.dept_id, employees.gender} (
      aggregate {
        avg_salary = average salaries.salary
      }
    )
"""

options = prql.CompileOptions(
    format=True, signature_comment=True, target="sql.postgres"
)

sql = prql.compile(prql_query)
sql_postgres = prql.compile(prql_query, options)
</code></pre>
<p>Relies on <a href="https://github.com/PyO3/pyo3">pyo3</a> for all the magic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="r-prqlr"><a class="header" href="#r-prqlr">R (prqlr)</a></h1>
<p>R bindings for <code>prql-compiler</code>.</p>
<p><code>prqlr</code> also includes <code>knitr</code> (R Markdown and Quarto) integration, which allows us to easily create documents with the PRQL conversion results embedded in.</p>
<p>Check out <a href="https://eitsupi.github.io/prqlr/">https://eitsupi.github.io/prqlr/</a> for more context.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/bindings/r.html#admonition-note"></a>
</div>
<div>
<p><code>prqlr</code> is generously maintained by <a href="https://github.com/eitsupi">@eitsupi</a> in the <a href="https://github.com/eitsupi/prqlr">eitsupi/prqlr</a> repo.</p>
</div>
</div>
<h2 id="å®‰è£-6"><a class="header" href="#å®‰è£-6">å®‰è£</a></h2>
<pre><code class="language-r">install.packages("prqlr")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Please check the documentation of the <a href="https://docs.rs/prql-compiler/latest/prql_compiler/">prql-compiler crate</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ•´åˆ"><a class="header" href="#æ•´åˆ">æ•´åˆ</a></h1>
<p>PRQL is building integrations with lots of external tools, including:</p>
<ul>
<li><a href="project/integrations/./jupyter.html">Jupyter</a></li>
<li><a href="project/integrations/./clickhouse.html">ClickHouse</a></li>
<li><a href="project/integrations/./duckdb.html">DuckDB</a></li>
<li><a href="project/integrations/./prefect.html">Prefect</a></li>
<li><a href="project/integrations/./vscode.html">VS Code</a></li>
<li><a href="project/integrations/./rill.html">Rill</a></li>
</ul>
<p>We also have a CLI, <a href="project/integrations/./prqlc-cli.html"><code>prqlc</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prql-compiler-cli--prqlc"><a class="header" href="#prql-compiler-cli--prqlc">PRQL compiler CLI â€”Â <code>prqlc</code></a></h1>
<p><code>prqlc</code> æ˜¯ PRQL ç·¨è­¯å™¨çš„ CLIã€‚å®ƒæ˜¯ä¸€å€‹ç„¡ç›¸ä¾é …çš„äºŒé€²ä½æª”ï¼Œå¯ä»¥å°‡ PRQL ç·¨è­¯ç‚º SQLã€‚</p>
<h2 id="ç”¨æ³•-5"><a class="header" href="#ç”¨æ³•-5">ç”¨æ³•</a></h2>
<h3 id="prqlc-compile"><a class="header" href="#prqlc-compile"><code>prqlc compile</code></a></h3>
<p>This command works as a filter that compiles a PRQL string into an SQL string.</p>
<pre><code class="language-sh">$ echo 'from employees | filter has_dog | select salary' | prqlc compile

SELECT
  salary
FROM
  employees
WHERE
  has_dog
</code></pre>
<p>A PRQL query can be executed with CLI tools compatible with SQL,, such as <a href="https://duckdb.org/docs/api/cli.html">DuckDB CLI</a>.</p>
<pre><code class="language-sh">$ curl -fsL https://raw.githubusercontent.com/PRQL/prql/0.8.1/prql-compiler/tests/integration/data/chinook/albums.csv -o albums.csv
$ echo 'from `albums.csv` | take 3' | prqlc compile | duckdb
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ album_id â”‚                 title                 â”‚ artist_id â”‚
â”‚  int64   â”‚                varchar                â”‚   int64   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚        1 â”‚ For Those About To Rock We Salute You â”‚         1 â”‚
â”‚        2 â”‚ Balls to the Wall                     â”‚         2 â”‚
â”‚        3 â”‚ Restless and Wild                     â”‚         2 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>Executing this command without any argument will start interactive mode, allowing a PRQL query to be written interactively. In this mode, after writing PRQL and press <code>Ctrl-d</code> (Linux, macOS) or <code>Ctrl-z</code> (Windows) to display the compiled SQL.</p>
<pre><code class="language-sh">prqlc compile
</code></pre>
<p>Just like when using it as a filter, SQL string output can be passed to the DuckDB CLI and similar tools.</p>
<pre><code class="language-sh">$ prqlc compile | duckdb
Enter PRQL, then press ctrl-d to compile:

from `albums.csv`
take 3
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ album_id â”‚                 title                 â”‚ artist_id â”‚
â”‚  int64   â”‚                varchar                â”‚   int64   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚        1 â”‚ For Those About To Rock We Salute You â”‚         1 â”‚
â”‚        2 â”‚ Balls to the Wall                     â”‚         2 â”‚
â”‚        3 â”‚ Restless and Wild                     â”‚         2 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="å®‰è£-7"><a class="header" href="#å®‰è£-7">å®‰è£</a></h2>
<p><a href="https://repology.org/project/prqlc/versions"><img src="https://repology.org/badge/vertical-allrepos/prqlc.svg" alt="Packaging status" /></a></p>
<h3 id="via-homebrew-macos-linux"><a class="header" href="#via-homebrew-macos-linux">via Homebrew (macOS, Linux)</a></h3>
<pre><code class="language-sh">brew install prqlc
</code></pre>
<h3 id="via-winget-windows"><a class="header" href="#via-winget-windows">via winget (Windows)</a></h3>
<pre><code class="language-sh">winget install prqlc
</code></pre>
<h3 id="from-github-release-page"><a class="header" href="#from-github-release-page">From GitHub release page</a></h3>
<p>Precompiled binaries are available for Linux, macOS, and Windows on the <a href="https://github.com/PRQL/prql/releases">PRQL release page</a>.</p>
<h3 id="from-source"><a class="header" href="#from-source">From source</a></h3>
<pre><code class="language-sh"># From crates.io
cargo install prqlc
</code></pre>
<pre><code class="language-sh"># From a local PRQL repository
cargo install --path prqlc/prqlc
</code></pre>
<h3 id="shell-completions"><a class="header" href="#shell-completions">Shell completions</a></h3>
<p>The <code>prqlc shell-completion</code> command prints a shell completion script for supported shells, and saving the printed scripts to files makes for shells to load completions for each session.</p>
<h4 id="bash"><a class="header" href="#bash">Bash</a></h4>
<p>For Linux:</p>
<pre><code class="language-sh">prqlc shell-completion bash &gt;/etc/bash_completion.d/prqlc
</code></pre>
<p>For macOS:</p>
<pre><code class="language-sh">prqlc shell-completion bash &gt;/usr/local/etc/bash_completion.d/prqlc
</code></pre>
<h4 id="fish"><a class="header" href="#fish">fish</a></h4>
<pre><code class="language-sh">prqlc shell-completion fish &gt;~/.config/fish/completions/prqlc.fish
</code></pre>
<h4 id="powershell"><a class="header" href="#powershell">PowerShell</a></h4>
<pre><code class="language-powershell">mkdir -Path (Split-Path -Parent $profile) -ErrorAction SilentlyContinue
prqlc shell-completion powershell &gt;path/to/prqlc.ps1
echo 'Invoke-Expression -Command path/to/prqlc.ps1' &gt;&gt;$profile
</code></pre>
<h4 id="zsh"><a class="header" href="#zsh">zsh</a></h4>
<pre><code class="language-sh">prqlc shell-completion zsh &gt;"${fpath[1]}/_prqlc"
</code></pre>
<p>Ensure that the following lines are present in <code>~/.zshrc</code>:</p>
<pre><code class="language-sh">autoload -U compinit
compinit -i
</code></pre>
<h2 id="helpers"><a class="header" href="#helpers">Helpers</a></h2>
<p>Cheat sheets for <code>prqlc</code> are available on various websites and with various tools.</p>
<ul>
<li><a href="https://tldr.sh/"><code>tldr</code></a> (<a href="https://tldr.inbrowser.app/pages/common/prqlc">on the web</a>)</li>
<li><a href="https://github.com/srsudar/eg"><code>eg</code></a></li>
</ul>
<!-- Issues: #2034 cheat/cheatsheets, #2041 devhints.io -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="clickhouse"><a class="header" href="#clickhouse">ClickHouse</a></h1>
<p>PRQL works natively in ClickHouse. Check out the <a href="https://clickhouse.com/docs/en/guides/developer/alternative-query-languages">ClickHouse docs</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jupyter"><a class="header" href="#jupyter">Jupyter</a></h1>
<p><a href="https://pypi.org/project/pyprql/">pyprql</a> contains <code>pyprql.magic</code>, a thin wrapper of <a href="https://pypi.org/project/jupysql/"><code>JupySQL</code></a>â€™s SQL IPython magics. This allows us to run PRQL interactively on Jupyter/IPython.</p>
<p>Check out <a href="https://pyprql.readthedocs.io/">https://pyprql.readthedocs.io/</a> for more context.</p>
<h2 id="å®‰è£-8"><a class="header" href="#å®‰è£-8">å®‰è£</a></h2>
<pre><code class="language-sh">pip install pyprql
</code></pre>
<h2 id="ç”¨æ³•-6"><a class="header" href="#ç”¨æ³•-6">ç”¨æ³•</a></h2>
<p>When installing pyprql, the <a href="https://pypi.org/project/duckdb-engine/">duckdb-engine</a> package is also installed with it, so we can start using PRQL immediately to query CSV and Parquet files.</p>
<p>For example, running <a href="https://jupysql.ploomber.io/en/latest/quick-start.html">the example from the JupySQL documentation</a> on IPython:</p>
<pre><code class="language-python">In [1]: %load_ext pyprql.magic

In [2]: !curl -sL https://raw.githubusercontent.com/mwaskom/seaborn-data/master/penguins.csv -o penguins.csv

In [3]: %prql duckdb://

In [4]: %prql from `penguins.csv` | take 3
Out[4]:
  species     island  bill_length_mm  bill_depth_mm  flipper_length_mm  body_mass_g     sex
0  Adelie  Torgersen            39.1           18.7                181         3750    MALE
1  Adelie  Torgersen            39.5           17.4                186         3800  FEMALE
2  Adelie  Torgersen            40.3           18.0                195         3250  FEMALE

In [5]: %%prql
   ...: from `penguins.csv`
   ...: filter bill_length_mm &gt; 40
   ...: take 3
   ...:
   ...:
Out[5]:
  species     island  bill_length_mm  bill_depth_mm  flipper_length_mm  body_mass_g     sex
0  Adelie  Torgersen            40.3           18.0                195         3250  FEMALE
1  Adelie  Torgersen            42.0           20.2                190         4250    None
2  Adelie  Torgersen            41.1           17.6                182         3200  FEMALE
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="duckdb"><a class="header" href="#duckdb">DuckDB</a></h1>
<p>Thereâ€™s an experimental <a href="https://duckdb.org/">DuckDB</a> extension from <strong><a href="https://github.com/ywelsch">@ywelsch</a></strong> at <a href="https://github.com/ywelsch/duckdb-prql">ywelsch/duckdb-prql</a>.</p>
<p>Check out the Readme for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefect"><a class="header" href="#prefect">Prefect</a></h1>
<p>Because <a href="https://www.prefect.io/">Prefect</a> is in native Python, itâ€™s extremely easy to integrate with PRQL.</p>
<p>With a Postgres Task, replace:</p>
<pre><code class="language-python">PostgresExecute.run(..., query=sql)
</code></pre>
<p>â€¦withâ€¦</p>
<pre><code class="language-python">PostgresExecute.run(..., query=prql_python.compile(prql))
</code></pre>
<p>Weâ€™re big fans of Prefect, and if there is anything that would make the integration easier, please open an issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-code-extension"><a class="header" href="#visual-studio-code-extension">Visual Studio Code extension</a></h1>
<p>PRQL has a Visual Studio Code extension that compiles a PRQL query in a VS Code editor and displays the resulting SQL code in a second pane on the side. This is very handy for editing, saving, and reusing PRQL queries in VS Code.</p>
<p>To install the VS Code extension, open VS Code and type <kbd>Ctrl</kbd>-<kbd>Shift</kbd>-<kbd>P</kbd> (<kbd>Cmd</kbd>-<kbd>Shift</kbd>-<kbd>P</kbd> on a Mac) and type <code>PRQL</code>. Install the extension as usual.</p>
<p><a href="https://github.com/PRQL/prql-vscode">Repo for the PRQL VS Code extension</a></p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=PRQL-lang.prql-vscode">Extension on VS Marketplace</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rill"><a class="header" href="#rill">Rill</a></h1>
<p>PRQL has had some work to integrate with Rill. See the <a href="https://github.com/PRQL/prql/issues?q=is%3Aissue+rill">Rill ssues</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ–‡æ³•èªæ³•æ¨™æ˜"><a class="header" href="#æ–‡æ³•èªæ³•æ¨™æ˜">æ–‡æ³•/èªæ³•æ¨™æ˜</a></h1>
<p>PRQL contains multiple grammar definitions to enable tools to highlight PRQL code. These are all intended to provide as good an experience as the grammar supports. Please raise any shortcomings in a GitHub issue.</p>
<p>The definitions are somewhat scattered around the codebase; this page serves as an index.</p>
<ul>
<li>
<p><a href="https://ace.c9.io/">Ace</a> â€” supported. The grammar is upstream (<a href="https://github.com/ajaxorg/ace/blob/master/src/mode/prql_highlight_rules.js">prql_highlight_rules.js</a>). See the <a href="https://prql-lang.org/demos/ace-demo">demo</a>.</p>
</li>
<li>
<p><a href="https://github.com/alecthomas/chroma">chroma</a> â€” Go library used by the static website generator Hugo. The grammar is upstream (<a href="https://github.com/alecthomas/chroma/blob/master/lexers/embedded/prql.xml">prql.xml</a>). See the <a href="https://swapoff.org/chroma/playground/">demo</a>.</p>
</li>
<li>
<p><a href="https://lezer.codemirror.net/">Lezer</a> â€” used by CodeMirror editors. The PRQL file is at <a href="https://github.com/PRQL/prql/tree/main/grammars/prql-lezer/README.md"><code>grammars/prql-lezer/README.md</code></a>.</p>
</li>
<li>
<p><a href="https://handlebarsjs.com/">Handlebars</a> â€” currently duplicated:</p>
<ul>
<li>The book: <a href="https://github.com/PRQL/prql/blob/main/web/book/highlight-prql.js"><code>book/highlight-prql.js</code></a></li>
<li>The website (outside of the book &amp; playground): <a href="https://github.com/PRQL/prql/blob/main/web/book/highlight-prql.js"><code>website/themes/prql-theme/static/plugins/highlight/prql.js</code></a></li>
</ul>
</li>
<li>
<p><a href="https://macromates.com/manual/en/language_grammars">Textmate</a> â€” used by the VS Code extension. Itâ€™s in the <code>prql-vscode</code> repo in <a href="https://github.com/PRQL/prql-vscode/blob/main/syntaxes/prql.tmLanguage.json"><code>prql-vscode/syntaxes/prql.tmLanguage.json</code></a>.</p>
</li>
<li>
<p><a href="https://microsoft.github.io/monaco-editor/monarch.html">Monarch</a> â€” used by the Monaco editor, which we use for the Playground. The grammar is at <a href="https://github.com/PRQL/prql/blob/main/web/playground/src/workbench/prql-syntax.js"><code>playground/src/workbench/prql-syntax.js</code></a>.</p>
</li>
<li>
<p><a href="https://pygments.org/">Pygments</a> â€” Python library used by Wikipedia, Bitbucket, Sphinx and <a href="https://pygments.org/faq/#who-uses-pygments">more</a>. The grammar is upstream (<a href="https://github.com/pygments/pygments/blob/master/pygments/lexers/prql.py">prql.py</a>). See the <a href="https://pygments.org/demo/">demo</a>.</p>
</li>
<li>
<p><a href="https://tree-sitter.github.io/tree-sitter">Tree-Sitter</a> â€” used by the neovim and helix. The grammar can be found at <a href="https://github.com/PRQL/tree-sitter-prql">https://github.com/PRQL/tree-sitter-prql</a>.</p>
</li>
</ul>
<hr />
<p>Since the <a href="https://elm-lang.org/">Elm</a> language coincidentally provides syntax highlighting suitable for PRQL, it may look better to mark PRQL code as Elm when the above definition files are not available.</p>
<p>For example, the following Markdown code block will be nicely highlighted on GitHub, Pandoc, and other Markdown renderers:</p>
<pre><code class="language-markdown">```elm
from employees
filter start_date &gt; @2021-01-01
```
</code></pre>
<p>We hope that in the future these renderers will recognize PRQL code blocks and have syntax highlighting applied, and we are tracking these with several issues.</p>
<ul>
<li>GitHub (Linguist): <a href="https://github.com/PRQL/prql/issues/1636">https://github.com/PRQL/prql/issues/1636</a></li>
<li>Pandoc (Kate): <a href="https://github.com/PRQL/prql/issues/2213">https://github.com/PRQL/prql/issues/2213</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>If youâ€™re interested in joining the community to build a better SQL, here are ways to start:</p>
<ul>
<li>æ˜Ÿæ¨™æ”¶è—<a href="https://github.com/PRQL/prql">å„²å­˜åº«</a>ã€‚</li>
<li>Send a link to PRQL to a couple of people whose opinion you respect.</li>
<li>Subscribe to <a href="https://www.jessesquires.com/blog/2020/07/30/github-tip-watching-releases/">new releases</a> for updates.</li>
<li>åœ¨ <a href="https://twitter.com/prql_lang">Twitter</a> ä¸Šé—œæ³¨æˆ‘å€‘ã€‚</li>
<li>åŠ å…¥æˆ‘å€‘çš„ <a href="https://discord.gg/eQcfaCmsNc">Discord</a>ã€‚</li>
<li>Find an issue labeled <a href="https://github.com/prql/prql/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">Good First Issue</a> and start contributing to the code.</li>
<li>Join our <a href="https://github.com/PRQL/prql/issues/1083">fortnightly Developer Call</a>; (<a href="project/contributing/./fortnightly-dev-call.ics">iCal file</a>).</li>
</ul>
<p>PRQL is evolving from a project with lots of excitement into a project that folks are using in their work and integrating into their tools. Weâ€™re actively looking for collaborators to lead that growth with us.</p>
<h2 id="areas-for-larger-contributions"><a class="header" href="#areas-for-larger-contributions">Areas for larger contributions</a></h2>
<h3 id="ç·¨è­¯å™¨"><a class="header" href="#ç·¨è­¯å™¨">ç·¨è­¯å™¨</a></h3>
<p>The compiler is written in Rust, and thereâ€™s enough to do such that any level of experience with Rust is sufficient.</p>
<p>We try to keep a few onboarding issues on hand under the <a href="https://github.com/PRQL/prql/labels/good%20first%20issue">â€œgood first issueâ€ label</a>. These have been screened to have sufficient context to get started (and we very much welcome questions where thereâ€™s some context missing).</p>
<p>To get started, check out the docs on <a href="project/contributing/./development.html">Development</a> and the <a href="https://github.com/PRQL/prql/blob/main/prqlc/ARCHITECTURE.md">Compiler architecture</a></p>
<p>And if you have questions, there are lots of friendly people on the Discord who will patiently help you.</p>
<h3 id="bindings--integrations"><a class="header" href="#bindings--integrations">Bindings &amp; integrations</a></h3>
<p>For PRQL to be successful, it needs to be available for the languages &amp; tools that people already use.</p>
<ul>
<li>We currently have bindings to the PRQL compiler in a few different languages; many of these can be improved, documented, and packaged in a better way.</li>
<li>If you have experience with packaging in an ecosystem that doesnâ€™t currently have bindings, then creating PRQL bindings for that language we donâ€™t currently support would be valuable to the project.</li>
<li>If thereâ€™s a tool that you use yourself to run data queries which you think would benefit from a PRQL integration, suggest one to us or the tool. If itâ€™s open-source, build &amp; share a prototype.</li>
</ul>
<p>Relevant issues are labeled <a href="https://github.com/PRQL/prql/labels/integrations">Integrations</a>.</p>
<h3 id="èªè¨€è¨­è¨ˆ"><a class="header" href="#èªè¨€è¨­è¨ˆ">èªè¨€è¨­è¨ˆ</a></h3>
<p>We decide on new language features in GitHub issues, usually under <a href="https://github.com/PRQL/prql/issues?q=is%3Aopen+label%3Alanguage-design+sort%3Aupdated-desc">â€œlanguage designâ€ label</a>.</p>
<p>You can also contribute by:</p>
<ul>
<li>Finding instances where the compiler produces incorrect results, and post a bug report â€”Â feel free to use the <a href="https://prql-lang.org/playground">playground</a>.</li>
<li>Opening an issue / append to an existing issue with examples of queries that are difficult to express in PRQL â€”Â especially if more difficult than SQL.</li>
</ul>
<p>æä¾›å……è¶³çš„ç¯„ä¾‹ä¾†å»ºè­°èªè¨€è®Šæ›´ï¼ï¼ˆç”±æ–¼æ²’æœ‰ç¯„ä¾‹çš„å»ºè­°å¾ˆé›£é€²è¡Œè¨è«–ï¼Œå› æ­¤è«‹å‹™å¿…å°‡å»ºè­°å»ºç«‹åœ¨å…·é«”ç¯„ä¾‹ä¹‹ä¸Šã€‚ï¼‰</p>
<h3 id="marketing"><a class="header" href="#marketing">Marketing</a></h3>
<ul>
<li>Improve our website. We have <a href="https://github.com/PRQL/prql/labels/web">a few issues open</a> on this front and are looking for anyone with at least some design skills.</li>
<li>Contribute towards the docs. Anything from shaping a whole section of the docs, to simply improving a confusing paragraph or fixing a typo.</li>
<li>Tell people about PRQL.</li>
<li>Find a group of users who would be interested in PRQL, help them get up to speed, help the project understand what they need.</li>
</ul>
<h2 id="æ ¸å¿ƒåœ˜éšŠ"><a class="header" href="#æ ¸å¿ƒåœ˜éšŠ">æ ¸å¿ƒåœ˜éšŠ</a></h2>
<p>If you have any questions or feedback and donâ€™t receive a response on one of the general channels such as GitHub or Discord, feel free to reach out to:</p>
<ul>
<li><a href="https://github.com/aljazerzen"><strong>@aljazerzen</strong></a> â€” AljaÅ¾ Mur ErÅ¾en</li>
<li><a href="https://github.com/max-sixty"><strong>@max-sixty</strong></a> â€” Maximilian Roos</li>
<li><a href="https://github.com/eitsupi"><strong>@eitsupi</strong></a> â€” SHIMA Tatsuya</li>
<li><a href="https://github.com/snth"><strong>@snth</strong></a> â€” Tobias Brandt</li>
</ul>
<h3 id="æ ¸å¿ƒåœ˜éšŠæ¦®è­½æˆå“¡"><a class="header" href="#æ ¸å¿ƒåœ˜éšŠæ¦®è­½æˆå“¡">æ ¸å¿ƒåœ˜éšŠæ¦®è­½æˆå“¡</a></h3>
<p>Thank you to those who have previously served on the core team:</p>
<ul>
<li><a href="https://github.com/charlie-sanders"><strong>@charlie-sanders</strong></a> â€” Charlie Sanders</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é–‹ç™¼-3"><a class="header" href="#é–‹ç™¼-3">é–‹ç™¼</a></h1>
<h2 id="setting-up-an-initial-dev-environment"><a class="header" href="#setting-up-an-initial-dev-environment">Setting up an initial dev environment</a></h2>
<p>We can set up a local development environment sufficient for navigating, editing, and testing PRQLâ€™s compiler code in two minutes:</p>
<ul>
<li>
<p>Install <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html"><code>rustup</code> &amp; <code>cargo</code></a>.</p>
</li>
<li>
<p>[Optional but highly recommended] Install <code>cargo-insta</code>, our testing framework:</p>
<pre><code class="language-sh">cargo install cargo-insta
</code></pre>
</li>
<li>
<p>Thatâ€™s it! Running the unit tests for the <code>prql-compiler</code> crate after cloning the repo should complete successfully:</p>
<pre><code class="language-sh">cargo test --package prql-compiler --lib
</code></pre>
<p>â€¦or, to run tests and update the test snapshots:</p>
<pre><code class="language-sh">cargo insta test --accept --package prql-compiler --lib
</code></pre>
<p>Thereâ€™s more context on our tests in <a href="project/contributing/development.html#how-we-test">How we test</a> below.</p>
</li>
</ul>
<p>Thatâ€™s sufficient for making an initial contribution to the compiler.</p>
<hr />
<h2 id="setting-up-a-full-dev-environment"><a class="header" href="#setting-up-a-full-dev-environment">Setting up a full dev environment</a></h2>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-info"></a>
</div>
<div>
<p>We really care about this process being easy, both because the project benefits from more contributors like you, and to reciprocate your future contribution. If something isnâ€™t easy, please let us know in a GitHub Issue. Weâ€™ll enthusiastically help you, and use your feedback to improve the scripts &amp; instructions.</p>
</div>
</div>
<p>For more advanced development; for example compiling for wasm or previewing the website, we have two options:</p>
<h3 id="option-1-use-the-projects-task"><a class="header" href="#option-1-use-the-projects-task">Option 1: Use the projectâ€™s <code>task</code></a></h3>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-note"></a>
</div>
<div>
<p>This is tested on macOS, should work on amd64 Linux, but wonâ€™t work on others (include Windows), since it relies on <code>brew</code>.</p>
</div>
</div>
<ul>
<li>
<p><a href="https://taskfile.dev/installation/">Install Task</a>.</p>
</li>
<li>
<p>Then run the <code>setup-dev</code> task. This runs commands from our <a href="https://github.com/PRQL/prql/blob/main/Taskfile.yml">Taskfile.yml</a>, installing dependencies with <code>cargo</code>, <code>brew</code>, <code>npm</code> &amp; <code>pip</code>, and suggests some VS Code extensions.</p>
<pre><code class="language-sh">task setup-dev
</code></pre>
</li>
</ul>
<h3 id="option-2-install-tools-individually"><a class="header" href="#option-2-install-tools-individually">Option 2: Install tools individually</a></h3>
<ul>
<li>
<p>Weâ€™ll need <code>cargo-insta</code>, to update snapshot tests:</p>
<pre><code class="language-sh">cargo install cargo-insta
</code></pre>
</li>
<li>
<p>Weâ€™ll need Python, which most systems will have already. The easiest way to check is to try running the full tests:</p>
<pre><code class="language-sh">cargo test
</code></pre>
<p>â€¦and if that doesnâ€™t complete successfully, ensure we have Python &gt;= 3.7, to compile <code>prql-python</code>.</p>
</li>
<li>
<p>For more involved contributions, such as building the website, playground, book, or some release artifacts, weâ€™ll need some additional tools. But we wonâ€™t need those immediately, and the error messages on whatâ€™s missing should be clear when we attempt those things. When we hit them, the <a href="https://github.com/PRQL/prql/blob/main/Taskfile.yml">Taskfile.yml</a> will be a good source to copy &amp; paste instructions from.</p>
</li>
</ul>
<h3 id="é¸é …-3ä½¿ç”¨-dev-container"><a class="header" href="#é¸é …-3ä½¿ç”¨-dev-container">é¸é … 3ï¼šä½¿ç”¨ Dev Container</a></h3>
<p>This project has a <a href="https://github.com/PRQL/prql/blob/main/.devcontainer/devcontainer.json">devcontainer.json file</a> and a <a href="https://github.com/PRQL/prql/pkgs/container/prql-devcontainer-base">pre-built dev container base Docker image</a>. Learn more about Dev Containers at <a href="https://containers.dev/">https://containers.dev/</a></p>
<p>Currently, the tools for Rust are already installed in the pre-built image, and, Node.js, Python and others are configured to be installed when build the container.</p>
<p>While there are a variety of tools that support Dev Containers, the focus here is on developing with VS Code in a container by <a href="https://docs.github.com/en/codespaces/overview">GitHub Codespaces</a> or <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers">VS Code Dev Containers extension</a>.</p>
<p>To use a Dev Container on a local computer with VS Code, install the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers">VS Code Dev Containers extension</a> and its system requirements. Then refer to the links above to get started.</p>
<h3 id="é¸é …-4ä½¿ç”¨-nix-é–‹ç™¼ç’°å¢ƒ"><a class="header" href="#é¸é …-4ä½¿ç”¨-nix-é–‹ç™¼ç’°å¢ƒ">é¸é … 4ï¼šä½¿ç”¨ nix é–‹ç™¼ç’°å¢ƒ</a></h3>
<p>A <a href="https://nixos.org/">nix</a> flake <code>flake.nix</code> provides 3 development environments:</p>
<ul>
<li><strong>default</strong>, for building the compiler</li>
<li><strong>web</strong>, for the compiler and the website,</li>
<li><strong>full</strong>, for the compiler, the website and the compiler bindings.</li>
</ul>
<p>To load the shell:</p>
<ol>
<li>
<p><a href="https://nixos.org/download">Install nix (the package manager)</a>. (only first time)</p>
</li>
<li>
<p>Enable flakes, which are a (pretty stable) experimental feature of nix. (only first time)</p>
<p>For non-NixOS users:</p>
<pre><code>mkdir -p ~/.config/nix/
tee 'experimental-features = nix-command flakes' &gt;&gt; ~/.config/nix/nix.conf
</code></pre>
<p>For NixOs users, follow instructions <a href="https://nixos.wiki/wiki/Flakes">here</a>.</p>
</li>
<li>
<p>Run:</p>
<pre><code>nix develop
</code></pre>
<p>If you want â€œwebâ€ or â€œfullâ€ shell, run:</p>
<pre><code>nix develop .#web
</code></pre>
</li>
</ol>
<p>Optionally, you can install <a href="https://direnv.net/">direnv</a>, to automatically load the shell when you enter this repo. The easiest way is to also install <a href="https://github.com/nix-community/nix-direnv">direnv-nix</a> and configure your <code>.envrc</code> with:</p>
<pre><code># .envrc
use flake .#full
</code></pre>
<hr />
<h2 id="contribution-workflow"><a class="header" href="#contribution-workflow">Contribution workflow</a></h2>
<p>Weâ€™re similar to most projects on GitHub â€” open a Pull Request with a suggested change!</p>
<h3 id="commits"><a class="header" href="#commits">Commits</a></h3>
<ul>
<li>If a change is user-facing, please add a line in <a href="https://github.com/PRQL/prql/blob/main/CHANGELOG.md"><strong><code>CHANGELOG.md</code></strong></a>, with <code>{message}, ({@contributor, #X})</code> where <code>X</code> is the PR number.
<ul>
<li>If thereâ€™s a missing entry, a follow-up PR containing just the changelog entry is welcome.</li>
</ul>
</li>
<li>Weâ€™re using <a href="https://www.conventionalcommits.org">Conventional Commits</a> message format, enforced through <a href="https://github.com/amannn/action-semantic-pull-request">action-semantic-pull-request</a>.</li>
</ul>
<h3 id="merges"><a class="header" href="#merges">Merges</a></h3>
<ul>
<li><strong>We merge any code that makes PRQL better</strong></li>
<li>A PR doesnâ€™t need to be perfect to be merged; it doesnâ€™t need to solve a big problem. It needs to:
<ul>
<li>be in the right direction,</li>
<li>make incremental progress,</li>
<li>be explicit on its current state, so others can continue the progress.</li>
</ul>
</li>
<li>That said, there are a few instances when we need to ensure we have some consensus before merging code â€” for example non-trivial changes to the language, or large refactorings to the library.</li>
<li>If you have merge permissions, and are reasonably confident that a PR is suitable to merge (whether or not youâ€™re the author), feel free to merge.
<ul>
<li>If you donâ€™t have merge permissions and have authored a few PRs, ask and ye shall receive.</li>
</ul>
</li>
<li>The primary way we ratchet the code quality is through automated tests.
<ul>
<li>This means PRs almost always need a test to demonstrate incremental progress.</li>
<li>If a change breaks functionality without breaking tests, our tests were probably insufficient.</li>
<li>If a change breaks existing tests (for example, changing an external API), that indicates we should be careful about merging a change, including soliciting othersâ€™ views.</li>
</ul>
</li>
<li>We use PR reviews to give general context, offer specific assistance, and collaborate on larger decisions.
<ul>
<li>Reviews around â€˜nitsâ€™ like code formatting / idioms / etc are very welcome. But the norm is for them to be received as helpful advice, rather than as mandatory tasks to complete. Adding automated tests &amp; lints to automate these suggestions is welcome.</li>
<li>If you have merge permissions and would like a PR to be reviewed before it merges, thatâ€™s great â€” ask or assign a reviewer.</li>
<li>If a PR hasnâ€™t received attention after a day, please feel free to ping the pull request.</li>
</ul>
</li>
<li>People may review a PR after itâ€™s merged. As part of the understanding that we can merge quickly, contributors are expected to incorporate substantive feedback into a future PR.</li>
<li>We should revert quickly if the impact of a PR turns out not to be consistent with our expectations, or there isnâ€™t as much consensus on a decision as we had hoped. Itâ€™s very easy to revert code and then re-revert when weâ€™ve resolved the issue; itâ€™s a sign of moving quickly. Other options which resolve issues immediately are also fine, such as commenting out an incorrect test or adding a quick fix for the underlying issue.</li>
</ul>
<h2 id="docs"><a class="header" href="#docs">Docs</a></h2>
<p>Weâ€™re very keen on contributions to improve our documentation.</p>
<p>This includes our docs in the book, on the website, in our code, or in a Readme. We also appreciate issues pointing out that our documentation was confusing, incorrect, or stale â€” if itâ€™s confusing for you, itâ€™s probably confusing for others.</p>
<p>Some principles for ensuring our docs remain maintainable:</p>
<ul>
<li>Docs should be as close as possible to the code. Doctests are ideal on this dimension â€” theyâ€™re literally very close to the code and they canâ€™t drift apart since theyâ€™re tested on every commit. Or, for example, itâ€™s better to add text to a <code>--help</code> message, rather than write a paragraph in the Readme explaining the CLI.</li>
<li>We should have some visualization of how to maintain docs when we add them. Docs have a habit of falling out of date â€” the folks reading them are often different from those writing them, theyâ€™re sparse from the code, generally not possible to test, and are rarely the by-product of other contributions. Docs that are concise &amp; specific are easier to maintain.</li>
<li>Docs should be specifically relevant to PRQL; anything else we can instead link to.</li>
</ul>
<p>If something doesnâ€™t fit into one of these categories, there are still lots of ways of getting the word out there â€” a blog post / gist / etc. Let us know and weâ€™re happy to link to it / tweet it.</p>
<h2 id="how-we-test"><a class="header" href="#how-we-test">How we test</a></h2>
<p>We use a pyramid of tests â€” we have fast, focused tests at the bottom of the pyramid, which give us low latency feedback when developing, and then slower, broader tests which ensure that we donâ€™t miss anything as PRQL develops<sup><a name="to-footnote-1"><a href="project/contributing/development.html#footnote-1">1</a></a></sup>.</p>
<!-- markdownlint-disable MD053 -->
<div id="admonition-info-1" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-1-title">
<div class="admonition-title">
<div id="admonition-info-1-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-info-1"></a>
</div>
<div>
<p>If youâ€™re making your first contribution, you donâ€™t need to engage with all this â€” itâ€™s fine to just make a change and push the results; the tests that run in GitHub will point you towards any errors, which can be then be run locally if needed. Weâ€™re always around to help out.</p>
</div>
</div>
<p>Our tests, from the bottom of the pyramid to the top:</p>
<ul>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/main/.pre-commit-config.yaml">Static checks</a></strong> â€” we run a few static checks to ensure the code stays healthy and consistent. Theyâ€™re defined in <a href="https://github.com/PRQL/prql/blob/main/.pre-commit-config.yaml"><strong><code>.pre-commit-config.yaml</code></strong></a>, using <a href="https://pre-commit.com">pre-commit</a>. They can be run locally with</p>
<pre><code class="language-sh">task test-lint
# or
pre-commit run -a
</code></pre>
<p>The tests fix most of the issues they find themselves. Most of them also run on GitHub on every commit; any changes they make are added onto the branch automatically in an additional commit.</p>
<ul>
<li>Checking by <a href="https://megalinter.io/latest/">MegaLinter</a>, which includes more Linters, is also done automatically on GitHub. (experimental)</li>
</ul>
</li>
<li>
<p><strong>Unit tests &amp; inline insta snapshots</strong> â€” we rely on unit tests to rapidly check that our code basically works. We extensively use <a href="https://insta.rs/">Insta</a>, a snapshot testing tool which writes out the values generated by our code, making it fast &amp; simple to write and modify tests<sup><a name="to-footnote-2"><a href="project/contributing/development.html#footnote-2">2</a></a></sup></p>
<p>These are the fastest tests which run our code; theyâ€™re designed to run on every save while youâ€™re developing. We include a <code>task</code> which does this:</p>
<pre><code class="language-sh">task test-rust-fast
# or
cargo insta test --accept --package prql-compiler --lib
# or, to run on every change:
task -w test-rust-fast
</code></pre>
</li>
</ul>
<!--
This is the previous doc. It has the advantage that it explains what it's doing, and is
easy to change (e.g. to run all packages). But because of
https://github.com/watchexec/watchexec/issues/371, the ignore behavior is unfortunately quite
inconsistent in watchexec. Let's revert back if it gets solved.

[^2]: For example, this is a command I frequently run:

    ```sh
    RUST_BACKTRACE=1 watchexec -e rs,toml,md -cr --ignore='target/**' -- cargo -q insta test --accept -p prql-compiler --lib
    ```

    Breaking this down:

    - `RUST_BACKTRACE=1` will print a full backtrace, including where an error
      value was created, for Rust tests which return `Result`s.
    - `watchexec -e rs,toml,md -cr --ignore='target/**' --` will run the
      subsequent command on any change to files with extensions which we are
      generally editing.
    - `cargo insta test --accept --` runs tests with `insta`, a snapshot
      library, and writes any results immediately. I rely on git to track
      changes, so I run with `--accept`, but YMMV.
    - `-p prql-compiler --lib` is passed to cargo by `insta`; `-p prql-compiler`
      tells it to only run the tests for `prql-compiler` rather than the other
      crates, and `--lib` to only run the unit tests rather than the integration
      tests, which are slower.
    - Note that we don't want to re-run on _any_ file changing, because we can
      get into a loop of writing snapshot files, triggering a change, writing a
      snapshot file, etc. -->
<ul>
<li>
<p><strong><a href="https://github.com/PRQL/prql/tree/main/web/book/tests/documentation">Documentation</a></strong> â€” we compile all examples from our documentation in the Website, README, and PRQL Book, to test that they produce the SQL we expect, and that changes to our code donâ€™t cause any unexpected regressions. These are included in:</p>
<pre><code class="language-sh">cargo insta test --accept
</code></pre>
</li>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/main/prqlc/prql-compiler/tests/integration">Integration tests</a></strong> â€” we run tests with example queries against databases with actual data to ensure weâ€™re producing correct SQL across our supported dialects. The in-process tests can be run locally with:</p>
<pre><code class="language-sh">task test-rust
# or
cargo insta test --accept --features=test-dbs
</code></pre>
<p>More details on running with external databases are in the <a href="https://github.com/PRQL/prql/tree/main/prqlc/prql-compiler/tests/integration">Readme</a>.</p>
</li>
</ul>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="project/contributing/development.html#admonition-note-1"></a>
</div>
<div>
<p>Integration tests use DuckDB, and so require a clang compiler to compile <a href="https://github.com/wangfenjin/duckdb-rs"><code>duckdb-rs</code></a>. Most development systems will have one, but the test command fails, install it with:</p>
<ul>
<li>On macOS, install xcode with <code>xcode-select --install</code></li>
<li>On Debian Linux, <code>apt-get update &amp;&amp; apt-get install clang</code></li>
<li>On Windows, <code>duckdb-rs</code> isnâ€™t supported, so these tests are excluded</li>
</ul>
</div>
</div>
<ul>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/main/.github/workflows/tests.yaml">GitHub Actions on every commit</a></strong> â€” we run tests relevant to a PRâ€™s changes in CI â€” for example changes to docs will attempt to build docs, changes to a binding will run that bindingâ€™s tests. The vast majority of changes trigger tests which run in less than five minutes, and we should be reassessing their scope if they take longer than that. Once these pass, a pull request can be merged.</p>
</li>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/c042eef48709e2c1af577161554fd09f14e67e0f/.github/workflows/pull-request.yaml#L124">GitHub Actions on merge</a></strong> â€” we run a wider set tests on every merge to main. This includes testing across OSs, all our language bindings, a measure of test code coverage, and some performance benchmarks.</p>
<p>If these tests fail after merging, we should revert the commit before fixing the test and then re-reverting.</p>
<p>Most of these will run locally with:</p>
<pre><code class="language-sh">task test-all
</code></pre>
</li>
<li>
<p><strong><a href="https://github.com/PRQL/prql/blob/main/.github/workflows/nightly.yaml">GitHub Actions nightly</a></strong> â€” every night, we run tests that take longer, are less likely to fail, or are unrelated to code changes â€” such as security checks, bindingsâ€™ tests on multiple OSs, or expensive timing benchmarks.</p>
<p>We can run these tests before a merge by adding a label <code>pr-nightly</code> to the PR.</p>
</li>
</ul>
<p>The goal of our tests is to allow us to make changes quickly. If you find theyâ€™re making it more difficult for you to make changes, or there are missing tests that would give you the confidence to make changes faster, then please raise an issue.</p>
<hr />
<h2 id="ç¶²ç«™"><a class="header" href="#ç¶²ç«™">ç¶²ç«™</a></h2>
<p>The website is published together with the book and the playground, and is automatically built and released on any push to the <code>web</code> branch.</p>
<p>The <code>web</code> branch points to the latest release plus any website-specific fixes. That way, the compiler behavior in the playground matches the latest release while allowing us to fix mistakes in the docs with a tighter loop than every release.</p>
<p>Fixes to the playground, book, or website should have a <code>pr-backport-web</code> label added to their PR â€” a bot will then open &amp; merge another PR onto the <code>web</code> branch once the initial branch merges.</p>
<p>The website components will run locally with:</p>
<pre><code class="language-sh"># Run the main website
task run-website
# Run the PRQL online book
task run-book
# Run the PRQL playground
task run-playground
</code></pre>
<hr />
<h2 id="releasing"><a class="header" href="#releasing">Releasing</a></h2>
<p>Currently we release in a semi-automated way:</p>
<ol>
<li>
<p>PR &amp; merge an updated <a href="https://github.com/PRQL/prql/blob/main/CHANGELOG.md">Changelog</a>. GitHub will produce a draft version at <a href="https://github.com/PRQL/prql/releases/new">https://github.com/PRQL/prql/releases/new</a>, including â€œNew Contributorsâ€.</p>
<p>Use this script to generate the first line:</p>
<pre><code class="language-sh">echo "This release has $(git rev-list --count $(git rev-list --tags --max-count=1)..) commits from $(git shortlog --summary $(git rev-list --tags --max-count=1).. | wc -l | tr -d '[:space:]') contributors. Selected changes:"
</code></pre>
</li>
<li>
<p>If the current version is correct, then skip ahead. But if the version needs to be changed â€” for example, we had planned on a patch release, but instead require a minor release â€” then run <code>cargo release version $version -x &amp;&amp; cargo release replace -x</code> to bump the version and PR the resulting commit.</p>
</li>
<li>
<p>After merging, go to <a href="https://github.com/PRQL/prql/releases/new">Draft a new release</a><sup><a name="to-footnote-3"><a href="project/contributing/development.html#footnote-3">3</a></a></sup>, copy the changelog entry into the release description<sup><a name="to-footnote-4"><a href="project/contributing/development.html#footnote-4">4</a></a></sup>, enter the tag to be created, and hit â€œPublishâ€.</p>
</li>
<li>
<p>From there, both the tag and release is created and all packages are published automatically based on our <a href="https://github.com/PRQL/prql/blob/main/.github/workflows/release.yaml">release workflow</a>.</p>
</li>
<li>
<p>Run <code>cargo release version patch -x --no-confirm &amp;&amp; cargo release replace -x --no-confirm</code> to bump the versions and add a new Changelog section; then PR the resulting commit.</p>
</li>
<li>
<p>Check whether there are <a href="https://github.com/PRQL/prql/milestones">milestones</a> that need to be pushed out.</p>
</li>
<li>
<p>Review the <strong>Current Status</strong> on the README.md to ensure it reflects the project state.</p>
</li>
</ol>
<p>We may make this more automated in future; e.g. automatic changelog creation.<p><hr/></p>
<p><a name="footnote-1"><a href="project/contributing/development.html#to-footnote-1">1</a></a>: Our approach is very consistent with <strong><a href="https://github.com/matklad">@matklad</a></strong>â€™s advice, in his excellent blog post <a href="https://matklad.github.io//2021/05/31/how-to-test.html">How to Test</a>.</p>
<p><a name="footnote-2"><a href="project/contributing/development.html#to-footnote-2">2</a></a>: <a href="https://github.com/PRQL/prql/blob/0.2.2/prql-compiler/src/parser.rs#L580-L605">Hereâ€™s an example of an insta test</a> â€” note that only the initial line of each test is written by us; the remainder is filled in by insta.</p>
<p><a name="footnote-3"><a href="project/contributing/development.html#to-footnote-3">3</a></a>: Only maintainers have access to this page.</p>
<p><a name="footnote-4"><a href="project/contributing/development.html#to-footnote-4">4</a></a>: Unfortunately GitHubâ€™s markdown parser interprets linebreaks as newlines. I havenâ€™t found a better way of editing the markdown to look reasonable than manually editing the text.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="èªè¨€è¨­è¨ˆ-1"><a class="header" href="#èªè¨€è¨­è¨ˆ-1">èªè¨€è¨­è¨ˆ</a></h1>
<p>In a way PRQL is just a transpiler to SQL. This can cause its language design to gravitate toward thinking about PRQL features in terms of how they translate to SQL.</p>
<pre><code>PRQL feature -&gt; SQL feature -&gt; relational result
</code></pre>
<p>This is flawed because:</p>
<ul>
<li>it does not model interactions between features well,</li>
<li>SQL behavior can sometimes be misleading (the order of a subquery will not persist in the parent query) or even differs between dialects (set operations).</li>
</ul>
<p>Instead, we should think of PRQL features in terms of how they affect PRQL expressions, which in most cases means how they affect relations.</p>
<pre><code>PRQL feature -&gt; relation
                   |
                   v
PRQL feature -&gt; relation
                   |
                   v
PRQL feature -&gt; relation
                   |
                   v
            relational result
</code></pre>
<p>Thinking about SQL comes in only at the last step when relation (or rather relational expression) is translated to an SQL expression.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="highlight-prql.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
