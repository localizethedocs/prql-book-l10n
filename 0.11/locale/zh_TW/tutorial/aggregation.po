msgid ""
msgstr ""
"Project-Id-Version: PRQL language book\n"
"POT-Creation-Date: 2026-01-10T16:16:28Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/tutorial/aggregation.md:1
msgid "Aggregation"
msgstr "聚合"

#: src/tutorial/aggregation.md:3
msgid ""
"A key feature of analytics is reducing many values down to some summary. "
"This act is called \"aggregation\" and always includes a function — for "
"example, `average` or `sum` — that reduces values in the table to a single "
"row."
msgstr ""

#: src/tutorial/aggregation.md:7
msgid "`aggregate` transform"
msgstr "`aggregate` 變換"

#: src/tutorial/aggregation.md:9
msgid ""
"The `aggregate` transform takes a tuple to create one or more new columns "
"that \"distill down\" data from all the rows."
msgstr ""
"`aggregate` 變換接受一個元組來建立一個或多個新列，以「歸納」來自所有行的資"
"料。"

#: src/tutorial/aggregation.md:17
msgid ""
"The query above computes the sum of the `total` column of all rows of the "
"`invoices` table to produce a single value."
msgstr "上面的查詢計算 `invoices` 表所有行的 `total` 列的總和，以產生單一值。"

#: src/tutorial/aggregation.md:20
msgid ""
"`aggregate` can produce multiple summaries at once when one or more "
"aggregation expressions are contained in a tuple. `aggregate` discards all "
"columns that are not present in the tuple."
msgstr ""
"當元組中包含一個或多個聚合表達式時，`aggregate` 可以一次產生多個摘要。"
"`aggregate` 會捨棄元組中不存在的所有列。"

#: src/tutorial/aggregation.md:32
msgid ""
"In the example above, the result is a single row with two columns. The "
"`count` function displays the number of rows in the table that was passed "
"in; the `sum` function adds up the values of the `total` column of all rows."
msgstr ""
"在上面的示例中，結果是有兩列的單一行。`count` 函式顯示傳入的表中的行數；"
"`sum` 函式將所有行的 `total` 列的值相加。"

#: src/tutorial/aggregation.md:36
msgid "Grouping"
msgstr "分組"

#: src/tutorial/aggregation.md:38
msgid ""
"Suppose we want to produce summaries of invoices _for each city_ in the "
"table. We could create a query for each city, and aggregate its rows:"
msgstr ""
"假設我們想要產生表中 _每個城市_ 發票的摘要。我們可以為每個城市建立一個查詢，"
"並聚合其行："

#: src/tutorial/aggregation.md:41
msgid ""
"```prql no-eval\n"
"from albums\n"
"filter billing_city == \"Oslo\"\n"
"aggregate { sum_of_orders = sum total }\n"
"```"
msgstr ""

#: src/tutorial/aggregation.md:47
msgid ""
"But we would need to do it for each city: `London`, `Frankfurt`, etc. Of "
"course this is repetitive (and boring) and error prone (because we would "
"need to type each `billing_city` by hand). Moreover, we would need to create "
"a list of each `billing_city` before we started."
msgstr ""
"但我們需要為每個城市做這種操作：`London`、`Frankfurt` 等。當然這是重複的（且"
"令人厭倦的）且容易出錯（因為我們需要手動輸入每個 `billing_city`）。此外，我們"
"需要在開始前建立每個 `billing_city` 的列表。"

#: src/tutorial/aggregation.md:52
msgid "`group` transform"
msgstr "`group` 變換"

#: src/tutorial/aggregation.md:54
msgid ""
"The `group` transform separates the table into groups (say, those having the "
"same city) using information that's already in the table. It then applies a "
"transform to each group, and combines the results back together:"
msgstr ""
"`group` 變換使用表中已有的資訊將表分成群組（例如，具有相同城市的行）。然後它"
"對每個群組套用變換，並將結果重新組合在一起："

#: src/tutorial/aggregation.md:68
msgid ""
"Those familiar with SQL have probably noticed that we just decoupled "
"aggregation from grouping."
msgstr "熟悉 SQL 的人可能已經注意到，我們剛才將聚合與分組分離了。"

#: src/tutorial/aggregation.md:71
msgid ""
"Although these operations are connected in SQL, PRQL makes it "
"straightforward to use `group` and `aggregate` separate from each other, "
"while combining with other transform functions, such as:"
msgstr ""
"雖然這些操作在 SQL 中是相關的，但 PRQL 使得可以直接將 `group` 和 `aggregate`"
"分開使用，同時與其他變換函式結合，例如："

#: src/tutorial/aggregation.md:82
msgid "This code collects the first two rows for each city's `group`."
msgstr "這段程式碼收集每個城市 `group` 的前兩行。"
