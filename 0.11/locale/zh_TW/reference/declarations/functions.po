msgid ""
msgstr ""
"Project-Id-Version: PRQL language book\n"
"POT-Creation-Date: 2026-01-10T16:16:28Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/reference/declarations/functions.md:1
msgid "Functions"
msgstr ""

#: src/reference/declarations/functions.md:7
msgid "Functions have two types of parameters:"
msgstr ""

#: src/reference/declarations/functions.md:9
msgid "Positional parameters, which require an argument."
msgstr ""

#: src/reference/declarations/functions.md:10
msgid ""
"Named parameters, which optionally take an argument, otherwise using their "
"default value."
msgstr ""

#: src/reference/declarations/functions.md:13
msgid ""
"So this function is named `fahrenheit_to_celsius` and has one parameter "
"`temp`:"
msgstr ""

#: src/reference/declarations/functions.md:22
msgid ""
"This function is named `interp`, and has two positional parameters named "
"`high` and `x`, and one named parameter named `low` which takes a default "
"argument of `0`. It calculates the proportion of the distance that `x` is "
"between `low` and `high`."
msgstr ""

#: src/reference/declarations/functions.md:37
msgid "Other examples"
msgstr ""

#: src/reference/declarations/functions.md:39
msgid ""
"```prql\n"
"let is_adult = col -> col >= 18\n"
"let writes_code = col -> (col | in [\"PRQL\", \"Rust\"])\n"
"let square = col -> (col | math.pow 2)\n"
"let starts_with_a = col -> (col | text.lower | text.starts_with(\"a\"))\n"
"\n"
"from employees\n"
"select {\n"
"    first_name,\n"
"    last_name,\n"
"    hobby,\n"
"    adult = is_adult age,\n"
"    age_squared = square age,\n"
"}\n"
"filter ((starts_with_a last_name) && (writes_code hobby))\n"
"```"
msgstr ""

#: src/reference/declarations/functions.md:56
msgid "Piping values into functions"
msgstr ""

#: src/reference/declarations/functions.md:58
msgid ""
"Consistent with the principles of PRQL, it's possible to pipe values into "
"functions, which makes composing many functions more readable. When piping a "
"value into a function, the value is passed as an argument to the final "
"positional parameter of the function. Here's the same result as the examples "
"above with an alternative construction:"
msgstr ""

#: src/reference/declarations/functions.md:74
msgid "and"
msgstr ""

#: src/reference/declarations/functions.md:83
msgid "We can combine a chain of functions, which makes logic more readable:"
msgstr ""

#: src/reference/declarations/functions.md:93
msgid "Late binding"
msgstr ""

#: src/reference/declarations/functions.md:95
msgid ""
"Functions can bind to any variable that is in scope when the function is "
"executed. For example, here `cost_total` refers to the column that's "
"introduced in the `from`."
msgstr ""
