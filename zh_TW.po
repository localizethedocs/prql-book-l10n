msgid ""
msgstr ""
"Project-Id-Version: PRQL Language Book\n"
"POT-Creation-Date: 2026-01-10T16:16:40Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/examples/index.md:1
msgid "Examples"
msgstr "範例"

#: src/examples/index.md:3
msgid ""
"These examples are rewritten from other languages such as SQL. They try to "
"express real-world problems in PRQL, covering most of the language features. "
"We are looking for different use-cases of data transformation, be it "
"database queries, semnatic bussiness modeling or data cleaning."
msgstr ""

#: src/examples/index.md:5
msgid ""
"If you want to help, translate some of your queries to PRQL and [open a PR]"
"(https://github.com/prql/prql/pulls) to add them here!"
msgstr ""

#: src/examples/employees.md:1
msgid "Employees"
msgstr ""

#: src/examples/employees.md:3
msgid ""
"These are homework tasks on [employees database](https://github.com/"
"vrajmohan/pgsql-sample-data.git)."
msgstr ""

#: src/examples/employees.md:5
msgid "Clone and init the database (requires a local PostgreSQL instance):"
msgstr ""

#: src/examples/employees.md:7
msgid ""
"    $ psql -U postgres -c 'CREATE DATABASE employees;'\n"
"    $ git clone https://github.com/vrajmohan/pgsql-sample-data.git\n"
"    $ psql -U postgres -d employees -f pgsql-sample-data/employee/employees."
"dump\n"
"    "
msgstr ""

#: src/examples/employees.md:11
msgid "Execute a PRQL query:"
msgstr ""

#: src/examples/employees.md:15
msgid "Task 1"
msgstr ""

#: src/examples/employees.md:17
msgid ""
"rank the employee titles according to the average salary for each department."
msgstr ""

#: src/examples/employees.md:19
msgid "My solution:"
msgstr ""

#: src/examples/employees.md:21
msgid "for each employee, find their average salary,"
msgstr ""

#: src/examples/employees.md:22
msgid ""
"join employees with their departments and titles (duplicating employees for "
"each of their titles and departments)"
msgstr ""

#: src/examples/employees.md:23
msgid "group by department and title, aggregating average salary"
msgstr ""

#: src/examples/employees.md:24
msgid "join with department to get department name"
msgstr ""

#: src/examples/employees.md:40
msgid "Task 2"
msgstr ""

#: src/examples/employees.md:42
msgid ""
"Estimate distribution of salaries and gender for each department departments."
msgstr ""

#: src/examples/employees.md:63
msgid "Task 3"
msgstr ""

#: src/examples/employees.md:65
msgid "Estimate distribution of salaries and gender for each manager."
msgstr ""

#: src/examples/employees.md:67
msgid ""
"```prql\n"
"from employees\n"
"join salaries [emp_no]\n"
"group [emp_no, gender] (\n"
"  aggregate [\n"
"    emp_salary = average salary\n"
"  ]\n"
")\n"
"join de=dept_emp [emp_no]\n"
"join dm=dept_manager [\n"
"  (dm.dept_no == de.dept_no) and s\"(de.from_date, de.to_date) OVERLAPS (dm."
"from_date, dm.to_date)\"\n"
"]\n"
"group [dm.emp_no, gender] (\n"
"  aggregate [\n"
"    salary_avg = average emp_salary,\n"
"    salary_sd = stddev emp_salary\n"
"  ]\n"
")\n"
"derive mng_no = dm.emp_no\n"
"join managers=employees [emp_no]\n"
"derive mng_name = s\"managers.first_name || ' ' || managers.last_name\"\n"
"select [mng_name, managers.gender, salary_avg, salary_sd]\n"
"```"
msgstr ""

#: src/examples/employees.md:91
msgid "Task 4"
msgstr ""

#: src/examples/employees.md:93
msgid "Find distributions of titles, salaries and genders for each department."
msgstr ""

#: src/examples/employees.md:95
msgid ""
"```prql\n"
"from de=dept_emp\n"
"join s=salaries side:left [\n"
"  (s.emp_no == de.emp_no),\n"
"  s\"({s.from_date}, {s.to_date}) OVERLAPS ({de.from_date}, {de.to_date})\"\n"
"]\n"
"group [de.emp_no, de.dept_no] (\n"
"  aggregate salary = (average s.salary)\n"
")\n"
"join employees [emp_no]\n"
"join titles [emp_no]\n"
"select [dept_no, salary, employees.gender, titles.title]\n"
"```"
msgstr ""

#: src/examples/functions.md:1
msgid ""
"This mostly works, apart from window clauses, and the version & db args on "
"the first line."
msgstr ""

#: src/examples/functions.md:34
msgid "Notes"
msgstr ""

#: src/examples/functions.md:36
msgid "The SQL can be a bit better, by pulling the window clause out."
msgstr ""

#: src/examples/list-equivalence.md:1
msgid "Single item is coerced into a list"
msgstr ""

#: src/examples/list-equivalence.md:8
msgid "Same as above but with `salary` in a list:"
msgstr ""

#: src/examples/list-equivalence.md:15
msgid "Multiple items"
msgstr ""

#: src/examples/list-equivalence.md:25
msgid "Same as above but split into two lines:"
msgstr ""

#: src/examples/variables.md:1
msgid ""
"```prql\n"
"from employees\n"
"filter country == \"USA\"                       # Each line transforms the "
"previous result.\n"
"derive [                                     # This adds columns / "
"variables.\n"
"  gross_salary = salary + payroll_tax,\n"
"  gross_cost = gross_salary + benefits_cost  # Variables can use other "
"variables.\n"
"]\n"
"filter gross_cost > 0\n"
"group [title, country] (                     # For each group use a nested "
"pipeline\n"
"  aggregate [                                # Aggregate each group to a "
"single row\n"
"    average salary,\n"
"    average gross_salary,\n"
"    sum salary,\n"
"    sum gross_salary,\n"
"    average gross_cost,\n"
"    sum_gross_cost = sum gross_cost,\n"
"    ct = count,\n"
"  ]\n"
")\n"
"sort sum_gross_cost\n"
"filter ct > 200\n"
"take 20\n"
"```"
msgstr ""

#: src/examples/variables.md:25
msgid ""
"```prql\n"
"from employees\n"
"group [emp_no] (\n"
"  aggregate [\n"
"    emp_salary = average salary     # average salary resolves to "
"\"AVG(salary)\" (from stdlib)\n"
"  ]\n"
")\n"
"join titles [emp_no]\n"
"group [title] (\n"
"  aggregate [\n"
"    avg_salary = average emp_salary\n"
"  ]\n"
")\n"
"select salary_k = avg_salary / 1000 # avg_salary should resolve to "
"\"AVG(emp_salary)\"\n"
"take 10                             # induces new SELECT\n"
"derive salary = salary_k * 1000     # salary_k should not resolve to "
"\"avg_salary / 1000\"\n"
"```"
msgstr ""

#: src/integrations/index.md:1
msgid "Integrations"
msgstr "整合"

#: src/integrations/dbt.md:1
msgid "dbt-prql"
msgstr ""

#: src/integrations/dbt.md:3
msgid "Original docs at <https://github.com/prql/dbt-prql>"
msgstr ""

#: src/integrations/dbt.md:5
msgid ""
"[dbt-prql](https://github.com/prql/dbt-prql) allows writing PRQL in dbt "
"models. This combines the benefits of PRQL's power & simplicity _within_ "
"queries, with dbt's version control, lineage & testing _across_ queries."
msgstr ""

#: src/integrations/dbt.md:9
msgid ""
"Once `dbt-prql` in installed, dbt commands compile PRQL between `{% prql %}` "
"& `{% endprql %}` jinja tags to SQL as part of dbt's compilation. No "
"additional config is required."
msgstr ""

#: src/integrations/dbt.md:15
msgid "Simple example"
msgstr ""

#: src/integrations/dbt.md:24 src/integrations/dbt.md:49
msgid "...would appear to dbt as:"
msgstr ""

#: src/integrations/dbt.md:36
msgid "Less simple example"
msgstr ""

#: src/integrations/dbt.md:54 src/integrations/dbt.md:56
msgid "'salesforce'"
msgstr ""

#: src/integrations/dbt.md:54 src/integrations/dbt.md:56
msgid "'in_process'"
msgstr ""

#: src/integrations/dbt.md:57
msgid "'team'"
msgstr ""

#: src/integrations/dbt.md:57
msgid "'team_sales'"
msgstr ""

#: src/integrations/dbt.md:62
msgid ""
"...and then dbt will compile the `source` and `ref`s to a full SQL query."
msgstr ""

#: src/integrations/dbt.md:64
msgid "Replacing macros"
msgstr ""

#: src/integrations/dbt.md:66
msgid ""
"dbt's use of macros has saved many of us many lines of code, and even saved "
"some people some time. But imperatively programming text generation with "
"code like `if not loop.last` is not our highest calling. It's the "
"\"necessary\" part rather than beautiful part of dbt."
msgstr ""

#: src/integrations/dbt.md:71
msgid ""
"Here's the canonical example of macros in the [dbt documentation](https://"
"docs.getdbt.com/tutorial/learning-more/using-jinja):"
msgstr ""

#: src/integrations/dbt.md:75
msgid "\"bank_transfer\""
msgstr ""

#: src/integrations/dbt.md:75
msgid "\"credit_card\""
msgstr ""

#: src/integrations/dbt.md:75
msgid "\"gift_card\""
msgstr ""

#: src/integrations/dbt.md:80
msgid "'{{payment_method}}'"
msgstr ""

#: src/integrations/dbt.md:83
msgid "'raw_payments'"
msgstr ""

#: src/integrations/dbt.md:87
msgid "Here's that model using PRQL[^1], including the prql jinja tags."
msgstr ""

#: src/integrations/dbt.md:89
msgid ""
"```prql_no_test\n"
"{% prql %}\n"
"func filter_amount method -> s\"sum(case when payment_method = '{method}' "
"then amount end) as {method}_amount\"\n"
"\n"
"from {{ ref('raw_payments') }}\n"
"group order_id (\n"
"  aggregate [\n"
"    filter_amount bank_transfer,\n"
"    filter_amount credit_card,\n"
"    filter_amount gift_card,\n"
"  ]\n"
")\n"
"{% endprql %}\n"
"```"
msgstr ""

#: src/integrations/dbt.md:104
msgid ""
"As well the query being simpler in its final form, writing in PRQL also "
"gives us live feedback around any errors, on every keystroke. Though there's "
"much more to come, check out the current version on [PRQL Playground]"
"(https://prql-lang.org/playground/)."
msgstr ""

#: src/integrations/dbt.md:109
msgid "What it does"
msgstr ""

#: src/integrations/dbt.md:111
msgid "When dbt compiles models to SQL queries:"
msgstr ""

#: src/integrations/dbt.md:113
msgid ""
"Any text in a dbt model between `{% prql %}` and `{% endprql %}` tags is "
"compiled from PRQL to SQL before being passed to dbt."
msgstr ""

#: src/integrations/dbt.md:115
msgid ""
"The PRQL complier passes text that's containing `{{` & `}}` through to dbt "
"without modification, which allows us to embed jinja expressions in PRQL. "
"(This was added to PRQL specifically for this use-case.)"
msgstr ""

#: src/integrations/dbt.md:118
msgid ""
"dbt will then compile the resulting model into its final form of raw SQL, "
"and dispatch it to the database, as per usual."
msgstr ""

#: src/integrations/dbt.md:121
msgid ""
"There's no config needed in the dbt project; this works automatically on any "
"dbt command (e.g. `dbt run`) assuming `dbt-prql` is installed."
msgstr ""

#: src/integrations/dbt.md:124
msgid "Installation"
msgstr "安裝"

#: src/integrations/dbt.md:130
msgid "Current state"
msgstr ""

#: src/integrations/dbt.md:132
msgid ""
"Currently this is new, but fairly feature-complete. It's enthusiastically "
"supported — if there are any problems, please open an issue."
msgstr ""

#: src/integrations/jupyter.md:1
msgid "Jupyter"
msgstr "Jupyter"

#: src/integrations/jupyter.md:3
msgid ""
"Original docs at <https://pyprql.readthedocs.io/en/latest/magic_readme.html>"
msgstr ""

#: src/integrations/jupyter.md:5
msgid "Work with pandas and PRQL in an IPython terminal or Jupyter notebook."
msgstr ""

#: src/integrations/jupyter.md:7
msgid "Implementation"
msgstr ""

#: src/integrations/jupyter.md:9
msgid ""
"This is a thin wrapper around the fantastic [IPython-sql](https://github.com/"
"catherinedevlin/ipython-sql) magic. Roughly speaking, all we do is parse "
"PRQL to SQL and pass that through to `ipython-sql`. A full documentation of "
"the supported features is available at their [repository](https://github.com/"
"catherinedevlin/ipython-sql). Here, we document those places where we differ "
"from them, plus those features we think you are mostly likely to find useful."
msgstr ""

#: src/integrations/jupyter.md:18
msgid "Usage"
msgstr "用法"

#: src/integrations/jupyter.md:22
msgid ""
"If you have already installed PyPRQL into your environment, then you should "
"be could to go! We bundle in `IPython` and `pandas`, though you'll need to "
"install `Jupyter` separately. If you haven't installed PyPRQL, that's as "
"simple as:"
msgstr ""

#: src/integrations/jupyter.md:33
msgid "Set Up"
msgstr ""

#: src/integrations/jupyter.md:35
msgid ""
"Open up either an `IPython` terminal or `Jupyter` notebook. First, we need "
"to load the extension and connect to a database."
msgstr ""

#: src/integrations/jupyter.md:43
msgid "Connecting a database"
msgstr ""

#: src/integrations/jupyter.md:45
msgid "We have two options for connecting a database"
msgstr ""

#: src/integrations/jupyter.md:47
msgid "Create an in-memory DB. This is the easiest way to get started."
msgstr ""

#: src/integrations/jupyter.md:53
msgid ""
"However, in-memory databases start off empty! So, we need to add some data. "
"We have a two options:"
msgstr ""

#: src/integrations/jupyter.md:56
msgid ""
"We can easily add a [pandas](https://pandas.pydata.org) dataframe to the "
"`DuckDB` database like so:"
msgstr ""

#: src/integrations/jupyter.md:63
msgid ""
"where `df` is a pandas dataframe. This adds a table named `df` to the in-"
"memory `DuckDB` instance."
msgstr ""

#: src/integrations/jupyter.md:66
msgid "Or download a CSV and query it directly, with DuckDB:"
msgstr ""

#: src/integrations/jupyter.md:72
msgid "...and then `from products.csv` will work."
msgstr ""

#: src/integrations/jupyter.md:74
msgid "Connect to an existing database"
msgstr ""

#: src/integrations/jupyter.md:76
msgid ""
"When connecting to a database, pass the connection string as an argument to "
"the line magic `%prql`. The connection string needs to be in [SQLAlchemy "
"format](https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls), "
"so any connection supported by `SQLAlchemy` is supported by the magic. "
"Additional connection parameters can be passed as a dictionary using the `--"
"connection_arguments` flag to the the `%prql` line magic. We ship with the "
"necessary extensions to use [DuckDB](https://duckdb.org) as the backend, and "
"here connect to an in-memory database."
msgstr ""

#: src/integrations/jupyter.md:84
msgid "Querying"
msgstr ""

#: src/integrations/jupyter.md:86
msgid ""
"Now, let's do a query! By default, `PRQLMagic` always returns the results as "
"dataframe, and always prints the results. The results of the previous query "
"are accessible in the `_` variable."
msgstr ""

#: src/integrations/jupyter.md:90
msgid "These examples are based on the `products.csv` example above."
msgstr ""

#: src/integrations/jupyter.md:116
msgid "\"unitPrice\""
msgstr ""

#: src/integrations/jupyter.md:127
msgid "We can capture the results into a different variable like so:"
msgstr ""

#: src/integrations/jupyter.md:136
msgid "\"unitsInStock\""
msgstr ""

#: src/integrations/jupyter.md:140
msgid "Now, the output of the query is saved to `results`."
msgstr ""

#: src/integrations/prefect.md:1
msgid "Prefect"
msgstr "Prefect"

#: src/integrations/prefect.md:3
msgid ""
"Because Prefect is in native python, it's extremely easy to integrate with "
"PRQL."
msgstr ""

#: src/integrations/prefect.md:5
msgid "With a Postgres Task, replace:"
msgstr ""

#: src/integrations/prefect.md:15
msgid ""
"We're big fans of Prefect, and if there is anything that would make the "
"integration easier, please open an issue."
msgstr ""

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr "介紹"

#: src/introduction.md:3
msgid ""
"PRQL is a modern language for transforming data — a simple, powerful, "
"pipelined SQL replacement. Like SQL, it's readable, explicit and "
"declarative. Unlike SQL, it forms a logical pipeline of transformations, and "
"supports abstractions such as variables and functions. It can be used with "
"any database that uses SQL, since it transpiles to SQL."
msgstr ""

#: src/introduction.md:9
msgid "Let's get started with an example:"
msgstr ""

#: src/introduction.md:13
msgid ""
"```prql\n"
"from employees\n"
"filter start_date > @2021-01-01               # Clear date syntax.\n"
"derive [                                      # `derive` adds columns / "
"variables.\n"
"  gross_salary = salary + (tax ?? 0),         # Terse coalesce\n"
"  gross_cost = gross_salary + benefits_cost,  # Variables can use other "
"variables.\n"
"]\n"
"filter gross_cost > 0\n"
"group [title, country] (                      # `group` runs a pipeline over "
"each group.\n"
"  aggregate [                                 # `aggregate` reduces each "
"group to a row.\n"
"    average gross_salary,\n"
"    sum_gross_cost = sum gross_cost,          # `=` sets a column name.\n"
"  ]\n"
")\n"
"filter sum_gross_cost > 100000                # Identical syntax for SQL's "
"`WHERE` & `HAVING`.\n"
"derive [\n"
"  id = f\"{title}_{country}\",                   # F-strings like python.\n"
"  db_version = s\"version()\",                  # An S-string, which "
"transpiles directly into SQL\n"
"]\n"
"sort [sum_gross_cost, -country]               # `-country` means descending "
"order.\n"
"take 1..20                                    # Range expressions (also "
"valid here as `take 20`).\n"
"```"
msgstr ""

#: src/introduction.md:36
msgid ""
"As you can see, PRQL is a linear **pipeline of transformations** — each line "
"of the query is a transformation of the previous line's result."
msgstr ""

#: src/introduction.md:39
msgid ""
"You can see that in SQL, operations do not follow one another, which makes "
"it hard to compose larger queries."
msgstr ""

#: src/language-features/index.md:1
msgid "Language Features"
msgstr ""

#: src/language-features/coalesce.md:1
msgid "Coalesce"
msgstr "合併"

#: src/language-features/coalesce.md:3
msgid ""
"We can coalesce values with an `??` operator. Coalescing takes either the "
"first value or, if that value is null, the second value."
msgstr ""
"我們可以使用 `??` 運算子合併值。合併會取第一個值，或者如果該值為空，則取第二"
"個值。"

#: src/language-features/dates_and_times.md:1
msgid "Dates & Times"
msgstr ""

#: src/language-features/dates_and_times.md:3
msgid ""
"PRQL uses `@` followed by a string to represent dates & times. This is less "
"verbose than SQL's approach of `TIMESTAMP '2004-10-19 10:23:54'` and more "
"explicit than SQL's implicit option of just using a string `'2004-10-19 "
"10:23:54'`."
msgstr ""

#: src/language-features/dates_and_times.md:7
msgid ""
"```admonish note\n"
"Currently PRQL passes strings which can be compiled straight through to the\n"
"database, and so many compatible formats string may work, but we may refine "
"this\n"
"in the future to aid in compatibility across databases. We'll always support "
"the\n"
"canonical [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format described "
"below.\n"
"```"
msgstr ""

#: src/language-features/dates_and_times.md:14
msgid "Dates"
msgstr "日期"

#: src/language-features/dates_and_times.md:16
msgid ""
"Dates are represented by `@{yyyy-mm-dd}` — a `@` followed by the date format."
msgstr "日期由 `@{yyyy-mm-dd}` 表示 — `@` 後面跟著日期格式。"

#: src/language-features/dates_and_times.md:24
msgid "Times"
msgstr "時間"

#: src/language-features/dates_and_times.md:26
msgid ""
"Times are represented by `@{HH:mm:ss.SSS±Z}` with any parts not supplied "
"being rounded to zero, including the timezone, which is represented by `+HH:"
"mm`, `-HH:mm` or `Z`. This is consistent with the ISO8601 time format."
msgstr ""

#: src/language-features/dates_and_times.md:35
msgid "Timestamps"
msgstr "時間戳記"

#: src/language-features/dates_and_times.md:37
msgid ""
"Timestamps are represented by `@{yyyy-mm-ddTHH:mm:ss.SSS±Z}` / `@{date}"
"T{time}`, with any time parts not supplied being rounded to zero, including "
"the timezone, which is represented by `+HH:mm`, `-HH:mm` or `Z`. This is `@` "
"followed by the ISO8601 datetime format, which uses `T` to separate date & "
"time."
msgstr ""

#: src/language-features/dates_and_times.md:47
msgid "Intervals"
msgstr ""

#: src/language-features/dates_and_times.md:49
msgid ""
"Intervals are represented by `{N}{periods}`, such as `2years` or "
"`10minutes`, without a space."
msgstr ""

#: src/language-features/dates_and_times.md:67
msgid "Here's a fuller list of examples:"
msgstr ""

#: src/language-features/dates_and_times.md:69
msgid ""
"`@20221231` is forbidden — it must contain full punctuation (`-` and `:`),"
msgstr ""

#: src/language-features/dates_and_times.md:70
msgid "`@2022-12-31` is a date"
msgstr "`@2022-12-31` 是日期"

#: src/language-features/dates_and_times.md:71
msgid ""
"`@2022-12` or `@2022` are forbidden — SQL can't express a month, only a date"
msgstr ""

#: src/language-features/dates_and_times.md:72
msgid "`@16:54:32.123456` is a time"
msgstr "`@16:54:32.123456` 是時間"

#: src/language-features/dates_and_times.md:73
msgid ""
"`@16:54:32`, `@16:54`, `@16` are all allowed, expressing `@16:54:32.000000`, "
"`@16:54:00.000000`, `@16:00:00.000000` respectively"
msgstr ""
"`@16:54:32`、`@16:54`、`@16` 都是允許的，分別表示 `@16:54:32.000000`、"
"`@16:54:00.000000`、`@16:00:00.000000`"

#: src/language-features/dates_and_times.md:74
msgid "`@2022-12-31T16:54:32.123456` is a timestamp without timezone"
msgstr "`@2022-12-31T16:54:32.123456` 是沒有時區的時間戳記"

#: src/language-features/dates_and_times.md:75
msgid "`@2022-12-31T16:54:32.123456Z` is a timestamp in UTC"
msgstr "`@2022-12-31T16:54:32.123456Z` 是 UTC 時區的時間戳記"

#: src/language-features/dates_and_times.md:76
msgid "`@2022-12-31T16:54+02` is timestamp in UTC+2"
msgstr "`@2022-12-31T16:54+02` 是 UTC+2 時區的時間戳記"

#: src/language-features/dates_and_times.md:77
msgid ""
"`@2022-12-31T16:54+02:00` and `@2022-12-31T16:54+02` are datetimes in UTC+2"
msgstr ""
"`@2022-12-31T16:54+02:00` 和 `@2022-12-31T16:54+02` 是 UTC+2 時區的日期時間"

#: src/language-features/dates_and_times.md:78
msgid ""
"`@16:54+02` is forbidden — time is always local, so it cannot have a timezone"
msgstr ""

#: src/language-features/dates_and_times.md:79
msgid ""
"`@2022-12-31+02` is forbidden — date is always local, so it cannot have a "
"timezone"
msgstr ""

#: src/language-features/dates_and_times.md:81
msgid "Roadmap"
msgstr "路線圖"

#: src/language-features/dates_and_times.md:83
msgid "Datetimes"
msgstr ""

#: src/language-features/dates_and_times.md:85
msgid ""
"Datetimes are supported by some databases (e.g. MySql, BigQuery) in addition "
"to timestamps. When we have type annotations, these will be represented by a "
"timestamp annotated as a datetime:"
msgstr ""

#: src/language-features/dates_and_times.md:93
msgid "These are some examples we can then add:"
msgstr "以下是我們可以添加的一些範例："

#: src/language-features/dates_and_times.md:95
msgid "`@2022-12-31T16:54<datetime>` is datetime without timezone"
msgstr ""

#: src/language-features/dates_and_times.md:96
msgid "`@2022-12-31<datetime>` is forbidden — datetime must specify time"
msgstr ""

#: src/language-features/dates_and_times.md:97
msgid "`@16:54<datetime>` is forbidden — datetime must specify date"
msgstr ""

#: src/language-features/distinct.md:1
msgid "Distinct"
msgstr ""

#: src/language-features/distinct.md:3
msgid ""
"PRQL doesn't have a specific `distinct` keyword. Instead, use `group` and "
"`take 1`:"
msgstr ""

#: src/language-features/distinct.md:13
msgid "This also works without a linebreak:"
msgstr ""

#: src/language-features/distinct.md:21
msgid "Selecting from each group"
msgstr ""

#: src/language-features/distinct.md:23
msgid ""
"We are be able to [select a rows from each group](https://stackoverflow.com/"
"questions/3800551/select-first-row-in-each-group-by-group) by combining "
"`group` and `sort`:"
msgstr ""

#: src/language-features/distinct.md:38
msgid "When using Postgres dialect, we are planning to compile:"
msgstr ""

#: src/language-features/distinct.md:49
msgid "... to ..."
msgstr ""

#: src/language-features/f-strings.md:1
msgid "F-Strings"
msgstr ""

#: src/language-features/f-strings.md:3
msgid ""
"f-strings are a readable approach to building new strings from existing "
"strings. Currently PRQL supports this for concatenating strings:"
msgstr ""

#: src/language-features/f-strings.md:6
msgid ""
"```prql\n"
"from employees\n"
"select full_name = f\"{first_name} {last_name}\"\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"select full_name = f\"{first_name} {last_name}\"\n"
"```"

#: src/language-features/f-strings.md:11
msgid ""
"This can be much easier to read for longer strings, relative to the SQL "
"approach:"
msgstr ""

#: src/language-features/f-strings.md:13
msgid ""
"```prql\n"
"from web\n"
"select url = f\"http{tls}://www.{domain}.{tld}/{page}\"\n"
"```"
msgstr ""
"```prql\n"
"from web\n"
"select url = f\"http{tls}://www.{domain}.{tld}/{page}\"\n"
"```"

#: src/language-features/f-strings.md:20
msgid ""
"In the future, f-strings may incorporate string formatting such as "
"datetimes, numbers, and padding. If there's a feature that would be helpful, "
"please [post an issue](https://github.com/prql/prql/issues/new/)."
msgstr ""

#: src/language-features/null.md:1
msgid "Null handling"
msgstr "Null 處理"

#: src/language-features/null.md:3
msgid ""
"SQL has an unconventional way of handling `NULL` values, since it treats "
"them as unknown values. As a result, in SQL:"
msgstr ""

#: src/language-features/null.md:6
msgid ""
"`NULL` is not a value indicating a missing entry, but a placeholder for "
"anything possible,"
msgstr ""

#: src/language-features/null.md:7
msgid ""
"`NULL = NULL` evaluates to `NULL`, since one cannot know if one unknown is "
"equal to another unknown,"
msgstr ""

#: src/language-features/null.md:8
msgid "`NULL <> NULL` evaluates to `NULL`, using same logic,"
msgstr ""

#: src/language-features/null.md:9
msgid ""
"to check if a value is `NULL`, SQL introduces `IS NULL` and `IS NOT NULL` "
"operators,"
msgstr ""

#: src/language-features/null.md:10
msgid "`DISTINCT column` may return multiple `NULL` values."
msgstr ""

#: src/language-features/null.md:12
msgid ""
"For more information, check out the [Postgres documentation](https://www."
"postgresql.org/docs/current/functions-comparison.html)."
msgstr ""

#: src/language-features/null.md:14
msgid "PRQL, on the other hand, treats `null` as a value, which means that:"
msgstr ""

#: src/language-features/null.md:16
msgid "`null == null` evaluates to `true`,"
msgstr ""

#: src/language-features/null.md:17
msgid "`null != null` evaluates to `false`,"
msgstr ""

#: src/language-features/null.md:18
msgid "distinct column cannot contain multiple `null` values."
msgstr ""

#: src/language-features/null.md:26
msgid ""
"Note that PRQL doesn't change how `NULL` is compared between columns, for "
"example in joins. (PRQL compiles to SQL and so can't change the behavior of "
"the database)."
msgstr ""

#: src/language-features/null.md:30
msgid ""
"For more context or to provide feedback check out the discussion on [issue "
"#99](https://github.com/prql/prql/issues/99)."
msgstr ""

#: src/language-features/ranges.md:1
msgid "Ranges"
msgstr "範圍"

#: src/language-features/ranges.md:3
msgid "PRQL has a concise range syntax `start..end`."
msgstr ""

#: src/language-features/ranges.md:5
msgid "This can be used in filters with the `in` function:"
msgstr ""

#: src/language-features/ranges.md:12
msgid "Like in SQL, ranges are inclusive."
msgstr ""

#: src/language-features/ranges.md:14
msgid ""
"As discussed in the [take](../transforms/take.md) docs, ranges can also be "
"used in `take`:"
msgstr ""

#: src/language-features/s-strings.md:1
msgid "S-Strings"
msgstr ""

#: src/language-features/s-strings.md:3
msgid ""
"An s-string inserts SQL directly, as an escape hatch when there's something "
"that PRQL doesn't yet implement. For example, there's no `version()` "
"function in SQL that returns the Postgres version, so if we want to use "
"that, we use an s-string:"
msgstr ""

#: src/language-features/s-strings.md:7
msgid ""
"```prql\n"
"derive db_version = s\"version()\"\n"
"```"
msgstr ""

#: src/language-features/s-strings.md:11
msgid ""
"We can embed columns in an s-string using braces. For example, PRQL's "
"standard library defines the `average` function as:"
msgstr ""

#: src/language-features/s-strings.md:14
msgid ""
"```prql_no_test\n"
"func average column -> s\"AVG({column})\"\n"
"```"
msgstr ""

#: src/language-features/s-strings.md:18
msgid "So this compiles using the function:"
msgstr ""

#: src/language-features/s-strings.md:25
msgid "Here's an example of a more involved use of an s-string:"
msgstr ""

#: src/language-features/s-strings.md:27
msgid ""
"```prql\n"
"from de=dept_emp\n"
"join s=salaries side:left [\n"
"  (s.emp_no == de.emp_no),\n"
"  s\"\"\"({s.from_date}, {s.to_date})\n"
"  OVERLAPS\n"
"  ({de.from_date}, {de.to_date})\"\"\"\n"
"]\n"
"```"
msgstr ""

#: src/language-features/s-strings.md:37
msgid ""
"For those who have used python, s-strings are similar to python's f-strings, "
"but the result is SQL, rather than a string literal — a python f-string of "
"`f\"average{col}\"` where `col=\"salary\"` would produce "
"`\"average(salary)\"`, with the quotes. `s\"average{col}\"` produces "
"`average(salary)`, without quotes."
msgstr ""

#: src/language-features/s-strings.md:42
msgid ""
"s-strings in user code are intended as an escape-hatch for an unimplemented "
"feature. If we often need s-strings to express something, that's a sign we "
"should implement it in PRQL or PRQL's stdlib."
msgstr ""

#: src/language-features/strings.md:1
msgid "Strings"
msgstr "字串"

#: src/language-features/strings.md:3
msgid "Strings in PRQL can use either single or double quotes:"
msgstr ""

#: src/language-features/strings.md:5
msgid ""
"```prql\n"
"derive x = \"hello world\"\n"
"```"
msgstr ""

#: src/language-features/strings.md:13
msgid ""
"To quote a string containing quotes, either use the \"other\" type of quote, "
"or use three-or-more quotes, and close with the same number."
msgstr ""

#: src/language-features/strings.md:16
msgid ""
"```prql\n"
"derive x = '\"hello world\"'\n"
"```"
msgstr ""

#: src/language-features/strings.md:20
msgid ""
"```prql\n"
"derive x = \"\"\"I said \"hello world\"!\"\"\"\n"
"```"
msgstr ""

#: src/language-features/strings.md:24
msgid ""
"```prql\n"
"derive x = \"\"\"\"\"I said \"\"\"hello world\"\"\"!\"\"\"\"\"\n"
"```"
msgstr ""

#: src/queries/queries.md:1
msgid "Queries"
msgstr "查詢"

#: src/queries/dialect_and_version.md:1
msgid "Query header: Dialect & Version"
msgstr ""

#: src/queries/dialect_and_version.md:3
msgid "Dialect"
msgstr ""

#: src/queries/dialect_and_version.md:5
msgid ""
"PRQL allows specifying a dialect at the top of the query, which allows PRQL "
"to compile to a database-specific SQL flavor."
msgstr ""

#: src/queries/dialect_and_version.md:26
msgid "Supported dialects"
msgstr ""

#: src/queries/dialect_and_version.md:28
msgid ""
"Note that dialect support is _very_ early — most differences are not "
"implemented, and most dialects' implementations are identical to "
"`generic`'s. Contributions are very welcome."
msgstr ""

#: src/queries/dialect_and_version.md:32
msgid "`ansi`"
msgstr ""

#: src/queries/dialect_and_version.md:33
msgid "`bigquery`"
msgstr ""

#: src/queries/dialect_and_version.md:34
msgid "`clickhouse`"
msgstr ""

#: src/queries/dialect_and_version.md:35
msgid "`generic`"
msgstr ""

#: src/queries/dialect_and_version.md:36
msgid "`hive`"
msgstr ""

#: src/queries/dialect_and_version.md:37
msgid "`mssql`"
msgstr ""

#: src/queries/dialect_and_version.md:38
msgid "`mysql`"
msgstr ""

#: src/queries/dialect_and_version.md:39
msgid "`postgres`"
msgstr ""

#: src/queries/dialect_and_version.md:40
msgid "`sqlite`"
msgstr ""

#: src/queries/dialect_and_version.md:41
msgid "`snowflake`"
msgstr ""

#: src/queries/dialect_and_version.md:43
msgid "Version"
msgstr "版本"

#: src/queries/dialect_and_version.md:45
msgid ""
"PRQL allows specifying a version of the language in the PRQL header, like:"
msgstr ""

#: src/queries/dialect_and_version.md:53
msgid ""
"When the functionality is implemented, it will allow the language to evolve "
"without breaking existing queries."
msgstr ""

#: src/queries/functions.md:1
msgid "Functions"
msgstr "函式"

#: src/queries/functions.md:7
msgid ""
"Functions are a fundamental abstraction in PRQL — they allow us to run code "
"in many places that we've written once. This reduces the number of errors in "
"our code, makes our code more readable, and simplifies making changes."
msgstr ""

#: src/queries/functions.md:11
msgid "Functions have two types of parameters:"
msgstr ""

#: src/queries/functions.md:13
msgid "Positional parameters, which require an argument."
msgstr ""

#: src/queries/functions.md:14
msgid ""
"Named parameters, which optionally take an argument, otherwise using their "
"default value."
msgstr ""

#: src/queries/functions.md:17
msgid ""
"So this function is named `celsius_of_fahrenheit` and has one parameter "
"`temp`:"
msgstr ""

#: src/queries/functions.md:26
msgid ""
"This function is named `interp`, and has two positional parameters named "
"`higher` and `x`, and one named parameter named `lower` which takes a "
"default argument of `0`. It calculates the proportion of the distance that "
"`x` is between `lower` and `higher`."
msgstr ""

#: src/queries/functions.md:41
msgid "Piping"
msgstr ""

#: src/queries/functions.md:43
msgid ""
"Consistent with the principles of PRQL, it's possible to pipe values into "
"functions, which makes composing many functions more readable. When piping a "
"value into a function, the value is passed as an argument to the final "
"positional parameter of the function. Here's the same result as the examples "
"above with an alternative construction:"
msgstr ""

#: src/queries/functions.md:59
msgid "and"
msgstr "且"

#: src/queries/functions.md:68
msgid "We can combine a chain of functions, which makes logic more readable:"
msgstr ""

#: src/queries/functions.md:80
msgid "Late binding"
msgstr ""

#: src/queries/functions.md:82
msgid ""
"Currently, functions require a binding to variables in scope; they can't "
"late-bind to column names; so for example:"
msgstr ""

#: src/queries/functions.md:89
msgid "...isn't yet a valid function, and instead would needs to be:"
msgstr ""

#: src/queries/functions.md:95
msgid "(which makes functions in this case not useful)"
msgstr ""

#: src/queries/pipelines.md:1
msgid "Pipelines"
msgstr ""

#: src/queries/pipelines.md:3
msgid "The simplest pipeline"
msgstr ""

#: src/queries/pipelines.md:5
msgid "The simplest pipeline is just:"
msgstr ""

#: src/queries/pipelines.md:11
msgid "Adding transformations"
msgstr ""

#: src/queries/pipelines.md:13
msgid "We can add additional lines, each one transforms the result:"
msgstr ""

#: src/queries/pipelines.md:20
msgid "...and so on:"
msgstr ""

#: src/queries/pipelines.md:28
msgid "Compiling to SQL"
msgstr ""

#: src/queries/pipelines.md:30
msgid ""
"When compiling to SQL, the PRQL compiler will try to represent as many "
"transforms as possible with a single `SELECT` statement. When necessary it "
"will \"overflow\" using CTEs (common table expressions):"
msgstr ""

#: src/queries/pipelines.md:43
msgid "See also"
msgstr "另請參見"

#: src/queries/pipelines.md:45
msgid "[Syntax](./syntax.md)"
msgstr ""

#: src/queries/syntax.md:1 src/queries/syntax.md:9
msgid "Syntax"
msgstr "語法"

#: src/queries/syntax.md:3
msgid "Summary"
msgstr "摘要"

#: src/queries/syntax.md:5
msgid "A summary of PRQL syntax"
msgstr ""

#: src/queries/syntax.md:9
msgid "Example"
msgstr "範例"

#: src/queries/syntax.md:11
msgid "<code>\\|</code>"
msgstr ""

#: src/queries/syntax.md:11
msgid "Pipe"
msgstr ""

#: src/queries/syntax.md:11
msgid "<code>from employees \\| select first_name</code>"
msgstr ""

#: src/queries/syntax.md:12
msgid "`=`"
msgstr ""

#: src/queries/syntax.md:12
msgid "Assigns & Aliases"
msgstr ""

#: src/queries/syntax.md:12
msgid "`from e = employees` <br> `derive total = (sum salary)`"
msgstr ""

#: src/queries/syntax.md:13
msgid "`:`"
msgstr ""

#: src/queries/syntax.md:13
msgid "Named args & Parameters"
msgstr ""

#: src/queries/syntax.md:13
msgid "`interp lower:0 1600 sat_score`"
msgstr ""

#: src/queries/syntax.md:14
msgid "`[]`"
msgstr ""

#: src/queries/syntax.md:14
msgid "List"
msgstr ""

#: src/queries/syntax.md:14
msgid "`select [id, amount]`"
msgstr ""

#: src/queries/syntax.md:15
msgid "`()`"
msgstr ""

#: src/queries/syntax.md:15
msgid "Precedence"
msgstr "優先級"

#: src/queries/syntax.md:15
msgid "`derive fahrenheit = (celsius - 32) * 1.8`"
msgstr ""

#: src/queries/syntax.md:16
msgid "`#`"
msgstr ""

#: src/queries/syntax.md:16
msgid "Comment"
msgstr ""

#: src/queries/syntax.md:16
msgid "`# A comment`"
msgstr ""

#: src/queries/syntax.md:17
msgid "`@`"
msgstr ""

#: src/queries/syntax.md:17
msgid "Date & times"
msgstr ""

#: src/queries/syntax.md:17
msgid "`@2021-01-01`"
msgstr ""

#: src/queries/syntax.md:18
msgid "`==`"
msgstr ""

#: src/queries/syntax.md:18
msgid "Equality comparison"
msgstr ""

#: src/queries/syntax.md:18
msgid "`join s=salaries [s.emp_id == e.id]`"
msgstr ""

#: src/queries/syntax.md:19
msgid "`->`"
msgstr ""

#: src/queries/syntax.md:19
msgid "Function definitions"
msgstr ""

#: src/queries/syntax.md:19
msgid "`func add a b -> a + b`"
msgstr ""

#: src/queries/syntax.md:20
msgid "`+`/`-`"
msgstr ""

#: src/queries/syntax.md:20
msgid "Sort order"
msgstr ""

#: src/queries/syntax.md:20
msgid "`sort [-amount, +date]`"
msgstr ""

#: src/queries/syntax.md:21
msgid "`??`"
msgstr ""

#: src/queries/syntax.md:21
msgid "`amount ?? 0`"
msgstr ""

#: src/queries/syntax.md:22
msgid "`<type>`"
msgstr ""

#: src/queries/syntax.md:22
msgid "Annotations"
msgstr ""

#: src/queries/syntax.md:22
msgid "`@2021-01-01<datetime>`"
msgstr ""

#: src/queries/syntax.md:24
msgid "Pipes"
msgstr "管道"

#: src/queries/syntax.md:26
msgid ""
"Pipes — the connection between [transforms](../transforms.md) that make up a "
"pipeline — can be either line breaks or a pipe character (`|`)."
msgstr ""

#: src/queries/syntax.md:29
msgid ""
"In almost all situations, line-breaks pipe the result of a line's transform "
"into the transform on the following line. For example, the `filter` "
"transform operates on the result of `from employees` (which is just the "
"`employees` table), and the `select` transform operates on the result of the "
"`filter` transform."
msgstr ""

#: src/queries/syntax.md:34
msgid ""
"```prql\n"
"from employees\n"
"filter department == \"Product\"\n"
"select [first_name, last_name]\n"
"```"
msgstr ""

#: src/queries/syntax.md:40
msgid ""
"In the place of a line-break, it's also possible to use the `|` character to "
"pipe results, such that this is equivalent:"
msgstr ""

#: src/queries/syntax.md:43
msgid ""
"```prql\n"
"from employees | filter department == \"Product\" | select [first_name, "
"last_name]\n"
"```"
msgstr ""

#: src/queries/syntax.md:47
msgid "A line-break doesn't create a pipeline in a couple of cases:"
msgstr ""

#: src/queries/syntax.md:49
msgid "within a list (e.g. the `derive` examples below),"
msgstr ""

#: src/queries/syntax.md:50
msgid ""
"when the following line is a new statement, which starts with a keyword of "
"`func`, `table` or `from`."
msgstr ""

#: src/queries/syntax.md:53
msgid "Lists"
msgstr ""

#: src/queries/syntax.md:55
msgid ""
"Lists are represented with `[]`, and can span multiple lines. A final "
"trailing comma is optional."
msgstr ""

#: src/queries/syntax.md:70
msgid ""
"Most transforms can take either a list or a single item, so these are "
"equivalent:"
msgstr ""

#: src/queries/syntax.md:83
msgid "Parentheses"
msgstr "括號"

#: src/queries/syntax.md:85
msgid ""
"Parentheses — `()` — are used to give precedence to inner expressions, as is "
"the case in almost all languages / math."
msgstr ""

#: src/queries/syntax.md:88
msgid ""
"In particular, parentheses are used to nest pipelines for transforms such as "
"`group` and `window`, which take a pipeline. Here, the `aggregate` pipeline "
"is applied to each group of unique `title` and `country` values."
msgstr ""

#: src/queries/syntax.md:102
msgid "Comments"
msgstr "註釋"

#: src/queries/syntax.md:104
msgid ""
"Comments are represented by `#`. Currently only single line comments exist."
msgstr ""

#: src/queries/tables.md:1
msgid "Tables"
msgstr ""

#: src/queries/tables.md:3
msgid "We can create a table — similar to a CTE in SQL — with `table`:"
msgstr ""

#: src/queries/tables.md:16
msgid ""
"In PRQL `table`s are far less common than CTEs are in SQL, since a linear "
"series of CTEs can be represented with a single pipeline."
msgstr ""

#: src/queries/tables.md:21
msgid ""
"Currently it's not yet possible to have an [s-string](./../language-features/"
"s-strings.md) as a whole table. See [\\#376](https://github.com/prql/prql/"
"issues/376) for more details."
msgstr ""

#: src/queries/tables.md:27
msgid ""
"```prql_no_test\n"
"table a = s\"\"\"\n"
"  SELECT *\n"
"  FROM employees\n"
"\"\"\"\n"
"\n"
"from a\n"
"```"
msgstr ""

#: src/stdlib.md:1
msgid "Stdlib"
msgstr ""

#: src/stdlib.md:3
msgid ""
"The standard library is currently fairly limited, and we're very to "
"expanding it. If we find ourselves using [s-strings](./language-features/s-"
"strings.md) for something frequently, raise an issue and we'll add it to the "
"stdlib."
msgstr ""

#: src/stdlib.md:13
msgid ""
"Here's the source of the current [PRQL stdlib](https://github.com/prql/prql/"
"blob/main/prql-compiler/src/sql/stdlib.prql):"
msgstr ""

#: src/stdlib.md:16
msgid ""
"```prql_no_test\n"
"# Aggregate Functions\n"
"\n"
"func min <scalar|column> column ->  s\"MIN({column})\"\n"
"func max <scalar|column> column ->  s\"MAX({column})\"\n"
"func sum <scalar|column> column ->  s\"SUM({column})\"\n"
"func avg <scalar|column> column ->  s\"AVG({column})\"\n"
"func stddev <scalar|column> column ->  s\"STDDEV({column})\"\n"
"func average <scalar|column> column ->  s\"AVG({column})\"\n"
"func count <scalar|column> non_null:s\"*\" ->  s\"COUNT({non_null})\"\n"
"func round <scalar|column> column n_digits ->  s\"ROUND({column}, "
"{n_digits})\"\n"
"# TODO: Possibly make this into `count distinct:true` (or like `distinct:` "
"as an\n"
"# abbreviation of that?)\n"
"func count_distinct <scalar|column> column ->  s\"COUNT(DISTINCT `{column}"
"`)\"\n"
"\n"
"# TODO: Introduce a notation for getting start and end out of a ranges\n"
"# could be range.0? or range.start? But to make this happen, we need to "
"make\n"
"# changes to how variables are resolved.\n"
"func in<scalar> range value ->  s\"{value} BETWEEN {range}\"\n"
"\n"
"# Casting functions\n"
"\n"
"func as<scalar> column type ->  s\"CAST({column} AS {type})\"\n"
"\n"
"# Window functions\n"
"func lag<column> offset column ->  s\"LAG({column}, {offset})\"\n"
"func lead<column> offset column ->  s\"LEAD({column}, {offset})\"\n"
"func first<column> offset column ->  s\"FIRST_VALUE({column}, {offset})\"\n"
"func last<column> offset column ->  s\"LAST_VALUE({column}, {offset})\"\n"
"func rank<column> ->  s\"RANK()\"\n"
"func rank_dense<column> ->  s\"DENSE_RANK()\"\n"
"func row_number<column> ->  s\"ROW_NUMBER()\"\n"
"\n"
"# Logical functions\n"
"func coalesce value default -> s\"COALESCE({value}, {default})\"\n"
"```"
msgstr ""

#: src/SUMMARY.md:9
msgid "Dialect & Version"
msgstr ""

#: src/SUMMARY.md:10
msgid "Transforms"
msgstr "轉換"

#: src/SUMMARY.md:11
msgid "Aggregate"
msgstr "聚合"

#: src/SUMMARY.md:12
msgid "Derive"
msgstr "衍生"

#: src/SUMMARY.md:13
msgid "Filter"
msgstr "篩選"

#: src/SUMMARY.md:14
msgid "From"
msgstr "從"

#: src/SUMMARY.md:15
msgid "Group"
msgstr "群組"

#: src/SUMMARY.md:16
msgid "Join"
msgstr "聯接"

#: src/SUMMARY.md:17
msgid "Select"
msgstr "選擇"

#: src/SUMMARY.md:18
msgid "Sort"
msgstr "排序"

#: src/SUMMARY.md:19
msgid "Take"
msgstr "取"

#: src/SUMMARY.md:20
msgid "Window"
msgstr "視窗"

#: src/SUMMARY.md:21
msgid "Language features"
msgstr ""

#: src/SUMMARY.md:31
msgid "Regex"
msgstr ""

#: src/SUMMARY.md:38
msgid "dbt"
msgstr ""

#: src/SUMMARY.md:41
msgid "VSCode"
msgstr ""

#: src/SUMMARY.md:42
msgid "Rill"
msgstr "Rill"

#: src/SUMMARY.md:45
msgid "Variables"
msgstr ""

#: src/SUMMARY.md:46
msgid "List equivalence"
msgstr ""

#: src/SUMMARY.md:48
msgid "CTE (intermediate tables)"
msgstr ""

#: src/SUMMARY.md:49
msgid "SQL parameters"
msgstr ""

#: src/transforms.md:3
msgid ""
"PRQL queries are a pipeline of transformations (\"transforms\"), where each "
"transform takes the previous result and adjusts it in some way, before "
"passing it onto to the next transform."
msgstr ""

#: src/transforms.md:7
msgid ""
"Because PRQL focuses on modularity, we have far fewer transforms than SQL, "
"each one fulfilling a specific purpose. That's often referred to as "
"\"orthogonality\"."
msgstr ""

#: src/transforms.md:10
msgid "These are the currently available transforms:"
msgstr ""

#: src/transforms.md:12
msgid "Transform"
msgstr ""

#: src/transforms.md:12
msgid "Purpose"
msgstr ""

#: src/transforms.md:12
msgid "SQL Equivalent"
msgstr ""

#: src/transforms.md:14
msgid "[**`from`**](./transforms/from.md)"
msgstr ""

#: src/transforms.md:14
msgid "Starts from a table"
msgstr ""

#: src/transforms.md:14
msgid "`FROM`"
msgstr ""

#: src/transforms.md:15
msgid "[**`derive`**](./transforms/derive.md)"
msgstr ""

#: src/transforms.md:15
msgid "Computes new columns"
msgstr ""

#: src/transforms.md:15
msgid "`SELECT *, ... AS ...`"
msgstr ""

#: src/transforms.md:16
msgid "[**`select`**](./transforms/select.md)"
msgstr ""

#: src/transforms.md:16
msgid "Picks & computes columns"
msgstr ""

#: src/transforms.md:16
msgid "`SELECT ... AS ...`"
msgstr ""

#: src/transforms.md:17
msgid "[**`filter`**](./transforms/filter.md)"
msgstr ""

#: src/transforms.md:17
msgid "Picks rows based on their values"
msgstr ""

#: src/transforms.md:17
msgid "`WHERE`, `HAVING`,`QUALIFY`"
msgstr ""

#: src/transforms.md:18
msgid "[**`sort`**](./transforms/sort.md)"
msgstr ""

#: src/transforms.md:18
msgid "Orders rows based on the values of columns"
msgstr ""

#: src/transforms.md:18
msgid "`ORDER BY`"
msgstr ""

#: src/transforms.md:19
msgid "[**`join`**](./transforms/join.md)"
msgstr ""

#: src/transforms.md:19
msgid "Adds columns from another table, matching rows based on a condition"
msgstr ""

#: src/transforms.md:19
msgid "`JOIN`"
msgstr ""

#: src/transforms.md:20
msgid "[**`take`**](./transforms/take.md)"
msgstr ""

#: src/transforms.md:20
msgid "Picks rows based on their position"
msgstr ""

#: src/transforms.md:20
msgid "`TOP`, `LIMIT`, `OFFSET`"
msgstr ""

#: src/transforms.md:21
msgid "[**`group`**](./transforms/group.md)"
msgstr ""

#: src/transforms.md:21
msgid "Partitions rows into groups and applies a pipeline to each of them"
msgstr ""

#: src/transforms.md:21
msgid "`GROUP BY`, `PARTITION BY`"
msgstr ""

#: src/transforms.md:22
msgid "[**`aggregate`**](./transforms/aggregate.md)"
msgstr ""

#: src/transforms.md:22
msgid "Summarizes many rows into one row"
msgstr ""

#: src/transforms.md:22
msgid "`SELECT foo(...)`"
msgstr ""

#: src/transforms.md:23
msgid "[**`window`**](./transforms/window.md)"
msgstr ""

#: src/transforms.md:23
msgid "Applies a pipeline to overlapping segments of rows"
msgstr ""

#: src/transforms.md:23
msgid "`OVER`, `ROWS`, `RANGE`"
msgstr ""

#: src/transforms/aggregate.md:3
msgid "Summarizes many rows into one row."
msgstr ""

#: src/transforms/aggregate.md:5
msgid "When applied:"
msgstr ""

#: src/transforms/aggregate.md:7
msgid "without `group`, it produces one row from the whole table,"
msgstr ""

#: src/transforms/aggregate.md:8
msgid "within a `group` pipeline, it produces one row from each group."
msgstr ""

#: src/transforms/derive.md:3
msgid "Computes one or more new columns."
msgstr "計算一個或多個新欄位。"

#: src/transforms/derive.md:24
msgid ""
"`derive` generally computes a column from existing columns, but can also "
"take a literal in which case it can begin a pipeline `from`:"
msgstr ""

#: src/transforms/filter.md:3
msgid "Picks rows based on their values."
msgstr ""

#: src/transforms/from.md:3
msgid "Specifies a data source."
msgstr ""

#: src/transforms/from.md:15
msgid "To introduce an alias, use an assign expression:"
msgstr ""

#: src/transforms/group.md:3
msgid ""
"Partitions the rows into groups and applies a pipeline to each of the groups."
msgstr ""

#: src/transforms/group.md:9
msgid ""
"The partitioning of groups are determined by the `key_column`s (first "
"argument)."
msgstr ""

#: src/transforms/group.md:11
msgid "The most conventional use of `group` is with `aggregate`:"
msgstr ""

#: src/transforms/group.md:23
msgid ""
"In concept, a transform in context of a `group` does the same transformation "
"to the group as it would to the table — for example finding the employee who "
"joined first across the whole table:"
msgstr ""

#: src/transforms/group.md:33
msgid ""
"To find the employee who joined first in each department, it's exactly the "
"same pipeline, but within a `group` expression:"
msgstr ""

#: src/transforms/join.md:3
msgid "Adds columns from another table, matching rows based on a condition."
msgstr ""

#: src/transforms/join.md:9
msgid "Parameters"
msgstr "參數"

#: src/transforms/join.md:11
msgid "`side` decides which rows to include. Defaults to `inner`"
msgstr ""

#: src/transforms/join.md:12
msgid "Table reference"
msgstr ""

#: src/transforms/join.md:13
msgid "List of conditions"
msgstr ""

#: src/transforms/join.md:14
msgid ""
"If all terms are column identifiers, this will compile to `USING(...)`. In "
"this case, both tables must contain specified columns. The result will only "
"contain one column for each specified column."
msgstr ""

#: src/transforms/select.md:3
msgid "Picks and compute columns."
msgstr ""

#: src/transforms/select.md:21
msgid ""
"```prql\n"
"from employees\n"
"select name = f\"{first_name} {last_name}\"\n"
"```"
msgstr ""

#: src/transforms/select.md:26
msgid ""
"```prql\n"
"from employees\n"
"select [\n"
"  name = f\"{first_name} {last_name}\",\n"
"  age_eoy = dob - @2022-12-31,\n"
"]\n"
"```"
msgstr ""

#: src/transforms/sort.md:3
msgid "Orders rows based on the values of one or more columns."
msgstr ""

#: src/transforms/sort.md:11
msgid "One column or a list of columns to sort by"
msgstr ""

#: src/transforms/sort.md:12
msgid "Each column can be prefixed with:"
msgstr ""

#: src/transforms/sort.md:13
msgid "`+`, for ascending order, the default"
msgstr ""

#: src/transforms/sort.md:14
msgid "`-`, for descending order"
msgstr ""

#: src/transforms/sort.md:15
msgid ""
"When using prefixes, make sure to wrap columns in a list. Otherwise, `sort -"
"column` is interpreted as subtraction between `sort` and `column`."
msgstr ""

#: src/transforms/sort.md:36
msgid "Currently `sort` does not accept expressions:"
msgstr ""

#: src/transforms/sort.md:38
msgid ""
"```prql_no_test\n"
"from employees\n"
"sort [s\"substr({first_name}, 2, 5)\"]  # Currently will fail\n"
"```"
msgstr ""

#: src/transforms/take.md:3
msgid "Picks rows based on their position."
msgstr ""

#: src/transforms/take.md:9
msgid ""
"See [Ranges](../language-features/ranges.md) for more details on how ranges "
"work."
msgstr ""

#: src/transforms/window.md:3
msgid ""
"Applies a pipeline to segments of rows, producing one output value for every "
"input value."
msgstr ""

#: src/transforms/window.md:10
msgid ""
"For each row, the segment over which the pipeline is applied is determined "
"by one of:"
msgstr ""

#: src/transforms/window.md:13
msgid ""
"`rows`, which takes a range of rows relative to the current row position."
msgstr ""

#: src/transforms/window.md:14
msgid "`0` references the current row."
msgstr ""

#: src/transforms/window.md:15
msgid "`range`, which takes a range of values relative to current row value."
msgstr ""

#: src/transforms/window.md:17
msgid ""
"The bounds of the range are inclusive. If a bound is omitted, the segment "
"will extend until the edge of the table or group."
msgstr ""

#: src/transforms/window.md:22
msgid "For ease of use, there are two flags that override `rows` or `range`:"
msgstr ""

#: src/transforms/window.md:24
msgid ""
"`expanding:true` is an alias for `rows:..0`. A sum using this window is also "
"known as \"cumulative sum\"."
msgstr ""

#: src/transforms/window.md:26
msgid ""
"`rolling:n` is an alias for `row:(-n+1)..0`, where `n` is an integer. This "
"will include `n` last values, including current row. An average using this "
"window is also knows as a Simple Moving Average."
msgstr ""

#: src/transforms/window.md:30
msgid "Some examples:"
msgstr ""

#: src/transforms/window.md:32
msgid "Expression"
msgstr "表達式"

#: src/transforms/window.md:32
msgid "Meaning"
msgstr "意義"

#: src/transforms/window.md:34
msgid "`rows:0..2`"
msgstr ""

#: src/transforms/window.md:34
msgid "current row plus two following"
msgstr ""

#: src/transforms/window.md:35
msgid "`rows:-2..0`"
msgstr ""

#: src/transforms/window.md:35
msgid "two preceding rows plus current row"
msgstr ""

#: src/transforms/window.md:36
msgid "`rolling:3`"
msgstr ""

#: src/transforms/window.md:36 src/transforms/window.md:39
msgid "(same as previous)"
msgstr ""

#: src/transforms/window.md:37
msgid "`rows:-2..4`"
msgstr ""

#: src/transforms/window.md:37
msgid "two preceding rows plus current row plus four following rows"
msgstr ""

#: src/transforms/window.md:38
msgid "`rows:..0`"
msgstr ""

#: src/transforms/window.md:38
msgid "all rows from the start of the table up to & including current row"
msgstr ""

#: src/transforms/window.md:39
msgid "`expanding:true`"
msgstr ""

#: src/transforms/window.md:40
msgid "`rows:0..`"
msgstr ""

#: src/transforms/window.md:40
msgid "current row and all following rows until the end of the table"
msgstr ""

#: src/transforms/window.md:41
msgid "`rows:..`"
msgstr ""

#: src/transforms/window.md:41
msgid "all rows, which same as not having window at all"
msgstr ""
