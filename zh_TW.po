msgid ""
msgstr ""
"Project-Id-Version: PRQL language book\n"
"POT-Creation-Date: 2026-01-10T16:13:49Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/project/bindings/index.md:1
msgid "Bindings"
msgstr "綁定"

#: src/project/bindings/index.md:3
msgid "PRQL has bindings for many languages. These include:"
msgstr ""

#: src/project/bindings/index.md:5
msgid "We have three tiers of bindings:"
msgstr ""

#: src/project/bindings/index.md:7 src/project/bindings/index.md:11
msgid "Supported"
msgstr ""

#: src/project/bindings/index.md:8 src/project/bindings/index.md:33
msgid "Unsupported"
msgstr ""

#: src/project/bindings/index.md:9 src/project/bindings/index.md:43
msgid "Nascent"
msgstr ""

#: src/project/bindings/index.md:13
msgid "Supported bindings require:"
msgstr ""

#: src/project/bindings/index.md:15
msgid "A maintainer."
msgstr ""

#: src/project/bindings/index.md:16
msgid ""
"Implementations of the [core compile functions](https://docs.rs/prqlc/latest/"
"prqlc/#functions)."
msgstr ""

#: src/project/bindings/index.md:18
msgid "Test coverage for these functions."
msgstr ""

#: src/project/bindings/index.md:19
msgid "A published package to the language's standard package repository."
msgstr ""

#: src/project/bindings/index.md:20
msgid "A script in `Taskfile.yaml` to bootstrap a development environment."
msgstr ""

#: src/project/bindings/index.md:21
msgid ""
"Any dev tools, such as a linter & formatter, in pre-commit or MegaLinter."
msgstr ""

#: src/project/bindings/index.md:23
msgid "The currently supported bindings are:"
msgstr ""

#: src/project/bindings/index.md:25
msgid "[JavaScript](./javascript.md)"
msgstr ""

#: src/project/bindings/index.md:26
msgid "[Python](./python.md)"
msgstr "[Python](./python.md)"

#: src/project/bindings/index.md:27
msgid "[R](./r.md)"
msgstr "[R](./r.md)"

#: src/project/bindings/index.md:28
msgid "[Rust](./rust.md)"
msgstr "[Rust](./rust.md)"

#: src/project/bindings/index.md:30
msgid ""
"Most of these are in the main PRQL repo, and we gate any changes to the "
"compiler's API on compatible changes to the bindings."
msgstr ""

#: src/project/bindings/index.md:35
msgid ""
"Unsupported bindings work, but don't fulfil all of the above criteria. We "
"don't gate changes to the compiler's API. If they stop working, we'll demote "
"them to nascent."
msgstr ""

#: src/project/bindings/index.md:39
msgid "[Java](./java.md)"
msgstr "[Java](./java.md)"

#: src/project/bindings/index.md:40
msgid "[Elixir](./elixir.md)"
msgstr "[Elixir](./elixir.md)"

#: src/project/bindings/index.md:41
msgid "`prqlc-c`, the C bindings"
msgstr ""

#: src/project/bindings/index.md:45
msgid "Nascent bindings are in development, and may not yet fully work."
msgstr ""

#: src/project/bindings/index.md:47
msgid "[.NET](./dotnet.md)"
msgstr "[.NET](./dotnet.md)"

#: src/project/bindings/index.md:48
msgid "[PHP](./php.md)"
msgstr "[PHP](./php.md)"

#: src/project/bindings/index.md:50
msgid "Naming"
msgstr ""

#: src/project/bindings/index.md:52
msgid "Over time, we're trying to move to a consistent naming scheme:"
msgstr ""

#: src/project/bindings/index.md:54
msgid "Crates are named `prqlc-$lang`."
msgstr ""

#: src/project/bindings/index.md:55
msgid ""
"Where possible, packages are published to each language's package repository "
"as `prqlc`."
msgstr ""

#: src/project/bindings/elixir.md:1
msgid "PRQL"
msgstr ""

#: src/project/bindings/elixir.md:3
msgid "[PRQL](https://prql-lang.org/) bindings for Elixir."
msgstr ""

#: src/project/bindings/elixir.md:5
msgid "Installation"
msgstr "安裝"

#: src/project/bindings/elixir.md:7
msgid ""
"```elixir\n"
"def deps do\n"
"  [\n"
"    {:prql, \"~> 0.1.0\"}\n"
"  ]\n"
"end\n"
"```"
msgstr ""

#: src/project/bindings/elixir.md:15
msgid "Basic Usage"
msgstr ""

#: src/project/bindings/elixir.md:17
msgid ""
"```elixir\n"
"  iex> PRQL.compile(\"from customers\")\n"
"      {:ok, \"SELECT\\n  *\\nFROM\\n  customers\\n\\n-- Generated by PRQL "
"compiler version 0.3.1 (https://prql-lang.org)\\n\"}\n"
"\n"
"\n"
"  iex> PRQL.compile(\"from customers\\ntake 10\", dialect: :mssql)\n"
"  {:ok, \"SELECT\\n  *\\nFROM\\n  customers\\nORDER BY\\n  (\\n    "
"SELECT\\n      NULL\\n  ) OFFSET 0 ROWS\\nFETCH FIRST\\n  10 ROWS "
"ONLY\\n\\n-- Generated by PRQL compiler version 0.3.1 (https://prql-lang."
"org)\\n\"}\n"
"```"
msgstr ""

#: src/project/bindings/elixir.md:26
msgid "Development"
msgstr "開發"

#: src/project/bindings/elixir.md:28
msgid "We are in the early stages of developing Elixir bindings."
msgstr ""

#: src/project/bindings/elixir.md:30
msgid "We're using `Rustler` to provide Rust bindings for `prqlc`."
msgstr ""

#: src/project/bindings/elixir.md:32
msgid ""
"Currently using the bindings in an Elixir project requires compiling the "
"Rust crate from this repo:"
msgstr ""

#: src/project/bindings/elixir.md:35
msgid "Install dependencies with `mix deps.get`"
msgstr ""

#: src/project/bindings/elixir.md:36
msgid "Compile project `mix compile`"
msgstr ""

#: src/project/bindings/elixir.md:37
msgid "Run tests `mix test`"
msgstr ""

#: src/project/bindings/elixir.md:39
msgid ""
"Future work includes publishing pre-compiled artifacts, so Elixir projects "
"can run PRQL without needing a Rust toolchain."
msgstr ""

#: src/project/bindings/java.md:1
msgid "prql-java"
msgstr ""

#: src/project/bindings/java.md:3
msgid ""
"`prql-java` offers Java bindings to the `prqlc` Rust library. It exposes a "
"Java native method `public static native String toSql(String query)`."
msgstr ""

#: src/project/bindings/java.md:6
msgid ""
"It's still at an early stage, and currently requires compiling locally, and "
"isn't published to Maven. Contributions are welcome."
msgstr ""

#: src/reference/syntax/index.md:11
msgid "Usage"
msgstr "用法"

#: src/project/bindings/java.md:26
msgid "\"from table\""
msgstr ""

#: src/project/bindings/javascript.md:1
msgid "prqlc-js"
msgstr ""

#: src/project/bindings/javascript.md:3
msgid "JavaScript bindings for [`prqlc`](https://github.com/PRQL/prql/)."
msgstr ""

#: src/project/bindings/javascript.md:13
msgid "Currently these functions are exposed"
msgstr ""

#: src/project/bindings/javascript.md:27
msgid "From Node.js"
msgstr ""

#: src/project/bindings/javascript.md:29
msgid "Direct usage"
msgstr ""

#: src/project/bindings/javascript.md:32 src/project/bindings/javascript.md:53
#: src/project/bindings/javascript.md:63
msgid "\"prqlc\""
msgstr ""

#: src/project/bindings/javascript.md:34
msgid "`from employees | select first_name`"
msgstr ""

#: src/project/bindings/javascript.md:38
msgid "Options"
msgstr "選項"

#: src/project/bindings/javascript.md:42
msgid "\"sql.mssql\""
msgstr ""

#: src/project/bindings/javascript.md:46
msgid "`from employees | take 10`"
msgstr ""

#: src/project/bindings/javascript.md:50
msgid "Template literal"
msgstr ""

#: src/project/bindings/javascript.md:54 src/project/bindings/javascript.md:64
msgid "\"\""
msgstr ""

#: src/project/bindings/javascript.md:56
msgid "prql`from employees | select first_name`"
msgstr ""

#: src/project/bindings/javascript.md:60
msgid "Template literal with newlines"
msgstr ""

#: src/project/bindings/javascript.md:66
msgid ""
"prql`\n"
"    from employees\n"
"    select first_name\n"
"`"
msgstr ""

#: src/project/bindings/javascript.md:73
msgid "From a browser"
msgstr ""

#: src/project/bindings/javascript.md:78
msgid "\"module\""
msgstr ""

#: src/project/bindings/javascript.md:79
msgid "\"./dist/web/prql_js.js\""
msgstr ""

#: src/project/bindings/javascript.md:82
msgid "\"from employees | select first_name\""
msgstr ""

#: src/project/bindings/javascript.md:91
msgid "From a framework or a bundler"
msgstr ""

#: src/project/bindings/javascript.md:93
msgid ""
"```typescript\n"
"import compile from \"prqlc/dist/bundler\";\n"
"\n"
"const sql = compile(`from employees | select first_name`);\n"
"console.log(sql);\n"
"```"
msgstr ""

#: src/project/bindings/javascript.md:100
msgid "Errors"
msgstr ""

#: src/project/bindings/javascript.md:102
msgid "Errors are returned as following object, serialized as a JSON array:"
msgstr ""

#: src/project/bindings/javascript.md:104
msgid ""
"```typescript\n"
"interface ErrorMessage {\n"
"  /// Message kind. Currently only Error is implemented.\n"
"  kind: \"Error\" | \"Warning\" | \"Lint\";\n"
"  /// Machine-readable identifier of the error\n"
"  code: string | null;\n"
"  /// Plain text of the error\n"
"  reason: string;\n"
"  /// A list of suggestions of how to fix the error\n"
"  hint: string | null;\n"
"  /// Character offset of error origin within a source file\n"
"  span: [number, number] | null;\n"
"\n"
"  /// Annotated code, containing cause and hints.\n"
"  display: string | null;\n"
"  /// Line and column number of error origin within a source file\n"
"  location: SourceLocation | null;\n"
"}\n"
"\n"
"/// Location within the source file.\n"
"/// Tuples contain:\n"
"/// - line number (0-based),\n"
"/// - column number within that line (0-based),\n"
"interface SourceLocation {\n"
"  start: [number, number];\n"
"\n"
"  end: [number, number];\n"
"}\n"
"```"
msgstr ""

#: src/project/bindings/javascript.md:134
msgid "These errors can be caught as such:"
msgstr ""

#: src/project/bindings/javascript.md:138
msgid "`from employees | foo first_name`"
msgstr ""

#: src/project/bindings/javascript.md:149
msgid "Build:"
msgstr ""

#: src/project/bindings/javascript.md:155
msgid "This builds Node, bundler and web packages in the `dist` path."
msgstr ""

#: src/project/bindings/javascript.md:157
msgid "Test:"
msgstr "測試："

#: src/project/bindings/javascript.md:163
msgid ""
"By default the `wasm` binaries are optimized on each run, even if the "
"underlying code hasn't changed, which can be slow. For a lower-latency dev "
"loop, pass `--profile=dev` to `npm install` for a faster, less optimized "
"build."
msgstr ""

#: src/project/bindings/javascript.md:171
msgid "Notes"
msgstr ""

#: src/project/bindings/javascript.md:173
msgid ""
"This uses [`wasm-pack`](https://rustwasm.github.io/docs/wasm-pack/) to "
"generate bindings[^1]."
msgstr ""

#: src/project/bindings/javascript.md:175
msgid ""
"We've added an `npm` layer on top of the usual approach of just using `wasm-"
"pack`, so we can distribute a single package with targets of `node`, "
"`bundler` and `no-modules` — somewhat inverting the approach recommended by "
"`wasm-pack`. The build instruction goes in a `build` script, rather than a "
"`pack` script."
msgstr ""

#: src/project/bindings/javascript.md:182
msgid ""
"    Though we would be very open to other approaches, given wasm-pack does "
"not\n"
"    seem maintained, and we're eliding many of its features to build for "
"three\n"
"    targets. See <https://github.com/PRQL/prql/issues/1836> for more "
"details.\n"
"    "
msgstr ""

#: src/project/bindings/dotnet.md:1
msgid "prql-dotnet"
msgstr "prql-dotnet"

#: src/project/bindings/dotnet.md:3
msgid ""
"`prql-net` offers PRQL bindings for .NET bindings as a `netstandard2.0` "
"library."
msgstr ""

#: src/project/bindings/dotnet.md:5
msgid ""
"It provides the `PrqlCompiler` class which contains the `ToJson` and `ToSql` "
"static methods."
msgstr ""

#: src/project/bindings/dotnet.md:8
msgid ""
"It's still at an early stage, and isn't published to NuGet. Contributions "
"are welcome."
msgstr ""

#: src/project/bindings/dotnet.md:13
msgid ""
"Make sure that `libprqlc_c.so` (Linux), `libprqlc_c.dylib` (macOS) or "
"`libprqlc_c.dll` (Windows) is in the project's `bin` directory together with "
"`PrqlCompiler.dll` and the rest of the project's compiled files. I.e. "
"`{your_project}/bin/Debug/net7.0/`."
msgstr ""

#: src/project/bindings/dotnet.md:18
msgid "The `libprqlc_c` library gets dynamically imported at runtime."
msgstr ""

#: src/project/bindings/dotnet.md:22
msgid ""
"```csharp\n"
"using Prql.Compiler;\n"
"\n"
"var options = new PrqlCompilerOptions\n"
"{\n"
"    Format = false,\n"
"    SignatureComment = false,\n"
"};\n"
"var sql = PrqlCompiler.Compile(\"from employees\", options);\n"
"Console.WriteLine(sql);\n"
"```"
msgstr ""

#: src/project/bindings/dotnet.md:34
msgid "TODO"
msgstr ""

#: src/project/bindings/dotnet.md:36
msgid ""
"This is currently at 0.1.0 because we're waiting to update prqlc-c for the "
"latest API. When we've done that, we can match the version here with the "
"broader PRQL version."
msgstr ""

#: src/project/bindings/php.md:1
msgid "prql-php"
msgstr ""

#: src/project/bindings/php.md:3
msgid "`prql-php` offers PHP bindings to `prqlc` crate through FFI."
msgstr ""

#: src/project/bindings/php.md:5
msgid ""
"It provides the `Compiler` class which contains `compile`, `prqlToPL`, "
"`plToRQ` and `rqToSQL` functions."
msgstr ""

#: src/project/bindings/php.md:8
msgid ""
"It's still at an early stage, and isn't published to Composer. Contributions "
"are welcome."
msgstr ""

#: src/project/bindings/php.md:13
msgid ""
"The [PHP FFI extension](https://www.php.net/manual/en/book.ffi.php) needs to "
"be enabled. Set `ffi.enable` in your php.ini configuration file to "
"`\"true\"`."
msgstr ""

#: src/project/bindings/php.md:24
msgid "\"from employees\""
msgstr ""

#: src/project/bindings/php.md:31
msgid "Environment"
msgstr ""

#: src/project/bindings/php.md:33
msgid ""
"A way to establish a dev environment with PHP, the ext-ffi extension and "
"Composer is to use a [nix flake](https://github.com/loophp/nix-shell). After "
"installing nix, enable experimental flakes feature:"
msgstr ""

#: src/project/bindings/php.md:39
msgid "\"experimental-features = nix-command flakes\""
msgstr ""

#: src/project/bindings/php.md:42
msgid "Now you can spawn a shell from `prql-php/`:"
msgstr ""

#: src/project/bindings/php.md:48
msgid ""
"This will pull-in ext-ffi extension, because it's declared in `composer."
"json`."
msgstr ""

#: src/project/bindings/php.md:50
msgid "Building"
msgstr ""

#: src/project/bindings/php.md:52
msgid "There is a `task build-php` script that:"
msgstr ""

#: src/project/bindings/php.md:54
msgid "runs cargo to build `libprqlc_c`,"
msgstr ""

#: src/project/bindings/php.md:55
msgid "copies `libprqlc_c.*` into `lib`,"
msgstr ""

#: src/project/bindings/php.md:56
msgid "copies `prqlc.h` into `lib`."
msgstr ""

#: src/project/bindings/php.md:58
msgid "Tests"
msgstr ""

#: src/project/bindings/php.md:65
msgid "Code style"
msgstr ""

#: src/project/bindings/python.md:1
msgid "PRQL - Python Bindings"
msgstr ""

#: src/project/bindings/python.md:3
msgid ""
"Python bindings for [PRQL](https://github.com/PRQL/prql), the Pipelined "
"Relational Query Language."
msgstr ""

#: src/project/bindings/python.md:6
msgid ""
"PRQL is a modern language for transforming data — a simple, powerful, "
"pipelined SQL replacement. Like SQL, it's readable, explicit and "
"declarative. Unlike SQL, it forms a logical pipeline of transformations, and "
"supports abstractions such as variables and functions. It can be used with "
"any database that uses SQL, since it compiles to SQL."
msgstr ""
"PRQL 是一種用於變換資料的現代語言 — 一個簡單、強大且採用管道化設計的 SQL 替代"
"方案。與 SQL 一樣，它具備易讀性、明確性且屬於宣告型語言。與 SQL 不同的是，它"
"構建了一個邏輯上的變換管道，並支援變數與函式等抽象概念。由於它可以編譯為 "
"SQL，因此適用於任何使用 SQL 的資料庫。"

#: src/project/bindings/python.md:12
msgid "PRQL can be as simple as:"
msgstr ""

#: src/project/bindings/python.md:14
msgid ""
"```\n"
"from tracks\n"
"filter artist == \"Bob Marley\"     # Each line transforms the previous "
"result\n"
"aggregate {                       # `aggregate` reduces each column to a "
"value\n"
"  plays    = sum plays,\n"
"  longest  = max length,\n"
"  shortest = min length,          # Trailing commas are allowed\n"
"}\n"
"```"
msgstr ""

#: src/project/bindings/python.md:26
msgid "`pip install prqlc`"
msgstr ""

#: src/project/bindings/python.md:30
msgid "Basic usage:"
msgstr ""

#: src/project/bindings/python.md:35
msgid ""
"\"\"\"\n"
"    from employees\n"
"    join salaries (==emp_id)\n"
"    group {employees.dept_id, employees.gender} (\n"
"      aggregate {\n"
"        avg_salary = average salaries.salary\n"
"      }\n"
"    )\n"
"\"\"\""
msgstr ""

#: src/project/bindings/python.md:46
msgid "\"sql.postgres\""
msgstr ""

#: src/project/bindings/python.md:53
msgid "The following functions and classes are exposed:"
msgstr ""

#: src/project/bindings/python.md:57
msgid "\"\"\"Compiles a PRQL query into SQL.\"\"\""
msgstr ""

#: src/project/bindings/python.md:61
msgid "\"\"\"Converts a PRQL query to PL AST in JSON format.\"\"\""
msgstr ""

#: src/project/bindings/python.md:65
msgid ""
"\"\"\"Converts PL AST as a JSON string into a formatted PRQL string.\"\"\""
msgstr ""

#: src/project/bindings/python.md:69
msgid "\"\"\"Resolves and lowers PL AST (JSON) into RQ AST (JSON).\"\"\""
msgstr ""

#: src/project/bindings/python.md:73
msgid "\"\"\"Converts RQ AST (JSON) into a SQL query.\"\"\""
msgstr ""

#: src/project/bindings/python.md:81
msgid "\"sql.any\""
msgstr ""

#: src/project/bindings/python.md:84
msgid ""
"\"\"\"Compilation options for SQL backend of the compiler.\n"
"\n"
"    Args:\n"
"        format (bool): Pass generated SQL string through a formatter that "
"splits\n"
"            it into multiple lines and prettifies indentation and spacing.\n"
"            Defaults to True.\n"
"        target (str): Target dialect to compile to. Defaults to \"sql.any\", "
"which\n"
"            uses the 'target' argument from the query header to determine "
"the\n"
"            SQL dialect. Other targets are available by calling the "
"`get_targets`\n"
"            function.\n"
"        signature_comment (bool): Emits the compiler signature as a comment "
"after\n"
"            the generated SQL. Defaults to True.\n"
"\n"
"    \"\"\""
msgstr ""

#: src/project/bindings/python.md:101
msgid "\"\"\"List available target dialects for compilation.\"\"\""
msgstr ""

#: src/project/bindings/python.md:105
msgid "Debugging functions"
msgstr ""

#: src/project/bindings/python.md:107
msgid ""
"The following functions are available within the `prqlc.debug` module. They "
"are for experimental purposes and may be unstable."
msgstr ""

#: src/project/bindings/python.md:112
msgid ""
"\"\"\"Computes a column-level lineage graph from a PRQL query.\n"
"\n"
"    Returns JSON-formatted string. See the docs for the `prqlc debug "
"lineage`\n"
"    CLI command for more details.\n"
"    \"\"\""
msgstr ""

#: src/project/bindings/python.md:120
msgid "\"\"\"Computes a column-level lineage graph from PL AST (JSON).\"\"\""
msgstr ""

#: src/project/bindings/python.md:126
msgid "For development, we use `uv` for fast dependency management:"
msgstr ""

#: src/project/bindings/python.md:129
msgid "# Install development dependencies and run tests\n"
msgstr ""

#: src/project/bindings/python.md:131
msgid "# Run type checking\n"
msgstr ""

#: src/project/bindings/python.md:134
msgid "# Or use the task runner\n"
msgstr ""

#: src/project/bindings/python.md:141
msgid ""
"These bindings are in a crate named `prqlc-python` and published to a Python "
"package on PyPI named `prqlc`, available at <https://pypi.org/project/"
"prqlc>. This crate is not published to crates.io."
msgstr ""

#: src/project/bindings/python.md:145
msgid ""
"The package is consumed by [pyprql](https://github.com/prql/pyprql) & [dbt-"
"prql](https://github.com/prql/dbt-prql)."
msgstr ""

#: src/project/bindings/python.md:148
msgid "Relies on [pyo3](https://github.com/PyO3/pyo3) for all the magic."
msgstr ""

#: src/project/bindings/r.md:1
msgid "R (prqlr)"
msgstr ""

#: src/project/bindings/r.md:3
msgid "R bindings for `prqlc`."
msgstr ""

#: src/project/bindings/r.md:5
msgid ""
"`prqlr` also includes `knitr` (R Markdown and Quarto) integration, which "
"allows us to easily create documents with the PRQL conversion results "
"embedded in."
msgstr ""

#: src/project/bindings/r.md:8
msgid "Check out <https://prql.github.io/prqlc-r/> for more context."
msgstr ""

#: src/project/bindings/r.md:11
msgid ""
"\\[!NOTE\\] `prqlr` is generously maintained by [@eitsupi](https://github."
"com/eitsupi) in the [PRQL/prqlc-r](https://github.com/PRQL/prqlc-r) repo."
msgstr ""

#: src/project/bindings/r.md:19
msgid "\"prqlr\""
msgstr ""

#: src/project/bindings/rust.md:1
msgid ""
"Please check the documentation of the [prqlc crate](https://docs.rs/prqlc/"
"latest/prqlc/)."
msgstr ""

#: src/project/changelog.md:1
msgid "PRQL Changelog"
msgstr "PRQL 變更日誌"

#: src/project/changelog.md:3
msgid "\\[unreleased\\]"
msgstr ""

#: src/project/changelog.md:5 src/project/changelog.md:263
#: src/project/changelog.md:479 src/project/changelog.md:565
#: src/project/changelog.md:654 src/project/changelog.md:800
msgid "**Language**:"
msgstr "**語言**："

#: src/project/changelog.md:7 src/project/changelog.md:28
#: src/project/changelog.md:53 src/project/changelog.md:111
#: src/project/changelog.md:136 src/project/changelog.md:231
#: src/project/changelog.md:281 src/project/changelog.md:348
#: src/project/changelog.md:415 src/project/changelog.md:456
#: src/project/changelog.md:488 src/project/changelog.md:528
#: src/project/changelog.md:571 src/project/changelog.md:717
#: src/project/changelog.md:906 src/project/changelog.md:977
#: src/project/changelog.md:1046 src/project/changelog.md:1114
#: src/project/changelog.md:1261 src/project/changelog.md:1296
#: src/project/changelog.md:1345 src/project/changelog.md:1377
#: src/project/changelog.md:1538 src/project/changelog.md:1601
#: src/project/changelog.md:1644
msgid "**Features**:"
msgstr "**功能**："

#: src/project/changelog.md:9 src/project/changelog.md:32
#: src/project/changelog.md:57 src/project/changelog.md:96
#: src/project/changelog.md:115 src/project/changelog.md:142
#: src/project/changelog.md:208 src/project/changelog.md:242
#: src/project/changelog.md:293 src/project/changelog.md:360
#: src/project/changelog.md:421 src/project/changelog.md:464
#: src/project/changelog.md:503 src/project/changelog.md:533
#: src/project/changelog.md:683 src/project/changelog.md:724
#: src/project/changelog.md:925 src/project/changelog.md:1077
#: src/project/changelog.md:1174 src/project/changelog.md:1229
#: src/project/changelog.md:1269 src/project/changelog.md:1482
#: src/project/changelog.md:1549 src/project/changelog.md:1608
#: src/project/changelog.md:1649 src/project/changelog.md:1669
#: src/project/changelog.md:1680 src/project/changelog.md:1726
#: src/project/changelog.md:1749
msgid "**Fixes**:"
msgstr ""

#: src/project/changelog.md:11 src/project/changelog.md:74
#: src/project/changelog.md:158 src/project/changelog.md:728
#: src/project/changelog.md:1085 src/project/changelog.md:1180
#: src/project/changelog.md:1236 src/project/changelog.md:1276
#: src/project/changelog.md:1488 src/project/changelog.md:1614
#: src/project/changelog.md:1655 src/project/changelog.md:1693
#: src/project/changelog.md:1731 src/project/changelog.md:1757
msgid "**Documentation**:"
msgstr "**文件**："

#: src/project/changelog.md:13 src/project/changelog.md:103
#: src/project/changelog.md:365 src/project/changelog.md:510
#: src/project/changelog.md:596 src/project/changelog.md:693
#: src/project/changelog.md:732 src/project/changelog.md:1051
#: src/project/changelog.md:1500 src/project/changelog.md:1698
msgid "**Web**:"
msgstr ""

#: src/project/changelog.md:15 src/project/changelog.md:78
#: src/project/changelog.md:163 src/project/changelog.md:193
#: src/project/changelog.md:299 src/project/changelog.md:371
#: src/project/changelog.md:425 src/project/changelog.md:539
#: src/project/changelog.md:606 src/project/changelog.md:697
#: src/project/changelog.md:738 src/project/changelog.md:930
#: src/project/changelog.md:1091 src/project/changelog.md:1186
#: src/project/changelog.md:1240 src/project/changelog.md:1505
#: src/project/changelog.md:1702 src/project/changelog.md:1737
msgid "**Integrations**:"
msgstr "**整合**："

#: src/project/changelog.md:17
msgid ""
"[micro](https://micro-editor.github.io/) 2.0.15 has syntax highlighting for "
"PRQL. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:20 src/project/changelog.md:36
#: src/project/changelog.md:45 src/project/changelog.md:82
#: src/project/changelog.md:121 src/project/changelog.md:170
#: src/project/changelog.md:304 src/project/changelog.md:402
#: src/project/changelog.md:433 src/project/changelog.md:514
#: src/project/changelog.md:702 src/project/changelog.md:744
#: src/project/changelog.md:934 src/project/changelog.md:1056
#: src/project/changelog.md:1095 src/project/changelog.md:1198
#: src/project/changelog.md:1283 src/project/changelog.md:1513
#: src/project/changelog.md:1619 src/project/changelog.md:1661
#: src/project/changelog.md:1707 src/project/changelog.md:1742
#: src/project/changelog.md:1762
msgid "**Internal changes**:"
msgstr "**內部變更**："

#: src/project/changelog.md:22 src/project/changelog.md:88
#: src/project/changelog.md:177 src/project/changelog.md:215
#: src/project/changelog.md:324 src/project/changelog.md:383
#: src/project/changelog.md:446 src/project/changelog.md:518
#: src/project/changelog.md:638 src/project/changelog.md:706
#: src/project/changelog.md:759 src/project/changelog.md:773
#: src/project/changelog.md:950 src/project/changelog.md:1066
#: src/project/changelog.md:1206 src/project/changelog.md:1218
#: src/project/changelog.md:1249 src/project/changelog.md:1288
#: src/project/changelog.md:1362
msgid "**New Contributors**:"
msgstr ""

#: src/project/changelog.md:24
msgid "0.13.10 — 2025-12-16"
msgstr ""

#: src/project/changelog.md:26
msgid "0.13.10 completes the npm OIDC publishing fix from 0.13.9."
msgstr ""

#: src/project/changelog.md:30
msgid "Add `read_json` support for DuckDB and ClickHouse (@adamnemecek, #5608)"
msgstr ""

#: src/project/changelog.md:34
msgid "Fix `text.length` on Snowflake (@priithaamer, #5614)"
msgstr ""

#: src/project/changelog.md:38
msgid "Fix npm OIDC publishing by upgrading to Node 24 (@max-sixty, #5619)"
msgstr ""

#: src/project/changelog.md:39
msgid "Fix push-web-branch workflow permissions (@max-sixty, #5620)"
msgstr ""

#: src/project/changelog.md:41
msgid "0.13.9 — 2025-12-12"
msgstr ""

#: src/project/changelog.md:43
msgid "0.13.9 is a re-release of 0.13.8 with fixed npm publishing."
msgstr ""

#: src/project/changelog.md:47
msgid "Use OIDC for npm publishing (@max-sixty, #5609)"
msgstr ""

#: src/project/changelog.md:49
msgid "0.13.8 — 2025-12-12"
msgstr ""

#: src/project/changelog.md:51
msgid "0.13.8 has 47 commits from 6 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:55
msgid "Add named parameter support for DuckDB read_parquet (@max-sixty, #5563)"
msgstr ""

#: src/project/changelog.md:59
msgid "Snowflake interval quoting style (@priithaamer, #5604)"
msgstr ""

#: src/project/changelog.md:60
msgid ""
"Return error instead of panicking when window rows/range is not a range "
"(@max-sixty, #5603)"
msgstr ""

#: src/project/changelog.md:62
msgid ""
"Add ORDER BY fallback for Snowflake window functions (@max-sixty, #5583)"
msgstr ""

#: src/project/changelog.md:63
msgid ""
"DISTINCT ON to include wildcard when projection is empty (@max-sixty, #5562)"
msgstr ""

#: src/project/changelog.md:64
msgid "Lineage traces through CTEs to source tables (@nightscape, #5581)"
msgstr ""

#: src/project/changelog.md:65
msgid "Lineage works with unions (@nightscape, #5550)"
msgstr ""

#: src/project/changelog.md:66
msgid ""
"Handle lineage correctly when group pipeline simplifies to non-TransformCall "
"(@max-sixty, #5584)"
msgstr ""

#: src/project/changelog.md:68
msgid ""
"Return error for join referencing inaccessible table (@max-sixty, #5587)"
msgstr ""

#: src/project/changelog.md:69
msgid "Error when table variable used in scalar context (@max-sixty, #5585)"
msgstr ""

#: src/project/changelog.md:70
msgid "Improve error messages for missing main pipeline (@max-sixty, #5565)"
msgstr ""

#: src/project/changelog.md:71
msgid "Provide clear error for empty tuple/array in from (@max-sixty, #5564)"
msgstr ""

#: src/project/changelog.md:72
msgid ""
"Improve error message for negative numbers in transforms (@max-sixty, #5566)"
msgstr ""

#: src/project/changelog.md:76
msgid "Close HTML comment in sort.md documentation (@max-sixty, #5597)"
msgstr ""

#: src/project/changelog.md:80
msgid "Add grammar file for Raku (@vanillajonathan, #5576)"
msgstr ""

#: src/project/changelog.md:84
msgid "Upgrade mdbook to 0.5.0 (#5568)"
msgstr ""

#: src/project/changelog.md:85
msgid "Update macOS runners to version 15 (#5596)"
msgstr ""

#: src/project/changelog.md:86
msgid "Remove 2nd person from error messages (#5567)"
msgstr ""

#: src/project/changelog.md:90
msgid "@nightscape, with #5550"
msgstr ""

#: src/project/changelog.md:92
msgid "0.13.7 — 2025-11-08"
msgstr ""

#: src/project/changelog.md:94
msgid "0.13.7 has 8 commits from 6 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:98
msgid "Fix INTERVAL quoting in Redshift (@lukapeschke, #5545)"
msgstr ""

#: src/project/changelog.md:99
msgid "Fix support for text.contains in sql.redshift target (@dimtion, #5549)"
msgstr ""

#: src/project/changelog.md:100
msgid "Fix division in Redshift produces float (@priithaamer, #5546)"
msgstr ""

#: src/project/changelog.md:101
msgid ""
"Use || operator over CONCAT for std.concat in Redshift (@lukapeschke, #5540)"
msgstr ""

#: src/project/changelog.md:105
msgid "Bump vite from 7.1.11 to 7.2.0 in playground (#5547)"
msgstr ""

#: src/project/changelog.md:107
msgid "0.13.6 — 2025-11-01"
msgstr ""

#: src/project/changelog.md:109
msgid "0.13.6 has 40 commits from 6 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:113
msgid "Add support for Redshift dialect (@priithaamer, #5537)"
msgstr ""

#: src/project/changelog.md:117
msgid "Fix append regression in 0.13.5 (@priithaamer, #5495)"
msgstr ""

#: src/project/changelog.md:118
msgid "Fix s-string escaping (@priithaamer, #5497)"
msgstr ""

#: src/project/changelog.md:119
msgid ""
"Filter out attestation manifests in platform verification (@max-sixty, #5509)"
msgstr ""

#: src/project/changelog.md:123
msgid ""
"Migrate devcontainer build from QEMU to native ARM64 runners (@max-sixty, "
"\\#5506)"
msgstr ""

#: src/project/changelog.md:125
msgid "Migrate from markdown-link-check to lychee (@max-sixty, #5519)"
msgstr ""

#: src/project/changelog.md:126
msgid ""
"Use zero-copy slice for binary/hex/octal number parsing (perf improvement, "
"@max-sixty, #5488)"
msgstr ""

#: src/project/changelog.md:128
msgid "Update rust toolchain version (#5536)"
msgstr ""

#: src/project/changelog.md:129
msgid "Do not allow incompatible rust-version dependencies (@eitsupi, #5493)"
msgstr ""

#: src/project/changelog.md:130
msgid "Pin typos to v1.37.2 (@max-sixty, #5510)"
msgstr ""

#: src/project/changelog.md:132
msgid "0.13.5 — 2025-10-09"
msgstr ""

#: src/project/changelog.md:134
msgid "0.13.5 has 237 commits from 14 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:138
msgid "Support for SQL arrays as `s[...]` syntax (@Robert Valek, #5312)"
msgstr ""

#: src/project/changelog.md:139
msgid ""
"Extract SQL column names from s-string tables when possible (@lukapeschke, "
"\\#5310)"
msgstr ""

#: src/project/changelog.md:144
msgid ""
"Sort step before an aggregate step no longer requires its columns to avoid a "
"group by clause error (@julien-pinchelimouroux, #5347)"
msgstr ""

#: src/project/changelog.md:146
msgid ""
"Always add quotes on identifiers for Snowflake dialect (@julien-"
"pinchelimouroux, #5461)"
msgstr ""

#: src/project/changelog.md:148
msgid ""
"Join with table containing column named \"source\" now works correctly "
"(@Priit Haamer, #5468)"
msgstr ""

#: src/project/changelog.md:150
msgid ""
"Columns required by sorting are properly redirected (@lukapeschke, #5464)"
msgstr ""

#: src/project/changelog.md:151
msgid ""
"Ensure sorts are done on columns of the right table (@lukapeschke, #5338)"
msgstr ""

#: src/project/changelog.md:152
msgid "Deduplicate selected items in gen_projection (@lukapeschke, #5305)"
msgstr ""

#: src/project/changelog.md:153
msgid "Handle complex append cases (@Elouan Poupard-Cosquer, #5366)"
msgstr ""

#: src/project/changelog.md:154
msgid "Improve requirement logic (@Elouan Poupard-Cosquer, #5357)"
msgstr ""

#: src/project/changelog.md:155
msgid ""
"Avoid type mismatch with Postgres in append (@Elouan Poupard-Cosquer, #5343)"
msgstr ""

#: src/project/changelog.md:156
msgid "Apply column order on CTEs in append (@Elouan Poupard-Cosquer, #5323)"
msgstr ""

#: src/project/changelog.md:160
msgid "Fix binary literal example (@ftsfranklin, #5475)"
msgstr ""

#: src/project/changelog.md:161
msgid "Use correct table in grouping tutorial (@fnuttens, #5332)"
msgstr ""

#: src/project/changelog.md:165
msgid ""
"TEA 63.3.1, a Qt-based text editor has syntax highlighting for PRQL "
"(@vanillajonathan, #5220)"
msgstr ""

#: src/project/changelog.md:167
msgid "Micro text editor grammar is now upstream (@vanillajonathan, #5353)"
msgstr ""

#: src/project/changelog.md:168
msgid "Add LSP stub (@vanillajonathan, #5197)"
msgstr ""

#: src/project/changelog.md:172
msgid ""
"Upgrade parser and lexer to chumsky 0.11, providing a 7x performance "
"improvement (#5223, #5476, #5477)"
msgstr ""

#: src/project/changelog.md:174
msgid "Set Rust linker on win64, fix build crash (@kgutwin, #5345)"
msgstr ""

#: src/project/changelog.md:175
msgid "Integration tests compile all dialects and diff (@kgutwin, #5344)"
msgstr ""

#: src/project/changelog.md:179
msgid "@Elouan Poupard-Cosquer, with #5366"
msgstr ""

#: src/project/changelog.md:180
msgid "@Priit Haamer, with #5468"
msgstr ""

#: src/project/changelog.md:181
msgid "@Robert Valek, with #5312"
msgstr ""

#: src/project/changelog.md:182
msgid "@fnuttens, with #5332"
msgstr ""

#: src/project/changelog.md:183
msgid "@ftsfranklin, with #5475"
msgstr ""

#: src/project/changelog.md:184
msgid "@julien-pinchelimouroux, with #5347"
msgstr ""

#: src/project/changelog.md:186
msgid "0.13.4 — 2025-03-26"
msgstr ""

#: src/project/changelog.md:188
msgid "0.13.4 is a small bugfix release."
msgstr ""

#: src/project/changelog.md:190
msgid ""
"It has 57 commits from 10 contributors. Selected changes (in particular, a "
"few bugfixes aren't listed here):"
msgstr ""

#: src/project/changelog.md:195
msgid ""
"Add syntax highlight file for KSyntaxHighlighting. (@vanillajonathan, #5177)"
msgstr ""

#: src/project/changelog.md:196
msgid "Add syntax highlight file for Vim. (@vanillajonathan, #5185)"
msgstr ""

#: src/project/changelog.md:197
msgid "Add syntax highlight file for GNU Emacs. (@vanillajonathan, #5189)"
msgstr ""

#: src/project/changelog.md:198
msgid ""
"[Kakoune](https://kakoune.org/), a terminal-based text editor has syntax "
"highlighting for PRQL. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:200
msgid ""
"[Neovim](https://neovim.io/) 0.11 has syntax highlighting for PRQL. "
"(@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:203
msgid "0.13.3 — 2025-01-25"
msgstr ""

#: src/project/changelog.md:205
msgid ""
"0.13.3 is a small release containing a few bug fixes and improvements. It "
"has 86 commits from 10 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:210
msgid ""
"Sort steps in sub-pipelines no longer cause a column lookup error "
"(@lukapeschke, #5066)"
msgstr ""

#: src/project/changelog.md:212
msgid ""
"Dereferencing of sort columns when rendering SQL now done in context of main "
"pipeline (@kgutwin, #5098)"
msgstr ""

#: src/project/changelog.md:217
msgid "@lukapeschke, with #5066"
msgstr ""

#: src/project/changelog.md:219
msgid "0.13.2"
msgstr ""

#: src/project/changelog.md:221
msgid ""
"0.13.2 is a tiny release to fix an issue publishing 0.13.1 to crates.io."
msgstr ""

#: src/project/changelog.md:223
msgid "0.13.1"
msgstr ""

#: src/project/changelog.md:225
msgid ""
"0.13.1 is a small release containing a few bug fixes and improvements. "
"Velocity has slowed down a bit in recent months, we're still hoping to "
"finish the new resolver and the new formatter in the near future."
msgstr ""

#: src/project/changelog.md:229
msgid "It has 97 commits from 10 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:233
msgid ""
"Add a option to the experimental documentation generator to output the docs "
"in HTML format. The option is given using the `--format=html` option. "
"(@vanillajonathan, 4791)"
msgstr ""

#: src/project/changelog.md:237
msgid ""
"The version of the library is now read from `git describe`. This doesn't "
"affect libraries built on git tags (such as our releases), only those built "
"when developing. When reporting bugs, this helps identify the exact version. "
"(@max-sixty & @m-span, #4804)"
msgstr ""

#: src/project/changelog.md:244
msgid ""
"Raw strings (`r\"...\"`) are retained through `prqlc fmt` (@max-sixty, #4848)"
msgstr ""

#: src/project/changelog.md:246
msgid ""
"Strings containing an odd contiguous number of quotes are now delimited by "
"an odd number of quotes when being formatted. The previous implementation "
"would use an even number, which is invalid PRQL. (@max-sixty, #4850)"
msgstr ""

#: src/project/changelog.md:250
msgid ""
"A few more keywords are quoted, such as `user`, which is a reserved keyword "
"in PostgreSQL. (@max-sixty)"
msgstr ""

#: src/project/changelog.md:253
msgid "0.13.0 — 2024-07-25"
msgstr ""

#: src/project/changelog.md:255
msgid ""
"0.13.0 brings a new debug logging framework, a big refactor of the parser, a "
"new highlighter, an `**` operator for exponentiation, a few bug fixes, and "
"lots of other changes. It has 153 commits from 11 contributors."
msgstr ""

#: src/project/changelog.md:259
msgid ""
"Our work continues on rewriting the resolver and completing `prqlc fmt`."
msgstr ""

#: src/project/changelog.md:261
msgid "Selected changes:"
msgstr ""

#: src/project/changelog.md:265
msgid ""
"Parentheses are always required around pipelines, even within tuples. For "
"example:"
msgstr ""

#: src/project/changelog.md:276
msgid ""
"This is a small breaking change. The new behavior matches the existing "
"documentation. (@max-sixty, #4775)"
msgstr ""

#: src/project/changelog.md:279
msgid ""
"A new `**` operator for exponentiation. (@aljazerzen & @max-sixty, #4125)"
msgstr ""

#: src/project/changelog.md:283
msgid ""
"`prqlc compile --debug-log=log.html` will generate an HTML file with a "
"detailed log of the compilation process. (@aljazerzen, #4646)"
msgstr ""

#: src/project/changelog.md:285
msgid ""
"Added `prqlc debug json-schema` command to auto-generate JSON Schema "
"representations of commonly exposed IR types such as PL and RQ. (@kgutwin, "
"\\#4698)"
msgstr ""

#: src/project/changelog.md:288
msgid ""
"Add documentation comments to the output of the documentation generator. "
"(@vanillajonathan, #4729)"
msgstr ""

#: src/project/changelog.md:290
msgid ""
"Add CLI syntax highlighting to `prqlc`. You can try it as `prqlc "
"experimental highlight example.prql`. (@vanillajonathan, #4755)"
msgstr ""

#: src/project/changelog.md:295
msgid ""
"Using `in` with an empty array pattern (e.g. `expr | in []`) will now output "
"a constant `false` condition instead of an `expr IN ()`, which is "
"syntactically invalid in some SQL dialects (@Globidev, #4598)"
msgstr ""

#: src/project/changelog.md:301
msgid ""
"The Snap package previously released on the edge channel is now released on "
"the stable channel. (@vanillajonathan, #4784)"
msgstr ""

#: src/project/changelog.md:306
msgid ""
"Major reorganization of `prqlc-parser` — `prqlc-ast` is merged into `prqlc-"
"parser`, and `prqlc-parser`'s files are rearranged, including its exports. "
"This is part of an effort to modularize the compiler by stage, reducing the "
"amount of context that's required to understand a single stage. There will "
"likely be some further changes (more detail in the PR description). (@m-"
"span, #4634)"
msgstr ""

#: src/project/changelog.md:312
msgid ""
"This is a breaking change for any libraries that depend on `prqlc-parser` "
"(which should be fairly rare)."
msgstr ""

#: src/project/changelog.md:315
msgid ""
"Renamed `prql-compiler-macros` to `prqlc-macros` for consistency with other "
"crates (@max-sixty, #4565)"
msgstr ""

#: src/project/changelog.md:318
msgid ""
"`prql-compiler`, the old name for `prqlc`, is removed as a facade to "
"`prqlc`. It had been deprecated for a few versions and will no longer be "
"updated. (@max-sixty)"
msgstr ""

#: src/project/changelog.md:322
msgid "New benchmarks (@max-sixty, #4654)"
msgstr ""

#: src/project/changelog.md:326
msgid "@Globidev, with #4598"
msgstr ""

#: src/project/changelog.md:328
msgid "0.12.2 — 2024-06-10"
msgstr ""

#: src/project/changelog.md:330
msgid ""
"0.12.2 is a very small release which renames `prql-js` to `prqlc-js` to "
"match our standard naming scheme. Within node the package is imported as "
"`prqlc`."
msgstr ""

#: src/project/changelog.md:333
msgid "It also fixes a mistake in the `prqlc-python` release pipeline."
msgstr ""

#: src/project/changelog.md:335
msgid "0.12.1 — 2024-06-09"
msgstr ""

#: src/project/changelog.md:337
msgid ""
"0.12.1 is a tiny hotfix release which fixes how intra-prql crate "
"dependencies were specified."
msgstr ""

#: src/project/changelog.md:340
msgid "0.12.0 — 2024-06-08"
msgstr ""

#: src/project/changelog.md:342
msgid ""
"0.12.0 contains a few months of smaller features. Our focus has been on "
"rewriting the resolver, an effort that is still ongoing."
msgstr ""

#: src/project/changelog.md:345
msgid ""
"It has 239 commits from 12 contributors. Selected changes (most are not "
"listed here, possibly we should be more conscientious about adding them...):"
msgstr ""

#: src/project/changelog.md:350
msgid "Add `prqlc lex` command to the CLI (@max-sixty)"
msgstr ""

#: src/project/changelog.md:351
msgid ""
"Add `prqlc debug lineage` command to the CLI, creating an expression lineage "
"graph from a query (@kgutwin, #4533)"
msgstr ""

#: src/project/changelog.md:353
msgid ""
"Initial implementation of an experimental documentation generator that "
"generates Markdown documentation from `.prql` files. (@vanillajonathan, "
"\\#4152)."
msgstr ""

#: src/project/changelog.md:356
msgid ""
"Join's `side` parameter can take a reference that resolves to a literal "
"(note: this is an experimental feature which may change in the future) "
"(@kgutwin, \\#4499)"
msgstr ""

#: src/project/changelog.md:362
msgid ""
"Support expressions on left hand side of `std.in` operator. (@kgutwin, #4498)"
msgstr ""

#: src/project/changelog.md:363
msgid "Prevent panic for `from {}` and `std` (@m-span, #4538)"
msgstr ""

#: src/project/changelog.md:367
msgid ""
"The `browser` dist files are now built with `wasm-pack`'s `web` target. As a "
"result, they should be usable as ES Modules, through JS CDNs, and for "
"example with Observable Framework (@srenatus, #4274)."
msgstr ""

#: src/project/changelog.md:373
msgid ""
"The syntax highlighter package for Sublime Text is now [published](https://"
"packagecontrol.io/packages/PRQL) (@vanillajonathan)."
msgstr ""

#: src/project/changelog.md:375
msgid ""
"The [VSCode Great Icons](https://marketplace.visualstudio.com/items?"
"itemName=emmanuelbeziat.vscode-great-icons) icon pack extension shows a "
"database icon for `.prql` files. (@EmmanuelBeziat)"
msgstr ""

#: src/project/changelog.md:378
msgid ""
"[Tokei](https://github.com/XAMPPRocky/tokei), a source lines of code counter "
"now has support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:380
msgid ""
"Add syntax highlight file for the [micro](https://micro-editor.github.io/) "
"text editor. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:385
msgid "@srenatus, with #4274"
msgstr ""

#: src/project/changelog.md:386
msgid "@jacquayj, with #4332"
msgstr ""

#: src/project/changelog.md:387
msgid "@pdelewski, with #4337"
msgstr ""

#: src/project/changelog.md:388
msgid "@m-span, with #4422"
msgstr ""

#: src/project/changelog.md:389
msgid "@kgutwin, with #4498"
msgstr ""

#: src/project/changelog.md:391
msgid "0.11.4 — 2024-02-25"
msgstr ""

#: src/project/changelog.md:393
msgid ""
"0.11.4 is a hotfix release, fixing a CI issue that caused the CLI binaries "
"to be built without the `cli` feature."
msgstr ""

#: src/project/changelog.md:396
msgid "0.11.3 — 2024-02-10"
msgstr ""

#: src/project/changelog.md:398
msgid "0.11.3 is a very small release, mostly a rename of the Python bindings."
msgstr ""

#: src/project/changelog.md:400
msgid "The release has 13 commits from 4 contributors."
msgstr ""

#: src/project/changelog.md:404
msgid ""
"As part of making our names more consistent, the Python bindings are "
"renamed. `prql-python` becomes a package published and importable as "
"`prqlc`. The internal Rust crate is named `prqlc-python`."
msgstr ""

#: src/project/changelog.md:408
msgid "0.11.2 — 2024-02-07"
msgstr ""

#: src/project/changelog.md:410
msgid ""
"0.11.2 contains lots of internal changes, lots of syntax highlighting, and "
"the beginning of `lutra`, a query runner."
msgstr ""

#: src/project/changelog.md:413
msgid "This release has 122 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:417
msgid ""
"Initial implementation of `lutra`, a query runner. (@aljazerzen, #4182, "
"#4174, \\#4134)"
msgstr ""

#: src/project/changelog.md:419
msgid "`prqlc fmt` works on projects with multiple files. (@max-sixty, #4028)"
msgstr ""

#: src/project/changelog.md:423
msgid "Reduce stack memory usage (@aljazerzen, #4103)"
msgstr ""

#: src/project/changelog.md:427
msgid "Add syntax highlight file for GtkSourceView. (@vanillajonathan, #4062)"
msgstr ""

#: src/project/changelog.md:428
msgid "Add syntax highlight file for CotEditor. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:429
msgid "Add syntax highlight file for Sublime Text. (@vanillajonathan, #4127)"
msgstr ""

#: src/project/changelog.md:430
msgid ""
"[sloc](https://github.com/flosse/sloc), a source lines of code counter now "
"has support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:435
msgid ""
"`prql-compiler` has been renamed to `prqlc`, and we've established a more "
"consistent naming scheme. The existing crate will still be published, re-"
"exporting `prqlc`, so no dependencies will break. A future version will add "
"a deprecation warning."
msgstr ""

#: src/project/changelog.md:439
msgid ""
"The `prqlc-clib` crate was renamed to `prqlc-c`, and associated artifacts "
"were renamed. We're trying to make names consistent (ideally for the final "
"time!), and have a plan to rename some other bindings. (@max-sixty, #4077)"
msgstr ""

#: src/project/changelog.md:442
msgid ""
"Add lots of whitespace items to the lexer, in preparation for the completion "
"of `prqlc fmt` (@max-sixty, #4109, #4105)"
msgstr ""

#: src/project/changelog.md:444
msgid "Table declarations (@aljazerzen, #4126)"
msgstr ""

#: src/project/changelog.md:448
msgid "@kaspermarstal, with #4124"
msgstr ""

#: src/project/changelog.md:450
msgid "0.11.1 — 2023-12-26"
msgstr ""

#: src/project/changelog.md:452
msgid "0.11.1 fixes a couple of small bugs; it comes a few days after 0.11."
msgstr ""

#: src/project/changelog.md:454
msgid "This release has 16 commits from 6 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:458
msgid ""
"Infer the type of array literals to be the union of types of its items. "
"(@aljazerzen, #3989)"
msgstr ""

#: src/project/changelog.md:460
msgid ""
"`prql` module is added and the `prql_version` function is renamed to the "
"`prql.version` function. The old `prql_version` function is deprecated and "
"will be removed in the future release. (@eitsupi, #4006)"
msgstr ""

#: src/project/changelog.md:466
msgid ""
"Do not compile to `DISTINCT ON` when `take n` is used with `group` for the "
"targets `clickhouse`, `duckdb` and `postgres`. (@PrettyWood, #3988)"
msgstr ""

#: src/project/changelog.md:468
msgid ""
"Fix `take` n rows for `mssql` dialect by switching from TOP to FETCH "
"(@PrettyWood, #3994)"
msgstr ""

#: src/project/changelog.md:471
msgid "0.11.0 — 2023-12-19"
msgstr ""

#: src/project/changelog.md:473
msgid ""
"0.11.0 introduces new `date`, `text` & `math` modules with lots of standard "
"functions, including a new `date.to_text` function. It contains a few bugs "
"fixes, and lots of internal improvements to the compiler."
msgstr ""

#: src/project/changelog.md:477
msgid "This release has 119 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:481
msgid ""
"_Breaking_: `group`'s `by` columns are now excluded from the partition. "
"(#3490)"
msgstr ""

#: src/project/changelog.md:483
msgid ""
"_Breaking_: `round` is now in the `math` module and needs to be called via "
"`math.round`. (#3928)"
msgstr ""

#: src/project/changelog.md:485
msgid ""
"_Breaking_: `lower` and `upper` are now in the `text` module and need to be "
"called via `text.lower` and `text.upper`. (#3913, #3973)"
msgstr ""

#: src/project/changelog.md:490
msgid ""
"The `std.in` function now supports a list of values (@PrettyWood, #3883)"
msgstr ""

#: src/project/changelog.md:491
msgid ""
"Most standard mathematical functions are now supported: `abs`, `floor`, "
"`ceil`, `pi`, `exp`, `ln`, `log10`, `log`, `sqrt`, `degrees`, `radians`, "
"`cos`, `acos`, `sin`, `asin`, `tan`, `atan`, `pow` and `round`.  \n"
"Those functions are in the `math` module (@PrettyWood, #3909, #3916 & 3928)"
msgstr ""

#: src/project/changelog.md:495
msgid ""
"Most standard string functions are now supported: `ltrim`, `rtrim`, `trim`, "
"`length`, `extract`, `replace`. Utility functions `starts_with`, `contains` "
"and `ends_with` are also available.  \n"
"Those functions are in the `text` module (@PrettyWood, #3913, #3973)"
msgstr ""

#: src/project/changelog.md:499
msgid ""
"Formatting a date to a text is now available for Clickhouse, DuckDB, MySQL, "
"MSSQL and Postgres. A new `date` module has been added with the `to_text` "
"function (@PrettyWood, #3951, #3954 & #3955)"
msgstr ""

#: src/project/changelog.md:505
msgid "Fix an issue with arithmetic precedence (@max-sixty, #3846)"
msgstr ""

#: src/project/changelog.md:506
msgid "`+` and `-` can be used after a cast (@PrettyWood, #3923)"
msgstr ""

#: src/project/changelog.md:507
msgid ""
"The [Lezer](https://lezer.codemirror.net/) grammar had plenty of "
"improvements and fixes. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:512
msgid "The Playground now uses [Vite](https://vitejs.dev/). (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:516
msgid "Bump `prql-compiler`'s MSRV to 1.70.0 (@eitsupi, #3876)"
msgstr ""

#: src/project/changelog.md:520
msgid "@PrettyWood, with #3883"
msgstr ""

#: src/project/changelog.md:522
msgid "0.10.1 — 2023-11-14"
msgstr ""

#: src/project/changelog.md:524
msgid ""
"0.10.1 is a small release containing some internal fixes of the compiler."
msgstr ""

#: src/project/changelog.md:526
msgid "This release has 36 commits from 7 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:530
msgid ""
"The `std.sql.read_csv` function and the `std.sql.read_parquet` function "
"supports the `sql.glaredb` target. (@eitsupi, #3749)"
msgstr ""

#: src/project/changelog.md:535
msgid ""
"Fix the bug of compiling to `DISTINCT ON` when `take 1` is used with `group "
"by` for the targets `sql.clickhouse`, `sql.duckdb` and `sql.postgres`. "
"(@aljazerzen, #3792)"
msgstr ""

#: src/project/changelog.md:541
msgid "Enable integration tests for GlareDB. (@eitsupi, #3749)"
msgstr ""

#: src/project/changelog.md:542
msgid ""
"[trapd00r/LS_COLORS](https://github.com/trapd00r/LS_COLORS), a collection of "
"LS_COLORS definitions colorizes `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:544
msgid ""
"[vivid](https://github.com/sharkdp/vivid), a themeable LS_COLORS generator "
"colorizes `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:546
msgid ""
"[colorls](https://github.com/athityakumar/colorls), displays `.prql` files "
"with a database icon. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:548
msgid ""
"[Emoji File Icons](https://marketplace.visualstudio.com/items?"
"itemName=mightbesimon.emoji-icons), a VS Code extension displays `.prql` "
"files with a database emoji icon. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:551
msgid ""
"[eza](https://eza.rocks/), a modern ls replacement colorizes `.prql` files. "
"(@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:553
msgid ""
"[lsd](https://github.com/lsd-rs/lsd), next gen ls command displays `.prql` "
"files with a database icon. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:556
msgid "0.10.0 — 2023-10-26"
msgstr ""

#: src/project/changelog.md:558
msgid ""
"0.10.0 contains lots of small improvements, including support for new types "
"of literal notation, support for `read_*` functions in more dialects, "
"playground improvements, and a better Lezer grammar (which we're planning on "
"using for a Jupyter extension)."
msgstr ""

#: src/project/changelog.md:563
msgid "This release has 155 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:567
msgid ""
"_Breaking:_ Case syntax now uses brackets `[]` rather than braces `{}`. To "
"convert previous PRQL queries to this new syntax simply change `case { ... }"
"` to `case [ ... ]`. (@AaronMoat, #3517)"
msgstr ""

#: src/project/changelog.md:573
msgid ""
"_Breaking_: The `std.sql.read_csv` function is now compiled to `read_csv` by "
"default. Please set the target `sql.duckdb` to use the DuckDB's "
"`read_csv_auto` function as previously. (@eitsupi, #3599)"
msgstr ""

#: src/project/changelog.md:576
msgid ""
"_Breaking_: The `std.every` function is renamed to `std.all` (@aljazerzen, "
"\\#3703)"
msgstr ""

#: src/project/changelog.md:578
msgid ""
"The `std.sql.read_csv` function and the `std.sql.read_parquet` function "
"supports the `sql.clickhouse` target. (@eitsupi, #1533)"
msgstr ""

#: src/project/changelog.md:580
msgid "Add `std.prql_version` function to return PRQL version (@hulxv, #3533)"
msgstr ""

#: src/project/changelog.md:581
msgid "A new type `anytype` is added. (@aljazerzen, #3703)"
msgstr ""

#: src/project/changelog.md:582
msgid ""
"Add support for hex escape sequences in strings. Example `\"Hello \\x51\"`. "
"(@vanillajonathan, #3568)"
msgstr ""

#: src/project/changelog.md:584
msgid ""
"Add support for long Unicode escape sequences. Example `\"Hello "
"\\u{01F422}\"`. (@vanillajonathan, #3569)"
msgstr ""

#: src/project/changelog.md:586
msgid ""
"Add support for binary numerical notation. Example `filter status == "
"0b1111000011110000`. (@vanillajonathan, #3661)"
msgstr ""

#: src/project/changelog.md:588
msgid ""
"Add support for hexadecimal numerical notation. Example `filter status == "
"0xff`. (@vanillajonathan, #3654)"
msgstr ""

#: src/project/changelog.md:590
msgid ""
"Add support for octal numerical notation. Example `filter status == 0o777`. "
"(@vanillajonathan, #3672)"
msgstr ""

#: src/project/changelog.md:592
msgid ""
"New compile target `sql.glaredb` for [GlareDB](https://docs.glaredb.com/) "
"and integration tests for it (However, there is a bug in the test and it is "
"currently not running). (@universalmind303, @scsmithr, @eitsupi, #3669)"
msgstr ""

#: src/project/changelog.md:598
msgid ""
"Allow cmd-/ (Mac) or ctrl-/ (Windows) to toggle comments in the playground "
"editor (@AaronMoat, #3522)"
msgstr ""

#: src/project/changelog.md:601
msgid ""
"Limit maximum height of the playground editor's error panel to avoid taking "
"over whole screen (@AaronMoat, #3524)"
msgstr ""

#: src/project/changelog.md:604
msgid "The playground now uses [Vite](https://vitejs.dev/) (@vanillajonathan)."
msgstr ""

#: src/project/changelog.md:608
msgid ""
"Add a CLI command `prqlc collect` to collect a project's modules into a "
"single file (@aljazerzen, #3739)"
msgstr ""

#: src/project/changelog.md:610
msgid ""
"Add a CLI command `prqlc debug expand-pl` to parse & and expand into PL "
"without resolving (@aljazerzen, #3739)"
msgstr ""

#: src/project/changelog.md:612
msgid "Bump `prqlc`'s MSRV to 1.70.0 (@eitsupi, #3521)"
msgstr ""

#: src/project/changelog.md:613
msgid ""
"[Pygments](https://pygments.org/), a syntax highlighting library now has "
"syntax highlighting for PRQL. (@vanillajonathan, #3564)"
msgstr ""

#: src/project/changelog.md:615
msgid ""
"[chroma](https://github.com/alecthomas/chroma), a syntax highlighting "
"library written in Go and used by the static website generator [Hugo]"
"(https://gohugo.io/). (@vanillajonathan, #3597)"
msgstr ""

#: src/project/changelog.md:618
msgid ""
"[scc](https://github.com/boyter/scc), a source lines of code counter now has "
"support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:620
msgid ""
"[gcloc](https://github.com/JoaoDanielRufino/gcloc) a source lines of code "
"counter now has support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:622
msgid ""
"[cloc](https://github.com/AlDanial/cloc) a source lines of code counter now "
"has support for `.prql` files. (@AlDanial)"
msgstr ""

#: src/project/changelog.md:624
msgid ""
"[gocloc](https://github.com/hhatto/gocloc) a source lines of code counter "
"now has support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:626
msgid ""
"[The Quarto VS Code extension](https://marketplace.visualstudio.com/items?"
"itemName=quarto.quarto) supports editing PRQL code blocks ([`prqlr`](https://"
"prql-lang.org/book/project/bindings/r.html) is required to render Quarto "
"Markdown with PRQL code blocks). (@jjallaire)"
msgstr ""

#: src/project/changelog.md:631 src/project/changelog.md:1555
msgid "**Internal**:"
msgstr ""

#: src/project/changelog.md:633
msgid ""
"Rename some of the internal crates, and refactored their paths in the repo. "
"(@aljazerzen, #3683)."
msgstr ""

#: src/project/changelog.md:635
msgid ""
"Add a `justfile` for developers who prefer that above our `Taskfile.yaml` "
"(@aljazerzen, #3681)"
msgstr ""

#: src/project/changelog.md:640
msgid "@hulxv, with #3533"
msgstr ""

#: src/project/changelog.md:641
msgid "@AaronMoat, with #3522"
msgstr ""

#: src/project/changelog.md:642
msgid "@jangorecki, with #3634"
msgstr ""

#: src/project/changelog.md:644
msgid "0.9.5 — 2023-09-16"
msgstr ""

#: src/project/changelog.md:646
msgid ""
"0.9.5 adds a line-wrapping character, fixes a few bugs, and improves our CI. "
"The release has 77 commits from 8 contributors. Selected changes are below."
msgstr ""

#: src/project/changelog.md:649
msgid ""
"Look out for some conference talks coming up over the next few weeks, "
"including [QCon SF on Oct 2](https://qconsf.com/presentation/oct2023/prql-"
"simple-powerful-pipelined-sql-replacement) and [date2day on Oct 12](https://"
"www.data2day.de/veranstaltung-21353-0-prql-a-modern-language-for-data-"
"transformation.html)."
msgstr ""

#: src/project/changelog.md:656
msgid ""
"A new line-wrapping character, for lines that are long and we want to break "
"up into multiple physical lines. This is slightly different from from many "
"languages — it's on the subsequent line:"
msgstr ""

#: src/project/changelog.md:660
msgid ""
"```prql no-eval\n"
"from artists\n"
"select is_europe =\n"
"\\ country == \"DE\"\n"
"\\ || country == \"FR\"\n"
"\\ || country == \"ES\"\n"
"```"
msgstr ""

#: src/project/changelog.md:668
msgid ""
"This allows for easily commenting out physical lines while maintaining a "
"correct logical line; for example:"
msgstr ""

#: src/project/changelog.md:681
msgid "(@max-sixty, #3408)"
msgstr ""

#: src/project/changelog.md:685
msgid ""
"Fix stack overflow on very long queries in Windows debug builds (@max-sixty, "
"\\#2908)"
msgstr ""

#: src/project/changelog.md:688
msgid ""
"Fix panic when unresolved lineage appears in group or window (@davidot, "
"#3266)"
msgstr ""

#: src/project/changelog.md:690
msgid ""
"Fix a corner-case in handling precedence, and remove unneeded parentheses in "
"some outputs (@max-sixty, #3472)"
msgstr ""

#: src/project/changelog.md:695
msgid "Compiler panics are now printed to the console (@max-sixty, #3446)"
msgstr ""

#: src/project/changelog.md:699
msgid ""
"[Ace](https://ace.c9.io/), the JavaScript code editor now has syntax "
"highlighting for PRQL. (@vanillajonathan, #3493)"
msgstr ""

#: src/project/changelog.md:704
msgid "Simplify & speed up lexer (@max-sixty, #3426, #3418)"
msgstr ""

#: src/project/changelog.md:708
msgid "@davidot, with #3450"
msgstr ""

#: src/project/changelog.md:710
msgid "0.9.4 — 2023-08-24"
msgstr ""

#: src/project/changelog.md:712
msgid ""
"0.9.4 is a small release with some improvements and bug fixes in the "
"compiler and `prqlc`. And, the documentation and CI are continually being "
"improved."
msgstr ""

#: src/project/changelog.md:715
msgid "This release has 110 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:719
msgid ""
"Strings can be delimited with any odd number of quote characters. The logic "
"for lexing quotes is now simpler and slightly faster. Escapes in single-"
"quote-delimited strings escape single-quotes rather than double-quotes. "
"(@max-sixty, #3274)"
msgstr ""

#: src/project/changelog.md:726
msgid "S-strings within double braces now parse correctly (@max-sixty, #3265)"
msgstr ""

#: src/project/changelog.md:730
msgid "New docs for strings (@max-sixty, #3281)"
msgstr ""

#: src/project/changelog.md:734
msgid ""
"Improve syntax highlighting for numbers in the book & website (@max-sixty, "
"\\#3261)"
msgstr ""

#: src/project/changelog.md:736
msgid "Add ClickHouse integration to docs (@max-sixty, #3251)"
msgstr ""

#: src/project/changelog.md:740
msgid ""
"`prqlc` no longer displays a prompt when piping a query into its stdin (@max-"
"sixty, #3248)."
msgstr ""

#: src/project/changelog.md:742
msgid ""
"Add a minimal example for use `prql-lib` with Zig (@vanillajonathan, #3372)"
msgstr ""

#: src/project/changelog.md:746
msgid ""
"Overhaul our CI to run a cohesive set of tests depending on the specific "
"changes in the PR, and elide all others. This cuts CI latency to less than "
"three minutes for most changes, and enables GitHub's auto-merge to wait for "
"all relevant tests. It also reduces the CI time on merging to main, by "
"moving some tests to only run on specific path changes or on our nightly run."
msgstr ""

#: src/project/changelog.md:752
msgid ""
"We now have one label we can add to PRs to run more tests — `pr-nightly`. "
"(@max-sixty, #3317 & others)."
msgstr ""

#: src/project/changelog.md:755
msgid "Auto-merge PRs for backports or pre-commit updates (@max-sixty, #3246)"
msgstr ""

#: src/project/changelog.md:756
msgid ""
"Add a workflow to create an issue when the scheduled nightly workflow fails "
"(@max-sixty, #3304)"
msgstr ""

#: src/project/changelog.md:761
msgid "@FinnRG, with #3292"
msgstr ""

#: src/project/changelog.md:762
msgid "@sitiom, with #3353"
msgstr ""

#: src/project/changelog.md:764
msgid "0.9.3 — 2023-08-02"
msgstr ""

#: src/project/changelog.md:766
msgid ""
"0.9.3 is a small release, with mostly documentation, internal, and CI "
"changes."
msgstr ""

#: src/project/changelog.md:768
msgid "This release has 85 commits from 10 contributors."
msgstr ""

#: src/project/changelog.md:770
msgid ""
"We'd like to welcome @not-my-profile as someone who has helped with lots of "
"internal refactoring in the past couple of weeks."
msgstr ""

#: src/project/changelog.md:775
msgid "@vthriller, with #3171"
msgstr ""

#: src/project/changelog.md:776
msgid "@postmeback, with #3216"
msgstr ""

#: src/project/changelog.md:778
msgid "0.9.2 — 2023-07-25"
msgstr ""

#: src/project/changelog.md:780
msgid ""
"0.9.2 is a hotfix release to fix an issue in the 0.9.0 & 0.9.1 release "
"pipelines."
msgstr ""

#: src/project/changelog.md:783
msgid "0.9.1 — 2023-07-25"
msgstr ""

#: src/project/changelog.md:785
msgid ""
"0.9.1 is a hotfix release to fix an issue in the 0.9.0 release pipeline."
msgstr ""

#: src/project/changelog.md:787
msgid "0.9.0 — 2023-07-24"
msgstr ""

#: src/project/changelog.md:789
msgid ""
"0.9.0 is probably PRQL's biggest ever release. We have dialect-specific "
"standard-libraries, a regex operator, an initial implementation of multiple-"
"file projects & modules, lots of bug fixes, and many many internal changes."
msgstr ""

#: src/project/changelog.md:793
msgid ""
"We've made a few backward incompatible syntax changes. Most queries will "
"work with a simple find/replace; see below for details."
msgstr ""

#: src/project/changelog.md:796
msgid "The release has 421 commits from 12 contributors."
msgstr ""

#: src/project/changelog.md:798 src/project/changelog.md:1044
msgid "A small selection of the changes:"
msgstr ""

#: src/project/changelog.md:802
msgid ""
"The major breaking change is a new syntax for lists, which have been renamed "
"to _tuples_, and are now represented with braces `{}` rather than brackets "
"`[]`."
msgstr ""

#: src/project/changelog.md:806
msgid ""
"To convert previous PRQL queries to this new syntax simply change `[ ... ]` "
"to `{ ... }`."
msgstr ""

#: src/project/changelog.md:809
msgid ""
"We made the syntax change to incorporate arrays. Almost every major language "
"uses `[]` for arrays. We are adopting that convention — arrays use `[]`, "
"tuples will use `{}`. (Though we recognize that `{}` for tuples is also rare "
"(Hi, Erlang!), but didn't want to further load parentheses with meaning.)"
msgstr ""

#: src/project/changelog.md:814
msgid ""
"Arrays are conceptually similar to columns — their elements have a single "
"type. Array syntax can't contain assignments."
msgstr ""

#: src/project/changelog.md:817
msgid ""
"As part of this, we've also formalized tuples as containing both individual "
"items (`select {foo, baz}`), and assignments (`select {foo=bar, baz=fuz}`)."
msgstr ""

#: src/project/changelog.md:820
msgid "Some significant changes regarding SQL dialects:"
msgstr ""

#: src/project/changelog.md:821
msgid ""
"Operators and functions can be defined on per-dialect basis. (@aljazerzen, "
"\\#2681)"
msgstr ""

#: src/project/changelog.md:823
msgid ""
"_Breaking_: The `sql.duckdb` target supports DuckDB 0.8 (@eitsupi, #2810)."
msgstr ""

#: src/project/changelog.md:824
msgid "_Breaking_: The `sql.hive` target is removed (@eitsupi, #2837)."
msgstr ""

#: src/project/changelog.md:826
msgid ""
"New arithmetic operators. These compile to different function or operator "
"depending on the target."
msgstr ""

#: src/project/changelog.md:828
msgid ""
"_Breaking_: Operator `/` now always performs floating division (@aljazerzen, "
"\\#2684). See the [Division docs](https://prql-lang.org/book/reference/"
"syntax/operators.html#division-and-integer-division) for details."
msgstr ""

#: src/project/changelog.md:833
msgid ""
"Truncated integer division operator `//` (@aljazerzen, #2684). See the "
"[Division docs](https://prql-lang.org/book/reference/syntax/operators."
"html#division-and-integer-division) for details."
msgstr ""

#: src/project/changelog.md:837
msgid "Regex search operator `~=` (@max-sixty, #2458). An example:"
msgstr ""

#: src/project/changelog.md:839
msgid ""
"```prql no-eval\n"
"from tracks\n"
"filter (name ~= \"Love\")\n"
"```"
msgstr ""

#: src/project/changelog.md:844
msgid "...compiles to;"
msgstr ""

#: src/project/changelog.md:852
msgid "'Love'"
msgstr ""

#: src/project/changelog.md:855
msgid ""
"...though the exact form differs by dialect; see the [Regex docs](https://"
"prql-lang.org/book/reference/syntax/operators.html#regex) for more details."
msgstr ""

#: src/project/changelog.md:859
msgid ""
"New aggregation functions: `every`, `any`, `average`, and `concat_array`. "
"_Breaking:_ Remove `avg` in favor of `average`."
msgstr ""

#: src/project/changelog.md:862
msgid ""
"_Breaking:_ We've changed our function declaration syntax to match other "
"declarations. Functions were one of the first language constructs in PRQL, "
"and since then we've added normal declarations there's no compelling reason "
"for functions to be different."
msgstr ""

#: src/project/changelog.md:871
msgid "Previously, this was:"
msgstr ""

#: src/project/changelog.md:877
msgid ""
"Experimental modules, which allow importing declarations from other files. "
"Docs are forthcoming."
msgstr ""

#: src/project/changelog.md:880
msgid ""
"Relation literals create a relation (a \"table\") as an _array_ of _tuples_. "
"This example demonstrates the new syntax for arrays `[]` and tuples `{}`. "
"(@aljazerzen, #2605)"
msgstr ""

#: src/project/changelog.md:890
msgid ""
"`this` can be used to refer to the current pipeline, for situations where "
"plain column name would be ambiguous:"
msgstr ""

#: src/project/changelog.md:899
msgid ""
"Within a `join` transform, there is also a reference to the right relation: "
"`that`."
msgstr ""

#: src/project/changelog.md:902
msgid ""
"_Breaking:_ functions `count`, `rank` and `row_number` now require an "
"argument of the array to operate on. In most cases you can directly replace "
"`count` with `count this`. The `non_null` argument of `count` has been "
"removed."
msgstr ""

#: src/project/changelog.md:908
msgid "We've changed how we handle colors."
msgstr ""

#: src/project/changelog.md:910
msgid ""
"`Options::color` is deprecated and has no effect. Code which consumes "
"`prql_compiler::compile` should instead accept the output with colors and "
"use a library such as `anstream` to handle the presentation of colors. To "
"ensure minimal disruption, `prql_compiler` will currently strip color codes "
"when a standard environment variable such as `CLI_COLOR=0` is set or when it "
"detects `stderr` is not a TTY."
msgstr ""

#: src/project/changelog.md:917
msgid ""
"We now use the [`anstream`](https://github.com/rust-cli/anstyle) library in "
"`prqlc` & `prql-compiler`."
msgstr ""

#: src/project/changelog.md:920
msgid "(@max-sixty, #2773)"
msgstr ""

#: src/project/changelog.md:922
msgid ""
"`prqlc` can now show backtraces when the standard backtrace env var "
"(`RUST_BACKTRACE`) is active. (@max-sixty, #2751)"
msgstr ""

#: src/project/changelog.md:927
msgid ""
"Numbers expressed with scientific notation — `1e9` — are now handled "
"correctly by the compiler (@max-sixty, #2865)."
msgstr ""

#: src/project/changelog.md:932
msgid "prql-python now provides type hints (@philpep, #2912)"
msgstr ""

#: src/project/changelog.md:936
msgid ""
"Annotations in PRQL. These have limited support but are currently used to "
"specify binding strengths. They're modeled after Rust's annotations, but "
"with `@` syntax, more similar to traditional decorators. (#2729)"
msgstr ""

#: src/project/changelog.md:940
msgid ""
"```prql no-eval\n"
"@{binding_strength=11}\n"
"let mod = l r -> s\"{l} % {r}\"\n"
"```"
msgstr ""

#: src/project/changelog.md:945
msgid ""
"Remove BigQuery's special handling of quoted identifiers, now that our "
"module system handles its semantics (@max-sixty, #2609)."
msgstr ""

#: src/project/changelog.md:948
msgid "ClickHouse is tested in CI (@eitsupi, #2815)."
msgstr ""

#: src/project/changelog.md:952
msgid "@maxmcd, with #2533"
msgstr ""

#: src/project/changelog.md:953
msgid "@khoa165, with #2876"
msgstr ""

#: src/project/changelog.md:954
msgid "@philpep, with #2912"
msgstr ""

#: src/project/changelog.md:955
msgid "@not-my-profile, with #2971"
msgstr ""

#: src/project/changelog.md:957
msgid "0.8.1 — 2023-04-29"
msgstr ""

#: src/project/changelog.md:959
msgid ""
"0.8.1 is a small release with a new `list-targets` command in `prqlc`, some "
"documentation improvements, and some internal improvements."
msgstr ""

#: src/project/changelog.md:962
msgid "This release has 41 commits from 8 contributors."
msgstr ""

#: src/project/changelog.md:964
msgid ""
"From the broader perspective of the project, we're increasing the relative "
"prioritization of it being easy for folks to actually use PRQL — either with "
"existing tools, or a tool we'd build. We'll be thinking about & discussing "
"the best way to do that over the next few weeks."
msgstr ""

#: src/project/changelog.md:969
msgid "0.8.0 — 2023-04-14"
msgstr ""

#: src/project/changelog.md:971
msgid ""
"0.8.0 renames the `and` & `or` operators to `&&` & `||` respectively, "
"reorganizes the Syntax section in the book, and introduces `read_parquet` & "
"`read_csv` functions for reading files with DuckDB."
msgstr ""

#: src/project/changelog.md:975
msgid "This release has 38 commits from 8 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:979
msgid ""
"Rename `and` to `&&` and `or` to `||`. Operators which are symbols are now "
"consistently infix, while \"words\" are now consistently functions "
"(@aljazerzen, \\#2422)."
msgstr ""

#: src/project/changelog.md:983
msgid ""
"New functions `read_parquet` and `read_csv`, which mirror the DuckDB "
"functions, instructing the database to read from files (@max-sixty, #2409)."
msgstr ""

#: src/project/changelog.md:986
msgid "0.7.1 — 2023-04-03"
msgstr ""

#: src/project/changelog.md:988
msgid ""
"0.7.1 is a hotfix release to fix `prql-js`'s `npm install` behavior when "
"being installed as a dependency."
msgstr ""

#: src/project/changelog.md:991
msgid "This release has 17 commits from 4 contributors."
msgstr ""

#: src/project/changelog.md:993
msgid "0.7.0 — 2023-04-01"
msgstr ""

#: src/project/changelog.md:995
msgid ""
"0.7.0 is a fairly small release in terms of new features, with lots of "
"internal improvements, such as integration tests with a whole range of DBs, "
"a blog post on Pi day, RFCs for a type system, and more robust language "
"bindings."
msgstr ""

#: src/project/changelog.md:999
msgid ""
"There's a very small breaking change to the Rust API, hence the minor "
"version bump."
msgstr ""

#: src/project/changelog.md:1002
msgid ""
"Here's our April 2023 Update, from our [Readme](https://github.com/PRQL/prql/"
"blob/main/README.md):"
msgstr ""

#: src/project/changelog.md:1005
msgid "April 2023 update"
msgstr ""

#: src/project/changelog.md:1007
msgid ""
"PRQL is being actively developed by a growing community. It's ready to use "
"by the intrepid, either as part of one of our supported extensions, or "
"within your own tools, using one of our supported language bindings."
msgstr ""

#: src/project/changelog.md:1011
msgid ""
"PRQL still has some minor bugs and some missing features, and probably is "
"only ready to be rolled out to non-technical teams for fairly simple queries."
msgstr ""

#: src/project/changelog.md:1014
msgid ""
"Here's our current [Roadmap](https://prql-lang.org/roadmap/) and our "
"[Milestones.](https://github.com/PRQL/prql/milestones)"
msgstr ""

#: src/project/changelog.md:1017
msgid "Our immediate focus for the code is on:"
msgstr ""

#: src/project/changelog.md:1019
msgid ""
"Building out the next few big features, including [types](https://github.com/"
"PRQL/prql/pull/1964) and [modules](https://github.com/PRQL/prql/pull/2129)."
msgstr ""

#: src/project/changelog.md:1022
msgid ""
"Ensuring our supported features feel extremely robust; resolving any "
"[priority bugs](https://github.com/PRQL/prql/issues?"
"q=is%3Aissue+is%3Aopen+label%3Abug+label%3Apriority)."
msgstr ""

#: src/project/changelog.md:1025
msgid "We're also spending time thinking about:"
msgstr ""

#: src/project/changelog.md:1027
msgid ""
"Making it really easy to start using PRQL. We're doing that by building "
"integrations with tools that folks already use; for example our VS Code "
"extension & Jupyter integration. If there are tools you're familiar with "
"that you think would be open to integrating with PRQL, please let us know in "
"an issue."
msgstr ""

#: src/project/changelog.md:1032
msgid ""
"Making it easier to contribute to the compiler. We have a wide group of "
"contributors to the project, but contributions to the compiler itself are "
"quite concentrated. We're keen to expand this; [\\#1840](https://github.com/"
"PRQL/prql/issues/1840) for feedback."
msgstr ""

#: src/project/changelog.md:1039
msgid ""
"The release has 131 commits from 10 contributors. Particular credit goes to "
"to @eitsupi & @jelenkee, who have made significant contributions, and "
"@vanillajonathan, whose prolific contribution include our growing language "
"bindings."
msgstr ""

#: src/project/changelog.md:1048
msgid ""
"`prqlc compile` adds `--color` & `--include-signature-comment` options. "
"(@max-sixty, #2267)"
msgstr ""

#: src/project/changelog.md:1053
msgid ""
"Added the PRQL snippets from the book to the [Playground](https://prql-lang."
"org/playground/) (@jelenkee, #2197)"
msgstr ""

#: src/project/changelog.md:1058
msgid ""
"_Breaking_: The `compile` function's `Options` now includes a `color` "
"member, which determines whether error messages use ANSI color codes. This "
"is technically a breaking change to the API. (@max-sixty, #2251)"
msgstr ""

#: src/project/changelog.md:1061
msgid ""
"The `Error` struct now exposes the `MessageKind` enum. (@vanillajonathan, "
"\\#2307)"
msgstr ""

#: src/project/changelog.md:1063
msgid ""
"Integration tests run in CI with DuckDB, SQLite, PostgreSQL, MySQL and SQL "
"Server (@jelenkee, #2286)"
msgstr ""

#: src/project/changelog.md:1068
msgid "@k-nut, with #2294"
msgstr ""

#: src/project/changelog.md:1070
msgid "0.6.1 — 2023-03-12"
msgstr ""

#: src/project/changelog.md:1072
msgid ""
"0.6.1 is a small release containing an internal refactoring and improved "
"bindings for C, PHP & .NET."
msgstr ""

#: src/project/changelog.md:1075
msgid "This release has 54 commits from 6 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:1079
msgid ""
"No longer incorrectly compile to `DISTINCT` when a `take 1` refers to a "
"different set of columns than are in the `group`. (@max-sixty, with thanks "
"to @cottrell, #2109)"
msgstr ""

#: src/project/changelog.md:1082
msgid ""
"The version specification of the dependency Chumsky was bumped from `0.9.0` "
"to `0.9.2`. `0.9.0` has a bug that causes an infinite loop. (@eitsupi, #2110)"
msgstr ""

#: src/project/changelog.md:1087
msgid ""
"Add a policy for which bindings are supported / unsupported / nascent. See "
"<https://prql-lang.org/book/project/bindings/index.html> for more details "
"(@max-sixty, #2062) (@max-sixty, #2062)"
msgstr ""

#: src/project/changelog.md:1093
msgid "\\[prql-lib\\] Added C++ header file. (@vanillajonathan, #2126)"
msgstr ""

#: src/project/changelog.md:1097
msgid ""
"Many of the items that were in the root of the repo have been aggregated "
"into `web` & `bindings`, simplifying the repo's structure. There's also "
"`grammars` & `packages` (@max-sixty, #2135, #2117, #2121)."
msgstr ""

#: src/project/changelog.md:1101
msgid "0.6.0 — 2023-03-08"
msgstr ""

#: src/project/changelog.md:1103
msgid ""
"0.6.0 introduces a rewritten parser, giving us the ability to dramatically "
"improve error messages, renames `switch` to `case` and includes lots of "
"minor improvements and fixes. It also introduces `loop`, which compiles to "
"`WITH RECURSIVE`, as a highly experimental feature."
msgstr ""

#: src/project/changelog.md:1108
msgid ""
"There are a few cases of breaking changes, including switching `switch` to "
"`case`, in case that's confusing. There are also some minor parsing changes "
"outlined below."
msgstr ""

#: src/project/changelog.md:1112
msgid "This release has 108 commits from 11 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:1116
msgid ""
"Add a (highly experimental) `loop` language feature, which translates to "
"`WITH RECURSIVE`. We expect changes and refinements in upcoming releases. "
"(#1642, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1119
msgid ""
"Rename the experimental `switch` function to `case` given it more closely "
"matches the traditional semantics of `case`. (@max-sixty, #2036)"
msgstr ""

#: src/project/changelog.md:1121
msgid ""
"Change the `case` syntax to use `=>` instead of `->` to distinguish it from "
"function syntax."
msgstr ""

#: src/project/changelog.md:1123
msgid "Convert parser from pest to Chumsky (@aljazerzen, #1818)"
msgstr ""

#: src/project/changelog.md:1124
msgid ""
"Improved error messages, and the potential to make even better in the "
"future. Many of these improvements come from error recovery."
msgstr ""

#: src/project/changelog.md:1126
msgid "String escapes (`\\n \\t`)."
msgstr ""

#: src/project/changelog.md:1127
msgid "Raw strings that don't escape backslashes."
msgstr ""

#: src/project/changelog.md:1128
msgid ""
"String interpolations can only contain identifiers and not any expression."
msgstr ""

#: src/project/changelog.md:1129
msgid ""
"Operator associativity has been changed from right-to-left to left-to-right "
"to be more similar to other conventional languages."
msgstr ""

#: src/project/changelog.md:1131
msgid ""
"`and` now has a higher precedence than `or` (of same reason as the previous "
"point)."
msgstr ""

#: src/project/changelog.md:1133
msgid "Dates, times and timestamps have stricter parsing rules."
msgstr ""

#: src/project/changelog.md:1134
msgid "`let`, `func`, `prql`, `case` are now treated as keywords."
msgstr ""

#: src/project/changelog.md:1135
msgid "Float literals without fraction part are not allowed anymore (`1.`)."
msgstr ""

#: src/project/changelog.md:1136
msgid ""
"Add a `--format` option to `prqlc parse` which can return the AST in YAML "
"(@max-sixty, #1962)"
msgstr ""

#: src/project/changelog.md:1138
msgid "Add a new subcommand `prqlc jinja`. (@aljazerzen, #1722)"
msgstr ""

#: src/project/changelog.md:1139
msgid ""
"_Breaking_: prql-compiler no longer passes text containing `{{` & `}}` "
"through to the output. (@aljazerzen, #1722)"
msgstr ""

#: src/project/changelog.md:1142
msgid "For example, the following PRQL query"
msgstr ""

#: src/project/changelog.md:1148
msgid ""
"was compiled to the following SQL previously, but now it raises an error."
msgstr ""

#: src/project/changelog.md:1157
msgid "This pass-through feature existed for integration with dbt."
msgstr ""

#: src/project/changelog.md:1159
msgid ""
"We're again considering how to best integrate with dbt, and this change is "
"based on the idea that the jinja macro should run before the PRQL compiler."
msgstr ""

#: src/project/changelog.md:1162
msgid ""
"If you're interested in dbt integration, subscribe or 👍 to <https://github."
"com/dbt-labs/dbt-core/pull/5982>."
msgstr ""

#: src/project/changelog.md:1165
msgid ""
"A new compile target `\"sql.any\"`. When `\"sql.any\"` is used as the target "
"of the compile function's option, the target contained in the query header "
"will be used. (@aljazerzen, #1995)"
msgstr ""

#: src/project/changelog.md:1168
msgid "Support for SQL parameters with similar syntax (#1957, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1169
msgid ""
"Allow `:` to be elided in timezones, such as `0800` in "
"`@2020-01-01T13:19:55-0800` (@max-sixty, #1991)."
msgstr ""

#: src/project/changelog.md:1171
msgid ""
"Add `std.upper` and `std.lower` functions for changing string casing "
"(@Jelenkee, #2019)."
msgstr ""

#: src/project/changelog.md:1176
msgid ""
"`prqlc compile` returns a non-zero exit code for invalid queries. (@max-"
"sixty, \\#1924)"
msgstr ""

#: src/project/changelog.md:1178
msgid ""
"Identifiers can contain any alphabetic unicode characters (@max-sixty, #2003)"
msgstr ""

#: src/project/changelog.md:1182
msgid "Operator precedence (@aljazerzen, #1818)"
msgstr ""

#: src/project/changelog.md:1183
msgid ""
"Error messages for invalid queries are displayed in the book (@max-sixty, "
"\\#2015)"
msgstr ""

#: src/project/changelog.md:1188
msgid "\\[prql-php\\] Added PHP bindings. (@vanillajonathan, #1860)"
msgstr ""

#: src/project/changelog.md:1189
msgid "\\[prql-dotnet\\] Added .NET bindings. (@vanillajonathan, #1917)"
msgstr ""

#: src/project/changelog.md:1190
msgid "\\[prql-lib\\] Added C header file. (@vanillajonathan, #1879)"
msgstr ""

#: src/project/changelog.md:1191
msgid ""
"Added a workflow building a `.deb` on each release. (Note that it's not yet "
"published on each release). (@vanillajonathan, #1883)"
msgstr ""

#: src/project/changelog.md:1193
msgid ""
"Added a workflow building a `.rpm` on each release. (Note that it's not yet "
"published on each release). (@vanillajonathan, #1918)"
msgstr ""

#: src/project/changelog.md:1195
msgid ""
"Added a workflow building a Snap package on each release. (@vanillajonathan, "
"\\#1881)"
msgstr ""

#: src/project/changelog.md:1200
msgid ""
"Test that the output of our nascent autoformatter can be successfully "
"compiled into SQL. Failing examples are now clearly labeled. (@max-sixty, "
"#2016)"
msgstr ""

#: src/project/changelog.md:1202
msgid ""
"Definition files have been added to configure [Dev Containers](https://"
"containers.dev/) for Rust development environment. (@eitsupi, #1893, #2025, "
"#2028)"
msgstr ""

#: src/project/changelog.md:1208
msgid "@linux-china, with #1971"
msgstr ""

#: src/project/changelog.md:1209
msgid "@Jelenkee, with #2019"
msgstr ""

#: src/project/changelog.md:1211
msgid "0.5.2 — 2023-02-18"
msgstr ""

#: src/project/changelog.md:1213
msgid ""
"0.5.2 is a tiny release to fix an build issue in yesterday's `prql-js` 0.5.1 "
"release."
msgstr ""

#: src/project/changelog.md:1216
msgid "This release has 7 commits from 2 contributors."
msgstr ""

#: src/project/changelog.md:1220
msgid "@matthias-Q, with #1873"
msgstr ""

#: src/project/changelog.md:1222
msgid "0.5.1 — 2023-02-17"
msgstr ""

#: src/project/changelog.md:1224
msgid ""
"0.5.1 contains a few fixes, and another change to how bindings handle "
"default target / dialects."
msgstr ""

#: src/project/changelog.md:1227
msgid "This release has 53 commits from 7 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:1231
msgid ""
"Delegate dividing literal integers to the DB. Previously integer division "
"was executed during PRQL compilation, which could be confusing given that "
"behavior is different across DBs. Other arithmetic operations are still "
"executed during compilation. (@max-sixty, #1747)"
msgstr ""

#: src/project/changelog.md:1238
msgid "Add docs on the `from_text` transform (@max-sixty, #1756)"
msgstr ""

#: src/project/changelog.md:1242
msgid ""
"\\[prql-js\\] Default compile target changed from `Sql(Generic)` to "
"`Sql(None)`. (@eitsupi, #1856)"
msgstr ""

#: src/project/changelog.md:1244
msgid ""
"\\[prql-python\\] Compilation options can now be specified from Python. "
"(@eitsupi, \\#1807)"
msgstr ""

#: src/project/changelog.md:1246
msgid ""
"\\[prql-python\\] Default compile target changed from `Sql(Generic)` to "
"`Sql(None)`. (@eitsupi, #1861)"
msgstr ""

#: src/project/changelog.md:1251
msgid "@vanillajonathan, with #1766"
msgstr ""

#: src/project/changelog.md:1253
msgid "0.5.0 — 2023-02-08"
msgstr ""

#: src/project/changelog.md:1255
msgid ""
"0.5.0 contains a few fixes, some improvements to bindings, lots of docs "
"improvements, and some work on forthcoming features. It contains one "
"breaking change in the compiler's `Options` interface."
msgstr ""

#: src/project/changelog.md:1259
msgid "This release has 74 commits from 12 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:1263
msgid ""
"Change public API to use target instead of dialect in preparation for "
"feature work (@aljazerzen, #1684)"
msgstr ""

#: src/project/changelog.md:1266
msgid ""
"`prqlc watch` command which watches filesystem for changes and compiles ."
"prql files to .sql (@aljazerzen, #1708)"
msgstr ""

#: src/project/changelog.md:1271
msgid ""
"Support double brackets in s-strings which aren't symmetric (@max-sixty, "
"\\#1650)"
msgstr ""

#: src/project/changelog.md:1273
msgid "Support Postgres's Interval syntax (@max-sixty, #1649)"
msgstr ""

#: src/project/changelog.md:1274
msgid "Fixed tests for `prql-elixir` with macOS (@kasvith, #1707)"
msgstr ""

#: src/project/changelog.md:1278
msgid ""
"Add a documentation test for prql-compiler, update prql-compiler README, and "
"include the README in the prql book section for Rust bindings. The code "
"examples in the README are included and tested as doctests in the prql-"
"compiler (@nkicg6, #1679)"
msgstr ""

#: src/project/changelog.md:1285
msgid ""
"Add tests for all PRQL website examples to prql-python to ensure compiled "
"results match expected SQL (@nkicg6, #1719)"
msgstr ""

#: src/project/changelog.md:1290
msgid "@ruslandoga, with #1628"
msgstr ""

#: src/project/changelog.md:1291
msgid "@RalfNorthman, with #1632"
msgstr ""

#: src/project/changelog.md:1292
msgid "@nicot, with #1662"
msgstr ""

#: src/project/changelog.md:1294
msgid "0.4.2 — 2023-01-25"
msgstr ""

#: src/project/changelog.md:1298
msgid ""
"New `from_text format-arg string-arg` function that supports JSON and CSV "
"formats. _format-arg_ can be `format:csv` or `format:json`. _string-arg_ can "
"be a string in any format. (@aljazerzen & @snth, #1514)"
msgstr ""

#: src/project/changelog.md:1302
msgid ""
"```prql no-eval\n"
"from_text format:csv \"\"\"\n"
"a,b,c\n"
"1,2,3\n"
"4,5,6\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/project/changelog.md:1310
msgid ""
"```prql no-eval\n"
"from_text format:json '''\n"
"    [{\"a\": 1, \"b\": \"x\", \"c\": false }, {\"a\": 4, \"b\": \"y\", "
"\"c\": null }]\n"
"'''\n"
"```"
msgstr ""

#: src/project/changelog.md:1316
msgid ""
"```prql no-eval\n"
"from_text format:json '''{\n"
"    \"columns\": [\"a\", \"b\", \"c\"],\n"
"    \"data\": [\n"
"        [1, \"x\", false],\n"
"        [4, \"y\", null]\n"
"    ]\n"
"}'''\n"
"```"
msgstr ""

#: src/project/changelog.md:1326
msgid "For now, the argument is limited to string constants."
msgstr ""

#: src/project/changelog.md:1328
msgid "**Fixes**"
msgstr ""

#: src/project/changelog.md:1330
msgid "Export constructor for SQLCompileOptions (@bcho, #1621)"
msgstr ""

#: src/project/changelog.md:1331
msgid "Remove backticks in count_distinct (@aljazerzen, #1611)"
msgstr ""

#: src/project/changelog.md:1333
msgid "**New Contributors**"
msgstr ""

#: src/project/changelog.md:1335
msgid "@1Kinoti, with #1596"
msgstr ""

#: src/project/changelog.md:1336
msgid "@veenaamb, with #1614"
msgstr ""

#: src/project/changelog.md:1338
msgid "0.4.1 — 2023-01-18"
msgstr ""

#: src/project/changelog.md:1340
msgid ""
"0.4.1 comes a few days after 0.4.0, with a couple of features and the "
"release of `prqlc`, the CLI crate."
msgstr ""

#: src/project/changelog.md:1343
msgid "0.4.1 has 35 commits from 6 contributors."
msgstr ""

#: src/project/changelog.md:1347
msgid "Inferred column names include the relation name (@aljazerzen, #1550):"
msgstr ""

#: src/project/changelog.md:1355
msgid ""
"Quoted identifiers such as `dir/*.parquet` are passed through to SQL. (@max-"
"sixty, #1516)."
msgstr ""

#: src/project/changelog.md:1358
msgid ""
"The CLI is installed with `cargo install prqlc`. The binary was renamed in "
"0.4.0 but required an additional `--features` flag, which has been removed "
"in favor of this new crate (@max-sixty & @aljazerzen, #1549)."
msgstr ""

#: src/project/changelog.md:1364
msgid "@fool1280, with #1554"
msgstr ""

#: src/project/changelog.md:1365
msgid "@nkicg6, with #1567"
msgstr ""

#: src/project/changelog.md:1367
msgid "0.4.0 — 2023-01-15"
msgstr ""

#: src/project/changelog.md:1369
msgid ""
"0.4.0 brings lots of new features including `case`, `select ![]` and numbers "
"with underscores. We have initial (unpublished) bindings to Elixir. And "
"there's the usual improvements to fixes & documentation (only a minority are "
"listed below in this release)."
msgstr ""

#: src/project/changelog.md:1374
msgid ""
"0.4.0 also has some breaking changes: `table` is `let`, `dialect` is renamed "
"to `target`, and the compiler's API has changed. Full details below."
msgstr ""

#: src/project/changelog.md:1379
msgid ""
"Defining a temporary table is now expressed as `let` rather than `table` "
"(@aljazerzen, #1315). See the [tables docs](https://prql-lang.org/book/"
"reference/declarations/variables.html) for details."
msgstr ""

#: src/project/changelog.md:1384
msgid ""
"_Experimental:_ The [`case`](https://prql-lang.org/book/reference/syntax/"
"case.html) function sets a variable to a value based on one of several "
"expressions (@aljazerzen, \\#1278)."
msgstr ""

#: src/project/changelog.md:1389
msgid ""
"```prql no-eval\n"
"derive var = case [\n"
"  score <= 10 -> \"low\",\n"
"  score <= 30 -> \"medium\",\n"
"  score <= 70 -> \"high\",\n"
"  true -> \"very high\",\n"
"]\n"
"```"
msgstr ""

#: src/project/changelog.md:1398
msgid "...compiles to:"
msgstr ""

#: src/project/changelog.md:1404
msgid "'low'"
msgstr ""

#: src/project/changelog.md:1405
msgid "'medium'"
msgstr ""

#: src/project/changelog.md:1406
msgid "'high'"
msgstr ""

#: src/project/changelog.md:1407
msgid "'very high'"
msgstr ""

#: src/project/changelog.md:1413
msgid ""
"Check out the [`case` docs](https://prql-lang.org/book/reference/syntax/case."
"html) for more details."
msgstr ""

#: src/project/changelog.md:1417
msgid ""
"_Experimental:_ Columns can be excluded by name with `select` (@aljazerzen, "
"\\#1329)"
msgstr ""

#: src/project/changelog.md:1425
msgid ""
"_Experimental:_ `append` transform, equivalent to `UNION ALL` in SQL. "
"(@aljazerzen, #894)"
msgstr ""

#: src/project/changelog.md:1433
msgid ""
"Check out the [`append` docs](https://prql-lang.org/book/reference/stdlib/"
"transforms/append.html) for more details."
msgstr ""

#: src/project/changelog.md:1437
msgid ""
"Numbers can contain underscores, which can make reading long numbers easier "
"(@max-sixty, #1467):"
msgstr ""

#: src/project/changelog.md:1448
msgid ""
"The SQL output contains a comment with the PRQL compiler version "
"(@aljazerzen, \\#1322)"
msgstr ""

#: src/project/changelog.md:1450
msgid ""
"`dialect` is renamed to `target`, and its values are prefixed with `sql.` "
"(@max-sixty, #1388); for example:"
msgstr ""

#: src/project/changelog.md:1459
msgid ""
"This gives us the flexibility to target other languages than SQL in the long "
"term."
msgstr ""

#: src/project/changelog.md:1462
msgid ""
"Tables definitions can contain a bare s-string (@max-sixty, #1422), which "
"enables us to include a full CTE of SQL, for example:"
msgstr ""

#: src/project/changelog.md:1465
msgid ""
"```prql no-eval\n"
"let grouping = s\"\"\"\n"
"  SELECT SUM(a)\n"
"  FROM tbl\n"
"  GROUP BY\n"
"    GROUPING SETS\n"
"    ((b, c, d), (d), (b, d))\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/project/changelog.md:1475
msgid "Ranges supplied to `in` can be half-open (@aljazerzen, #1330)."
msgstr ""

#: src/project/changelog.md:1477
msgid ""
"The crate's external API has changed to allow for compiling to intermediate "
"representation. This also affects bindings. See [`prql-compiler` docs]"
"(https://docs.rs/prql-compiler/latest/prql_compiler/) for more details."
msgstr ""

#: src/project/changelog.md:1484
msgid "\\[This release, the changelog only contains a subset of fixes\\]"
msgstr ""

#: src/project/changelog.md:1486
msgid "Allow interpolations in table s-strings (@aljazerzen, #1337)"
msgstr ""

#: src/project/changelog.md:1490
msgid ""
"\\[This release, the changelog only contains a subset of documentation "
"improvements\\]"
msgstr ""

#: src/project/changelog.md:1493
msgid ""
"Add docs on aliases in [Select](https://prql-lang.org/book/reference/stdlib/"
"transforms/select.html)"
msgstr ""

#: src/project/changelog.md:1495
msgid "Add JS template literal and multiline example (@BCsabaEngine, #1432)"
msgstr ""

#: src/project/changelog.md:1496
msgid "JS template literal and multiline example (@BCsabaEngine, #1432)"
msgstr ""

#: src/project/changelog.md:1497
msgid "Improve prql-compiler docs & examples (@aljazerzen, #1515)"
msgstr ""

#: src/project/changelog.md:1498
msgid "Fix string highlighting in book (@max-sixty, #1264)"
msgstr ""

#: src/project/changelog.md:1502
msgid ""
"The playground allows querying some sample data. As before, the result "
"updates on every keystroke. (@aljazerzen, #1305)"
msgstr ""

#: src/project/changelog.md:1507
msgid ""
"\\[This release, the changelog only contains a subset of integration "
"improvements\\]"
msgstr ""

#: src/project/changelog.md:1509
msgid ""
"Added Elixir integration exposing PRQL functions as NIFs (#1500, @kasvith)"
msgstr ""

#: src/project/changelog.md:1510
msgid "Exposed Elixir flavor with exceptions (#1513, @kasvith)"
msgstr ""

#: src/project/changelog.md:1511
msgid "Rename `prql-compiler` binary to `prqlc` (@aljazerzen #1515)"
msgstr ""

#: src/project/changelog.md:1515
msgid ""
"\\[This release, the changelog only contains a subset of internal changes\\]"
msgstr ""

#: src/project/changelog.md:1517
msgid "Add parsing for negative select (@max-sixty, #1317)"
msgstr ""

#: src/project/changelog.md:1518
msgid "Allow for additional builtin functions (@aljazerzen, #1325)"
msgstr ""

#: src/project/changelog.md:1519
msgid "Add an automated check for typos (@max-sixty, #1421)"
msgstr ""

#: src/project/changelog.md:1520
msgid "Add tasks for running playground & book (@max-sixty, #1265)"
msgstr ""

#: src/project/changelog.md:1521
msgid "Add tasks for running tests on every file change (@max-sixty, #1380)"
msgstr ""

#: src/project/changelog.md:1523
msgid "**New contributors**:"
msgstr ""

#: src/project/changelog.md:1525
msgid "@EArazli, with #1359"
msgstr ""

#: src/project/changelog.md:1526
msgid "@boramalper, with #1362"
msgstr ""

#: src/project/changelog.md:1527
msgid "@allurefx, with #1377"
msgstr ""

#: src/project/changelog.md:1528
msgid "@bcho, with #1375"
msgstr ""

#: src/project/changelog.md:1529
msgid "@JettChenT, with #1385"
msgstr ""

#: src/project/changelog.md:1530
msgid "@BlurrechDev, with #1411"
msgstr ""

#: src/project/changelog.md:1531
msgid "@BCsabaEngine, with #1432"
msgstr ""

#: src/project/changelog.md:1532
msgid "@kasvith, with #1500"
msgstr ""

#: src/project/changelog.md:1534
msgid "0.3.1 - 2022-12-03"
msgstr ""

#: src/project/changelog.md:1536
msgid "0.3.1 brings a couple of small improvements and fixes."
msgstr ""

#: src/project/changelog.md:1540
msgid "Support for using s-strings for `from` (#1197, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1542
msgid ""
"```prql no-eval\n"
"from s\"SELECT * FROM employees WHERE foo > 5\"\n"
"```"
msgstr ""

#: src/project/changelog.md:1546
msgid ""
"Helpful error message when referencing a table in an s-string (#1203, "
"@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1551
msgid "Multiple columns with same name created (#1211, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1552
msgid "Renaming via select breaks preceding sorting (#1204, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1553
msgid "Same column gets selected multiple times (#1186, @mklopets)"
msgstr ""

#: src/project/changelog.md:1557
msgid ""
"Update Github Actions and Workflows to current version numbers (and avoid "
"using Node 12)"
msgstr ""

#: src/project/changelog.md:1560
msgid "0.3.0 — 2022-11-29"
msgstr ""

#: src/project/changelog.md:1562
msgid ""
"🎉 0.3.0 is the biggest ever change in PRQL's compiler, rewriting much of "
"the internals: the compiler now has a semantic understanding of expressions, "
"including resolving names & building a DAG of column lineage 🎉."
msgstr ""

#: src/project/changelog.md:1566
msgid ""
"While the immediate changes to the language are modest — some long-running "
"bugs are fixed — this unlocks the development of many of the project's long-"
"term priorities, such as type-checking & auto-complete. And it simplifies "
"the building of our next language features, such as match-case expressions, "
"unions & table expressions."
msgstr ""

#: src/project/changelog.md:1572
msgid ""
"@aljazerzen has (mostly single-handedly) done this work over the past few "
"months. The project owes him immense appreciation."
msgstr ""

#: src/project/changelog.md:1575
msgid "**Breaking changes**:"
msgstr ""

#: src/project/changelog.md:1577
msgid "We've had to make some modest breaking changes for 0.3:"
msgstr ""

#: src/project/changelog.md:1579
msgid ""
"_Pipelines must start with `from`_. For example, a pipeline with only "
"`derive foo = 5`, with no `from` transform, is no longer valid. Depending on "
"demand for this feature, it would be possible to add this back."
msgstr ""

#: src/project/changelog.md:1583
msgid ""
"_Shared column names now require `==` in a join_. The existing approach is "
"ambiguous to the compiler — `id` in the following example could be a boolean "
"column."
msgstr ""

#: src/project/changelog.md:1593
msgid ""
"_Table references containing periods must be surrounded by backticks_. For "
"example, when referencing a schema name:"
msgstr ""

#: src/project/changelog.md:1603
msgid "Change self equality op to `==` (#1176, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1604
msgid "Add logging (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1605
msgid "Add clickhouse dialect (#1090, @max-sixty)"
msgstr ""

#: src/project/changelog.md:1606
msgid "Allow namespaces & tables to contain `.` (#1079, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1610
msgid ""
"Deduplicate column appearing in `SELECT` multiple times (#1186, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1611
msgid "Fix uppercase table names (#1184, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1612
msgid "Omit table name when only one ident in SELECT (#1094, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1616
msgid "Add chapter on semantics' internals (@aljazerzen, #1028)"
msgstr ""

#: src/project/changelog.md:1617
msgid "Add note about nesting variables in s-strings (@max-sixty, #1163)"
msgstr ""

#: src/project/changelog.md:1621
msgid "Flatten group and window (#1120, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1622
msgid "Split ast into expr and stmt (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1623
msgid "Refactor associativity (#1156, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1624
msgid "Rename Ident constructor to `from_name` (#1084, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1625
msgid "Refactor rq folding (#1177, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1626
msgid "Add tests for reported bugs fixes in semantic (#1174, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1627
msgid "Bump duckdb from 0.5.0 to 0.6.0 (#1132)"
msgstr ""

#: src/project/changelog.md:1628
msgid "Bump once_cell from 1.15.0 to 1.16.0 (#1101)"
msgstr ""

#: src/project/changelog.md:1629
msgid "Bump pest from 2.4.0 to 2.5.0 (#1161)"
msgstr ""

#: src/project/changelog.md:1630
msgid "Bump pest_derive from 2.4.0 to 2.5.0 (#1179)"
msgstr ""

#: src/project/changelog.md:1631
msgid "Bump sqlparser from 0.25.0 to 0.27.0 (#1131)"
msgstr ""

#: src/project/changelog.md:1632
msgid "Bump trash from 2.1.5 to 3.0.0 (#1178)"
msgstr ""

#: src/project/changelog.md:1634
msgid "0.2.11 — 2022-11-20"
msgstr ""

#: src/project/changelog.md:1636
msgid "0.2.11 contains a few helpful fixes."
msgstr ""

#: src/project/changelog.md:1638
msgid ""
"Work continues on our `semantic` refactor — look out for 0.3.0 soon! Many "
"thanks to @aljazerzen for his continued contributions to this."
msgstr ""

#: src/project/changelog.md:1641
msgid ""
"Note: 0.2.10 was skipped due to this maintainer's inability to read his own "
"docs on bumping versions..."
msgstr ""

#: src/project/changelog.md:1646
msgid ""
"Detect when compiler version is behind query version (@MarinPostma, #1058)"
msgstr ""

#: src/project/changelog.md:1647
msgid "Add `__version__` to prql-python package (@max-sixty, #1034)"
msgstr ""

#: src/project/changelog.md:1651
msgid ""
"Fix nesting of expressions with equal binding strength and left "
"associativity, such as `a - (b - c)` (@max-sixty, #1136)"
msgstr ""

#: src/project/changelog.md:1653
msgid "Retain floats without significant digits as floats (@max-sixty, #1141)"
msgstr ""

#: src/project/changelog.md:1657
msgid "Add documentation of `prqlr` bindings (@eitsupi, #1091)"
msgstr ""

#: src/project/changelog.md:1658
msgid "Add a 'Why PRQL' section to the website (@max-sixty, #1098)"
msgstr ""

#: src/project/changelog.md:1659
msgid "Add @snth to core-devs (@max-sixty, #1050)"
msgstr ""

#: src/project/changelog.md:1663
msgid "Use workspace versioning (@max-sixty, #1065)"
msgstr ""

#: src/project/changelog.md:1665
msgid "0.2.9 — 2022-10-14"
msgstr ""

#: src/project/changelog.md:1667
msgid "0.2.9 is a small release containing a bug fix for empty strings."
msgstr ""

#: src/project/changelog.md:1671
msgid "Fix parsing of empty strings (@aljazerzen, #1024)"
msgstr ""

#: src/project/changelog.md:1673
msgid "0.2.8 — 2022-10-10"
msgstr ""

#: src/project/changelog.md:1675
msgid ""
"0.2.8 is another modest release with some fixes, doc improvements, bindings "
"improvements, and lots of internal changes. Note that one of the fixes "
"causes the behavior of `round` and `cast` to change slightly — though it's "
"handled as a fix rather than a breaking change in semantic versioning."
msgstr ""

#: src/project/changelog.md:1682
msgid ""
"Change order of the `round` & `cast` function parameters to have the column "
"last; for example `round 2 foo_col` / `cast int foo`. This is consistent "
"with other functions, and makes piping possible:"
msgstr ""

#: src/project/changelog.md:1695
msgid "Split `DEVELOPMENT.md` from `CONTRIBUTING.md` (@richb-hanover, #1010)"
msgstr ""

#: src/project/changelog.md:1696
msgid "Make s-strings more prominent in website intro (@max-sixty, #982)"
msgstr ""

#: src/project/changelog.md:1700
msgid "Add GitHub star count to website (@max-sixty, #990)"
msgstr ""

#: src/project/changelog.md:1704
msgid ""
"Expose a shortened error message, in particular for the VS Code extension "
"(@aljazerzen, #1005)"
msgstr ""

#: src/project/changelog.md:1709
msgid "Specify 1.60.0 as minimum Rust version (@max-sixty, #1011)"
msgstr ""

#: src/project/changelog.md:1710
msgid "Remove old `wee-alloc` code (@max-sixty, #1013)"
msgstr ""

#: src/project/changelog.md:1711
msgid "Upgrade clap to version 4 (@aj-bagwell, #1004)"
msgstr ""

#: src/project/changelog.md:1712
msgid "Improve book-building script in Taskfile (@max-sixty, #989)"
msgstr ""

#: src/project/changelog.md:1713
msgid ""
"Publish website using an artifact rather than a long-lived branch (@max-"
"sixty, \\#1009)"
msgstr ""

#: src/project/changelog.md:1716
msgid "0.2.7 — 2022-09-17"
msgstr ""

#: src/project/changelog.md:1718
msgid ""
"0.2.7 is a fairly modest release, six weeks after 0.2.6. We have some more "
"significant features, including a `union` operator and an overhaul of our "
"type system, as open PRs which will follow in future releases."
msgstr ""

#: src/project/changelog.md:1722
msgid ""
"We also have new features in the [VS Code extension](https://github.com/PRQL/"
"prql-code), courtesy of @jiripospisil, including a live output panel."
msgstr ""

#: src/project/changelog.md:1728
msgid ""
"`range_of_ranges` checks the Range end is smaller than its start (@shuozeli, "
"\\#946)"
msgstr ""

#: src/project/changelog.md:1733
msgid "Improve various docs (@max-sixty, #974, #971, #972, #970, #925)"
msgstr ""

#: src/project/changelog.md:1734
msgid "Add reference to EdgeDB's blog post in our FAQ (@max-sixty, #922)"
msgstr ""

#: src/project/changelog.md:1735
msgid "Fix typos (@kianmeng, #943)"
msgstr ""

#: src/project/changelog.md:1739
msgid "Add `prql-lib`, enabling language bindings with `go` (@sigxcpu76, #923)"
msgstr ""

#: src/project/changelog.md:1740
msgid "Fix line numbers in JS exceptions (@charlie-sanders, #929)"
msgstr ""

#: src/project/changelog.md:1744
msgid ""
"Lock the version of the rust-toolchain, with auto-updates (@max-sixty, #926, "
"\\#927)"
msgstr ""

#: src/project/changelog.md:1747
msgid "0.2.6 — 2022-08-05"
msgstr ""

#: src/project/changelog.md:1751
msgid "Adjust `fmt` to only escape names when needed (@aljazerzen, #907)"
msgstr ""

#: src/project/changelog.md:1752
msgid "Fix quoting on upper case `table` names (@max-sixty, #893)"
msgstr ""

#: src/project/changelog.md:1753
msgid ""
"Fix scoping of identical column names from multiple tables (@max-sixty, #908)"
msgstr ""

#: src/project/changelog.md:1754
msgid "Fix parse error on newlines in a `table` (@sebastiantoh 🆕, #902)"
msgstr ""

#: src/project/changelog.md:1755
msgid "Fix quoting of upper case table names (@max-sixty, #893)"
msgstr ""

#: src/project/changelog.md:1759
msgid "Add docs on Architecture (@aljazerzen, #904)"
msgstr ""

#: src/project/changelog.md:1760
msgid "Add Changelog (@max-sixty, #890 #891)"
msgstr ""

#: src/project/changelog.md:1764
msgid "Start trial using Conventional Commits (@max-sixty, #889)"
msgstr ""

#: src/project/changelog.md:1765
msgid "Add crates.io release workflow, docs (@max-sixty, #887)"
msgstr ""

#: src/project/changelog.md:1767
msgid "0.2.5 - 2022-07-29"
msgstr ""

#: src/project/changelog.md:1769
msgid "0.2.5 is a very small release following 0.2.4 yesterday. It includes:"
msgstr ""

#: src/project/changelog.md:1771
msgid ""
"Add the ability to represent single brackets in an s-string, with two "
"brackets (#752, @max-sixty)"
msgstr ""

#: src/project/changelog.md:1773
msgid ""
"Fix the \"Copy to Clipboard\" command in the Playground, for Firefox (#880, "
"@mklopets)"
msgstr ""

#: src/project/changelog.md:1776
msgid "0.2.4 - 2022-07-28"
msgstr ""

#: src/project/changelog.md:1778
msgid ""
"0.2.4 is a small release following 0.2.3 a few days ago. The 0.2.4 release "
"includes:"
msgstr ""

#: src/project/changelog.md:1781
msgid ""
"Enrich our CLI, adding commands to get different stages of the compilation "
"process (@aljazerzen , #863)"
msgstr ""

#: src/project/changelog.md:1783
msgid ""
"Fix multiple `take n` statements in a query, leading to duplicate proxy "
"columns in generated SQL (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1785
msgid "Fix BigQuery quoting of identifiers in `SELECT` statements (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1786
msgid ""
"Some internal changes — reorganize top-level functions (@aljazerzen), add a "
"workflow to track our Rust compilation time (@max-sixty), simplify our "
"simple prql-to-sql tests (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1790
msgid ""
"Thanks to @ankane, `prql-compiler` is now available from homebrew core; "
"`brew install prql-compiler`[^1]."
msgstr ""

#: src/project/changelog.md:1794
msgid ""
"    we still need to update docs and add a release workflow for this:\n"
"    <https://github.com/PRQL/prql/issues/866>\n"
"    "
msgstr ""

#: src/project/changelog.md:1797
msgid "0.2.3 - 2022-07-24"
msgstr ""

#: src/project/changelog.md:1799
msgid ""
"A couple of weeks since the 0.2.2 release: we've squashed a few bugs, added "
"some mid-sized features to the language, and made a bunch of internal "
"improvements."
msgstr ""

#: src/project/changelog.md:1802
msgid "The 0.2.3 release includes:"
msgstr ""

#: src/project/changelog.md:1804
msgid ""
"Allow for escaping otherwise-invalid identifiers (@aljazerzen & @max-sixty)"
msgstr ""

#: src/project/changelog.md:1805
msgid "Fix a bug around operator precedence (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1806
msgid "Add a section the book on the language bindings (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1807
msgid ""
"Add tests for our `Display` representation while fixing some existing bugs. "
"This is gradually becoming our code formatter (@arrizalamin)"
msgstr ""

#: src/project/changelog.md:1809
msgid "Add a \"copy to clipboard\" button in the Playground (@mklopets)"
msgstr ""

#: src/project/changelog.md:1810
msgid ""
"Add lots of guidance to our `CONTRIBUTING.md` around our tests and process "
"for merging (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1812
msgid ""
"Add a `prql!` macro for parsing a prql query at compile time (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1813
msgid "Add tests for `prql-js` (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1814
msgid ""
"Add a `from_json` method for transforming json to a PRQL string "
"(@arrizalamin)"
msgstr ""

#: src/project/changelog.md:1815
msgid "Add a workflow to release `prql-java` to Maven (@doki23)"
msgstr ""

#: src/project/changelog.md:1816
msgid ""
"Enable running all tests from a PR by adding a `pr-run-all-tests` label "
"(@max-sixty)"
msgstr ""

#: src/project/changelog.md:1818
msgid "Have `cargo-release` to bump all crate & npm versions (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1819
msgid "Update `prql-js` to use the bundler build of `prql-js` (@mklopets)"
msgstr ""

#: src/project/changelog.md:1821
msgid ""
"As well as those contribution changes, thanks to those who've reported "
"issues, such as @mklopets @huw @mm444 @ajfriend."
msgstr ""

#: src/project/changelog.md:1824
msgid ""
"From here, we're planning to continue squashing bugs (albeit more minor than "
"those in this release), adding some features like `union`, while working on "
"bigger issues such as type-inference."
msgstr ""

#: src/project/changelog.md:1828
msgid ""
"We're also going to document and modularize the compiler further. It's "
"important that we give more people an opportunity to contribute to the guts "
"of PRQL, especially given the number and enthusiasm of contributions to "
"project in general — and it's not that easy to do so at the moment. While "
"this is ongoing if anyone has something they'd like to work on in the more "
"difficult parts of the compiler, let us know on GitHub or Discord, and we'd "
"be happy to work together on it."
msgstr ""

#: src/project/changelog.md:1836
msgid "Thank you!"
msgstr ""

#: src/project/changelog.md:1838
msgid "0.2.2 - 2022-07-10"
msgstr ""

#: src/project/changelog.md:1840
msgid ""
"We're a couple of weeks since our 0.2.0 release. Thanks for the surge in "
"interest and contributions! 0.2.2 has some fixes & some internal "
"improvements:"
msgstr ""

#: src/project/changelog.md:1843
msgid ""
"We now test against SQLite & DuckDB on every commit, to ensure we're "
"producing correct SQL. (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1845
msgid "We have the beginning of Java bindings! (@doki23)"
msgstr ""

#: src/project/changelog.md:1846
msgid "Idents surrounded by backticks are passed through to SQL (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1847
msgid ""
"More examples on homepage; e.g. `join` & `window`, lots of small docs "
"improvements"
msgstr ""

#: src/project/changelog.md:1849
msgid "Automated releases to homebrew (@roG0d)"
msgstr ""

#: src/project/changelog.md:1850
msgid ""
"[prql-js](https://github.com/PRQL/prql/tree/main/prqlc/bindings/js) is now a "
"single package for Node, browsers & webpack (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1852
msgid ""
"Parsing has some fixes, including `>=` and leading underscores in idents "
"(@mklopets)"
msgstr ""

#: src/project/changelog.md:1854
msgid "Ranges receive correct syntax highlighting (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1856
msgid ""
"Thanks to Aljaž Mur Eržen @aljazerzen , George Roldugin @roldugin , Jasper "
"McCulloch @Jaspooky , Jie Han @doki23 , Marko Klopets @mklopets , Maximilian "
"Roos @max-sixty , Rodrigo Garcia @roG0d , Ryan Russell @ryanrussell , Steven "
"Maude @StevenMaude , Charlie Sanders @charlie-sanders ."
msgstr ""

#: src/project/changelog.md:1861
msgid ""
"We're planning to continue collecting bugs & feature requests from users, as "
"well as working on some of the bigger features, like type-inference."
msgstr ""

#: src/project/changelog.md:1864
msgid ""
"For those interesting in joining, we also have a new [Contributing page]"
"(https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md)."
msgstr ""

#: src/project/changelog.md:1867
msgid "0.2.0 - 2022-06-27"
msgstr ""

#: src/project/changelog.md:1869
msgid "🎉 🎉 **After several months of building, PRQL is ready to use!** 🎉 🎉"
msgstr ""

#: src/project/changelog.md:1873
msgid "How we got here:"
msgstr ""

#: src/project/changelog.md:1875
msgid ""
"At the end of January, we published a proposal of a better language for data "
"transformation: PRQL. The reception was better than I could have hoped for — "
"we were no. 2 on HackerNews for a day, and gained 2.5K GitHub stars over the "
"next few days."
msgstr ""

#: src/project/changelog.md:1880
msgid ""
"But man cannot live on GitHub Stars alone — we had to do the work to build "
"it. So over the next several months, during many evenings & weekends, a "
"growing group of us gradually built the compiler, evolved the language, and "
"wrote some integrations."
msgstr ""

#: src/project/changelog.md:1885
msgid ""
"We want to double-down on the community and its roots in open source — it's "
"incredible that a few of us from all over the globe have collaborated on a "
"project without ever having met. We decided early-on that PRQL would always "
"be open-source and would never have a commercial product (despite lots of "
"outside interest to fund a seed round!). Because languages are so deep in "
"the stack, and the data stack has so many players, the best chance of "
"building a great language is to build an open language."
msgstr ""

#: src/project/changelog.md:1895
msgid ""
"We still have a long way to go. While PRQL is usable, it has lots of missing "
"features, and an incredible amount of unfulfilled potential, including a "
"language server, cohesion with databases, and type inference. Over the "
"coming weeks, we'd like to grow the number of intrepid users experimenting "
"PRQL in their projects, prioritize features that will unblock them, and then "
"start fulfilling PRQL's potential by working through our [roadmap](https://"
"prql-lang.org/roadmap/)."
msgstr ""

#: src/project/changelog.md:1903
msgid ""
"The best way to experience PRQL is to try it. Check out our [website]"
"(https://prql-lang.org) and the [Playground](https://prql-lang.org/"
"playground). Start using PRQL for your own projects in [dbt](https://github."
"com/prql/dbt-prql), [Jupyter notebooks](https://pyprql.readthedocs.io/en/"
"latest/magic_readme.html) and Prefect workflows."
msgstr ""

#: src/project/changelog.md:1910
msgid ""
"Keep in touch with PRQL by following the project on [Twitter](https://"
"twitter.com/prql_lang), joining us on [Discord](https://discord.gg/"
"eQcfaCmsNc), starring the [repo](https://github.com/PRQL/prql)."
msgstr ""

#: src/project/changelog.md:1915
msgid ""
"[Contribute](https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md) "
"to the project — we're a really friendly community, whether you're a recent "
"SQL user or an advanced Rust programmer. We need bug reports, documentation "
"tweaks & feature requests — just as much as we need compiler improvements "
"written in Rust."
msgstr ""

#: src/project/changelog.md:1923
msgid ""
"I especially want to give [Aljaž Mur Eržen](https://github.com/aljazerzen) "
"(@aljazerzen) the credit he deserves, who has contributed the majority of "
"the difficult work of building out the compiler. Much credit also goes to "
"@charlie-sanders, one of PRQL's earliest supporters and the author of "
"pyprql, and [Ryan Patterson-Cross](https://github.com/rbpatt2019) "
"(@rbpatt2019), who built the Jupyter integration among other Python "
"contributions."
msgstr ""

#: src/project/changelog.md:1930
msgid ""
"Other contributors who deserve a special mention include: @roG0d, @snth, "
"@kwigley"
msgstr ""

#: src/project/changelog.md:1935
msgid "Thank you, and we look forward to your feedback!"
msgstr ""

#: src/project/contributing/index.md:1
msgid "Contributing"
msgstr ""

#: src/project/contributing/index.md:3
msgid ""
"If you're interested in joining the community to build a better SQL, here "
"are ways to start:"
msgstr ""

#: src/project/contributing/index.md:6
msgid "Star the [repo](https://github.com/PRQL/prql)."
msgstr "星標收藏[儲存庫](https://github.com/PRQL/prql)。"

#: src/project/contributing/index.md:7
msgid "Send a link to PRQL to a couple of people whose opinion you respect."
msgstr ""

#: src/project/contributing/index.md:8
msgid ""
"Subscribe to [new releases](https://www.jessesquires.com/blog/2020/07/30/"
"github-tip-watching-releases/) for updates."
msgstr ""

#: src/project/contributing/index.md:11
msgid "Follow us on [Twitter](https://twitter.com/prql_lang)."
msgstr "在 [Twitter](https://twitter.com/prql_lang) 上關注我們。"

#: src/project/contributing/index.md:12
msgid "Join our [Discord](https://discord.gg/eQcfaCmsNc)."
msgstr "加入我們的 [Discord](https://discord.gg/eQcfaCmsNc)。"

#: src/project/contributing/index.md:13
msgid ""
"Find an issue labeled [Good First Issue](https://github.com/prql/prql/issues?"
"q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22) and start "
"contributing to the code."
msgstr ""

#: src/project/contributing/index.md:16
msgid ""
"Join our [fortnightly Developer Call](https://github.com/PRQL/prql/"
"issues/1083); ([iCal file](./fortnightly-dev-call.ics))."
msgstr ""

#: src/project/contributing/index.md:20
msgid ""
"PRQL is evolving from a project with lots of excitement into a project that "
"folks are using in their work and integrating into their tools. We're "
"actively looking for collaborators to lead that growth with us."
msgstr ""

#: src/project/contributing/index.md:24
msgid "Areas for larger contributions"
msgstr ""

#: src/project/contributing/index.md:26
msgid "Compiler"
msgstr "編譯器"

#: src/project/contributing/index.md:28
msgid ""
"The compiler is written in Rust, and there's enough to do such that any "
"level of experience with Rust is sufficient."
msgstr ""

#: src/project/contributing/index.md:31
msgid ""
"We try to keep a few onboarding issues on hand under the [\"good first "
"issue\" label](https://github.com/PRQL/prql/labels/good%20first%20issue). "
"These have been screened to have sufficient context to get started (and we "
"very much welcome questions where there's some context missing)."
msgstr ""

#: src/project/contributing/index.md:36
msgid ""
"To get started, check out the docs on [Development](./development.md) and "
"the [Compiler architecture](https://github.com/PRQL/prql/blob/main/prqlc/"
"prqlc/ARCHITECTURE.md)"
msgstr ""

#: src/project/contributing/index.md:39
msgid ""
"And if you have questions, there are lots of friendly people on the Discord "
"who will patiently help you."
msgstr ""

#: src/project/contributing/index.md:42
msgid "Bindings & integrations"
msgstr ""

#: src/project/contributing/index.md:44
msgid ""
"For PRQL to be successful, it needs to be available for the languages & "
"tools that people already use."
msgstr ""

#: src/project/contributing/index.md:47
msgid ""
"We currently have bindings to the PRQL compiler in a few different "
"languages; many of these can be improved, documented, and packaged in a "
"better way."
msgstr ""

#: src/project/contributing/index.md:49
msgid ""
"If you have experience with packaging in an ecosystem that doesn't currently "
"have bindings, then creating PRQL bindings for that language we don't "
"currently support would be valuable to the project."
msgstr ""

#: src/project/contributing/index.md:52
msgid ""
"If there's a tool that you use yourself to run data queries which you think "
"would benefit from a PRQL integration, suggest one to us or the tool. If "
"it's open-source, build & share a prototype."
msgstr ""

#: src/project/contributing/index.md:56
msgid ""
"Relevant issues are labeled [Integrations](https://github.com/PRQL/prql/"
"labels/integrations)."
msgstr ""

#: src/project/contributing/index.md:59
msgid "Language design"
msgstr "語言設計"

#: src/project/contributing/index.md:61
msgid ""
"We decide on new language features in GitHub issues, usually under "
"[\"language design\" label](https://github.com/PRQL/prql/issues?"
"q=is%3Aopen+label%3Alanguage-design+sort%3Aupdated-desc)."
msgstr ""

#: src/project/contributing/index.md:64
msgid "You can also contribute by:"
msgstr ""

#: src/project/contributing/index.md:66
msgid ""
"Finding instances where the compiler produces incorrect results, and post a "
"bug report — feel free to use the [playground](https://prql-lang.org/"
"playground)."
msgstr ""

#: src/project/contributing/index.md:69
msgid ""
"Opening an issue / append to an existing issue with examples of queries that "
"are difficult to express in PRQL — especially if more difficult than SQL."
msgstr ""

#: src/project/contributing/index.md:72
msgid ""
"With sufficient examples, suggest a change to the language! (Though "
"suggestions _without_ examples are difficult to engage with, so please do "
"anchor suggestions in examples.)"
msgstr ""
"提供充足的範例來建議語言變更！（由於沒有範例的建議很難進行討論，因此請務必將"
"建議建立在具體範例之上。）"

#: src/project/contributing/index.md:76
msgid "Marketing"
msgstr ""

#: src/project/contributing/index.md:78
msgid ""
"Improve our website. We have [a few issues open](https://github.com/PRQL/"
"prql/labels/web) on this front and are looking for anyone with at least some "
"design skills."
msgstr ""

#: src/project/contributing/index.md:81
msgid ""
"Contribute towards the docs. Anything from shaping a whole section of the "
"docs, to simply improving a confusing paragraph or fixing a typo."
msgstr ""

#: src/project/contributing/index.md:83
msgid "Tell people about PRQL."
msgstr ""

#: src/project/contributing/index.md:84
msgid ""
"Find a group of users who would be interested in PRQL, help them get up to "
"speed, help the project understand what they need."
msgstr ""

#: src/project/contributing/index.md:87
msgid "Core team"
msgstr "核心團隊"

#: src/project/contributing/index.md:89
msgid ""
"If you have any questions or feedback and don't receive a response on one of "
"the general channels such as GitHub or Discord, feel free to reach out to:"
msgstr ""
"如果您有任何問題或意見反饋，並且在 GitHub 或 Discord 等公開頻道未收到回覆，歡"
"迎隨時聯繫："

#: src/project/contributing/index.md:92
msgid "[**@aljazerzen**](https://github.com/aljazerzen) — Aljaž Mur Eržen"
msgstr "[**@aljazerzen**](https://github.com/aljazerzen) — Aljaž Mur Eržen"

#: src/project/contributing/index.md:93
msgid "[**@max-sixty**](https://github.com/max-sixty) — Maximilian Roos"
msgstr "[**@max-sixty**](https://github.com/max-sixty) — Maximilian Roos"

#: src/project/contributing/index.md:94
msgid "[**@eitsupi**](https://github.com/eitsupi) — SHIMA Tatsuya"
msgstr "[**@eitsupi**](https://github.com/eitsupi) — SHIMA Tatsuya"

#: src/project/contributing/index.md:95
msgid "[**@snth**](https://github.com/snth) — Tobias Brandt"
msgstr "[**@snth**](https://github.com/snth) — Tobias Brandt"

#: src/project/contributing/index.md:97
msgid "Core team Emeritus"
msgstr "核心團隊榮譽成員"

#: src/project/contributing/index.md:99
msgid "Thank you to those who have previously served on the core team:"
msgstr ""

#: src/project/contributing/index.md:101
msgid "**@charlie-sanders** — Charlie Sanders"
msgstr ""

#: src/project/contributing/development.md:3
msgid "Setting up an initial dev environment"
msgstr ""

#: src/project/contributing/development.md:5
msgid ""
"We can set up a local development environment sufficient for navigating, "
"editing, and testing PRQL's compiler code in two minutes:"
msgstr ""

#: src/project/contributing/development.md:8
msgid ""
"Install [`rustup` & `cargo`](https://doc.rust-lang.org/cargo/getting-started/"
"installation.html)."
msgstr ""

#: src/project/contributing/development.md:10
msgid ""
"\\[Optional but highly recommended\\] Install `cargo-insta`, our testing "
"framework:"
msgstr ""

#: src/project/contributing/development.md:17
msgid ""
"That's it! Running the unit tests for the `prqlc` crate after cloning the "
"repo should complete successfully:"
msgstr ""

#: src/project/contributing/development.md:24
msgid "...or, to run tests and update the test snapshots:"
msgstr ""

#: src/project/contributing/development.md:30
msgid "There's more context on our tests in [How we test](#how-we-test) below."
msgstr ""

#: src/project/contributing/development.md:32
msgid "That's sufficient for making an initial contribution to the compiler."
msgstr ""

#: src/project/contributing/development.md:36
msgid "Setting up a full dev environment"
msgstr ""

#: src/project/contributing/development.md:39
msgid ""
"\\[!NOTE\\] We really care about this process being easy, both because the "
"project benefits from more contributors like you, and to reciprocate your "
"future contribution. If something isn't easy, please let us know in a GitHub "
"Issue. We'll enthusiastically help you, and use your feedback to improve the "
"scripts & instructions."
msgstr ""

#: src/project/contributing/development.md:46
msgid ""
"For more advanced development; for example compiling for wasm or previewing "
"the website, we have two options:"
msgstr ""

#: src/project/contributing/development.md:49
msgid "Option 1: Use the project's `task`"
msgstr ""

#: src/project/contributing/development.md:52
msgid ""
"\\[!NOTE\\] This is tested on macOS, should work on amd64 Linux, but won't "
"work on others (include Windows), since it relies on `brew`."
msgstr ""

#: src/project/contributing/development.md:56
msgid "[Install Task](https://taskfile.dev/installation/)."
msgstr ""

#: src/project/contributing/development.md:57
msgid ""
"Then run the `setup-dev` task. This runs commands from our [Taskfile.yaml]"
"(https://github.com/PRQL/prql/blob/main/Taskfile.yaml), installing "
"dependencies with `cargo`, `brew`, `npm` & `uv`, and suggests some VS Code "
"extensions."
msgstr ""

#: src/project/contributing/development.md:66
msgid "Option 2: Install tools individually"
msgstr ""

#: src/project/contributing/development.md:68
msgid "We'll need `cargo-insta`, to update snapshot tests:"
msgstr ""

#: src/project/contributing/development.md:74
msgid ""
"We'll need Python, which most systems will have already. The easiest way to "
"check is to try running the full tests:"
msgstr ""

#: src/project/contributing/development.md:81
msgid ""
"...and if that doesn't complete successfully, ensure we have Python >= 3.7, "
"to compile `prqlc-python`."
msgstr ""

#: src/project/contributing/development.md:84
msgid ""
"For more involved contributions, such as building the website, playground, "
"book, or some release artifacts, we'll need some additional tools. But we "
"won't need those immediately, and the error messages on what's missing "
"should be clear when we attempt those things. When we hit them, the "
"[Taskfile.yaml](https://github.com/PRQL/prql/blob/main/Taskfile.yaml) will "
"be a good source to copy & paste instructions from."
msgstr ""

#: src/project/contributing/development.md:91
msgid "Option 3: Use a Dev Container"
msgstr "選項 3：使用 Dev Container"

#: src/project/contributing/development.md:93
msgid ""
"This project has a [devcontainer.json file](https://github.com/PRQL/prql/"
"blob/main/.devcontainer/devcontainer.json) and a [pre-built dev container "
"base Docker image](https://github.com/PRQL/prql/pkgs/container/prql-"
"devcontainer-base). Learn more about Dev Containers at [https://containers."
"dev/](https://containers.dev/)"
msgstr ""

#: src/project/contributing/development.md:100
msgid ""
"Currently, the tools for Rust are already installed in the pre-built image, "
"and, Node.js, Python and others are configured to be installed when build "
"the container."
msgstr ""

#: src/project/contributing/development.md:104
msgid ""
"While there are a variety of tools that support Dev Containers, the focus "
"here is on developing with VS Code in a container by [GitHub Codespaces]"
"(https://docs.github.com/en/codespaces/overview) or [VS Code Dev Containers "
"extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-"
"remote.remote-containers)."
msgstr ""

#: src/project/contributing/development.md:109
msgid ""
"To use a Dev Container on a local computer with VS Code, install the [VS "
"Code Dev Containers extension](https://marketplace.visualstudio.com/items?"
"itemName=ms-vscode-remote.remote-containers) and its system requirements. "
"Then refer to the links above to get started."
msgstr ""

#: src/project/contributing/development.md:113
msgid "Option 4: Use nix development environment"
msgstr "選項 4：使用 nix 開發環境"

#: src/project/contributing/development.md:116
msgid ""
"\\[!NOTE\\] This is used by a member of the core team on Linux, but doesn't "
"currently work on Mac. We're open to contributions to improve support."
msgstr ""

#: src/project/contributing/development.md:120
msgid ""
"A [nix](https://nixos.org/) flake `flake.nix` provides 3 development "
"environments:"
msgstr ""

#: src/project/contributing/development.md:123
msgid "**default**, for building the compiler"
msgstr ""

#: src/project/contributing/development.md:124
msgid "**web**, for the compiler and the website,"
msgstr ""

#: src/project/contributing/development.md:125
msgid "**full**, for the compiler, the website and the compiler bindings."
msgstr ""

#: src/project/contributing/development.md:127
msgid "To load the shell:"
msgstr ""

#: src/project/contributing/development.md:129
msgid ""
"[Install nix (the package manager)](https://nixos.org/download). (only first "
"time)"
msgstr ""

#: src/project/contributing/development.md:132
msgid ""
"Enable flakes, which are a (pretty stable) experimental feature of nix. "
"(only first time)"
msgstr ""

#: src/project/contributing/development.md:135
msgid "For non-NixOS users:"
msgstr ""

#: src/project/contributing/development.md:139
msgid "'experimental-features = nix-command flakes'"
msgstr "'experimental-features = nix-command flakes'"

#: src/project/contributing/development.md:142
msgid ""
"For NixOS users, follow instructions [here](https://nixos.wiki/wiki/Flakes)."
msgstr ""

#: src/project/contributing/development.md:144
msgid "Run:"
msgstr ""

#: src/project/contributing/development.md:150
msgid "To use the \"web\" or \"full\" shell, run:"
msgstr ""

#: src/project/contributing/development.md:156
msgid ""
"Optionally, you can install [direnv](https://direnv.net/), to automatically "
"load the shell when you enter this repo. The easiest way is to also install "
"[direnv-nix](https://github.com/nix-community/nix-direnv) and configure your "
"`.envrc` with:"
msgstr ""

#: src/project/contributing/development.md:162
msgid "# .envrc\n"
msgstr ""

#: src/project/contributing/development.md:168
msgid "Contribution workflow"
msgstr ""

#: src/project/contributing/development.md:170
msgid ""
"We're similar to most projects on GitHub — open a Pull Request with a "
"suggested change!"
msgstr ""

#: src/project/contributing/development.md:173
msgid "Commits"
msgstr ""

#: src/project/contributing/development.md:175
msgid ""
"If a change is user-facing, please add a line in [**`CHANGELOG.md`**]"
"(https://github.com/PRQL/prql/blob/main/CHANGELOG.md), with `{message}, "
"({@contributor, #X})` where `X` is the PR number."
msgstr ""

#: src/project/contributing/development.md:178
msgid ""
"If there's a missing entry, a follow-up PR containing just the changelog "
"entry is welcome."
msgstr ""

#: src/project/contributing/development.md:180
msgid ""
"We're using [Conventional Commits](https://www.conventionalcommits.org) "
"message format, enforced through [action-semantic-pull-request](https://"
"github.com/amannn/action-semantic-pull-request)."
msgstr ""

#: src/project/contributing/development.md:184
msgid "Merges"
msgstr ""

#: src/project/contributing/development.md:186
msgid "**We merge any code that makes PRQL better**"
msgstr ""

#: src/project/contributing/development.md:187
msgid ""
"A PR doesn't need to be perfect to be merged; it doesn't need to solve a big "
"problem. It needs to:"
msgstr ""

#: src/project/contributing/development.md:189
msgid "be in the right direction,"
msgstr ""

#: src/project/contributing/development.md:190
msgid "make incremental progress,"
msgstr ""

#: src/project/contributing/development.md:191
msgid "be explicit on its current state, so others can continue the progress."
msgstr ""

#: src/project/contributing/development.md:192
msgid ""
"That said, there are a few instances when we need to ensure we have some "
"consensus before merging code — for example non-trivial changes to the "
"language, or large refactorings to the library."
msgstr ""

#: src/project/contributing/development.md:195
msgid ""
"If you have merge permissions, and are reasonably confident that a PR is "
"suitable to merge (whether or not you're the author), feel free to merge."
msgstr ""

#: src/project/contributing/development.md:197
msgid ""
"If you don't have merge permissions and have authored a few PRs, ask and ye "
"shall receive."
msgstr ""

#: src/project/contributing/development.md:199
msgid "The primary way we ratchet the code quality is through automated tests."
msgstr ""

#: src/project/contributing/development.md:200
msgid ""
"This means PRs almost always need a test to demonstrate incremental progress."
msgstr ""

#: src/project/contributing/development.md:202
msgid ""
"If a change breaks functionality without breaking tests, our tests were "
"probably insufficient."
msgstr ""

#: src/project/contributing/development.md:204
msgid ""
"If a change breaks existing tests (for example, changing an external API), "
"that indicates we should be careful about merging a change, including "
"soliciting others' views."
msgstr ""

#: src/project/contributing/development.md:207
msgid ""
"We use PR reviews to give general context, offer specific assistance, and "
"collaborate on larger decisions."
msgstr ""

#: src/project/contributing/development.md:209
msgid ""
"Reviews around 'nits' like code formatting / idioms / etc are very welcome. "
"But the norm is for them to be received as helpful advice, rather than as "
"mandatory tasks to complete. Adding automated tests & lints to automate "
"these suggestions is welcome."
msgstr ""

#: src/project/contributing/development.md:213
msgid ""
"If you have merge permissions and would like a PR to be reviewed before it "
"merges, that's great — ask or assign a reviewer."
msgstr ""

#: src/project/contributing/development.md:215
msgid ""
"If a PR hasn't received attention after a day, please feel free to ping the "
"pull request."
msgstr ""

#: src/project/contributing/development.md:217
msgid ""
"People may review a PR after it's merged. As part of the understanding that "
"we can merge quickly, contributors are expected to incorporate substantive "
"feedback into a future PR."
msgstr ""

#: src/project/contributing/development.md:220
msgid ""
"We should revert quickly if the impact of a PR turns out not to be "
"consistent with our expectations, or there isn't as much consensus on a "
"decision as we had hoped. It's very easy to revert code and then re-revert "
"when we've resolved the issue; it's a sign of moving quickly. Other options "
"which resolve issues immediately are also fine, such as commenting out an "
"incorrect test or adding a quick fix for the underlying issue."
msgstr ""

#: src/project/contributing/development.md:227
msgid "Docs"
msgstr ""

#: src/project/contributing/development.md:229
msgid "We're very keen on contributions to improve our documentation."
msgstr ""

#: src/project/contributing/development.md:231
msgid ""
"This includes our docs in the book, on the website, in our code, or in a "
"Readme. We also appreciate issues pointing out that our documentation was "
"confusing, incorrect, or stale — if it's confusing for you, it's probably "
"confusing for others."
msgstr ""

#: src/project/contributing/development.md:236
msgid "Some principles for ensuring our docs remain maintainable:"
msgstr ""

#: src/project/contributing/development.md:238
msgid ""
"Docs should be as close as possible to the code. Doctests are ideal on this "
"dimension — they're literally very close to the code and they can't drift "
"apart since they're tested on every commit. Or, for example, it's better to "
"add text to a `--help` message, rather than write a paragraph in the Readme "
"explaining the CLI."
msgstr ""

#: src/project/contributing/development.md:243
msgid ""
"We should have some visualization of how to maintain docs when we add them. "
"Docs have a habit of falling out of date — the folks reading them are often "
"different from those writing them, they're sparse from the code, generally "
"not possible to test, and are rarely the by-product of other contributions. "
"Docs that are concise & specific are easier to maintain."
msgstr ""

#: src/project/contributing/development.md:248
msgid ""
"Docs should be specifically relevant to PRQL; anything else we can instead "
"link to."
msgstr ""

#: src/project/contributing/development.md:251
msgid ""
"If something doesn't fit into one of these categories, there are still lots "
"of ways of getting the word out there — a blog post / gist / etc. Let us "
"know and we're happy to link to it / tweet it."
msgstr ""

#: src/project/contributing/development.md:255
msgid "How we test"
msgstr ""

#: src/project/contributing/development.md:257
msgid ""
"We use a pyramid of tests — we have fast, focused tests at the bottom of the "
"pyramid, which give us low latency feedback when developing, and then "
"slower, broader tests which ensure that we don't miss anything as PRQL "
"develops<sup><a name=\"to-footnote-1\">[1](#footnote-1)</a></sup>."
msgstr ""

#: src/project/contributing/development.md:265
msgid ""
"\\[!NOTE\\] If you're making your first contribution, you don't need to "
"engage with all this — it's fine to just make a change and push the results; "
"the tests that run in GitHub will point you towards any errors, which can be "
"then be run locally if needed. We're always around to help out."
msgstr ""

#: src/project/contributing/development.md:271
msgid "Our tests, from the bottom of the pyramid to the top:"
msgstr ""

#: src/project/contributing/development.md:273
msgid ""
"**[Static checks](https://github.com/PRQL/prql/blob/main/.pre-commit-config."
"yaml)** — we run a few static checks to ensure the code stays healthy and "
"consistent. They're defined in [**`.pre-commit-config.yaml`**](https://"
"github.com/PRQL/prql/blob/main/.pre-commit-config.yaml), using [pre-commit]"
"(https://pre-commit.com). They can be run locally with"
msgstr ""

#: src/project/contributing/development.md:281
#: src/project/contributing/development.md:302
#: src/project/contributing/development.md:352
msgid "# or\n"
msgstr ""

#: src/project/contributing/development.md:285
msgid ""
"The tests fix most of the issues they find themselves. Most of them also run "
"on GitHub on every commit; any changes they make are added onto the branch "
"automatically in an additional commit."
msgstr ""

#: src/project/contributing/development.md:288
msgid ""
"Checking by [MegaLinter](https://megalinter.io/latest/), which includes more "
"Linters, is also done automatically on GitHub. (experimental)"
msgstr ""

#: src/project/contributing/development.md:291
msgid ""
"**Unit tests & inline insta snapshots** — we rely on unit tests to rapidly "
"check that our code basically works. We extensively use [Insta](https://"
"insta.rs/), a snapshot testing tool which writes out the values generated by "
"our code, making it fast & simple to write and modify tests<sup><a name=\"to-"
"footnote-2\">[2](#footnote-2)</a></sup>"
msgstr ""

#: src/project/contributing/development.md:297
msgid ""
"These are the fastest tests which run our code; they're designed to run on "
"every save while you're developing. We include a `task` which does this:"
msgstr ""

#: src/project/contributing/development.md:336
msgid ""
"**[Documentation](https://github.com/PRQL/prql/tree/main/web/book/tests/"
"documentation)** — we compile all examples from our documentation in the "
"Website, README, and PRQL Book, to test that they produce the SQL we expect, "
"and that changes to our code don't cause any unexpected regressions. These "
"are included in:"
msgstr ""

#: src/project/contributing/development.md:345
msgid ""
"**[Database integration tests](https://github.com/PRQL/prql/tree/main/prqlc/"
"prqlc/tests/integration/dbs)** — we run tests with example queries against "
"databases with actual data to ensure we're producing correct SQL across our "
"supported dialects. The in-process tests can be run locally with:"
msgstr ""

#: src/project/contributing/development.md:356
msgid ""
"More details on running with external databases are in the [Readme](https://"
"github.com/PRQL/prql/tree/main/prqlc/prqlc/tests/integration/dbs)."
msgstr ""

#: src/project/contributing/development.md:360
msgid ""
"\\[!NOTE\\] Integration tests use DuckDB, and so require a clang compiler to "
"compile [`duckdb-rs`](https://github.com/wangfenjin/duckdb-rs). Most "
"development systems will have one, but if the test command fails, install a "
"clang compiler with:"
msgstr ""

#: src/project/contributing/development.md:366
msgid "On macOS, install xcode with `xcode-select --install`"
msgstr ""

#: src/project/contributing/development.md:367
msgid "On Debian Linux, `apt-get update && apt-get install clang`"
msgstr ""

#: src/project/contributing/development.md:368
msgid "On Windows, `duckdb-rs` isn't supported, so these tests are excluded"
msgstr ""

#: src/project/contributing/development.md:370
msgid ""
"**[GitHub Actions on every commit](https://github.com/PRQL/prql/blob/main/."
"github/workflows/tests.yaml)** — we run tests relevant to a PR's changes in "
"CI — for example changes to docs will attempt to build docs, changes to a "
"binding will run that binding's tests. The vast majority of changes trigger "
"tests which run in less than five minutes, and we should be reassessing "
"their scope if they take longer than that. Once these pass, a pull request "
"can be merged."
msgstr ""

#: src/project/contributing/development.md:377
msgid ""
"**[GitHub Actions on merge](https://github.com/PRQL/prql/blob/"
"c042eef48709e2c1af577161554fd09f14e67e0f/.github/workflows/pull-request."
"yaml#L124)** — we run a wider set tests on every merge to main. This "
"includes testing across OSs, all our language bindings, a measure of test "
"code coverage, and some performance benchmarks."
msgstr ""

#: src/project/contributing/development.md:382
msgid ""
"If these tests fail after merging, we should revert the commit before fixing "
"the test and then re-reverting."
msgstr ""

#: src/project/contributing/development.md:385
msgid "Most of these will run locally with:"
msgstr ""

#: src/project/contributing/development.md:391
msgid ""
"**[GitHub Actions nightly](https://github.com/PRQL/prql/blob/main/.github/"
"workflows/nightly.yaml)** — every night, we run tests that take longer, are "
"less likely to fail, or are unrelated to code changes — such as security "
"checks, bindings' tests on multiple OSs, or expensive timing benchmarks."
msgstr ""

#: src/project/contributing/development.md:396
msgid ""
"We can run these tests before a merge by adding a label `pr-nightly` to the "
"PR."
msgstr ""

#: src/project/contributing/development.md:399
msgid ""
"The goal of our tests is to allow us to make changes quickly. If they're "
"making it more difficult to make changes, or there are missing tests that "
"would offer the confidence to make changes faster, please raise an issue."
msgstr ""

#: src/project/contributing/development.md:405
msgid "Website"
msgstr "網站"

#: src/project/contributing/development.md:407
msgid ""
"The website is published together with the book and the playground, and is "
"automatically built and released on any push to the `web` branch."
msgstr ""

#: src/project/contributing/development.md:410
msgid ""
"The `web` branch points to the latest release plus any website-specific "
"fixes. That way, the compiler behavior in the playground matches the latest "
"release while allowing us to fix mistakes in the docs with a tighter loop "
"than every release."
msgstr ""

#: src/project/contributing/development.md:415
msgid ""
"Fixes to the playground, book, or website should have a `pr-backport-web` "
"label added to their PR — a bot will then open & merge another PR onto the "
"`web` branch once the initial branch merges."
msgstr ""

#: src/project/contributing/development.md:419
msgid "The website components will run locally with:"
msgstr ""

#: src/project/contributing/development.md:422
msgid "# Run the main website\n"
msgstr ""

#: src/project/contributing/development.md:423
msgid "# Run the PRQL online book\n"
msgstr ""

#: src/project/contributing/development.md:425
msgid "# Run the PRQL playground\n"
msgstr ""

#: src/project/contributing/development.md:432
msgid ""
"We have a number of language bindings, as documented at <https://prql-lang."
"org/book/project/bindings/index.html>. Some of these are within our "
"monorepo, some are in separate repos. Here's a provisional framework for "
"when we use the main prql repo vs separate repos for bindings:"
msgstr ""

#: src/project/contributing/development.md:437
msgid "Factor"
msgstr ""

#: src/project/contributing/development.md:437
msgid "Rationale"
msgstr ""

#: src/project/contributing/development.md:437
msgid "Example"
msgstr "範例"

#: src/project/contributing/development.md:439
msgid "Does someone want to sign up to maintain a repo?"
msgstr ""

#: src/project/contributing/development.md:439
msgid "A different repo is harder for the core team to maintain"
msgstr ""

#: src/project/contributing/development.md:439
msgid "`tree-sitter-prql` is well maintained"
msgstr ""

#: src/project/contributing/development.md:440
msgid "Can it change independently from the compiler?"
msgstr ""

#: src/project/contributing/development.md:440
msgid ""
"If it's in a different repo, it can't be changed in lockstep with the "
"compiler"
msgstr ""

#: src/project/contributing/development.md:440
msgid "`prql-vscode` is fine to change \"behind\" the language"
msgstr ""

#: src/project/contributing/development.md:441
msgid "Would a separate repo invite new contributors?"
msgstr ""

#: src/project/contributing/development.md:441
msgid ""
"A monorepo with all the rust code can be less inviting for those familiar "
"with other langs"
msgstr ""

#: src/project/contributing/development.md:441
msgid "`prql-vscode` had some JS-only contributors"
msgstr ""

#: src/project/contributing/development.md:442
msgid "Is there an convention for a stand-alone repo?"
msgstr ""

#: src/project/contributing/development.md:442
msgid "A small number of ecosystems require a separate repo"
msgstr ""

#: src/project/contributing/development.md:442
msgid "`homebrew-prql` needs to be named that way for a Homebrew tap"
msgstr ""

#: src/project/contributing/development.md:446
msgid "Releasing"
msgstr ""

#: src/project/contributing/development.md:448
msgid "Currently we release in a semi-automated way:"
msgstr ""

#: src/project/contributing/development.md:450
msgid ""
"PR & merge an updated [Changelog](https://github.com/PRQL/prql/blob/main/"
"CHANGELOG.md). GitHub will produce a draft version at <https://github.com/"
"PRQL/prql/releases/new>, including \"New Contributors\"."
msgstr ""

#: src/project/contributing/development.md:455
msgid "Use this script to generate a line introducing the enumerated changes:"
msgstr ""

#: src/project/contributing/development.md:458
msgid ""
"\"It has $(git rev-list --count $(git rev-list --tags --max-count=1)..) "
"commits from $(git shortlog --summary $(git rev-list --tags --max-count=1).. "
"| wc -l | tr -d '[:space:]') contributors. Selected changes:\""
msgstr ""

#: src/project/contributing/development.md:461
msgid ""
"If the current version is correct, then skip ahead. But if the version needs "
"to be changed — for example, we had planned on a patch release, but instead "
"require a minor release — then run `cargo release version $version -x && "
"cargo release replace -x && task prqlc:test-all` to bump the version, and PR "
"the resulting commit."
msgstr ""

#: src/project/contributing/development.md:467
msgid ""
"Ensure all changes intended for the release are merged to `main`. Then "
"create the release (which creates the tag on the latest commit on `main`):"
msgstr ""

#: src/project/contributing/development.md:470
msgid ""
"**Web UI:** Go to [Draft a new release](https://github.com/PRQL/prql/"
"releases/new)<sup><a name=\"to-footnote-3\">[3](#footnote-3)</a></sup>, copy "
"the changelog entry into the release description<sup><a name=\"to-"
"footnote-4\">[4](#footnote-4)</a></sup>, enter the tag to be created, and "
"hit \"Publish\"."
msgstr ""

#: src/project/contributing/development.md:476
msgid "**CLI:**"
msgstr ""

#: src/project/contributing/development.md:479
msgid "\"$version\""
msgstr ""

#: src/project/contributing/development.md:479
msgid "\"$(cat <<'EOF'\n"
msgstr ""

#: src/project/contributing/development.md:485
msgid ""
"From there, both the tag and release is created and all packages are "
"published automatically based on our [release workflow](https://github.com/"
"PRQL/prql/blob/main/.github/workflows/release.yaml)."
msgstr ""

#: src/project/contributing/development.md:489
msgid ""
"Run `cargo release patch --no-publish --no-push --execute --no-verify --no-"
"confirm --no-tag && task prqlc:test-all` to bump the versions and add a new "
"Changelog section; then PR the resulting commit. Note this currently "
"contains `task prqlc:test-all` to update snapshot tests which contain the "
"version."
msgstr ""

#: src/project/contributing/development.md:497
msgid ""
"Check whether there are [milestones](https://github.com/PRQL/prql/"
"milestones) that need to be pushed out."
msgstr ""

#: src/project/contributing/development.md:500
msgid ""
"Review the **Current Status** on the README.md to ensure it reflects the "
"project state."
msgstr ""

#: src/project/contributing/development.md:503
msgid ""
"We may make this more automated in future; e.g. automatic changelog creation."
msgstr ""

#: src/project/contributing/development.md:507
msgid ""
"<a name=\"footnote-1\">[1](#to-footnote-1)</a>: Our approach is very "
"consistent with **[@matklad](https://github.com/matklad)**'s advice, in his "
"excellent blog post [How to Test](https://matklad.github.io//2021/05/31/how-"
"to-test.html)."
msgstr ""

#: src/project/contributing/development.md:512
msgid ""
"<a name=\"footnote-2\">[2](#to-footnote-2)</a>: [Here's an example of an "
"insta test](https://github.com/PRQL/prql/blob/0.2.2/prql-compiler/src/parser."
"rs#L580-L605) — note that only the initial line of each test is written by "
"us; the remainder is filled in by insta."
msgstr ""

#: src/project/contributing/development.md:516
msgid ""
"<a name=\"footnote-3\">[3](#to-footnote-3)</a>: Only maintainers have access "
"to this page."
msgstr ""

#: src/project/contributing/development.md:519
msgid ""
"<a name=\"footnote-4\">[4](#to-footnote-4)</a>: Unfortunately GitHub's "
"markdown parser interprets linebreaks as newlines. I haven't found a better "
"way of editing the markdown to look reasonable than manually editing the "
"text or asking LLM to help."
msgstr ""

#: src/project/contributing/language-design.md:3
msgid ""
"In a way PRQL is just a transpiler to SQL. This can cause its language "
"design to gravitate toward thinking about PRQL features in terms of how they "
"translate to SQL."
msgstr ""

#: src/project/contributing/language-design.md:11
msgid "This is flawed because:"
msgstr ""

#: src/project/contributing/language-design.md:13
msgid "it does not model interactions between features well,"
msgstr ""

#: src/project/contributing/language-design.md:14
msgid ""
"SQL behavior can sometimes be misleading (the order of a subquery will not "
"persist in the parent query) or even differs between dialects (set "
"operations)."
msgstr ""

#: src/project/contributing/language-design.md:18
msgid ""
"Instead, we should think of PRQL features in terms of how they affect PRQL "
"expressions, which in most cases means how they affect relations."
msgstr ""

#: src/project/contributing/language-design.md:34
msgid ""
"Thinking about SQL comes in only at the last step when relation (or rather "
"relational expression) is translated to an SQL expression."
msgstr ""

#: src/project/integrations/index.md:1
msgid "Integrations"
msgstr "整合"

#: src/project/integrations/index.md:3
msgid "PRQL is building integrations with lots of external tools, including:"
msgstr ""

#: src/project/integrations/index.md:5
msgid "[`prqlc` CLI](./prqlc-cli.md) - Rust compiler for the command line"
msgstr ""

#: src/project/integrations/index.md:6
msgid "[ClickHouse](./clickhouse.md)"
msgstr "[ClickHouse](./clickhouse.md)"

#: src/project/integrations/index.md:7
msgid "[Jupyter](./jupyter.md)"
msgstr "[Jupyter](./jupyter.md)"

#: src/project/integrations/index.md:8
msgid "[DuckDB](./duckdb.md)"
msgstr "[DuckDB](./duckdb.md)"

#: src/project/integrations/index.md:9
msgid "[QStudio](./qstudio.md)"
msgstr "[QStudio](./qstudio.md)"

#: src/project/integrations/index.md:10
msgid "[Prefect](./prefect.md)"
msgstr "[Prefect](./prefect.md)"

#: src/project/integrations/index.md:11
msgid "[VS Code](./vscode.md)"
msgstr "[VS Code](./vscode.md)"

#: src/project/integrations/index.md:12
msgid "[PostgreSQL](./postgresql.md)"
msgstr "[PostgreSQL](./postgresql.md)"

#: src/project/integrations/index.md:13
msgid "[Databend](./databend.md)"
msgstr "[Databend](./databend.md)"

#: src/project/integrations/index.md:14
msgid "[Rill](./rill.md)"
msgstr "[Rill](./rill.md)"

#: src/project/integrations/index.md:15
msgid "[Syntax highlighting](./syntax-highlighting.md) for many popular tools."
msgstr ""

#: src/project/integrations/clickhouse.md:1
msgid "ClickHouse"
msgstr "ClickHouse"

#: src/project/integrations/clickhouse.md:3
msgid ""
"PRQL works natively in ClickHouse. Check out the [ClickHouse docs](https://"
"clickhouse.com/docs/en/guides/developer/alternative-query-languages) for "
"more details."
msgstr ""

#: src/SUMMARY.md:106
msgid "Databend"
msgstr "Databend"

#: src/project/integrations/databend.md:3
msgid ""
"Databend natively supports PRQL. For more details see the [databend docs]"
"(https://www.databend.com/blog/2024-04-03-databend-integrates-prql/)."
msgstr ""

#: src/project/integrations/duckdb.md:1
msgid "DuckDB"
msgstr "DuckDB"

#: src/project/integrations/duckdb.md:3
msgid ""
"There's a [DuckDB](https://duckdb.org/) community extension by **[@ywelsch]"
"(https://github.com/ywelsch)** at the DuckDB Community Extension Repository."
msgstr ""

#: src/project/integrations/duckdb.md:9
msgid "-- Once the extension is loaded, you can write PRQL queries\n"
msgstr ""

#: src/project/integrations/duckdb.md:11
msgid ""
"'https://raw.githubusercontent.com/PRQL/prql/0.8.0/prql-compiler/tests/"
"integration/data/chinook/invoices.csv'"
msgstr ""

#: src/project/integrations/duckdb.md:16
msgid ""
"Check out the [extension's documentation](https://community-extensions."
"duckdb.org/extensions/prql.html) for more details."
msgstr ""

#: src/project/integrations/jupyter.md:1
msgid "Jupyter"
msgstr "Jupyter"

#: src/project/integrations/jupyter.md:3
msgid ""
"[pyprql](https://pypi.org/project/pyprql/) contains `pyprql.magic`, a thin "
"wrapper of [`JupySQL`](https://pypi.org/project/jupysql/)'s SQL IPython "
"magics. This allows us to run PRQL interactively on Jupyter/IPython."
msgstr ""

#: src/project/integrations/jupyter.md:7
msgid "Check out <https://pyprql.readthedocs.io/> for more context."
msgstr ""

#: src/project/integrations/jupyter.md:17
msgid ""
"When installing pyprql, the [duckdb-engine](https://pypi.org/project/duckdb-"
"engine/) package is also installed with it, so we can start using PRQL "
"immediately to query CSV and Parquet files."
msgstr ""

#: src/project/integrations/jupyter.md:22
msgid ""
"For example, running [the example from the JupySQL documentation](https://"
"jupysql.ploomber.io/en/latest/quick-start.html) on IPython:"
msgstr ""

#: src/project/integrations/postgresql.md:1
msgid "PostgreSQL"
msgstr "PostgreSQL"

#: src/project/integrations/postgresql.md:3
msgid ""
"PL/PRQL is a PostgreSQL extension that lets you write functions with PRQL."
msgstr ""

#: src/project/integrations/postgresql.md:5
msgid ""
"PL/PRQL functions serve as intermediaries, compiling the user's PRQL code "
"into SQL statements that PostgreSQL executes. The extension is based on the "
"[pgrx](https://github.com/pgcentralfoundation/pgrx) framework for developing "
"PostgreSQL extensions in Rust. This framework manages the interaction with "
"PostgreSQL's internal APIs, type conversions, and other function hooks "
"necessary to integrate PRQL with PostgreSQL."
msgstr ""

#: src/project/integrations/postgresql.md:12
msgid "Examples"
msgstr "範例"

#: src/project/integrations/postgresql.md:14
msgid "PL/PRQL functions are defined using the `plprql` language specifier:"
msgstr ""

#: src/project/integrations/postgresql.md:33
msgid "---------+----------\n"
msgstr ""

#: src/project/integrations/postgresql.md:40
msgid ""
"You can also run PRQL code directly with the `prql` function which is useful "
"for custom SQL in ORMs:"
msgstr ""

#: src/project/integrations/postgresql.md:44
#: src/project/integrations/postgresql.md:55
msgid "'from matches | filter player == ''Player1'''"
msgstr ""

#: src/project/integrations/postgresql.md:48
msgid "----+----------+-------+---------+-------+--------\n"
msgstr "----+----------+-------+---------+-------+--------\n"

#: src/project/integrations/postgresql.md:53
msgid ""
"-- Same as above without the need for the static types, but returns cursor\n"
msgstr ""

#: src/project/integrations/postgresql.md:55
msgid "'player1_cursor'"
msgstr ""

#: src/project/integrations/postgresql.md:59
msgid "Getting Started"
msgstr "開始使用"

#: src/project/integrations/postgresql.md:61
msgid ""
"For installation instructions and more information on the extension, see the "
"[PL/PRQL repository](https://github.com/kaspermarstal/plprql)."
msgstr ""

#: src/project/integrations/prefect.md:1
msgid "Prefect"
msgstr "Prefect"

#: src/project/integrations/prefect.md:3
msgid ""
"Because [Prefect](https://www.prefect.io/) is in native Python, it's "
"extremely easy to integrate with PRQL."
msgstr ""

#: src/project/integrations/prefect.md:6
msgid "With a Postgres Task, replace:"
msgstr ""

#: src/project/integrations/prefect.md:12
msgid "...with..."
msgstr ""

#: src/project/integrations/prefect.md:18
msgid ""
"We're big fans of Prefect, and if there is anything that would make the "
"integration easier, please open an issue."
msgstr ""

#: src/project/integrations/prqlc-cli.md:1
msgid "PRQL compiler"
msgstr "PRQL 編譯器"

#: src/project/integrations/prqlc-cli.md:3
msgid ""
"`prqlc` is the reference implementation of a compiler from PRQL to SQL, "
"written in Rust. It also serves as the CLI."
msgstr ""

#: src/project/integrations/prqlc-cli.md:6
msgid ""
"For more on PRQL, check out the [PRQL website](https://prql-lang.org) or the "
"[PRQL repo](https://github.com/PRQL/prql)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:9
msgid "CLI"
msgstr ""

#: src/project/integrations/prqlc-cli.md:11
msgid ""
"`prqlc` serves as a CLI for the PRQL compiler. It is a single, dependency-"
"free binary that compiles PRQL into SQL."
msgstr ""
"`prqlc` 是 PRQL 編譯器的 CLI。它是一個無相依項的二進位檔，可以將 PRQL 編譯為 "
"SQL。"

#: src/project/integrations/prqlc-cli.md:16
msgid "`prqlc compile`"
msgstr ""

#: src/project/integrations/prqlc-cli.md:18
msgid ""
"This command works as a filter that compiles a PRQL string into an SQL "
"string."
msgstr ""

#: src/project/integrations/prqlc-cli.md:21
msgid "'from employees | filter has_dog | select salary'"
msgstr ""

#: src/project/integrations/prqlc-cli.md:31
msgid ""
"A PRQL query can be executed with CLI tools compatible with SQL, such as "
"[DuckDB CLI](https://duckdb.org/docs/api/cli.html)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:36
msgid "'from `albums.csv` | take 3'"
msgstr ""

#: src/project/integrations/prqlc-cli.md:47
msgid ""
"Executing this command without any argument will start interactive mode, "
"allowing a PRQL query to be written interactively. In this mode, after "
"writing PRQL and press `Ctrl-d` (Linux, macOS) or `Ctrl-z` (Windows) to "
"display the compiled SQL."
msgstr ""

#: src/project/integrations/prqlc-cli.md:56
msgid ""
"Just like when using it as a filter, SQL string output can be passed to the "
"DuckDB CLI and similar tools."
msgstr ""

#: src/project/integrations/prqlc-cli.md:77
msgid ""
"[![Packaging status](https://repology.org/badge/vertical-allrepos/prqlc.svg)]"
"(https://repology.org/project/prqlc/versions)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:79
msgid "via Homebrew (macOS, Linux)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:85
msgid "via winget (Windows)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:91
msgid "From GitHub release page"
msgstr ""

#: src/project/integrations/prqlc-cli.md:93
msgid ""
"Precompiled binaries are available for Linux, macOS, and Windows on the "
"[PRQL release page](https://github.com/PRQL/prql/releases)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:96
msgid "From source"
msgstr ""

#: src/project/integrations/prqlc-cli.md:99
msgid "# From crates.io\n"
msgstr ""

#: src/project/integrations/prqlc-cli.md:104
msgid "# From a local PRQL repository\n"
msgstr ""

#: src/project/integrations/prqlc-cli.md:108
msgid "Shell completions"
msgstr ""

#: src/project/integrations/prqlc-cli.md:110
msgid ""
"The `prqlc shell-completion` command prints a shell completion script for "
"supported shells, and saving the printed scripts to files makes for shells "
"to load completions for each session."
msgstr ""

#: src/project/integrations/prqlc-cli.md:114
msgid "Bash"
msgstr ""

#: src/project/integrations/prqlc-cli.md:116
msgid "For Linux:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:122
msgid "For macOS:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:128
msgid "fish"
msgstr ""

#: src/project/integrations/prqlc-cli.md:134
msgid "PowerShell"
msgstr ""

#: src/project/integrations/prqlc-cli.md:142
msgid "zsh"
msgstr ""

#: src/project/integrations/prqlc-cli.md:145
msgid "\"${fpath[1]}/_prqlc\""
msgstr ""

#: src/project/integrations/prqlc-cli.md:148
msgid "Ensure that the following lines are present in `~/.zshrc`:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:155
msgid "Helpers"
msgstr ""

#: src/project/integrations/prqlc-cli.md:157
msgid ""
"Cheat sheets for `prqlc` are available on various websites and with various "
"tools."
msgstr ""

#: src/project/integrations/prqlc-cli.md:160
msgid ""
"[`tldr`](https://tldr.sh/) ([on the web](https://tldr.inbrowser.app/pages/"
"common/prqlc))"
msgstr ""

#: src/project/integrations/prqlc-cli.md:162
msgid "[`eg`](https://github.com/srsudar/eg)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:166
msgid "Library"
msgstr ""

#: src/project/integrations/prqlc-cli.md:168
msgid ""
"For more usage examples and the library documentation, check out the "
"[`prqlc` documentation](https://docs.rs/prqlc/)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:171
msgid "Library installation"
msgstr ""

#: src/project/integrations/prqlc-cli.md:179
msgid "Compile a PRQL string to a SQLite dialect string:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:182
msgid "// In a file src/main.rs\n"
msgstr ""

#: src/project/integrations/prqlc-cli.md:186
msgid "\"from employees | select {name, age}\""
msgstr ""

#: src/project/integrations/prqlc-cli.md:195
msgid "\"SELECT name, age FROM employees\""
msgstr ""

#: src/project/integrations/qstudio.md:1
msgid "QStudio IDE"
msgstr ""

#: src/project/integrations/qstudio.md:3
msgid ""
"[QStudio](https://www.timestored.com/qstudio/prql-ide) is a SQL GUI that "
"lets you browse tables, run SQL scripts, and chart and export the results. "
"QStudio runs on Windows, macOS and Linux, and works with every popular "
"database including mysql, postgresql, mssql, kdb...."
msgstr ""

#: src/project/integrations/qstudio.md:9
msgid ""
"\\[!NOTE\\] QStudio relies on the PRQL compiler. You must ensure that "
"`prqlc` is in your path. See the [installation instructions](https://prql-"
"lang.org/book/project/integrations/prqlc-cli.html#installation) for `prqlc` "
"in the PRQL reference guide for details."
msgstr ""

#: src/project/integrations/qstudio.md:15
msgid ""
"QStudio calls `prqlc` (the PRQL compiler) to generate SQL code from PRQL "
"queries (.prql files) then runs the SQL against the selected database to "
"display the results. For more details, check out:"
msgstr ""

#: src/project/integrations/qstudio.md:19
msgid "[QStudio site](https://www.timestored.com/qstudio/prql-ide)"
msgstr ""

#: src/project/integrations/qstudio.md:20
msgid ""
"[QStudio-PRQL Quick Start](https://github.com/richb-hanover/qStudio-"
"PRQL_Quick_Start)"
msgstr ""

#: src/project/integrations/qstudio.md:21
msgid ""
"There is a [double-clickable macOS app](https://randomneuronsfiring.com/wp-"
"content/uploads/QStudio.zip) that bundles QStudio and the `prqlc` compiler."
msgstr ""

#: src/project/integrations/rill.md:1
msgid "Rill"
msgstr "Rill"

#: src/project/integrations/rill.md:3
msgid ""
"PRQL has had some work to integrate with Rill. See the [Rill issues](https://"
"github.com/PRQL/prql/issues?q=is%3Aissue+rill) for more details."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:1
msgid "Grammars / syntax highlighting"
msgstr "文法/語法標明"

#: src/project/integrations/syntax-highlighting.md:3
msgid ""
"PRQL contains multiple grammar definitions to enable tools to highlight PRQL "
"code. These are all intended to provide as good an experience as the grammar "
"supports. Please raise any shortcomings in a GitHub issue."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:7
msgid ""
"The definitions are somewhat scattered around the codebase; this page serves "
"as an index."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:10
msgid ""
"[Ace](https://ace.c9.io/) — supported. The grammar is upstream "
"([prql_highlight_rules.js](https://github.com/ajaxorg/ace/blob/master/src/"
"mode/prql_highlight_rules.js)). See the [demo](https://prql-lang.org/demos/"
"ace-demo)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:14
msgid ""
"[chroma](https://github.com/alecthomas/chroma) — Go library used by the "
"static website generator Hugo. The grammar is upstream ([prql.xml](https://"
"github.com/alecthomas/chroma/blob/master/lexers/embedded/prql.xml)). See the "
"[demo](https://swapoff.org/chroma/playground/)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:19
msgid ""
"[CotEditor](https://coteditor.com/) — text editor for macOS. File is at "
"[`grammars/CotEditor/`](https://github.com/PRQL/prql/tree/main/grammars/"
"CotEditor/)."
msgstr ""
"[CotEditor](https://coteditor.com/) — macOS 的文字編輯器。檔案位於 "
"[`grammars/CotEditor/`](https://github.com/PRQL/prql/tree/main/grammars/"
"CotEditor/)。"

#: src/project/integrations/syntax-highlighting.md:22
msgid ""
"[Lezer](https://lezer.codemirror.net/) — used by CodeMirror editors. The "
"PRQL file is at [`grammars/prql-lezer/README.md`](https://github.com/PRQL/"
"prql/tree/main/grammars/prql-lezer/README.md)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:26
msgid ""
"emacs — used by terminal-based text editor GNU Emacs. File is at [`grammars/"
"emacs/`](https://github.com/PRQL/prql/tree/main/grammars/emacs/)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:29
msgid ""
"GtkSourceView — used by GNOME Text Editor, GNOME Builder and other GTK "
"applications. File is at [`grammars/GtkSourceView/`](https://github.com/PRQL/"
"prql/tree/main/grammars/GtkSourceView/)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:33
msgid "[Handlebars](https://handlebarsjs.com/) — currently duplicated:"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:34
msgid ""
"The book: [`book/highlight-prql.js`](https://github.com/PRQL/prql/blob/main/"
"web/book/highlight-prql.js)"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:36
msgid ""
"The website (outside of the book & playground): [`website/themes/prql-theme/"
"static/plugins/highlight/prql.js`](https://github.com/PRQL/prql/blob/main/"
"web/book/highlight-prql.js)"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:39
msgid ""
"[Helix](https://helix-editor.com/) — supported. The grammar is [upstream]"
"(https://github.com/helix-editor/helix/tree/master/runtime/queries/prql)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:42
msgid ""
"[Kakoune](https://kakoune.org/) — supported. The grammar is [upstream]"
"(https://github.com/mawww/kakoune/blob/master/rc/filetype/prql.kak)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:45
msgid ""
"KSyntaxHighlighting — used by Kate, KWrite and KDevelop and other Qt "
"applications. File is at [`grammars/KSyntaxHighlighting/`](https://github."
"com/PRQL/prql/tree/main/grammars/KSyntaxHighlighting/)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:49
msgid ""
"[micro](https://micro-editor.github.io/) — used by terminal-based text "
"editor Micro. The grammar is [upstream](https://github.com/zyedidia/micro/"
"blob/master/runtime/syntax/prql.yaml)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:53
msgid ""
"[nano](https://nano-editor.org/) — used by terminal-based text editor GNU "
"nano. File is at [`grammars/nano/`](https://github.com/PRQL/prql/tree/main/"
"grammars/nano/)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:57
msgid ""
"Sublime Text — in the [`sublime-prql`](https://github.com/PRQL/sublime-"
"prql/) repository."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:60
msgid ""
"TextMate — used by the VS Code extension; in the `prql-vscode` repo in "
"[`prql-vscode/syntaxes/prql.tmLanguage.json`](https://github.com/PRQL/prql-"
"vscode/blob/main/syntaxes/prql.tmLanguage.json)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:63
msgid ""
"[Monarch](https://microsoft.github.io/monaco-editor/monarch.html) — used by "
"the Monaco editor, which we use for the Playground. The grammar is at "
"[`playground/src/workbench/prql-syntax.js`](https://github.com/PRQL/prql/"
"blob/main/web/playground/src/workbench/prql-syntax.js)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:67
msgid ""
"[Pygments](https://pygments.org/) — Python library used by Wikipedia, "
"Bitbucket, Sphinx and [more](https://pygments.org/faq/#who-uses-pygments). "
"The grammar is upstream ([prql.py](https://github.com/pygments/pygments/blob/"
"master/pygments/lexers/prql.py)). See the [demo](https://pygments.org/demo/)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:73
msgid ""
"[Raku](https://raku.org/) — Grammar can be found at [`grammars/raku/`]"
"(https://github.com/PRQL/prql/tree/main/grammars/raku/)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:76
msgid ""
"[TEA](https://github.com/psemiletov/tea-qt/) — supported. The grammar is "
"[upstream](https://github.com/psemiletov/tea-qt/blob/master/hls/prql.xml)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:79
msgid ""
"[Tree-Sitter](https://tree-sitter.github.io/tree-sitter) — used by the "
"neovim and helix. The grammar can be found at [https://github.com/PRQL/tree-"
"sitter-prql](https://github.com/PRQL/tree-sitter-prql)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:83
msgid ""
"[vim](https://www.vim.org/) — used by terminal-based text editor Vim. "
"Instructions at [`grammars/vim/`](https://github.com/PRQL/prql/tree/main/"
"grammars/vim/). The grammar is [upstream](https://github.com/vim/vim/blob/"
"master/runtime/syntax/prql.vim)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:88
msgid "[Neovim](https://neovim.io/) supported. Grammar is upstream."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:92
msgid ""
"Since the [Elm](https://elm-lang.org/) language coincidentally provides "
"syntax highlighting suitable for PRQL, it may look better to mark PRQL code "
"as Elm when the above definition files are not available."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:96
msgid ""
"For example, the following Markdown code block will be nicely highlighted on "
"GitHub, Pandoc, and other Markdown renderers:"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:106
msgid ""
"We hope that in the future these renderers will recognize PRQL code blocks "
"and have syntax highlighting applied, and we are tracking these with several "
"issues."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:109
msgid "GitHub (Linguist): <https://github.com/PRQL/prql/issues/1636>"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:110
msgid "Pandoc (Kate): <https://github.com/PRQL/prql/issues/2213>"
msgstr ""

#: src/project/integrations/vscode.md:1
msgid "Visual Studio Code extension"
msgstr ""

#: src/project/integrations/vscode.md:3
msgid ""
"PRQL has a Visual Studio Code extension that compiles a PRQL query in a VS "
"Code editor and displays the resulting SQL code in a second pane on the "
"side. This is very handy for editing, saving, and reusing PRQL queries in VS "
"Code."
msgstr ""

#: src/project/integrations/vscode.md:7
msgid ""
"To install the VS Code extension, open VS Code and type <kbd>Ctrl</kbd>\\-"
"<kbd>Shift</kbd>\\-<kbd>P</kbd> (<kbd>Cmd</kbd>\\-<kbd>Shift</kbd>\\-<kbd>P</"
"kbd> on a Mac) and type `PRQL`. Install the extension as usual."
msgstr ""

#: src/project/integrations/vscode.md:12
msgid ""
"[Repo for the PRQL VS Code extension](https://github.com/PRQL/prql-vscode)"
msgstr ""

#: src/project/integrations/vscode.md:14
msgid ""
"[Extension on VS Marketplace](https://marketplace.visualstudio.com/items?"
"itemName=PRQL-lang.prql-vscode)"
msgstr ""

#: src/project/target.md:1
msgid "Target & Version"
msgstr ""

#: src/project/target.md:3
msgid "Target dialect"
msgstr ""

#: src/project/target.md:5
msgid ""
"PRQL allows specifying a target dialect at the top of the query, which "
"allows PRQL to compile to a database-specific SQL flavor."
msgstr ""

#: src/project/target.md:26
msgid "Dialects"
msgstr ""

#: src/project/target.md:30
msgid ""
"Supported dialects support all PRQL language features where possible, are "
"tested on every commit, and we'll endeavor to fix bugs."
msgstr ""

#: src/project/target.md:33
msgid "`sql.clickhouse`"
msgstr ""

#: src/project/target.md:34
msgid "`sql.duckdb`"
msgstr ""

#: src/project/target.md:35
msgid "`sql.generic` <sup><a name=\"to-footnote-1\">[1](#footnote-1)</a></sup>"
msgstr ""

#: src/project/target.md:37
msgid "`sql.glaredb`"
msgstr "`sql.glaredb`"

#: src/project/target.md:38
msgid "`sql.mysql`"
msgstr "`sql.mysql`"

#: src/project/target.md:39
msgid "`sql.postgres`"
msgstr "`sql.postgres`"

#: src/project/target.md:40
msgid "`sql.sqlite`"
msgstr "`sql.sqlite`"

#: src/project/target.md:44
msgid ""
"Unsupported dialects have implementations in the compiler, but are tested "
"minimally or not at all, and may have gaps for some features."
msgstr ""

#: src/project/target.md:47
msgid ""
"We're open to contributions to improve our coverage of these, and to adding "
"additional dialects."
msgstr ""

#: src/project/target.md:50
msgid "`sql.mssql`"
msgstr "`sql.mssql`"

#: src/project/target.md:51
msgid "`sql.ansi`"
msgstr "`sql.ansi`"

#: src/project/target.md:52
msgid "`sql.bigquery`"
msgstr "`sql.bigquery`"

#: src/project/target.md:53
msgid "`sql.snowflake`"
msgstr "`sql.snowflake`"

#: src/project/target.md:55
msgid "Priority of targets"
msgstr ""

#: src/project/target.md:57
msgid ""
"The compile target of a query is defined in the query's header or as an "
"argument to the compiler. option. The argument to the compiler takes "
"precedence."
msgstr ""

#: src/project/target.md:60
msgid ""
"For example, the following shell example specifies `sql.generic` in the "
"query and `sql.duckdb` in the `--target` option of the `prqlc compile` "
"command. In this case, `sql.duckdb` takes precedence and the SQL output is "
"based on the DuckDB dialect."
msgstr ""

#: src/project/target.md:66 src/project/target.md:74
msgid ""
"'prql target:sql.generic\n"
"      from foo'"
msgstr ""

#: src/project/target.md:70
msgid ""
"To use the target described in the query, a special target `sql.any` can be "
"specified in the compiler option."
msgstr ""

#: src/project/target.md:78
msgid "Version"
msgstr "版本"

#: src/project/target.md:80
msgid ""
"PRQL allows specifying a version of the language in the PRQL header, like:"
msgstr ""

#: src/project/target.md:82
msgid ""
"```prql\n"
"prql version:\"0.13.10\"\n"
"\n"
"from employees\n"
"```"
msgstr ""

#: src/project/target.md:88
msgid "This has two roles, one of which is implemented:"
msgstr ""

#: src/project/target.md:90
msgid ""
"The compiler will raise an error if the compiler is older than the query "
"version. This prevents confusing errors when queries use newer features of "
"the language but the compiler hasn't yet been upgraded."
msgstr ""

#: src/project/target.md:93
msgid ""
"The compiler will compile for the major version of the query. This allows "
"the language to evolve without breaking existing queries, or forcing "
"multiple installations of the compiler. This isn't yet implemented, but is a "
"gating feature for PRQL 1.0."
msgstr ""

#: src/project/target.md:98
msgid ""
"The version of the compiler currently in use can be called using the special "
"function `std.prql.version` in PRQL."
msgstr ""

#: src/project/target.md:106
msgid ""
"\\[!NOTE\\] This function was renamed from `std.prql_version` to `prql."
"version` in PRQL 0.11.1. `std.prql_version` will be removed in PRQL 0.12.0."
msgstr ""

#: src/project/target.md:112
msgid ""
"<a name=\"footnote-1\">[1](#to-footnote-1)</a>: while there's no \"generic\" "
"DB to test `sql.generic` against, we still count it as supported."
msgstr ""

#: src/reference/declarations/functions.md:1
msgid "Functions"
msgstr "函式"

#: src/reference/declarations/functions.md:7
msgid "Functions have two types of parameters:"
msgstr ""

#: src/reference/declarations/functions.md:9
msgid "Positional parameters, which require an argument."
msgstr ""

#: src/reference/declarations/functions.md:10
msgid ""
"Named parameters, which optionally take an argument, otherwise using their "
"default value."
msgstr ""

#: src/reference/declarations/functions.md:13
msgid ""
"So this function is named `fahrenheit_to_celsius` and has one parameter "
"`temp`:"
msgstr ""

#: src/reference/declarations/functions.md:22
msgid ""
"The function below is named `interp`, and has two positional parameters "
"named `high` and `x`, and one named parameter named `low` which takes a "
"default argument of `0`. It calculates the proportion of the distance that "
"`x` is between `low` and `high`."
msgstr ""

#: src/reference/declarations/functions.md:37
msgid "Other examples"
msgstr "其他範例"

#: src/reference/declarations/functions.md:39
msgid ""
"```prql\n"
"let is_adult = col -> col >= 18\n"
"let writes_code = col -> (col | in [\"PRQL\", \"Rust\"])\n"
"let square = col -> (col | math.pow 2)\n"
"let starts_with_a = col -> (col | text.lower | text.starts_with(\"a\"))\n"
"\n"
"from employees\n"
"select {\n"
"    first_name,\n"
"    last_name,\n"
"    hobby,\n"
"    adult = is_adult age,\n"
"    age_squared = square age,\n"
"}\n"
"filter ((starts_with_a last_name) && (writes_code hobby))\n"
"```"
msgstr ""

#: src/reference/declarations/functions.md:56
msgid "Piping values into functions"
msgstr ""

#: src/reference/declarations/functions.md:58
msgid ""
"Consistent with the principles of PRQL, it's possible to pipe values into "
"functions, which makes composing many functions more readable. When piping a "
"value into a function, the value is passed as an argument to the final "
"positional parameter of the function. Here's the same result as the examples "
"above with an alternative construction:"
msgstr ""

#: src/reference/declarations/functions.md:74
msgid "and"
msgstr "且"

#: src/reference/declarations/functions.md:83
msgid "We can combine a chain of functions, which makes logic more readable:"
msgstr ""

#: src/reference/declarations/functions.md:93
msgid "Late binding"
msgstr ""

#: src/reference/declarations/functions.md:95
msgid ""
"Functions can bind to any variable that is in scope when the function is "
"executed. For example, here `cost_total` refers to the column that's "
"introduced in the `from`."
msgstr ""

#: src/reference/declarations/functions.md:111
msgid "Partial application"
msgstr ""

#: src/reference/declarations/functions.md:113
msgid ""
"Functions can be partially applied, which is useful for creating reusable "
"transform wrappers. When a function returns a partially-applied transform, "
"the missing parameters are automatically propagated."
msgstr ""

#: src/reference/declarations/functions.md:117
msgid "For example, we can create a `top_n` function that wraps `take`:"
msgstr ""

#: src/reference/declarations/functions.md:126
msgid ""
"This works because `take` requires two arguments (the count and the "
"relation), but `top_n` only provides one. The relation parameter is "
"automatically filled in from the pipeline."
msgstr ""

#: src/reference/declarations/functions.md:130
msgid "We can also compose multiple partial applications:"
msgstr ""

#: src/reference/declarations/functions.md:142
msgid "Or store a fully-configured transform for reuse:"
msgstr ""

#: src/reference/declarations/variables.md:1
msgid "Variables — `let` & `into`"
msgstr "變數 — `let` 與 `into`"

#: src/reference/declarations/variables.md:3
msgid ""
"Variables assign a name — say `x` — to an expression, like in most "
"programming languages. The name can then be used in any expression, acting "
"as a substitute for the expression `x`."
msgstr ""

#: src/reference/declarations/variables.md:7
msgid "Syntactically, variables can take 3 forms."
msgstr ""

#: src/reference/declarations/variables.md:9
msgid "`let` declares the name before the expression."
msgstr ""

#: src/reference/declarations/variables.md:15
msgid ""
"`into` declares the name after the expression. This form is useful for quick "
"pipeline splitting and conforms with the \"flow from top to bottom\" rule of "
"pipelines."
msgstr ""

#: src/reference/declarations/variables.md:24
msgid "The final expression of a pipeline defaults to taking the name `main`."
msgstr ""

#: src/reference/declarations/variables.md:30
msgid "... is equivalent to:"
msgstr ""

#: src/reference/declarations/variables.md:36
msgid ""
"When compiling to SQL, relational variables are compiled to Common Table "
"Expressions (or sub-queries in some cases)."
msgstr ""

#: src/reference/declarations/variables.md:58
msgid ""
"Variables can be assigned an s-string containing the whole SQL query [s-"
"string](../syntax/s-strings.md), enabling us to use features which PRQL "
"doesn't yet support."
msgstr ""

#: src/reference/declarations/variables.md:62
msgid ""
"```prql\n"
"let grouping = s\"\"\"\n"
"  SELECT SUM(a)\n"
"  FROM tbl\n"
"  GROUP BY\n"
"    GROUPING SETS\n"
"    ((b, c, d), (d), (b, d))\n"
"\"\"\"\n"
"\n"
"from grouping\n"
"```"
msgstr ""

#: src/reference/data/index.md:1
msgid "Importing data"
msgstr "匯入資料"

#: src/reference/data/relation-literals.md:1
msgid "How do I: create ad-hoc relations?"
msgstr ""

#: src/reference/data/relation-literals.md:3
msgid ""
"It's often useful to make a small inline relation, for example when "
"exploring how a database will evaluate an expression, or for a small lookup "
"table. This can be quite verbose in SQL."
msgstr ""

#: src/reference/data/relation-literals.md:7
msgid ""
"PRQL offers two approaches — array literals, and a `from_text` transform."
msgstr ""

#: src/reference/data/relation-literals.md:9
msgid "Array literals"
msgstr ""

#: src/reference/data/relation-literals.md:11
msgid ""
"Because relations (aka a table) in PRQL are just arrays of tuples, they can "
"be expressed with array and tuple syntax:"
msgstr ""

#: src/reference/data/relation-literals.md:23
msgid ""
"```prql\n"
"let my_artists = [\n"
"  {artist=\"Miles Davis\"},\n"
"  {artist=\"Marvin Gaye\"},\n"
"  {artist=\"James Brown\"},\n"
"]\n"
"\n"
"from artists\n"
"join my_artists (==artist)\n"
"join albums (==artist_id)\n"
"select {artists.artist_id, albums.title}\n"
"```"
msgstr ""

#: src/reference/data/relation-literals.md:36
msgid "`from_text`"
msgstr ""

#: src/reference/data/relation-literals.md:38
msgid ""
"`from_text` takes a string in a common format, and converts it to table. It "
"accepts a few formats:"
msgstr ""

#: src/reference/data/relation-literals.md:41
msgid "`format:csv` parses CSV (default),"
msgstr ""

#: src/reference/data/relation-literals.md:43
msgid "`format:json` parses either:"
msgstr ""

#: src/reference/data/relation-literals.md:44
msgid "an array of objects each of which represents a row, or"
msgstr ""

#: src/reference/data/relation-literals.md:46
msgid ""
"an object with fields `columns` & `data`, where `columns` take an array of "
"column names and `data` takes an array of arrays."
msgstr ""

#: src/reference/data/relation-literals.md:49
msgid ""
"```prql\n"
"from_text \"\"\"\n"
"a,b,c\n"
"1,2,3\n"
"4,5,6\n"
"\"\"\"\n"
"derive {\n"
"    d = b + c,\n"
"    answer = 20 * 2 + 2,\n"
"}\n"
"```"
msgstr ""

#: src/reference/data/relation-literals.md:61
msgid ""
"```prql\n"
"from_text format:json \"\"\"\n"
"[\n"
"    {\"a\": 1, \"m\": \"5\"},\n"
"    {\"a\": 4, \"n\": \"6\"}\n"
"]\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/reference/data/relation-literals.md:70
msgid ""
"```prql\n"
"from_text format:json \"\"\"\n"
"{\n"
"    \"columns\": [\"a\", \"b\", \"c\"],\n"
"    \"data\": [\n"
"        [1, \"x\", false],\n"
"        [4, \"y\", null]\n"
"    ]\n"
"}\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/reference/data/relation-literals.md:82
msgid "See also"
msgstr "另請參見"

#: src/reference/data/relation-literals.md:84
msgid "[How do I: read files?](./read-files.md)"
msgstr ""

#: src/reference/data/from.md:1
msgid "From"
msgstr "從"

#: src/reference/data/from.md:3
msgid "Specifies a data source."
msgstr ""

#: src/reference/data/from.md:9
msgid "To introduce an alias, use an assign expression:"
msgstr ""

#: src/reference/data/from.md:16
msgid ""
"Table names containing spaces or special characters [need to be contained "
"within backticks](../syntax/keywords.md#quoting):"
msgstr ""

#: src/reference/data/from.md:23
msgid ""
"`default_db.tablename` can be used if the table name matches a function from "
"the standard library."
msgstr ""

#: src/reference/data/from.md:27
msgid ""
"\\[!NOTE\\] We realize this is an awkward workaround. Track & 👍 [\\#3271]"
"(https://github.com/PRQL/prql/issues/3271) for resolving this."
msgstr ""

#: src/reference/data/read-files.md:1
msgid "Reading files"
msgstr "讀取檔案"

#: src/reference/data/read-files.md:3
msgid ""
"There are a few functions mainly designed for DuckDB to read from files:"
msgstr ""

#: src/reference/data/read-files.md:5
msgid ""
"```prql\n"
"prql target:sql.duckdb\n"
"\n"
"from a = (read_parquet \"artists.parquet\")\n"
"join b = (read_csv \"albums.csv\") (a.artist_id == b.artist_id)\n"
"join c = (read_json \"metadata.json\") (a.artist_id == c.artist_id)\n"
"```"
msgstr ""

#: src/reference/data/read-files.md:14
msgid ""
"\\[!NOTE\\] These don't currently have all the DuckDB options. If those "
"would be helpful, please log an issue and it's a fairly easy addition."
msgstr ""

#: src/reference/data/read-files.md:19
msgid ""
"\\[!NOTE\\] We may be able to reduce the boilerplate `WITH table_x AS SELECT "
"* FROM...` in future versions."
msgstr ""

#: src/reference/data/read-files.md:23
msgid ""
"When specifying file names directly in the `FROM` clause without using "
"functions, which is allowed in DuckDB, enclose the file names in backticks "
"``` `` ``` as follows:"
msgstr ""

#: src/reference/data/read-files.md:33
msgid "[Target and Version](../../project/target.md)"
msgstr ""

#: src/reference/data/read-files.md:34
msgid "[Ad-hoc data](./relation-literals.md)"
msgstr ""

#: src/reference/spec/index.md:1
msgid "Specification"
msgstr "規範"

#: src/reference/spec/index.md:3
msgid ""
"This chapter explains PRQL's semantics: how expressions are interpreted and "
"their meaning. It's intended for advanced users and compiler contributors."
msgstr ""
"本章解釋了 PRQL 的語義：表達式如何被解釋及其含義。它適用於進階使用者和編譯器"
"貢獻者。"

#: src/reference/spec/modules.md:1
msgid "Modules"
msgstr "模組"

#: src/reference/spec/modules.md:4
msgid ""
"\\[!WARNING\\] The `module` facility is in discussion. This page documents "
"our understanding of the way the final PRQL compiler will likely work. The "
"PRQL compiler currently uses these techniques to compile the `std`, `date`, "
"`text`, and `math` modules into the language."
msgstr ""

#: src/reference/spec/modules.md:10
msgid ""
"However, at this time (Spring 2024), the `module` facility does not work "
"within a PRQL query itself. That is, a `module` statement in a query cannot "
"import files from the local file system."
msgstr ""

#: src/reference/spec/modules.md:14
msgid "Design goals for **modules**:"
msgstr ""

#: src/reference/spec/modules.md:16
msgid "Allow importing declarations from other files."
msgstr ""

#: src/reference/spec/modules.md:18
msgid "Have namespaces for things like `std`."
msgstr ""

#: src/reference/spec/modules.md:20
msgid "Have a hierarchical structure so we can represent files in directories."
msgstr ""

#: src/reference/spec/modules.md:22
msgid "Have an unambiguous module structure within a project."
msgstr ""

#: src/reference/spec/modules.md:24
msgid "Definition"
msgstr "定義"

#: src/reference/spec/modules.md:26
msgid ""
"A module is a namespace that contains declarations. A module is itself a "
"declaration, which means that it can contain nested child modules."
msgstr ""

#: src/reference/spec/modules.md:29
msgid ""
"This means that modules form a [tree graph](https://en.wikipedia.org/wiki/"
"Tree_(graph_theory)), which we call \"the module structure\"."
msgstr ""

#: src/reference/spec/modules.md:33
msgid ""
"For the sake of this document, we will express the module structure with "
"`module` keyword and a code block encased in curly braces:"
msgstr ""

#: src/reference/spec/modules.md:46
msgid ""
"The syntax `module name { ...decls... }` is not part of PRQL language, with "
"the objection that it is unnecessary as it only adds more ways of defining "
"modules. If a significant upside of this syntax is found, it may be added in "
"the future."
msgstr ""

#: src/reference/spec/modules.md:51
msgid "Name resolution"
msgstr "名稱解析"

#: src/reference/spec/modules.md:53
msgid ""
"Any declarations within a module can be referenced from the outside of the "
"module:"
msgstr ""

#: src/reference/spec/modules.md:65
msgid "Identifiers are resolved relative to current module."
msgstr ""

#: src/reference/spec/modules.md:78
msgid ""
"If an identifier cannot be resolved relative to the current module, it tries "
"to resolve relative to the parent module. This is repeated, stepping up the "
"module hierarchy until a match is found or root of the module structure is "
"reached."
msgstr ""

#: src/reference/spec/modules.md:98
msgid "Main var declaration"
msgstr ""

#: src/reference/spec/modules.md:100
msgid ""
"The final variable declaration in a module can omit the leading `let main =` "
"and acquire an implicit name main."
msgstr ""

#: src/reference/spec/modules.md:113
msgid ""
"When a module is referenced as a value, the `main` variable is used instead. "
"This is especially useful when referring to a module which is to be compiled "
"to RQ (and later SQL)."
msgstr ""

#: src/reference/spec/modules.md:122
msgid "File importing"
msgstr ""

#: src/reference/spec/modules.md:125 src/reference/spec/modules.md:279
msgid ""
"\\[!WARNING\\] The examples below do **not** work. At this time (Spring "
"2024), the `module` facility does not work within a PRQL query itself. That "
"is, a `module` statement in a query cannot import files from the local file "
"system."
msgstr ""

#: src/reference/spec/modules.md:130
msgid ""
"To include PRQL source code from other files, we can use the following "
"syntax:"
msgstr ""

#: src/reference/spec/modules.md:136
msgid ""
"This loads either `./my_playlists.prql` (a leaf module) or `./my_playlists/"
"_my_playlists.prql` (a directory module) and uses its contents as module "
"`my_playlists`. If none or both of the files are present, a compilation "
"error is raised."
msgstr ""

#: src/reference/spec/modules.md:141
msgid ""
"Only directory modules can contain module declarations. If a leaf module "
"contains a module declaration, a compilation error is raised, suggesting the "
"leaf module to be converted into a directory module. This is a step toward "
"any module structure having a single \"normalized\" representation in the "
"file system. Such normalization is desired because it restrains the possible "
"file system layouts to a comprehensible and predictable layout, while not "
"sacrificing any functionality."
msgstr ""

#: src/reference/spec/modules.md:149
msgid ""
"Described importing rules don't achieve this \"single normalized "
"representation\" in full, since any leaf modules could be replaced by a "
"directory module with zero submodules, without any semantic changes. "
"Restricting directory modules to have at least one sub-module would not "
"improve approachability enough to justify adding this restriction."
msgstr ""

#: src/reference/spec/modules.md:155
msgid ""
"For example, the following module structure is annotated with files names in "
"which the modules would reside:"
msgstr ""

#: src/reference/spec/modules.md:181
msgid ""
"If module `my_project.sales` wants to add a submodule `util`, it has to be "
"converted to a directory modules. This means that it has to be moved to "
"`sales/_sales.prql`. The new module would reside in `sales/util.prql`."
msgstr ""

#: src/reference/spec/modules.md:185
msgid ""
"The annotated layout is not the only possible layout for this module "
"structure, since any of the modules `sales`, `year_2023` or `year_2024` "
"could be converted into a directory module with zero sub-modules."
msgstr ""

#: src/reference/spec/modules.md:189
msgid ""
"Point 4 of design goals means that each declaration within a project has a "
"single fully-qualified name within this project. This is ensured by strict "
"rules regarding importing files and the fact that the module structure is a "
"tree."
msgstr ""

#: src/reference/spec/modules.md:193
msgid "Declaration order"
msgstr ""

#: src/reference/spec/modules.md:195
msgid ""
"The order of declarations in a module holds no semantic value, except the "
"\"last `main` variable\"."
msgstr ""

#: src/reference/spec/modules.md:198
msgid "References between modules can be cyclic."
msgstr ""

#: src/reference/spec/modules.md:210
msgid "References between variable declarations cannot be cyclic."
msgstr ""

#: src/reference/spec/modules.md:226
msgid "Compiler interface"
msgstr ""

#: src/reference/spec/modules.md:228
msgid "`prqlc` provides two interfaces for compiling files."
msgstr ""

#: src/reference/spec/modules.md:230
msgid "**Multi-file interface** requires three arguments:"
msgstr ""

#: src/reference/spec/modules.md:232
msgid ""
"path to the file containing the module which is the root of the module "
"structure,"
msgstr ""

#: src/reference/spec/modules.md:234
msgid ""
"identifier of the pipeline that should be compiled to RQ (this can also be "
"an identifier of a module that has a `main` pipeline) and,"
msgstr ""

#: src/reference/spec/modules.md:236
msgid "a \"file loader\", which can load files on-demand."
msgstr ""

#: src/reference/spec/modules.md:238
msgid ""
"The path to the root module can be automatically detected by searching for `."
"prql` files starting with `_` in the current working directory."
msgstr ""

#: src/reference/spec/modules.md:241
msgid "Example prqlc usage:"
msgstr ""

#: src/reference/spec/modules.md:248
msgid ""
"**Single-file interface** requires a single argument; the PRQL source. Any "
"attempts to load modules in this mode result in compilation errors. This "
"interface is needed, for example, when integrating the compiler with a "
"database connector (i.e. JDBC) where no other files can be loaded."
msgstr ""

#: src/reference/spec/modules.md:253
msgid "Built-in module structure"
msgstr ""

#: src/reference/spec/modules.md:255
msgid "As noted above, this facility is in discussion."
msgstr ""

#: src/reference/spec/modules.md:284
msgid ""
"This is an example project, where each of code block is a separate file."
msgstr ""

#: src/reference/spec/modules.md:339
msgid "Sources:"
msgstr ""

#: src/reference/spec/modules.md:341
msgid ""
"[Notes On Module System](https://matklad.github.io/2021/11/27/notes-on-"
"module-system.html), by @matklad."
msgstr ""

#: src/reference/spec/name-resolution.md:3
msgid ""
"Because PRQL primarily handles relational data, it has specialized scoping "
"rules for referencing columns."
msgstr ""

#: src/reference/spec/name-resolution.md:6
msgid "Scopes"
msgstr ""

#: src/reference/spec/name-resolution.md:8
msgid ""
"In PRQL's compiler, a scope is the collection of all names one can reference "
"from a specific point in the program."
msgstr ""

#: src/reference/spec/name-resolution.md:11
msgid ""
"In PRQL, names in the scope are composed from namespace and variable name "
"which are separated by a dot, similar to SQL. Namespaces can contain many "
"dots, but variable names cannot."
msgstr ""

#: src/reference/spec/name-resolution.md:16
msgid ""
"\\[!NOTE\\] For example, name `my_table.some_column` is a variable "
"`some_column` from namespace `my_table`."
msgstr ""

#: src/reference/spec/name-resolution.md:20
msgid "Name `foo.bar.baz` is a variable `baz` from namespace `foo.bar`."
msgstr ""

#: src/reference/spec/name-resolution.md:22
msgid ""
"When processing a query, a scope is maintained and updated for each point in "
"the query."
msgstr ""

#: src/reference/spec/name-resolution.md:25
msgid ""
"It start with only namespace `std`, which is the standard library. It "
"contains common functions like `sum` or `count`, along with all transform "
"functions such as `derive` and `group`."
msgstr ""

#: src/reference/spec/name-resolution.md:29
msgid ""
"In pipelines (or rather in transform functions), scope is also injected with "
"namespaces of tables which may have been referenced with `from` or `join` "
"transforms. These namespaces contain simply all the columns of the table and "
"possibly a wildcard variable, which matches any variable (see the algorithm "
"below). Within transforms, there is also a special namespace that does not "
"have a name. It is called a _\"frame\"_ and it contains columns of the "
"current table the transform is operating on."
msgstr ""

#: src/reference/spec/name-resolution.md:37
msgid "Resolving"
msgstr ""

#: src/reference/spec/name-resolution.md:39
msgid ""
"For each ident we want to resolve, we search the scope's items in order. One "
"of three things can happen:"
msgstr ""

#: src/reference/spec/name-resolution.md:42
msgid ""
"Scope contains an exact match, e.g. a name that matches in namespace and the "
"variable name."
msgstr ""

#: src/reference/spec/name-resolution.md:45
msgid ""
"Scope does not contain an exact match, but the ident did not specify a "
"namespace, so we can match a namespace that contains a `*` wildcard. If "
"there's a single namespace, the matched namespace is also updated to contain "
"this new variable name."
msgstr ""

#: src/reference/spec/name-resolution.md:50
msgid "Otherwise, the nothing is matched and an error is raised."
msgstr ""

#: src/reference/spec/name-resolution.md:52
msgid "Translating to SQL"
msgstr "翻譯為 SQL"

#: src/reference/spec/name-resolution.md:54
msgid ""
"When translating into an SQL statement which references only one table, "
"there is no need to reference column names with table prefix."
msgstr ""

#: src/reference/spec/name-resolution.md:62
msgid ""
"But when there are multiple tables and we don't have complete knowledge of "
"all table columns, a column without a prefix (i.e. `first_name`) may "
"actually reside in multiple tables. Because of this, we have to use table "
"prefixes for all column names."
msgstr ""

#: src/reference/spec/name-resolution.md:74
msgid ""
"As you can see, `employees.first_name` now needs table prefix, to prevent "
"conflicts with potential column with the same name in `departments` table. "
"Similarly, `d.title` needs the table prefix."
msgstr ""

#: src/SUMMARY.md:74
msgid "Null handling"
msgstr "Null 處理"

#: src/reference/spec/null.md:3
msgid ""
"SQL has an unconventional way of handling `NULL` values, since it treats "
"them as unknown values. As a result, in SQL:"
msgstr ""

#: src/reference/spec/null.md:6
msgid ""
"`NULL` is not a value indicating a missing entry, but a placeholder for "
"anything possible,"
msgstr ""

#: src/reference/spec/null.md:8
msgid ""
"`NULL = NULL` evaluates to `NULL`, since one cannot know if one unknown is "
"equal to another unknown,"
msgstr ""

#: src/reference/spec/null.md:10
msgid "`NULL <> NULL` evaluates to `NULL`, using same logic,"
msgstr ""

#: src/reference/spec/null.md:11
msgid ""
"to check if a value is `NULL`, SQL introduces `IS NULL` and `IS NOT NULL` "
"operators,"
msgstr ""

#: src/reference/spec/null.md:13
msgid "`DISTINCT column` may return multiple `NULL` values."
msgstr ""

#: src/reference/spec/null.md:15
msgid ""
"For more information, check out the [Postgres documentation](https://www."
"postgresql.org/docs/current/functions-comparison.html)."
msgstr ""

#: src/reference/spec/null.md:18
msgid "PRQL, on the other hand, treats `null` as a value, which means that:"
msgstr ""

#: src/reference/spec/null.md:20
msgid "`null == null` evaluates to `true`,"
msgstr ""

#: src/reference/spec/null.md:21
msgid "`null != null` evaluates to `false`,"
msgstr ""

#: src/reference/spec/null.md:22
msgid "distinct column cannot contain multiple `null` values."
msgstr ""

#: src/reference/spec/null.md:30
msgid ""
"Note that PRQL doesn't change how `NULL` is compared between columns, for "
"example in joins. (PRQL compiles to SQL and so can't change the behavior of "
"the database)."
msgstr ""

#: src/reference/spec/null.md:34
msgid ""
"For more context or to provide feedback check out the discussion on [issue "
"#99](https://github.com/PRQL/prql/issues/99)."
msgstr ""

#: src/reference/spec/type-system.md:1
msgid "Type system"
msgstr "型別系統"

#: src/reference/spec/type-system.md:3
msgid "Status: under development"
msgstr ""

#: src/reference/spec/type-system.md:5
msgid "The type system determines the allowed values of a term."
msgstr ""

#: src/reference/spec/type-system.md:7
msgid "Purpose"
msgstr ""

#: src/reference/spec/type-system.md:9
msgid ""
"Each of the SQL DBMSs has their own type system. Thanks to the SQL standard, "
"they are very similar, but have key differences regardless. For example, "
"SQLite does not have a type for date or time or timestamps, but it has "
"functions for handling date and time that take ISO 8601 strings or integers "
"that represent Unix timestamps. So it does support most of what is possible "
"to do with dates in other dialects, even though it stores data with a "
"different physical layout and uses different functions to achieve that."
msgstr ""

#: src/reference/spec/type-system.md:17
msgid ""
"PRQL's task is to define it's own description of _data formats_, just as how "
"it already defines common _data transformations_."
msgstr ""

#: src/reference/spec/type-system.md:20
msgid "This is done in two steps:"
msgstr ""

#: src/reference/spec/type-system.md:22
msgid ""
"Define PRQL's Type System (PTS), following principles we think a relational "
"language should have (and not fixate on what existing SQL DBMSs have)."
msgstr ""

#: src/reference/spec/type-system.md:25
msgid ""
"Define a mapping between SQL Type System (STS) and PTS, for each of the "
"DBMSs. Ideally we'd want that to be a bijection, so each type in PTS would "
"be represented by a single type in STS and vice-versa. Unfortunately this is "
"not entirely possible, as shown below."
msgstr ""

#: src/reference/spec/type-system.md:30
msgid "In practical terms, we want for a user to be able to:"
msgstr ""

#: src/reference/spec/type-system.md:32
msgid ""
"... express types of their database with PRQL (map their STS into PTS). In "
"some cases, we can allow to say \"your database is not representable with "
"PRQL, change it or use only a subset of it\". An example of what we don't "
"want to support are arrays with arbitrary indexes in Postgres (i.e. 2-based "
"index for arrays)."
msgstr ""

#: src/reference/spec/type-system.md:38
msgid ""
"This task of mapping to PTS could be automated by LSP server, by "
"introspecting user's SQL database and generating PRQL source."
msgstr ""

#: src/reference/spec/type-system.md:41
msgid ""
"... express their SQL queries in PRQL. Again, using mapping from STS to PTS, "
"one should be able to express any SQL operation in PRQL."
msgstr ""

#: src/reference/spec/type-system.md:44
msgid ""
"For example, translate MSSQL `DATEDIFF` to subtraction operator `-` in PRQL."
msgstr ""

#: src/reference/spec/type-system.md:46
msgid ""
"For now, this mapping is manual, but should be documented and may be "
"automated."
msgstr ""

#: src/reference/spec/type-system.md:49
msgid ""
"... use any PRQL feature in their database. Here we are mapping from PTS "
"into an arbitrary STS."
msgstr ""

#: src/reference/spec/type-system.md:52
msgid ""
"For example, translate PRQL's datetime operations to use TEXT in SQLite."
msgstr ""

#: src/reference/spec/type-system.md:54
msgid ""
"As of now, prqlc already does a good job of automatically doing this mapping."
msgstr ""

#: src/reference/spec/type-system.md:56
msgid "Example of the mapping between PTS and two STSs:"
msgstr ""

#: src/reference/spec/type-system.md:58
msgid "PTS"
msgstr ""

#: src/reference/spec/type-system.md:58
msgid "STS Postgres"
msgstr ""

#: src/reference/spec/type-system.md:58
msgid "STS SQLite"
msgstr ""

#: src/reference/spec/type-system.md:60
msgid "int32"
msgstr ""

#: src/reference/spec/type-system.md:60
msgid "integer"
msgstr ""

#: src/reference/spec/type-system.md:60 src/reference/spec/type-system.md:61
msgid "INTEGER"
msgstr ""

#: src/reference/spec/type-system.md:61
msgid "int64"
msgstr ""

#: src/reference/spec/type-system.md:61
msgid "bigint"
msgstr ""

#: src/reference/spec/type-system.md:62
msgid "timestamp"
msgstr ""

#: src/reference/spec/type-system.md:62
msgid "TEXT"
msgstr ""

#: src/reference/spec/type-system.md:64
msgid "Principles"
msgstr ""

#: src/reference/spec/type-system.md:66
msgid ""
"**Algebraic types** - have a way of expressing sum and product types. In "
"Rust, sum would be an enum and product would be tuple or a struct. In SQL, "
"product would be a row, since it can contain different types, all at once. "
"Sum would be harder to express, see [this post](https://www.parsonsmatt."
"org/2019/03/19/sum_types_in_sql.html)."
msgstr ""

#: src/reference/spec/type-system.md:72
msgid ""
"The value proposition here is that algebraic types give a lot modeling "
"flexibility, all while being conceptually simple."
msgstr ""

#: src/reference/spec/type-system.md:75
msgid ""
"**Composable** - as with transformation, we'd want types to compose together."
msgstr ""

#: src/reference/spec/type-system.md:77
msgid ""
"Using Python, JavaScript, C++ or Rust, one could define many different data "
"structures that would correspond to our idea of \"relation\". Most of them "
"would be an object/struct that has column names and types and then a generic "
"array of arrays for rows."
msgstr ""

#: src/reference/spec/type-system.md:82
msgid ""
"PRQL's type system should also be able to express relations as composed from "
"primitive types, but have only one idiomatic way of doing so."
msgstr ""

#: src/reference/spec/type-system.md:85
msgid ""
"In practice, this means that builtin types include only primitives (int, "
"text, bool, float), tuple (for product), enum (for sum) and array (for "
"repeating). An SQL row translates to a tuple, and a relation translates to "
"an array of tuples."
msgstr ""

#: src/reference/spec/type-system.md:89
msgid ""
"Composability also leads to a minimal type system, which does not "
"differentiate between tuples, objects and structs. A single product type is "
"enough."
msgstr ""

#: src/reference/spec/type-system.md:92
msgid "**No subtyping** - avoid super types and inheritance."
msgstr ""

#: src/reference/spec/type-system.md:94
msgid ""
"Subtyping is a natural extension to a type system, where a type can be a "
"super type of some other type. This is base mechanism for Object Oriented "
"Programming, but is also present in most dynamically types languages. For "
"example, a type `number` might be super type of `int` and `float`."
msgstr ""

#: src/reference/spec/type-system.md:99
msgid ""
"PTS does not have subtyping, because it requires dynamic dispatch and "
"because it adds unnecessary complexity to generic type arguments."
msgstr ""

#: src/reference/spec/type-system.md:102
msgid ""
"Dynamic dispatch, is a mechanism that would be able, for example, to call "
"appropriate `to_string` function for each element of an array of `number`. "
"This array contains both elements of type `int` and type `float`, with "
"different `to_string` implementations."
msgstr ""

#: src/reference/spec/type-system.md:132
msgid ""
"For any undefined terms used in this section, refer to set theory and "
"mathematical definitions in general."
msgstr ""

#: src/reference/spec/type-system.md:135
msgid ""
"A \"type of a variable\" is a \"set of all possible values of that "
"variable\"."
msgstr ""

#: src/reference/spec/type-system.md:137
msgid "Primitives"
msgstr ""

#: src/reference/spec/type-system.md:139
msgid ""
"At the moment of writing, PRQL defines following primitive types: `int`, "
"`float`, `bool`, `text`, `date`, `time` and `timestamp`. New primitive types "
"will be added in the future and some of existing types might be split into "
"smaller subsets (see section \"Splitting primitives\")."
msgstr ""

#: src/reference/spec/type-system.md:144
msgid "Tuples"
msgstr "元組"

#: src/reference/spec/type-system.md:146
msgid "Tuple type is a product type."
msgstr ""

#: src/reference/spec/type-system.md:148
msgid ""
"It contains n ordered fields, where n is known at compile-time. Each field "
"has a type itself and an optional name. Fields are not necessarily of the "
"same type."
msgstr ""

#: src/reference/spec/type-system.md:151
msgid ""
"In other languages, similar constructs are named record, struct, tuple, "
"named tuple or (data)class."
msgstr ""

#: src/reference/spec/type-system.md:158
msgid "Arrays"
msgstr "陣列"

#: src/reference/spec/type-system.md:160
msgid ""
"Array is a container type that contains n ordered fields, where n is not "
"known at compile-time. All fields are of the same type and cannot be named."
msgstr ""

#: src/reference/spec/type-system.md:173
msgid "Union"
msgstr ""

#: src/reference/spec/type-system.md:183
msgid "This is \"a sum type\"."
msgstr ""

#: src/reference/spec/type-system.md:185
msgid "Type annotations"
msgstr ""

#: src/reference/spec/type-system.md:187
msgid ""
"Variable annotations and function parameters may specify type annotations:"
msgstr ""

#: src/reference/spec/type-system.md:193
msgid "The value of `x` (and thus `a`) must be an element of `t`."
msgstr ""

#: src/reference/spec/type-system.md:199
msgid "The value of argument supplied to `x` must be an element of `t`."
msgstr ""

#: src/reference/spec/type-system.md:205
msgid "The value of function body `y` must be an element of `t`."
msgstr ""

#: src/reference/spec/type-system.md:207
msgid "Physical layout"
msgstr ""

#: src/reference/spec/type-system.md:209
msgid ""
"_Logical type_ is user-facing the notion of a type that is the building "
"block of the type system."
msgstr ""

#: src/reference/spec/type-system.md:212
msgid ""
"_Physical layout_ is the underlying memory layout of the data represented by "
"a variable."
msgstr ""

#: src/reference/spec/type-system.md:215
msgid ""
"In many programming languages, physical layout of a logical type is "
"dependent on the target platform. Similarly, physical layout of a PRQL "
"logical type is dependent on representation of that type in the target STS."
msgstr ""

#: src/reference/spec/type-system.md:223
msgid ""
"Note that not all STS types do not have a single physical layout. Postgres "
"has a logical (pseudo)type `anyelement`, which is a super type of any data "
"type. It can be used as a function parameter type, but does not have a "
"single physical layout so it cannot be used in a column declaration."
msgstr ""

#: src/reference/spec/type-system.md:228
msgid ""
"For now, PRQL does not define physical layouts of any type. It is not needed "
"since PRQL is not used for DDL (see section \"Splitting primitives\") or "
"does not support raw access to underlying memory."
msgstr ""

#: src/reference/spec/type-system.md:232
msgid ""
"As a consequence, results of a PRQL query cannot be robustly compared across "
"DBMSs, since the physical layout of the result will vary."
msgstr ""

#: src/reference/spec/type-system.md:235
msgid ""
"In the future, PRQL may define a common physical layout of types, probably "
"using Apache Arrow."
msgstr ""

#: src/reference/spec/type-system.md:261
msgid "Appendix"
msgstr "附錄"

#: src/reference/spec/type-system.md:263
msgid "Splitting primitives"
msgstr ""

#: src/reference/spec/type-system.md:265
msgid ""
"This document mentions `int32` and `int64` as distinct types, but there is "
"no need for that in the initial implementation. The built-in `int` can "
"associate with all operations on integers and translate PRQL to valid SQL "
"regardless of the size of the integer. Later, `int` cam be replaced by "
"`int8`, `int16`, `int32`, `int64`."
msgstr ""

#: src/reference/spec/type-system.md:271
msgid ""
"The general rule for \"when to make a distinction between types\" would be "
"\"as soon as the types carry different information and we find an operation "
"that would be expressed differently\". In this example, that would require "
"some operation on `int32` to have different syntax than same operation over "
"`int64`."
msgstr ""

#: src/reference/spec/type-system.md:276
msgid ""
"We can have such relaxed rule because PRQL is not aiming to be a Data "
"Definition Language and does not have to bother with exact physical layout "
"of types."
msgstr ""

#: src/reference/spec/type-system.md:279
msgid "Type representations"
msgstr ""

#: src/reference/spec/type-system.md:281
msgid ""
"There are cases where a PTS type has multiple possible and valid "
"representations in some STSs."
msgstr ""

#: src/reference/spec/type-system.md:284
msgid ""
"For such cases, we'd want to support the use of alternative representations "
"for storing data, but also application of any function that is defined for "
"the original type."
msgstr ""

#: src/reference/spec/type-system.md:288
msgid ""
"Using SQLite as an example again, users may have some temporal data stored "
"as INTEGER unix timestamp and some as TEXT that contains ISO 8601 without "
"timezone. From the user's perspective, both of these types are `timestamp`s "
"and should be declared as such. But when compiling operations over these "
"types to SQL, the compiler should consider their different representations "
"in STS. For example a difference between two timestamps `timestamp - "
"timestamp` can be translated to a normal int subtraction for INTEGER repr, "
"but must apply SQLite's function `unixepoch` when dealing with TEXT repr."
msgstr ""

#: src/reference/spec/type-system.md:297
msgid ""
"Table declarations should therefore support annotations that give hints "
"about which representation is used:"
msgstr ""

#: src/reference/spec/type-system.md:307
msgid ""
"A similar example is an \"array of strings type\" in PTS that could be "
"represented by a `text[]` (if DBMS supports arrays) or `json` or it's "
"variant `jsonb` in Postgres. Again, the representation would affect "
"operators: in Postgres, arrays would be accessed with `my_array[1]` and json "
"arrays would use `my_json_array -> 1`. This example may not be applicable, "
"if we decide that we want a separate JSON type in PST."
msgstr ""

#: src/reference/spec/type-system.md:314
msgid "RQ functions, targets and reprs"
msgstr ""

#: src/reference/spec/type-system.md:316
msgid ""
"This part is talks about technical implementations, not the language itself"
msgstr ""

#: src/reference/spec/type-system.md:318
msgid "Idea"
msgstr ""

#: src/reference/spec/type-system.md:320
msgid ""
"RQ contains a single node kind for expressing operations and functions: "
"BuiltInFunction (may be renamed in the future)."
msgstr ""

#: src/reference/spec/type-system.md:323
msgid ""
"It is a bottleneck that we can leverage when trying to affect how an "
"operator or a function interacts with different type representations on "
"different targets."
msgstr ""

#: src/reference/spec/type-system.md:326
msgid ""
"Idea is to implement the BuiltInFunction multiple times and annotate it with "
"it intended target and parameter representation. Then we can teach the "
"compiler to pick the appropriate function implementation that suit current "
"repr and compilation target."
msgstr ""

#: src/reference/spec/type-system.md:331
msgid "Specifics"
msgstr ""

#: src/reference/spec/type-system.md:333
msgid ""
"RQ specification is an interface that contains functions, identified by name "
"(i.e. `std.int8.add`). These functions have typed parameters and a return "
"value. If an RQ function call does not match the function declaration in "
"number or in types of the parameters, this is considered an invalid RQ AST."
msgstr ""

#: src/reference/spec/type-system.md:338
msgid ""
"We provide multiple implementations for each RQ function. They are annotated "
"with a target (i.e. `#[target(sql.sqlite)]`) and have their params annotated "
"with type reprs (i.e. `#[repr(int)]`)."
msgstr ""

#: src/reference/spec/type-system.md:342
msgid ""
"```\n"
"# using a made-up syntax\n"
"\n"
"#[target(sql.sqlite)]\n"
"func std.int8.add\n"
"    #[repr(int8)] x\n"
"    #[repr(int8)] y\n"
"    -> s\"{x} + {y}\"\n"
"```"
msgstr ""

#: src/reference/spec/type-system.md:352
msgid ""
"Each RQ type has one canonical repr that serves as the reference "
"implementation for other reprs and indicates the amount of contained data (i."
"e. 1 bit, 8 bits, 64 bits)."
msgstr ""

#: src/reference/spec/type-system.md:358
msgid ""
"Let's say for example, that we'd want to support 8bit integer arithmetic, "
"and that we'd want the result of `127 + 1` to be `-128` (ideally we'd handle "
"this better, but bear with me for the sake of the example). Because some "
"RDBMSs don't support 8bit numbers and do all their integer computation with "
"64bit numbers (SQLite), we need to implement an alternative type "
"representation for that target."
msgstr ""

#: src/reference/spec/type-system.md:365
msgid "The logical type `int8` could have the following two reprs:"
msgstr ""

#: src/reference/spec/type-system.md:367
msgid ""
"canonical `repr_int8` that contains 8 bits in two's complement, covering "
"integer values in range -128 to 127 (inclusive),"
msgstr ""

#: src/reference/spec/type-system.md:369
msgid ""
"`repr_int64` that contains 64 bits of data, but is using only the values "
"that are also covered by `repr_int8`."
msgstr ""

#: src/reference/spec/type-system.md:372
msgid ""
"Now we'd implement function `std.int8.add` for each of the reprs. Let's "
"assume that the `int8` implementation is straightforward and that databases "
"don't just change the data type when a number overflows. The impl for "
"`int64` requires a CASE statement that checks if the value would overflow "
"and subtact 256 in that case."
msgstr ""

#: src/reference/spec/type-system.md:378
msgid ""
"The goal here is that the results of the two impls are equivalent. To "
"validate that, we also need a way to convert between the reprs, or another "
"`to_string` function, implemented for both reprs."
msgstr ""

#: src/reference/stdlib/index.md:1
msgid "Standard library"
msgstr "標準庫"

#: src/reference/stdlib/index.md:3
msgid ""
"The standard library currently contains commonly used functions that are "
"used in SQL. It's not yet as broad as we'd like, and we're very open to "
"expanding it."
msgstr ""
"標準庫目前包含在 SQL 中使用的常用函式。它的覆蓋範圍還不如我們希望的那麼寬，我"
"們非常歡迎擴展它。"

#: src/reference/stdlib/index.md:6
msgid ""
"Currently s-strings are an escape-hatch for any function that isn't in our "
"standard library. If we find ourselves using them for something frequently, "
"raise an issue and we'll add it to the stdlib."
msgstr ""
"目前 s-字串是任何不在我們標準庫中的函式的逃脫艙口。如果我們發現自己經常為某些"
"東西使用它們，請提出問題，我們會將其新增到標準庫中。"

#: src/reference/stdlib/index.md:10
msgid ""
"Here's the source of the current [PRQL `std`](https://github.com/PRQL/prql/"
"blob/main/prqlc/prqlc/src/semantic/std.prql):"
msgstr ""
"以下是當前 [PRQL `std`](https://github.com/PRQL/prql/blob/main/prqlc/prqlc/"
"src/semantic/std.prql) 的源代碼："

#: src/reference/stdlib/index.md:14
msgid ""
"\\[!NOTE\\] PRQL 0.9.0 has started supporting different DB implementations "
"for standard library functions. The source is the [`std.sql`](https://github."
"com/PRQL/prql/blob/main/prqlc/prqlc/src/sql/std.sql.prql)."
msgstr ""
"\\[!NOTE\\] PRQL 0.9.0 開始支援不同資料庫實現的標準庫函式。源代碼是 [`std."
"sql`](https://github.com/PRQL/prql/blob/main/prqlc/prqlc/src/sql/std.sql."
"prql)。"

#: src/reference/stdlib/index.md:19
msgid ""
"````prql no-eval\n"
"# The PRQL standard library defines the following functions and transforms.\n"
"# The definitions are whitespace insensitive, and have this form:\n"
"#\n"
"# ```\n"
"# let my_func = param1 param2 ...  -> <return_type> body_expr\n"
"# ```\n"
"#\n"
"# Where:\n"
"#   * `my_func` is the name of the function\n"
"#   * `param1` is the first parameter optionally followed by a type in "
"\"< ... >\"\n"
"#   * `param2` etc. follow the same pattern as param1\n"
"#   * `<return_type>` is the type of result wrapped in \"< ... >\"\n"
"#   * `body_expr` defines the function body that creates the result.\n"
"#     It can be PRQL code or `internal ...` to indicate internal compiler "
"code.\n"
"\n"
"# Operators\n"
"\n"
"let mul = left right -> internal std.mul\n"
"let div_i = left right -> internal std.div_i\n"
"let div_f = left right -> internal std.div_f\n"
"let mod = left right -> internal std.mod\n"
"let add = left right -> internal std.add\n"
"let sub = left right -> internal std.sub\n"
"let eq = left right -> <bool> internal std.eq\n"
"let ne = left right -> <bool> internal std.ne\n"
"let gt = left right -> <bool> internal std.gt\n"
"let lt = left right -> <bool> internal std.lt\n"
"let gte = left right -> <bool> internal std.gte\n"
"let lte = left right -> <bool> internal std.lte\n"
"let and = left<bool> right<bool> -> <bool> internal std.and\n"
"let or = left<bool> right<bool> -> <bool> internal std.or\n"
"let coalesce = left right -> internal std.coalesce\n"
"let regex_search = text pattern -> <bool> internal std.regex_search\n"
"\n"
"let neg = expr -> internal std.neg\n"
"let not = expr<bool> -> <bool> internal std.not\n"
"\n"
"# Types\n"
"\n"
"## Type primitives\n"
"type int = int\n"
"type float = float\n"
"type bool = bool\n"
"type text = text\n"
"type date = date\n"
"type time = time\n"
"type timestamp = timestamp\n"
"type `func` = func\n"
"\n"
"## Generic array\n"
"type array = []\n"
"\n"
"## Generic relation\n"
"type relation = [{..}]\n"
"\n"
"## Range\n"
"type range = {start = *, end = *}\n"
"\n"
"## Transform\n"
"type transform = func relation -> relation\n"
"\n"
"# Functions\n"
"\n"
"## Relational transforms\n"
"let from = func\n"
"  `default_db.source` <relation>\n"
"  -> <relation> source\n"
"\n"
"let select = func\n"
"  columns\n"
"  tbl <relation>\n"
"  -> <relation> internal select\n"
"\n"
"let filter = func\n"
"  condition <bool>\n"
"  tbl <relation>\n"
"  -> <relation> internal filter\n"
"\n"
"let derive = func\n"
"  columns\n"
"  tbl <relation>\n"
"  -> <relation> internal derive\n"
"\n"
"let aggregate = func\n"
"  columns\n"
"  tbl <relation>\n"
"  -> <relation> internal aggregate\n"
"\n"
"let sort = func\n"
"  by\n"
"  tbl <relation>\n"
"  -> <relation> internal sort\n"
"\n"
"let take = func\n"
"  expr\n"
"  tbl <relation>\n"
"  -> <relation> internal take\n"
"\n"
"let join = func\n"
"  `default_db.with` <relation>\n"
"  condition <bool>\n"
"  `noresolve.side`:inner\n"
"  tbl <relation>\n"
"  -> <relation> internal join\n"
"\n"
"let group = func\n"
"  by\n"
"  pipeline <transform>\n"
"  tbl <relation>\n"
"  -> <relation> internal group\n"
"\n"
"let window = func\n"
"  rows:0..-1\n"
"  range:0..-1\n"
"  expanding <bool>:false\n"
"  rolling <int>:0\n"
"  pipeline <transform>\n"
"  tbl <relation>\n"
"  -> <relation> internal window\n"
"\n"
"let append = `default_db.bottom`<relation> top<relation> -> <relation> "
"internal append\n"
"let intersect = `default_db.bottom`<relation> top<relation> -> <relation> (\n"
"  t = top\n"
"  join (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b.*)))\n"
"  select t.*\n"
")\n"
"let remove = `default_db.bottom`<relation> top<relation> -> <relation> (\n"
"  t = top\n"
"  join side:left (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b."
"*)))\n"
"  filter (tuple_every (tuple_map _is_null b.*))\n"
"  select t.*\n"
")\n"
"let loop = func\n"
"  pipeline <transform>\n"
"  top <relation>\n"
"  -> <relation> internal loop\n"
"\n"
"## Aggregate functions\n"
"# These return either a scalar when used within `aggregate`, or a column "
"when used anywhere else.\n"
"\n"
"let min = column <array> -> internal std.min\n"
"\n"
"let max = column <array> -> internal std.max\n"
"\n"
"let sum = column <array> -> internal std.sum\n"
"\n"
"let average = column <array> -> internal std.average\n"
"\n"
"let stddev = column <array> -> internal std.stddev\n"
"\n"
"let all = column <array> -> <bool> internal std.all\n"
"\n"
"let any = column <array> -> <bool> internal std.any\n"
"\n"
"let concat_array = column <array> -> <text> internal std.concat_array\n"
"\n"
"# Counts number of items in the column.\n"
"# Note that the count will include null values.\n"
"let count = column <array> -> <int> internal count\n"
"\n"
"# Deprecated in favour of filtering input to the [std.count] function (not "
"yet implemented).\n"
"@{deprecated}\n"
"let count_distinct = column <array> -> internal std.count_distinct\n"
"\n"
"## Window functions\n"
"let lag =   offset <int>    column <array> -> internal std.lag\n"
"let lead =  offset <int>    column <array> -> internal std.lead\n"
"let first      = column <array> -> internal std.first\n"
"let last       = column <array> -> internal std.last\n"
"let rank       = column <array> -> internal std.rank\n"
"let rank_dense = column <array> -> internal std.rank_dense\n"
"let row_number = column <array> -> internal row_number\n"
"\n"
"# Mathematical functions\n"
"module math {\n"
"  let abs = column -> internal std.math.abs\n"
"  let floor = column -> <int> internal std.math.floor\n"
"  let ceil = column -> <int> internal std.math.ceil\n"
"  let pi = -> <float> internal std.math.pi\n"
"  let exp = column -> internal std.math.exp\n"
"  let ln = column -> internal std.math.ln\n"
"  let log10 = column -> internal std.math.log10\n"
"  let log = func base column -> internal std.math.log\n"
"  let sqrt = column -> internal std.math.sqrt\n"
"  let degrees = column -> internal std.math.degrees\n"
"  let radians = column -> internal std.math.radians\n"
"  let cos = column -> internal std.math.cos\n"
"  let acos = column -> internal std.math.acos\n"
"  let sin = column -> internal std.math.sin\n"
"  let asin = column -> internal std.math.asin\n"
"  let tan = column -> internal std.math.tan\n"
"  let atan = column -> internal std.math.atan\n"
"  let pow = exponent column -> internal std.math.pow\n"
"  let round = n_digits column -> internal std.math.round\n"
"}\n"
"\n"
"## Misc functions\n"
"let as = `noresolve.type` column -> internal std.as\n"
"let in = pattern value -> <bool> internal in\n"
"\n"
"## Tuple functions\n"
"let tuple_every = func list -> <bool> internal tuple_every\n"
"let tuple_map = func fn <func> list -> internal tuple_map\n"
"let tuple_zip = func a b -> internal tuple_zip\n"
"let _eq = func a -> internal _eq\n"
"let _is_null = func a -> _param.a == null\n"
"\n"
"## Misc\n"
"let from_text = input<text> `noresolve.format`:csv -> <relation> internal "
"from_text\n"
"\n"
"## Text functions\n"
"module text {\n"
"  let lower = column -> <text> internal std.text.lower\n"
"  let upper = column -> <text> internal std.text.upper\n"
"  let ltrim = column -> <text> internal std.text.ltrim\n"
"  let rtrim = column -> <text> internal std.text.rtrim\n"
"  let trim = column -> <text> internal std.text.trim\n"
"  let length = column -> <int> internal std.text.length\n"
"  let extract = offset<int> length<int> column -> <text> internal std.text."
"extract\n"
"  let replace = pattern<text> replacement<text> column -> <text> internal "
"std.text.replace\n"
"  let starts_with = prefix<text> column -> <bool> internal std.text."
"starts_with\n"
"  let contains = substr<text> column -> <bool> internal std.text.contains\n"
"  let ends_with = suffix<text> column -> <bool> internal std.text.ends_with\n"
"}\n"
"\n"
"## Date functions\n"
"module date {\n"
"  let to_text = format<text> column -> <text> internal std.date.to_text\n"
"}\n"
"\n"
"## File-reading functions, primarily for DuckDB\n"
"let read_parquet = func\n"
"  source <text>\n"
"  binary_as_string <bool>:false\n"
"  file_row_number <bool>:false\n"
"  hive_partitioning <bool>:null\n"
"  union_by_name <bool>:false\n"
"  -> <relation> internal std.read_parquet\n"
"let read_csv = source<text> -> <relation> internal std.read_csv\n"
"let read_json = source<text> -> <relation> internal std.read_json\n"
"\n"
"\n"
"## PRQL compiler functions\n"
"module `prql` {\n"
"  let version = -> <text> internal prql_version\n"
"}\n"
"\n"
"# Deprecated, will be removed in 0.12.0\n"
"let prql_version = -> <text> internal prql_version\n"
"````"
msgstr ""

#: src/reference/stdlib/index.md:271
msgid "And a couple of examples:"
msgstr "以下是幾個示例："

#: src/reference/stdlib/index.md:273
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = (salary + payroll_tax | as int),\n"
"  gross_salary_rounded = (gross_salary | math.round 0),\n"
"  time = s\"NOW()\",  # an s-string, given no `now` function exists in PRQL\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:282
msgid "Example of different implementations of division and integer division:"
msgstr "不同實現的除法和整數除法的示例："

#: src/reference/stdlib/index.md:284
msgid ""
"```prql\n"
"prql target:sql.sqlite\n"
"\n"
"from [{x = 13, y = 5}]\n"
"select {\n"
"  quotient = x / y,\n"
"  int_quotient = x // y,\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:294
msgid ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from [{x = 13, y = 5}]\n"
"select {\n"
"  quotient = x / y,\n"
"  int_quotient = x // y,\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/date.md:1
msgid "Date functions"
msgstr "日期函式"

#: src/reference/stdlib/date.md:3
msgid "These are all the functions defined in the `date` module:"
msgstr ""

#: src/reference/stdlib/date.md:5
msgid "`to_text`"
msgstr ""

#: src/reference/stdlib/date.md:7
msgid ""
"Converts a date into a text.  \n"
"Since there are many possible date representations, `to_text` takes a "
"`format` parameter that describes thanks to [specifiers](#date--time-format-"
"specifiers) how the date or timestamp should be structured."
msgstr ""

#: src/reference/stdlib/date.md:13
msgid ""
"\\[!NOTE\\] Since all RDBMS have different ways to format dates and times, "
"PRQL **requires an explicit dialect** to be specified"
msgstr ""

#: src/reference/stdlib/date.md:18
msgid ""
"\\[!NOTE\\] For now the supported DBs are: Clickhouse, DuckDB, MySQL, MSSQL "
"and Postgres."
msgstr ""

#: src/reference/stdlib/date.md:22
msgid ""
"```prql\n"
"prql target:sql.duckdb\n"
"\n"
"from invoices\n"
"select (invoice_date | date.to_text \"%d/%m/%Y\")\n"
"\n"
"```"
msgstr ""
"```prql\n"
"prql target:sql.duckdb\n"
"\n"
"from invoices\n"
"select (invoice_date | date.to_text \"%d/%m/%Y\")\n"
"\n"
"```"

#: src/reference/stdlib/date.md:30
msgid ""
"```prql\n"
"prql target:sql.postgres\n"
"\n"
"from invoices\n"
"select (invoice_date | date.to_text \"%d/%m/%Y\")\n"
"\n"
"```"
msgstr ""
"```prql\n"
"prql target:sql.postgres\n"
"\n"
"from invoices\n"
"select (invoice_date | date.to_text \"%d/%m/%Y\")\n"
"\n"
"```"

#: src/reference/stdlib/date.md:38
msgid ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from invoices\n"
"select (invoice_date | date.to_text \"%d/%m/%Y\")\n"
"\n"
"```"
msgstr ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from invoices\n"
"select (invoice_date | date.to_text \"%d/%m/%Y\")\n"
"\n"
"```"

#: src/reference/stdlib/date.md:46
msgid "Date & time format specifiers"
msgstr ""

#: src/reference/stdlib/date.md:48
msgid ""
"PRQL specifiers for date and time formatting is a subset of specifiers used "
"by [`chrono`](https://docs.rs/chrono/latest/chrono/format/strftime/index."
"html)."
msgstr ""

#: src/reference/stdlib/date.md:51
msgid "Here is the list of the specifiers currently supported:"
msgstr ""

#: src/reference/stdlib/date.md:53
msgid "Spec."
msgstr ""

#: src/reference/stdlib/date.md:53
msgid "Description"
msgstr ""

#: src/reference/stdlib/date.md:56
msgid "**DATE SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:57
msgid "`%Y`"
msgstr ""

#: src/reference/stdlib/date.md:57
msgid "`2001`"
msgstr ""

#: src/reference/stdlib/date.md:57
msgid "Year number, zero-padded to 4 digits"
msgstr ""

#: src/reference/stdlib/date.md:58
msgid "`%y`"
msgstr ""

#: src/reference/stdlib/date.md:58
msgid "`01`"
msgstr ""

#: src/reference/stdlib/date.md:58
msgid "Year number, zero-padded to 2 digits"
msgstr ""

#: src/reference/stdlib/date.md:59
msgid "`%m`"
msgstr ""

#: src/reference/stdlib/date.md:59
msgid "`07`"
msgstr ""

#: src/reference/stdlib/date.md:59
msgid "Month number (01–12), zero-padded to 2 digits"
msgstr ""

#: src/reference/stdlib/date.md:60
msgid "`%-m`"
msgstr ""

#: src/reference/stdlib/date.md:60
msgid "`7`"
msgstr ""

#: src/reference/stdlib/date.md:60
msgid "Month number (1-12)"
msgstr ""

#: src/reference/stdlib/date.md:61
msgid "`%b`"
msgstr ""

#: src/reference/stdlib/date.md:61
msgid "`Jul`"
msgstr ""

#: src/reference/stdlib/date.md:61
msgid "Abbreviated month name. Always 3 letters."
msgstr ""

#: src/reference/stdlib/date.md:62
msgid "`%B`"
msgstr ""

#: src/reference/stdlib/date.md:62
msgid "`July`"
msgstr ""

#: src/reference/stdlib/date.md:62
msgid "Full month name"
msgstr "完整月份名稱"

#: src/reference/stdlib/date.md:63
msgid "`%d`"
msgstr ""

#: src/reference/stdlib/date.md:63
msgid "`08`"
msgstr ""

#: src/reference/stdlib/date.md:63
msgid "Day number (01-31), zero-padded to 2 digits"
msgstr ""

#: src/reference/stdlib/date.md:64
msgid "`%-d`"
msgstr ""

#: src/reference/stdlib/date.md:64
msgid "` 8`"
msgstr ""

#: src/reference/stdlib/date.md:64
msgid "Day number (1-31)"
msgstr ""

#: src/reference/stdlib/date.md:65
msgid "`%a`"
msgstr ""

#: src/reference/stdlib/date.md:65
msgid "`Sun`"
msgstr ""

#: src/reference/stdlib/date.md:65
msgid "Abbreviated weekday name. Always 3 letters"
msgstr ""

#: src/reference/stdlib/date.md:66
msgid "`%A`"
msgstr ""

#: src/reference/stdlib/date.md:66
msgid "`Sunday`"
msgstr ""

#: src/reference/stdlib/date.md:66
msgid "Full weekday name"
msgstr ""

#: src/reference/stdlib/date.md:67
msgid "`%D`"
msgstr ""

#: src/reference/stdlib/date.md:67 src/reference/stdlib/date.md:68
msgid "`07/08/01`"
msgstr ""

#: src/reference/stdlib/date.md:67
msgid "Month-day-year format. Same as `%m/%d/%y`"
msgstr ""

#: src/reference/stdlib/date.md:68
msgid "`%x`"
msgstr ""

#: src/reference/stdlib/date.md:68
msgid "Locale's date representation"
msgstr ""

#: src/reference/stdlib/date.md:69
msgid "`%F`"
msgstr ""

#: src/reference/stdlib/date.md:69
msgid "`2001-07-08`"
msgstr ""

#: src/reference/stdlib/date.md:69
msgid "Year-month-day format (ISO 8601). Same as `%Y-%m-%d`"
msgstr ""

#: src/reference/stdlib/date.md:71
msgid "**TIME SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:72
msgid "`%H`"
msgstr ""

#: src/reference/stdlib/date.md:72
msgid "`00`"
msgstr ""

#: src/reference/stdlib/date.md:72
msgid "Hour number (00-23)"
msgstr ""

#: src/reference/stdlib/date.md:73
msgid "`%k`"
msgstr ""

#: src/reference/stdlib/date.md:73
msgid "` 0`"
msgstr ""

#: src/reference/stdlib/date.md:73
msgid "Same as `%H` but space-padded. Same as `%_H`."
msgstr ""

#: src/reference/stdlib/date.md:74
msgid "`%I`"
msgstr ""

#: src/reference/stdlib/date.md:74
msgid "`12`"
msgstr ""

#: src/reference/stdlib/date.md:74
msgid "Hour number in 12-hour clocks (01--12), zero-padded to 2 digits."
msgstr ""

#: src/reference/stdlib/date.md:75
msgid "`%p`"
msgstr ""

#: src/reference/stdlib/date.md:75
msgid "`AM`"
msgstr ""

#: src/reference/stdlib/date.md:75
msgid "`AM` or `PM` in 12-hour clocks."
msgstr ""

#: src/reference/stdlib/date.md:76
msgid "`%M`"
msgstr ""

#: src/reference/stdlib/date.md:76
msgid "`34`"
msgstr ""

#: src/reference/stdlib/date.md:76
msgid "Minute number (00-59), zero-padded to 2 digits."
msgstr ""

#: src/reference/stdlib/date.md:77
msgid "`%S`"
msgstr ""

#: src/reference/stdlib/date.md:77
msgid "`60`"
msgstr ""

#: src/reference/stdlib/date.md:77
msgid "Second number (00-59), zero-padded to 2 digits."
msgstr ""

#: src/reference/stdlib/date.md:78
msgid "`%f`"
msgstr ""

#: src/reference/stdlib/date.md:78
msgid "`264900`"
msgstr ""

#: src/reference/stdlib/date.md:78
msgid "Number of microseconds[^1] since last whole second"
msgstr ""

#: src/reference/stdlib/date.md:79
msgid "`%R`"
msgstr ""

#: src/reference/stdlib/date.md:79
msgid "`00:34`"
msgstr ""

#: src/reference/stdlib/date.md:79
msgid "Hour-minute format. Same as `%H:%M`."
msgstr ""

#: src/reference/stdlib/date.md:80
msgid "`%T`"
msgstr ""

#: src/reference/stdlib/date.md:80 src/reference/stdlib/date.md:81
msgid "`00:34:60`"
msgstr ""

#: src/reference/stdlib/date.md:80
msgid "Hour-minute-second format. Same as `%H:%M:%S`."
msgstr ""

#: src/reference/stdlib/date.md:81
msgid "`%X`"
msgstr ""

#: src/reference/stdlib/date.md:81
msgid "Locale's time representation (e.g., 23:13:48)."
msgstr ""

#: src/reference/stdlib/date.md:82
msgid "`%r`"
msgstr ""

#: src/reference/stdlib/date.md:82
msgid "`12:34:60 AM`"
msgstr ""

#: src/reference/stdlib/date.md:82
msgid "Locale's 12 hour clock time. (e.g., 11:11:04 PM)"
msgstr ""

#: src/reference/stdlib/date.md:84
msgid "**DATE & TIME SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:85
msgid "`%+`"
msgstr ""

#: src/reference/stdlib/date.md:85
msgid "`2001-07-08T00:34:60.026490Z`"
msgstr ""

#: src/reference/stdlib/date.md:85
msgid "ISO 8601 / RFC 3339 date & time format."
msgstr ""

#: src/reference/stdlib/date.md:87
msgid "**SPECIAL SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:88
msgid "`%t`"
msgstr ""

#: src/reference/stdlib/date.md:88
msgid "Literal tab (`\\t`)."
msgstr ""

#: src/reference/stdlib/date.md:89
msgid "`%n`"
msgstr ""

#: src/reference/stdlib/date.md:89
msgid "Literal newline (`\\n`)."
msgstr ""

#: src/reference/stdlib/date.md:90
msgid "`%%`"
msgstr ""

#: src/reference/stdlib/date.md:90
msgid "Literal percent sign."
msgstr ""

#: src/reference/stdlib/date.md:92
msgid "This is different from chrono, for which `%f` represents nanoseconds"
msgstr ""

#: src/reference/stdlib/math.md:1
msgid "Mathematical functions"
msgstr "數學函式"

#: src/reference/stdlib/math.md:3
msgid "These are all the functions defined in the `math` module:"
msgstr ""

#: src/reference/stdlib/math.md:5
msgid "function"
msgstr ""

#: src/reference/stdlib/math.md:5
msgid "parameters"
msgstr ""

#: src/reference/stdlib/math.md:5
msgid "description"
msgstr ""

#: src/reference/stdlib/math.md:7
msgid "abs"
msgstr ""

#: src/reference/stdlib/math.md:7 src/reference/stdlib/math.md:8
#: src/reference/stdlib/math.md:9 src/reference/stdlib/math.md:10
#: src/reference/stdlib/math.md:11 src/reference/stdlib/math.md:12
#: src/reference/stdlib/math.md:13 src/reference/stdlib/math.md:14
#: src/reference/stdlib/math.md:15 src/reference/stdlib/math.md:16
#: src/reference/stdlib/math.md:18 src/reference/stdlib/math.md:21
#: src/reference/stdlib/math.md:23 src/reference/stdlib/math.md:24
#: src/reference/stdlib/math.md:25
msgid "`col`"
msgstr ""

#: src/reference/stdlib/math.md:7
msgid "Absolute value of `col`"
msgstr ""

#: src/reference/stdlib/math.md:8
msgid "acos"
msgstr ""

#: src/reference/stdlib/math.md:8
msgid "Arccosine of `col`"
msgstr ""

#: src/reference/stdlib/math.md:9
msgid "asin"
msgstr ""

#: src/reference/stdlib/math.md:9
msgid "Arcsine of `col`"
msgstr ""

#: src/reference/stdlib/math.md:10
msgid "atan"
msgstr ""

#: src/reference/stdlib/math.md:10
msgid "Arctangent of `col`"
msgstr ""

#: src/reference/stdlib/math.md:11
msgid "ceil"
msgstr ""

#: src/reference/stdlib/math.md:11
msgid "Rounds the number up of `col`"
msgstr ""

#: src/reference/stdlib/math.md:12
msgid "cos"
msgstr ""

#: src/reference/stdlib/math.md:12
msgid "Cosine of `col`"
msgstr ""

#: src/reference/stdlib/math.md:13
msgid "degrees"
msgstr ""

#: src/reference/stdlib/math.md:13
msgid "Converts radians to degrees"
msgstr ""

#: src/reference/stdlib/math.md:14
msgid "exp"
msgstr ""

#: src/reference/stdlib/math.md:14
msgid "Exponential of `col`"
msgstr ""

#: src/reference/stdlib/math.md:15
msgid "floor"
msgstr ""

#: src/reference/stdlib/math.md:15
msgid "Rounds the number down"
msgstr ""

#: src/reference/stdlib/math.md:16
msgid "ln"
msgstr ""

#: src/reference/stdlib/math.md:16
msgid "Natural logarithm of `col`"
msgstr ""

#: src/reference/stdlib/math.md:17
msgid "log"
msgstr ""

#: src/reference/stdlib/math.md:17 src/reference/stdlib/math.md:20
msgid "`b` `col`"
msgstr ""

#: src/reference/stdlib/math.md:17
msgid "`b`\\-log of `col`"
msgstr ""

#: src/reference/stdlib/math.md:18
msgid "log10"
msgstr ""

#: src/reference/stdlib/math.md:18
msgid "10-log of `col`"
msgstr ""

#: src/reference/stdlib/math.md:19
msgid "pi"
msgstr ""

#: src/reference/stdlib/math.md:19
msgid "The constant π"
msgstr ""

#: src/reference/syntax/operators.md:30
msgid "pow"
msgstr "次方"

#: src/reference/stdlib/math.md:20
msgid "Computes `col` to the power `b`"
msgstr ""

#: src/reference/stdlib/math.md:21
msgid "radians"
msgstr ""

#: src/reference/stdlib/math.md:21
msgid "Converts degrees to radians"
msgstr ""

#: src/reference/stdlib/math.md:22
msgid "round"
msgstr ""

#: src/reference/stdlib/math.md:22
msgid "`n` `col`"
msgstr ""

#: src/reference/stdlib/math.md:22
msgid "Rounds `col` to `n` decimal places"
msgstr ""

#: src/reference/stdlib/math.md:23
msgid "sin"
msgstr ""

#: src/reference/stdlib/math.md:23
msgid "Sin of `col`"
msgstr ""

#: src/reference/stdlib/math.md:24
msgid "sqrt"
msgstr ""

#: src/reference/stdlib/math.md:24
msgid "Square root of `col`"
msgstr ""

#: src/reference/stdlib/math.md:25
msgid "tan"
msgstr ""

#: src/reference/stdlib/math.md:25
msgid "Tangent of `col`"
msgstr ""

#: src/reference/stdlib/distinct.md:1
msgid "How do I: remove duplicates?"
msgstr ""

#: src/reference/stdlib/distinct.md:3
msgid ""
"PRQL doesn't have a specific `distinct` keyword. Instead duplicate tuples in "
"a relation can be removed by using `group` and `take 1`:"
msgstr ""

#: src/reference/stdlib/distinct.md:14
msgid "This also works with a wildcard:"
msgstr ""

#: src/reference/stdlib/distinct.md:21
msgid "Remove duplicates from each group?"
msgstr ""

#: src/reference/stdlib/distinct.md:23
msgid ""
"To [select a single row from each group](https://stackoverflow.com/"
"questions/3800551/select-first-row-in-each-group-by-group) `group` can be "
"combined with `sort` and `take`:"
msgstr ""

#: src/reference/stdlib/distinct.md:36
msgid ""
"Note that we can't always compile to `DISTINCT`; when the columns in the "
"`group` aren't all the available columns, we need to use a window function:"
msgstr ""

#: src/reference/stdlib/text.md:1
msgid "Text functions"
msgstr "文字函式"

#: src/reference/stdlib/text.md:3
msgid "These are all the functions defined in the `text` module:"
msgstr ""

#: src/reference/stdlib/text.md:7
msgid "contains"
msgstr ""

#: src/reference/stdlib/text.md:7 src/reference/stdlib/text.md:8
#: src/reference/stdlib/text.md:15
msgid "`sub` `col`"
msgstr ""

#: src/reference/stdlib/text.md:7
msgid "Returns true if `col` contains `sub`"
msgstr ""

#: src/reference/stdlib/text.md:8
msgid "ends_with"
msgstr ""

#: src/reference/stdlib/text.md:8
msgid "Returns true if `col` ends with `sub`"
msgstr ""

#: src/reference/stdlib/text.md:9
msgid "extract"
msgstr ""

#: src/reference/stdlib/text.md:9
msgid "`idx` `len` `col`"
msgstr ""

#: src/reference/stdlib/text.md:9
msgid ""
"Extracts a substring at the index `idx` (starting at 1) with the length `len`"
msgstr ""

#: src/reference/stdlib/text.md:10
msgid "length"
msgstr ""

#: src/reference/stdlib/text.md:10
msgid "Returns the number of characters in `col`"
msgstr ""

#: src/reference/stdlib/text.md:11
msgid "lower"
msgstr ""

#: src/reference/stdlib/text.md:11
msgid "Converts `col` to lower case"
msgstr ""

#: src/reference/stdlib/text.md:12
msgid "ltrim"
msgstr ""

#: src/reference/stdlib/text.md:12
msgid "Removes all the whitespaces from the left side of `col`"
msgstr ""

#: src/reference/stdlib/text.md:13
msgid "replace"
msgstr ""

#: src/reference/stdlib/text.md:13
msgid "`before` `after` `col`"
msgstr ""

#: src/reference/stdlib/text.md:13
msgid "Replaces any occurrences of `before` with `after` in `col`"
msgstr ""

#: src/reference/stdlib/text.md:14
msgid "rtrim"
msgstr ""

#: src/reference/stdlib/text.md:14
msgid "Removes all the whitespaces from the right side of `col`"
msgstr ""

#: src/reference/stdlib/text.md:15
msgid "starts_with"
msgstr ""

#: src/reference/stdlib/text.md:15
msgid "Returns true if `col` starts with `sub`"
msgstr ""

#: src/reference/stdlib/text.md:16
msgid "trim"
msgstr ""

#: src/reference/stdlib/text.md:16
msgid "Removes all the whitespaces from both sides of `col`"
msgstr ""

#: src/reference/stdlib/text.md:17
msgid "upper"
msgstr ""

#: src/reference/stdlib/text.md:17
msgid "Converts `col` to upper case"
msgstr ""

#: src/reference/stdlib/text.md:21
msgid ""
"```prql\n"
"from employees\n"
"select {\n"
"  (last_name | text.lower | text.starts_with(\"a\")),\n"
"  (title | text.replace \"manager\" \"chief\"),\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/index.md:1
msgid "Transforms"
msgstr "變換"

#: src/reference/stdlib/transforms/index.md:3
msgid "Transforms are functions that take a relation and produce a relation."
msgstr ""

#: src/reference/stdlib/transforms/index.md:5
msgid ""
"Usually they are chained together into a pipeline, which resembles an SQL "
"query."
msgstr ""

#: src/reference/stdlib/transforms/index.md:7
msgid ""
"Transforms were designed with a focus on modularity, so each of them is "
"fulfilling a specific purpose and has defined invariants (properties of the "
"relation that are left unaffected). That's often referred to as "
"\"orthogonality\" and its goal is to keep transform functions composable by "
"minimizing interference of their effects. Additionally, it also keeps the "
"number of transforms low."
msgstr ""

#: src/reference/stdlib/transforms/index.md:14
msgid ""
"For example, `select` and `derive` will not change the number of rows, while "
"`filter` and `take` will not change the number of columns."
msgstr ""

#: src/reference/stdlib/transforms/index.md:17
msgid ""
"In SQL, we can see this lack of invariant when an aggregation function is "
"used in the `SELECT` clause. Before, the number of rows was kept constant, "
"but introduction of an aggregation function caused the whole statement to "
"produce only one row (per group)."
msgstr ""

#: src/reference/stdlib/transforms/index.md:22
msgid "These are the currently available transforms:"
msgstr ""

#: src/reference/stdlib/transforms/index.md:24
msgid "Transform"
msgstr ""

#: src/reference/stdlib/transforms/index.md:24
msgid "SQL Equivalent"
msgstr ""

#: src/reference/stdlib/transforms/index.md:26
msgid "`derive`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:26
msgid "[Compute new columns](./derive.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:26
msgid "`SELECT *, ... AS ...`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:27
msgid "`select`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:27
msgid "[Pick & compute columns](./select.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:27
msgid "`SELECT ... AS ...`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:28
msgid "`filter`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:28
msgid "[Pick rows based on their values](./filter.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:28
msgid "`WHERE`, `HAVING`,`QUALIFY`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:29
msgid "`sort`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:29
msgid "[Order rows based on the values of columns](./sort.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:29
msgid "`ORDER BY`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:30
msgid "`join`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:30
msgid ""
"[Add columns from another table, matching rows based on a condition](./join."
"md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:30
msgid "`JOIN`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:31
msgid "`take`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:31
msgid "[Pick rows based on their position](./take.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:31
msgid "`TOP`, `LIMIT`, `OFFSET`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:32
msgid "`group`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:32
msgid ""
"[Partition rows into groups and applies a pipeline to each of them](./group."
"md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:32
msgid "`GROUP BY`, `PARTITION BY`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:33
msgid "`aggregate`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:33
msgid "[Summarize many rows into one row](./aggregate.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:33
msgid "`SELECT foo(...)`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:34
msgid "`window`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:34
msgid "[Apply a pipeline to overlapping segments of rows](./window.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:34
msgid "`OVER`, `ROWS`, `RANGE`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:35
msgid "`loop`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:35
msgid ""
"[Iteratively apply a function to a relation until it's empty](./loop.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:35
msgid "`WITH RECURSIVE ...`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:39
msgid ""
"[`from`](../../data/from.md) — `from` is the main way of getting data into a "
"pipeline (it's not listed above since it's not technically a transform, "
"since it doesn't receive an input)."
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:1
msgid "Aggregate"
msgstr "聚合"

#: src/reference/stdlib/transforms/aggregate.md:3
msgid "Summarizes many rows into one row."
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:5
msgid "When applied:"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:7
msgid "without `group`, it produces one row from the whole table,"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:8
msgid "within a `group` pipeline, it produces one row from each group."
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:15
msgid ""
"\\[!NOTE\\] Currently, all declared aggregation functions are `min`, `max`, "
"`count`, `average`, `stddev`, `avg`, `sum` and `count_distinct`. We are in "
"the process of filling out [std lib](../)."
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:40
msgid "Aggregate is required"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:42
msgid ""
"Unlike in SQL, using an aggregation function in `derive` or `select` (or any "
"other transform except `aggregate`) will not trigger aggregation. By "
"default, PRQL will interpret such attempts functions as window functions:"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:51
msgid ""
"This ensures that `derive` does not manipulate the number of rows, but only "
"ever adds a column. For more information, see [window transform](./window."
"md)."
msgstr ""

#: src/SUMMARY.md:56
msgid "Append"
msgstr "附加"

#: src/reference/stdlib/transforms/append.md:3
msgid "Concatenates two tables together."
msgstr ""

#: src/reference/stdlib/transforms/append.md:5
msgid ""
"Equivalent to `UNION ALL` in SQL. The number of rows is always the sum of "
"the number of rows from the two input tables. To replicate `UNION DISTINCT`, "
"see [set operations](#set-operations)."
msgstr ""

#: src/reference/stdlib/transforms/append.md:14
msgid "Remove"
msgstr ""

#: src/reference/stdlib/transforms/append.md:16
#: src/reference/stdlib/transforms/append.md:28
#: src/reference/stdlib/transforms/append.md:37
msgid "_experimental_"
msgstr ""

#: src/reference/stdlib/transforms/append.md:18
msgid ""
"Removes rows that appear in another relation, like `EXCEPT ALL`. Duplicate "
"rows are removed one-for-one."
msgstr ""

#: src/reference/stdlib/transforms/append.md:26
msgid "Intersection"
msgstr ""

#: src/reference/stdlib/transforms/append.md:35
msgid "Set operations"
msgstr ""

#: src/reference/stdlib/transforms/append.md:39
msgid ""
"To imitate set operations i.e. (`UNION`, `EXCEPT` and `INTERSECT`), you can "
"use the following functions:"
msgstr ""

#: src/reference/stdlib/transforms/append.md:49
msgid ""
"Don't mind the `default_db.` and `noop`, these are compiler implementation "
"detail for now."
msgstr ""

#: src/reference/stdlib/transforms/derive.md:1
msgid "Derive"
msgstr "衍生"

#: src/reference/stdlib/transforms/derive.md:3
msgid "Computes one or more new columns."
msgstr "計算一個或多個新欄位。"

#: src/reference/stdlib/transforms/filter.md:1
msgid "Filter"
msgstr "篩選"

#: src/reference/stdlib/transforms/filter.md:3
msgid "Picks rows based on their values."
msgstr ""

#: src/reference/stdlib/transforms/filter.md:16
msgid ""
"```prql\n"
"from employees\n"
"filter (age > 25 || department != \"IT\")\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"filter (age > 25 || department != \"IT\")\n"
"```"

#: src/reference/stdlib/transforms/filter.md:21
msgid ""
"```prql\n"
"from employees\n"
"filter (department | in [\"IT\", \"HR\"])\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"filter (department | in [\"IT\", \"HR\"])\n"
"```"

#: src/reference/stdlib/transforms/group.md:1
msgid "Group"
msgstr "群組"

#: src/reference/stdlib/transforms/group.md:3
msgid ""
"Partitions the rows into groups and applies a pipeline to each of the groups."
msgstr ""

#: src/reference/stdlib/transforms/group.md:9
msgid ""
"The partitioning of groups are determined by the `key_column`s (first "
"argument)."
msgstr ""

#: src/reference/stdlib/transforms/group.md:11
msgid "The most conventional use of `group` is with `aggregate`:"
msgstr ""

#: src/reference/stdlib/transforms/group.md:23
msgid ""
"In concept, a transform in context of a `group` does the same transformation "
"to the group as it would to the table — for example finding the employee who "
"joined first across the whole table:"
msgstr ""

#: src/reference/stdlib/transforms/group.md:33
msgid ""
"To find the employee who joined first in each department, it's exactly the "
"same pipeline, but within a `group` expression:"
msgstr ""

#: src/reference/stdlib/transforms/join.md:1
msgid "Join"
msgstr "聯接"

#: src/reference/stdlib/transforms/join.md:3
msgid "Adds columns from another relation, matching rows based on a condition."
msgstr ""

#: src/reference/stdlib/transforms/join.md:9
msgid "Parameters"
msgstr "參數"

#: src/reference/stdlib/transforms/join.md:11
msgid "`side` specifies which rows to include, defaulting to `inner`."
msgstr ""

#: src/reference/stdlib/transforms/join.md:12
msgid ""
"`rel` - the relation to join with, possibly including an alias, e.g. "
"`a=artists`."
msgstr ""

#: src/reference/stdlib/transforms/join.md:14
msgid ""
"`condition` - the criteria on which to match the rows from the two "
"relations. Theoretically, `join` will produce a cartesian product of the two "
"input relations and then filter the result by the condition. It supports two "
"additional features:"
msgstr ""

#: src/reference/stdlib/transforms/join.md:18
msgid ""
"_Names [`this` & `that`](../../syntax/keywords.md#this--that)_: Along name "
"`this`, which refers to the first input relation, `condition` can use name "
"`that`, which refers to the second input relation."
msgstr ""

#: src/reference/stdlib/transforms/join.md:21
msgid ""
"_Self equality operator_: If the condition is an equality comparison between "
"two columns with the same name (i.e. `(this.col == that.col)`), it can be "
"expressed with only `(==col)`."
msgstr ""

#: src/reference/stdlib/transforms/join.md:51
msgid ""
"In SQL, CROSS JOIN is a join that returns each row from first relation "
"matched with all rows from the second relation. To accomplish this, we can "
"use condition `true`, which will return all rows of the cartesian product of "
"the input relations:"
msgstr ""

#: src/reference/stdlib/transforms/join.md:63
msgid ""
"[`this` & `that`](../../syntax/keywords.md#this--that) can be used to refer "
"to the current & other table respectively:"
msgstr ""

#: src/reference/stdlib/transforms/join.md:75
msgid ""
"If the join conditions are of form `left.x == right.x`, we can use \"self "
"equality operator\":"
msgstr ""

#: src/reference/stdlib/transforms/loop.md:1
msgid "Loop"
msgstr "循環"

#: src/reference/stdlib/transforms/loop.md:3
msgid "_Experimental_"
msgstr ""

#: src/reference/stdlib/transforms/loop.md:9
msgid ""
"Iteratively applies `step` function to `initial` relation until the `step` "
"returns an empty table. Returns a relation that contains rows of initial "
"relation and all intermediate relations."
msgstr ""

#: src/reference/stdlib/transforms/loop.md:13
msgid "This behavior could be expressed with following pseudo-code:"
msgstr ""

#: src/reference/stdlib/transforms/loop.md:39
msgid ""
"\\[!NOTE\\] The behavior of `WITH RECURSIVE` may depend on the database "
"configuration in MySQL. The compiler assumes the behavior described by the "
"[Postgres documentation](https://www.postgresql.org/docs/15/queries-with."
"html#QUERIES-WITH-RECURSIVE) and will not produce correct results for "
"[alternative configurations of MySQL](https://dev.mysql.com/doc/refman/8.0/"
"en/with.html#common-table-expressions-recursive)."
msgstr ""

#: src/reference/stdlib/transforms/loop.md:47
msgid ""
"\\[!NOTE\\] Currently, `loop` may produce references to the recursive CTE in "
"sub-queries, which is not supported by some database engines, e.g. SQLite. "
"For now, we suggest step functions are kept simple enough to fit into a "
"single SELECT statement."
msgstr ""

#: src/reference/stdlib/transforms/select.md:1
msgid "Select"
msgstr "選擇"

#: src/reference/stdlib/transforms/select.md:3
msgid "Picks and computes columns."
msgstr ""

#: src/reference/stdlib/transforms/select.md:17
msgid ""
"```prql\n"
"from employees\n"
"select name = f\"{first_name} {last_name}\"\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/select.md:22
msgid ""
"```prql\n"
"from employees\n"
"select {\n"
"  name = f\"{first_name} {last_name}\",\n"
"  age_eoy = dob - @2022-12-31,\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/select.md:40
msgid "Excluding columns"
msgstr ""

#: src/reference/stdlib/transforms/select.md:42
msgid ""
"We can use `!` to exclude a list of columns. This can operate in two ways:"
msgstr ""

#: src/reference/stdlib/transforms/select.md:44
msgid ""
"We use `SELECT * EXCLUDE` / `SELECT * EXCEPT` for the columns supplied to "
"`select !{}` in dialects which support it."
msgstr ""

#: src/reference/stdlib/transforms/select.md:46
msgid ""
"Otherwise, the columns must have been defined prior in the query (unless all "
"of a table's columns are excluded); for example in another `select` or a "
"`group` transform. In this case, we evaluate and specify the columns that "
"should be included in the output SQL."
msgstr ""

#: src/reference/stdlib/transforms/select.md:51
msgid "Some examples:"
msgstr ""

#: src/reference/stdlib/transforms/select.md:71
msgid ""
"Note that `!` is also the `NOT` operator, so without the tuple it has a "
"different meaning:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:1
msgid "Sort"
msgstr "排序"

#: src/reference/stdlib/transforms/sort.md:3
msgid ""
"Order rows based on the values of one or more expressions (generally "
"columns)."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:11
msgid "One expression or a tuple of expressions to sort by"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:12
msgid "Each expression can be prefixed with:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:13
msgid "`+`, for ascending order, the default"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:14
msgid "`-`, for descending order"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:15
msgid ""
"When using prefixes, even a single expression needs to be in a tuple or "
"parentheses. (Otherwise, `sort -foo` is parsed as a subtraction between "
"`sort` and `foo`.)"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:36
msgid "We can also use expressions:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:38
msgid ""
"```prql\n"
"from employees\n"
"sort {s\"substr({first_name}, 2, 5)\"}\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:43
msgid "Ordering guarantees"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:45
msgid "Ordering is persistent through a pipeline in PRQL. For example:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:53
msgid ""
"Here, PRQL pushes the `sort` down the pipeline, compiling the `ORDER BY` to "
"the _end_ of the query. Consequently, most relation transforms retain the "
"row order."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:56
msgid "The explicit semantics are:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:58
msgid "`sort` introduces a new order,"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:59
msgid "`group` resets the order,"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:60
msgid "`join` retains the order of the left relation,"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:61
msgid "database tables don't have a known order."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:63
msgid ""
"Comparatively, in SQL, relations possess no order, being orderable solely "
"within the context of the query result, `LIMIT` statement, or window "
"function. The lack of inherent order can result in an unexpected reshuffling "
"of a previously ordered relation from a `JOIN` or windowing operation."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:69
msgid ""
"\\[!NOTE\\] To be precise — in PRQL, a relation is an _array of tuples_ and "
"not a set or a bag. The persistent nature of this order remains intact "
"through sub-queries and intermediate table definitions."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:74
msgid "For instance, an SQL query such as:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:87
msgid ""
"...doesn't guarantee any row order (indeed — even without the `JOIN`, the "
"SQL standard doesn't guarantee an order, although most implementations will "
"respect it)."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:122
msgid ""
"<a name=\"footnote-1\">[1](#to-footnote-1)</a>: except for MSSQL, which "
"doesn't support this"
msgstr ""

#: src/reference/stdlib/transforms/take.md:1
msgid "Take"
msgstr "取"

#: src/reference/stdlib/transforms/take.md:3
msgid "Picks rows based on their position."
msgstr ""

#: src/reference/stdlib/transforms/take.md:9
msgid ""
"See [Ranges](../../syntax/ranges.md) for more details on how ranges work."
msgstr ""

#: src/reference/stdlib/transforms/window.md:1
msgid "Window"
msgstr "視窗"

#: src/reference/stdlib/transforms/window.md:3
msgid ""
"Applies a pipeline to segments of rows, producing one output value for every "
"input value."
msgstr ""

#: src/reference/stdlib/transforms/window.md:10
msgid ""
"For each row, the segment over which the pipeline is applied is determined "
"by one of:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:13
msgid ""
"`rows`, which takes a range of rows relative to the current row position."
msgstr ""

#: src/reference/stdlib/transforms/window.md:14
msgid "`0` references the current row."
msgstr ""

#: src/reference/stdlib/transforms/window.md:15
msgid "`range`, which takes a range of values relative to current row value."
msgstr ""

#: src/reference/stdlib/transforms/window.md:17
msgid ""
"The bounds of the range are inclusive. If a bound is omitted, the segment "
"will extend until the edge of the table or group."
msgstr ""

#: src/reference/stdlib/transforms/window.md:20
msgid "For ease of use, there are two flags that override `rows` or `range`:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:22
msgid ""
"`expanding:true` is an alias for `rows:..0`. A sum using this window is also "
"known as \"cumulative sum\"."
msgstr ""

#: src/reference/stdlib/transforms/window.md:24
msgid ""
"`rolling:n` is an alias for `rows:(-n+1)..0`, where `n` is an integer. This "
"will include `n` last values, including current row. An average using this "
"window is also knows as a Simple Moving Average."
msgstr ""

#: src/reference/stdlib/transforms/window.md:30
msgid "Expression"
msgstr "表達式"

#: src/reference/syntax/strings.md:71
msgid "Meaning"
msgstr "意義"

#: src/reference/stdlib/transforms/window.md:32
msgid "`rows:0..2`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:32
msgid "current row plus two following"
msgstr ""

#: src/reference/stdlib/transforms/window.md:33
msgid "`rows:-2..0`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:33
msgid "two preceding rows plus current row"
msgstr ""

#: src/reference/stdlib/transforms/window.md:34
msgid "`rolling:3`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:34
#: src/reference/stdlib/transforms/window.md:37
msgid "(same as previous)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:35
msgid "`rows:-2..4`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:35
msgid "two preceding rows plus current row plus four following rows"
msgstr ""

#: src/reference/stdlib/transforms/window.md:36
msgid "`rows:..0`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:36
msgid "all rows from the start of the table up to & including current row"
msgstr ""

#: src/reference/stdlib/transforms/window.md:37
msgid "`expanding:true`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:38
msgid "`rows:0..`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:38
msgid "current row and all following rows until the end of the table"
msgstr ""

#: src/reference/stdlib/transforms/window.md:39
msgid "`rows:..`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:39
msgid "all rows, which same as not having window at all"
msgstr ""

#: src/reference/stdlib/transforms/window.md:67
msgid "Rows vs Range:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "time_id"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "value"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "sma3rows"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "sma3range"
msgstr ""

#: src/reference/stdlib/transforms/window.md:90
msgid "1"
msgstr ""

#: src/reference/stdlib/transforms/window.md:90
#: src/reference/stdlib/transforms/window.md:94
msgid "15"
msgstr ""

#: src/reference/stdlib/transforms/window.md:91
msgid "2"
msgstr ""

#: src/reference/stdlib/transforms/window.md:91
msgid "11"
msgstr ""

#: src/reference/stdlib/transforms/window.md:91
msgid "13"
msgstr ""

#: src/reference/stdlib/transforms/window.md:92
msgid "3"
msgstr ""

#: src/reference/stdlib/transforms/window.md:92
msgid "16"
msgstr ""

#: src/reference/stdlib/transforms/window.md:92
msgid "14"
msgstr ""

#: src/reference/stdlib/transforms/window.md:93
msgid "4"
msgstr ""

#: src/reference/stdlib/transforms/window.md:93
msgid "9"
msgstr ""

#: src/reference/stdlib/transforms/window.md:93
msgid "12"
msgstr ""

#: src/reference/stdlib/transforms/window.md:94
msgid "7"
msgstr ""

#: src/reference/stdlib/transforms/window.md:94
msgid "20"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "8"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "22"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "17"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "21"
msgstr ""

#: src/reference/stdlib/transforms/window.md:97
msgid ""
"We can see that rows having `time_id` of 5 and 6 are missing in example "
"data; we can say there are gaps in our time series data."
msgstr ""

#: src/reference/stdlib/transforms/window.md:100
msgid "When computing SMA 3 for the fifth row (`time_id==7`) then:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:102
msgid "\"rows\" will compute average on 3 rows (`time_id` in `3, 4, 7`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:103
msgid "\"range\" will compute average on single row only (`time_id==7`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:105
msgid "When computing SMA 3 for the sixth row (`time_id==8`) then:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:107
msgid "\"rows\" will compute average on 3 rows (`time_id` in `4, 7, 8`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:108
msgid "\"range\" will compute average on 2 rows (`time_id` in `7, 8`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:110
msgid ""
"We can observe that \"rows\" ignores the content of the `time_id`, only uses "
"its order; we can say its window operates on physical rows. On the other "
"hand \"range\" looks at the content of the `time_id` and based on the "
"content decides how many rows fits into window; we can say window operates "
"on logical rows."
msgstr ""

#: src/reference/stdlib/transforms/window.md:115
msgid "Windowing by default"
msgstr ""

#: src/reference/stdlib/transforms/window.md:117
msgid ""
"If you use window functions without `window` transform, they will be applied "
"to the whole table. Unlike in SQL, they will remain window functions and "
"will not trigger aggregation."
msgstr ""

#: src/reference/stdlib/transforms/window.md:127
msgid "You can also only apply `group`:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:137
msgid "Window functions as first class citizens"
msgstr ""

#: src/reference/stdlib/transforms/window.md:139
msgid "There are no limitations on where windowed expressions can be used:"
msgstr ""

#: src/reference/syntax/index.md:1 src/reference/syntax/index.md:11
msgid "Syntax"
msgstr "語法"

#: src/reference/syntax/index.md:3
msgid "A summary of PRQL syntax:"
msgstr "PRQL 語法摘要："

#: src/reference/syntax/index.md:13
msgid "<code>\\|</code>"
msgstr ""

#: src/reference/syntax/index.md:13
msgid "[Pipelines](./function-calls.md)"
msgstr "[管道](./function-calls.md)"

#: src/reference/syntax/index.md:13
msgid "<code>from employees \\| select first_name</code>"
msgstr ""

#: src/reference/syntax/index.md:14
msgid "`=`"
msgstr ""

#: src/reference/syntax/index.md:14
msgid "[Assigns](../declarations/variables.md)"
msgstr "[指派](../declarations/variables.md)"

#: src/reference/syntax/index.md:14
msgid "`from e = employees` <br> `derive total = (sum salary)`"
msgstr ""

#: src/reference/syntax/index.md:15
msgid "`:`"
msgstr ""

#: src/reference/syntax/index.md:15
msgid "[Named args & parameters](../declarations/functions.md)"
msgstr "[具名引數和參數](../declarations/functions.md)"

#: src/reference/syntax/index.md:15
msgid "`interp low:0 1600 sat_score`"
msgstr ""

#: src/reference/syntax/index.md:16
msgid "`{}`"
msgstr ""

#: src/reference/syntax/index.md:16
msgid "[Tuples](./tuples.md)"
msgstr "[值組](./tuples.md)"

#: src/reference/syntax/index.md:16
msgid "`{id, false, total = 3}`"
msgstr ""

#: src/reference/syntax/index.md:17
msgid "`[]`"
msgstr ""

#: src/reference/syntax/index.md:17
msgid "[Arrays](./arrays.md)"
msgstr "[陣列](./arrays.md)"

#: src/reference/syntax/index.md:17
msgid "`[1, 4, 3, 4]`"
msgstr ""

#: src/reference/syntax/index.md:18
msgid "`+`,`!`,`&&`,`==`, etc"
msgstr "`+`、`!`、`&&`、`==` 等"

#: src/reference/syntax/index.md:18
msgid "[Operators](./operators.md)"
msgstr "[運算子](./operators.md)"

#: src/reference/syntax/index.md:18
msgid "<code>filter a == b + c \\|\\| d >= e</code>"
msgstr ""

#: src/reference/syntax/index.md:19
msgid "`()`"
msgstr ""

#: src/reference/syntax/index.md:19
msgid "[Parentheses](./operators.md#parentheses)"
msgstr "[括號](./operators.md#parentheses)"

#: src/reference/syntax/index.md:19
msgid "`derive celsius = (fht - 32) / 1.8`"
msgstr ""

#: src/reference/syntax/index.md:20
msgid "`\\`"
msgstr ""

#: src/reference/syntax/index.md:20
msgid "[Line wrap](./operators.md#wrapping-lines)"
msgstr "[換行](./operators.md#wrapping-lines)"

#: src/reference/syntax/index.md:20
msgid "<code>1 + 2 + 3 +</code><br><code>\\\\ 4 + 5</code>"
msgstr ""

#: src/reference/syntax/index.md:21
msgid "`1`,`100_000`,`5e10`"
msgstr "`1`、`100_000`、`5e10`"

#: src/reference/syntax/index.md:21
msgid "[Numbers](./literals.md#numbers)"
msgstr "[數字](./literals.md#numbers)"

#: src/reference/syntax/index.md:21
msgid "`derive { huge = 5e10 * 10_000 }`"
msgstr ""

#: src/reference/syntax/index.md:22
msgid "`''`,`\"\"`"
msgstr "`''`、`\"\"`"

#: src/reference/syntax/index.md:22
msgid "[Strings](./literals.md#strings)"
msgstr "[字串](./literals.md#strings)"

#: src/reference/syntax/index.md:22
msgid "`derive name = 'Mary'`"
msgstr ""

#: src/reference/syntax/index.md:23
msgid "`true`,`false`"
msgstr "`true`、`false`"

#: src/reference/syntax/index.md:23
msgid "[Booleans](./literals.md#booleans)"
msgstr "[布林值](./literals.md#booleans)"

#: src/reference/syntax/index.md:23
msgid "`derive { Col1 = true }`"
msgstr ""

#: src/reference/syntax/index.md:24
msgid "`null`"
msgstr ""

#: src/reference/syntax/index.md:24
msgid "[Null](./literals.md#null)"
msgstr ""

#: src/reference/syntax/index.md:24
msgid "`filter ( name != null )`"
msgstr ""

#: src/reference/syntax/index.md:25
msgid "`@`"
msgstr ""

#: src/reference/syntax/index.md:25
msgid "[Dates & times](./literals.md#date-and-time)"
msgstr "[日期和時間](./literals.md#date-and-time)"

#: src/reference/syntax/index.md:25
msgid "`@2021-01-01`"
msgstr ""

#: src/reference/syntax/index.md:26
msgid "`` ` ` ``"
msgstr ""

#: src/reference/syntax/index.md:26
msgid "[Quoted identifiers](./keywords.md#quoting)"
msgstr "[引用的識別符號](./keywords.md#quoting)"

#: src/reference/syntax/index.md:26
msgid "``select `first name` ``"
msgstr ""

#: src/reference/syntax/index.md:27
msgid "`#`"
msgstr ""

#: src/reference/syntax/index.md:27
msgid "[Comments](./comments.md)"
msgstr "[註釋](./comments.md)"

#: src/reference/syntax/index.md:27
msgid "`# A comment`"
msgstr ""

#: src/reference/syntax/index.md:28
msgid "`==`"
msgstr ""

#: src/reference/syntax/index.md:28
msgid ""
"[Self-equality in `join`](../stdlib/transforms/join.md#self-equality-"
"operator)"
msgstr ""
"[`join` 中的自相等](../stdlib/transforms/join.md#self-equality-operator)"

#: src/reference/syntax/index.md:28
msgid "`join s=salaries (==id)`"
msgstr ""

#: src/reference/syntax/index.md:29
msgid "`->`"
msgstr ""

#: src/reference/syntax/index.md:29
msgid "[Function definitions](../declarations/functions.md)"
msgstr "[函式定義](../declarations/functions.md)"

#: src/reference/syntax/index.md:29
msgid "`let add = a b -> a + b`"
msgstr ""

#: src/reference/syntax/index.md:30
msgid "`=>`"
msgstr ""

#: src/reference/syntax/index.md:30
msgid "[Case statement](./case.md)"
msgstr "[Case 語句](./case.md)"

#: src/reference/syntax/index.md:30
msgid "`case [a==1 => c, a==2 => d]`"
msgstr ""

#: src/reference/syntax/index.md:31
msgid "`+`,`-`"
msgstr "`+`、`-`"

#: src/reference/syntax/index.md:31
msgid "[Sort order](../stdlib/transforms/sort.md)"
msgstr "[排序順序](../stdlib/transforms/sort.md)"

#: src/reference/syntax/index.md:31
msgid "`sort {-amount, +date}`"
msgstr ""

#: src/reference/syntax/index.md:32
msgid "`??`"
msgstr ""

#: src/reference/syntax/index.md:32
msgid "[Coalesce](./operators.md#coalesce)"
msgstr "[合併](./operators.md#coalesce)"

#: src/reference/syntax/index.md:32
msgid "`amount ?? 0`"
msgstr ""

#: src/reference/syntax/arrays.md:3
msgid ""
"Array is a container type, composed of multiple items. All items must be of "
"the same type. Number of fields can be vary."
msgstr ""
"陣列是一個容器型別，由多個項目組成。所有項目必須是相同型別。欄位數量可以變"
"化。"

#: src/reference/syntax/arrays.md:7
msgid "\\[!WARNING\\] This page is a stub."
msgstr "\\[!WARNING\\] 本頁面是存根。"

#: src/reference/syntax/case.md:1
msgid "Case"
msgstr "情況"

#: src/reference/syntax/case.md:3
msgid ""
"Search for the first condition that evaluates to `true` and return its "
"associated value. If none of the conditions match, `null` is returned."
msgstr ""
"搜尋第一個評估為 `true` 的條件並返回其關聯值。如果沒有條件符合，則返回 "
"`null`。"

#: src/reference/syntax/case.md:6
msgid ""
"```prql\n"
"from employees\n"
"derive distance = case [\n"
"  city == \"Calgary\" => 0,\n"
"  city == \"Edmonton\" => 300,\n"
"]\n"
"```"
msgstr ""

#: src/reference/syntax/case.md:14
msgid "To set a default, a `true` condition can be used:"
msgstr "要設定預設值，可以使用 `true` 條件："

#: src/reference/syntax/case.md:16
msgid ""
"```prql\n"
"from employees\n"
"derive distance = case [\n"
"  city == \"Calgary\" => 0,\n"
"  city == \"Edmonton\" => 300,\n"
"  true => \"Unknown\",\n"
"]\n"
"```"
msgstr ""

#: src/reference/syntax/comments.md:1
msgid "Comments"
msgstr "註釋"

#: src/reference/syntax/comments.md:3
msgid "Character `#` denotes a comment until the end of the line."
msgstr "字元 `#` 表示註釋到行的結尾。"

#: src/reference/syntax/comments.md:11
msgid "There's no distinct multiline comment syntax."
msgstr "沒有明確的多行註釋語法。"

#: src/reference/syntax/function-calls.md:1
msgid "Function calls"
msgstr "函式呼叫"

#: src/reference/syntax/function-calls.md:3
msgid "Simple"
msgstr "簡單"

#: src/reference/syntax/function-calls.md:5
msgid ""
"A distinction between PRQL and most other programming languages is the "
"function call syntax. It consists of the function name followed by arguments "
"separated by whitespace."
msgstr ""
"PRQL 和大多數其他程式語言之間的區別是函式呼叫語法。它由函式名稱組成，後面跟著"
"以空格分隔的引數。"

#: src/reference/syntax/function-calls.md:13
msgid ""
"If one of the arguments is also a function call, it must be encased in "
"parentheses, so we know where arguments of inner function end and the "
"arguments of outer function start."
msgstr ""
"如果其中一個引數也是函式呼叫，它必須用括號括起來，這樣我們才能知道內部函式的"
"引數在哪裡結束，外部函式的引數在哪裡開始。"

#: src/reference/syntax/function-calls.md:21
msgid ""
"The function name must refer to a function variable, which has either [been "
"declared](../declarations/functions.md) in the [standard library](../"
"stdlib/) or some other module."
msgstr ""
"函式名稱必須指向函式變數，該變數要麼在[標準函式庫](../stdlib/)中[已被宣告]"
"(../declarations/functions.md)，要麼在其他某個模組中。"

#: src/reference/syntax/function-calls.md:25
msgid "Function calls can also specify named parameters using `:` notation:"
msgstr "函式呼叫也可以使用 `:` 符號指定具名參數："

#: src/reference/syntax/function-calls.md:31
msgid "Pipeline"
msgstr "管道"

#: src/reference/syntax/function-calls.md:33
msgid ""
"There is a alternative way of calling functions: using a pipeline. "
"Regardless of whether the pipeline is delimited by pipe symbol `|` or a new "
"line, the pipeline is equivalent to applying each of functions as the last "
"argument of the next function."
msgstr ""
"有另一種呼叫函式的方式：使用管道。無論管道是由管道符號 `|` 還是新行分隔，管道"
"相當於將每個函式作為下一個函式的最後一個引數應用。"

#: src/reference/syntax/function-calls.md:42
msgid "... is equivalent to ..."
msgstr "...等價於..."

#: src/reference/syntax/keywords.md:1
msgid "Identifiers & keywords"
msgstr "識別符與關鍵字"

#: src/reference/syntax/keywords.md:3
msgid ""
"Identifiers can contain alphanumeric characters and `_` and must not start "
"with a number. They can be chained together with the `.` lookup operator, "
"used to retrieve a tuple from a field or a variable from a module."
msgstr ""
"識別符可以包含英數字元和 `_`，且不能以數字開頭。它們可以用 `.` 查找運算子鏈接"
"在一起，用於從欄位擷取值組或從模組擷取變數。"

#: src/reference/syntax/keywords.md:15
msgid "`this` & `that`"
msgstr "`this` 和 `that`"

#: src/reference/syntax/keywords.md:17
msgid "`this` refers to the current relation:"
msgstr "`this` 指的是目前的關聯："

#: src/reference/syntax/keywords.md:26
msgid ""
"Within a [`join`](../stdlib/transforms/join.md), `that` refers to the other "
"table:"
msgstr ""
"在 [`join`](../stdlib/transforms/join.md) 中，`that` 指的是另一個表格："

#: src/reference/syntax/keywords.md:34
msgid ""
"`this` can also be used to remove any column ambiguity. For example, "
"currently using a bare `time` as a column name will fail, because it's also "
"a type:"
msgstr ""
"`this` 也可以用來移除任何欄位歧義。例如，目前使用裸 `time` 作為欄位名稱會失"
"敗，因為它也是一個型別："

#: src/reference/syntax/keywords.md:42
msgid "But with `this.time`, we can remove the ambiguity:"
msgstr "但有了 `this.time`，我們可以移除歧義："

#: src/reference/syntax/keywords.md:49
msgid "Quoting"
msgstr "引述"

#: src/reference/syntax/keywords.md:51
msgid ""
"To use characters that would be otherwise invalid, identifiers can be "
"surrounded by with backticks."
msgstr "為了使用其他方式無效的字元，識別符可以用反引號括起來。"

#: src/reference/syntax/keywords.md:54
msgid ""
"When compiling to SQL, these identifiers will use dialect-specific quotes "
"and quoting rules."
msgstr "編譯為 SQL 時，這些識別符將使用方言特定的引號和引述規則。"

#: src/reference/syntax/keywords.md:76
msgid "Schemas & database names"
msgstr "綱要和資料庫名稱"

#: src/reference/syntax/keywords.md:78
msgid ""
"Identifiers of database tables can be prefixed with schema and databases "
"names."
msgstr "資料庫表格的識別符可以加上綱要和資料庫名稱的前綴。"

#: src/reference/syntax/keywords.md:84
msgid ""
"Note that all of following identifiers will be treated as separate table "
"definitions: `tracks`, `public.tracks`, `my_database.public.tracks`."
msgstr ""
"請注意，以下所有識別符都將被視為單獨的表格定義：`tracks`、`public.tracks`、"
"`my_database.public.tracks`。"

#: src/reference/syntax/keywords.md:87
msgid "Keywords"
msgstr "關鍵字"

#: src/reference/syntax/keywords.md:89
msgid "PRQL uses following keywords:"
msgstr "PRQL 使用了以下關鍵字："

#: src/reference/syntax/keywords.md:91
msgid "**`prql`** - query header [_more..._](../../project/target.md)"
msgstr "**`prql`** - 查詢標頭 [_更多..._](../../project/target.md)"

#: src/reference/syntax/keywords.md:92
msgid ""
"**`let`** - variable definition [_more..._](../declarations/variables.md)"
msgstr "**`let`** - 變數定義 [_更多..._](../declarations/variables.md)"

#: src/reference/syntax/keywords.md:93
msgid ""
"**`into`** - variable definition [_more..._](../declarations/variables.md)"
msgstr "**`into`** - 變數定義 [_更多..._](../declarations/variables.md)"

#: src/reference/syntax/keywords.md:94
msgid "**`case`** - flow control [_more..._](../syntax/case.md)"
msgstr "**`case`** - 流程控制 [_更多..._](../syntax/case.md)"

#: src/reference/syntax/keywords.md:95
msgid "**`type`** - type declaration"
msgstr "**`type`** - 型別宣告"

#: src/reference/syntax/keywords.md:96
msgid ""
"**`func`** - explicit function declaration [_more..._](../declarations/"
"functions.md)"
msgstr "**`func`** - 明確的函式宣告 [_更多..._](../declarations/functions.md)"

#: src/reference/syntax/keywords.md:98
msgid "**`module`** - used internally"
msgstr "**`module`** - 內部使用"

#: src/reference/syntax/keywords.md:99
msgid "**`internal`** - used internally"
msgstr "**`internal`** - 內部使用"

#: src/reference/syntax/keywords.md:100
msgid "**`true`** - boolean [_more..._](./literals.md#booleans)"
msgstr "**`true`** - 布林值 [_更多..._](./literals.md#booleans)"

#: src/reference/syntax/keywords.md:101
msgid "**`false`** - boolean [_more..._](./literals.md#booleans)"
msgstr "**`false`** - 布林值 [_更多..._](./literals.md#booleans)"

#: src/reference/syntax/keywords.md:102
msgid "**`null`** - NULL [_more..._](./literals.md#null)"
msgstr "**`null`** - 空值 [_更多..._](./literals.md#null)"

#: src/reference/syntax/keywords.md:104
msgid ""
"Keywords can be used as identifiers (of columns or variables) when encased "
"in backticks: `` `case` ``."
msgstr "關鍵字可以用作識別符（欄位或變數），當被反引號括起來時：`` `case` ``。"

#: src/reference/syntax/keywords.md:107
msgid ""
"Transforms are normal functions within the `std` namespace, not keywords. "
"That is, `std.from` is the same function as `from`. In the example below, "
"the resulting query is the same as without the `std.` namespace:"
msgstr ""
"轉換是 `std` 命名空間中的普通函式，不是關鍵字。也就是說，`std.from` 與 "
"`from` 是相同的函式。在下面的範例中，產生的查詢與沒有 `std.` 命名空間時相同："

#: src/reference/syntax/literals.md:1
msgid "Literals"
msgstr "字面值"

#: src/reference/syntax/literals.md:3
msgid ""
"A literal is a constant value expression, with special syntax rules for each "
"data type."
msgstr "字面值是一個常數值表達式，每種資料型別都有特殊的語法規則。"

#: src/reference/syntax/literals.md:6
msgid "Numbers"
msgstr "數字"

#: src/reference/syntax/literals.md:8
msgid ""
"Number literals can contain number characters as well as a period, "
"underscores and char `e`."
msgstr "數字字面值可以包含數字字元以及句號、底線和字元 `e`。"

#: src/reference/syntax/literals.md:11
msgid ""
"If a number literal contains a dot or character `e`, it is treated as "
"floating point number (or just _float_), otherwise it is treated as integer "
"number."
msgstr ""
"如果數字字面值包含點或字元 `e`，則將其視為浮點數（或稱為 _float_），否則將其"
"視為整數。"

#: src/reference/syntax/literals.md:14
msgid ""
"Character `e` denotes [\"scientific notation\"](https://en.wikipedia.org/"
"wiki/Scientific_notation), where the number after `e` is the exponent in 10-"
"base."
msgstr ""
"字元 `e` 表示[\"科學記數法\"](https://en.wikipedia.org/wiki/"
"Scientific_notation)，其中 `e` 後面的數字是以 10 為基數的指數。"

#: src/reference/syntax/literals.md:18
msgid ""
"Underscores are ignored, so they can be placed at arbitrary positions, but "
"it is advised to use them as thousand separators."
msgstr "底線被忽略，所以它們可以放在任意位置，但建議將它們用作千位分隔符。"

#: src/reference/syntax/literals.md:21
msgid ""
"Integers can, alternatively, be expressed using hexadecimal, octal or binary "
"notation using these prefixes respectively: `0x`, `0o` or `0b`."
msgstr ""
"整數也可以使用十六進位、八進位或二進位表示法分別用這些前綴表示：`0x`、`0o` "
"或 `0b`。"

#: src/reference/syntax/literals.md:36
msgid "Strings"
msgstr "字串"

#: src/reference/syntax/literals.md:38
msgid ""
"PRQL supports string literals and several other formats of strings. See the "
"[Strings](./strings.md) page for more information."
msgstr ""
"PRQL 支援字串字面值和多種其他字串格式。如需詳細資訊，請參閱[字串](./strings."
"md)頁面。"

#: src/reference/syntax/literals.md:41
msgid "Booleans"
msgstr "布林值"

#: src/reference/syntax/literals.md:43
msgid "Boolean values can be expressed with `true` or `false` keyword."
msgstr "布林值可以用 `true` 或 `false` 關鍵字表示。"

#: src/reference/syntax/literals.md:45
msgid "Null"
msgstr "空值"

#: src/reference/syntax/literals.md:47
msgid ""
"The null value can be expressed with `null` keyword. See also the discussion "
"of how [PRQL handles nulls](../spec/null.md)."
msgstr ""
"空值可以用 `null` 關鍵字表示。另請參閱 [PRQL 如何處理空值](../spec/null.md)的"
"討論。"

#: src/reference/syntax/literals.md:50
msgid "Date and time"
msgstr "日期和時間"

#: src/reference/syntax/literals.md:52
msgid ""
"Date and time literals are expressed with character `@`, followed by a "
"string that encodes the date & time."
msgstr "日期和時間字面值用字元 `@` 表示，後面跟著編碼日期和時間的字串。"

#: src/reference/syntax/literals.md:56
msgid ""
"\\[!NOTE\\] PRQL's notation is designed to be less verbose than SQL's "
"`TIMESTAMP '2004-10-19 10:23:54'` and more explicit than SQL's implicit "
"option that just uses a string `'2004-10-19 10:23:54'`."
msgstr ""
"\\[!NOTE\\] PRQL 的表示法旨在比 SQL 的 `TIMESTAMP '2004-10-19 10:23:54'` 更簡"
"潔，比 SQL 隱含地使用字串 `'2004-10-19 10:23:54'` 的選項更明確。"

#: src/reference/syntax/literals.md:61
msgid "Dates"
msgstr "日期"

#: src/reference/syntax/literals.md:63
msgid ""
"Dates are represented by `@{yyyy-mm-dd}` — a `@` followed by the date format."
msgstr "日期由 `@{yyyy-mm-dd}` 表示 — `@` 後面跟著日期格式。"

#: src/reference/syntax/literals.md:70
msgid "Times"
msgstr "時間"

#: src/reference/syntax/literals.md:72
msgid ""
"Times are represented by `@{HH:mm:ss.SSS±Z}` with any parts not supplied "
"defaulting to zero. This includes the timezone, which is represented by `+HH:"
"mm`, `-HH:mm` or `Z`. This is consistent with the ISO8601 time format."
msgstr ""
"時間由 `@{HH:mm:ss.SSS±Z}` 表示，任何未提供的部分預設為零。這包括由 `+HH:"
"mm`、`-HH:mm` 或 `Z` 表示的時區。這符合 ISO8601 時間格式。"

#: src/reference/syntax/literals.md:81
msgid "Timestamps"
msgstr "時間戳記"

#: src/reference/syntax/literals.md:83
msgid ""
"Timestamps are represented by `@{yyyy-mm-ddTHH:mm:ss.SSS±Z}` / `@{date}"
"T{time}`, with any time parts not supplied being rounded to zero, including "
"the timezone, which is represented by `+HH:mm`, `-HH:mm` or `Z` (`:` is "
"optional). This is `@` followed by the ISO8601 datetime format, which uses "
"`T` to separate date & time."
msgstr ""
"\"\"時間戳記由 `@{yyyy-mm-ddTHH:mm:ss.SSS±Z}` / `@{date}T{time}` 表示，任何未"
"提供的時間部分被四捨五入為零，包括由 `+HH:mm`、`-HH:mm` 或 `Z`（`:` 是可選"
"的）表示的時區。這是 `@` 後面跟著 ISO8601 日期時間格式，該格式使用 `T` 分隔日"
"期和時間。"

#: src/reference/syntax/literals.md:94
msgid "Durations"
msgstr "持續時間"

#: src/reference/syntax/literals.md:96
msgid ""
"Durations are represented by `{N}{periods}`, such as `2years` or "
"`10minutes`, without a space."
msgstr ""
"持續時間由 `{N}{periods}` 表示，例如 `2years` 或 `10minutes`，中間沒有空格。"

#: src/reference/syntax/literals.md:100
msgid ""
"\\[!NOTE\\] These aren't the same as ISO8601, because we evaluated "
"`P3Y6M4DT12H30M5S` to be difficult to understand, but we could support a "
"simplified form if there's demand for it. We don't currently support "
"compound expressions, for example `2years10months`, but most DBs will allow "
"`2years + 10months`. Please raise an issue if this is inconvenient."
msgstr ""
"\\[!NOTE\\] 這些與 ISO8601 不同，因為我們認為 `P3Y6M4DT12H30M5S` 難以理解，但"
"如果有需求，我們可以支援簡化形式。我們目前不支援複合表達式，例如 "
"`2years10months`，但大多數資料庫允許 `2years + 10months`。如果不方便，請提出"
"問題。"

#: src/reference/syntax/literals.md:114
msgid "Here's a larger list of date and time examples:"
msgstr "以下是日期和時間範例的較大列表："

#: src/reference/syntax/literals.md:116
msgid ""
"`@20221231` is invalid — it must contain full punctuation (`-` and `:`),"
msgstr "`@20221231` 無效 — 它必須包含完整的標點符號（`-` 和 `:`），"

#: src/reference/syntax/literals.md:117
msgid "`@2022-12-31` is a date"
msgstr "`@2022-12-31` 是日期"

#: src/reference/syntax/literals.md:118
msgid ""
"`@2022-12` or `@2022` are invalid — SQL can't express a month, only a date"
msgstr "`@2022-12` 或 `@2022` 無效 — SQL 無法表達月份，只能表達日期"

#: src/reference/syntax/literals.md:119
msgid "`@16:54:32.123456` is a time"
msgstr "`@16:54:32.123456` 是時間"

#: src/reference/syntax/literals.md:120
msgid ""
"`@16:54:32`, `@16:54`, `@16` are all allowed, expressing `@16:54:32.000000`, "
"`@16:54:00.000000`, `@16:00:00.000000` respectively"
msgstr ""
"`@16:54:32`、`@16:54`、`@16` 都是允許的，分別表示 `@16:54:32.000000`、"
"`@16:54:00.000000`、`@16:00:00.000000`"

#: src/reference/syntax/literals.md:122
msgid "`@2022-12-31T16:54:32.123456` is a timestamp without timezone"
msgstr "`@2022-12-31T16:54:32.123456` 是沒有時區的時間戳記"

#: src/reference/syntax/literals.md:123
msgid "`@2022-12-31T16:54:32.123456Z` is a timestamp in UTC"
msgstr "`@2022-12-31T16:54:32.123456Z` 是 UTC 時區的時間戳記"

#: src/reference/syntax/literals.md:124
msgid "`@2022-12-31T16:54+02` is timestamp in UTC+2"
msgstr "`@2022-12-31T16:54+02` 是 UTC+2 時區的時間戳記"

#: src/reference/syntax/literals.md:125
msgid ""
"`@2022-12-31T16:54+02:00` and `@2022-12-31T16:54+02` are datetimes in UTC+2"
msgstr ""
"`@2022-12-31T16:54+02:00` 和 `@2022-12-31T16:54+02` 是 UTC+2 時區的日期時間"

#: src/reference/syntax/literals.md:126
msgid ""
"`@16:54+02` is invalid — time is always local, so it cannot have a timezone"
msgstr "`@16:54+02` 無效 — 時間總是本地的，所以它不能有時區"

#: src/reference/syntax/literals.md:127
msgid ""
"`@2022-12-31+02` is invalid — date is always local, so it cannot have a "
"timezone"
msgstr "`@2022-12-31+02` 無效 — 日期總是本地的，所以它不能有時區"

#: src/reference/syntax/literals.md:131
msgid ""
"\\[!NOTE\\] Currently prqlc does not parse or validate any of the datetime "
"strings and will pass them to the database engine without adjustment. This "
"might be refined in the future to aid in compatibility across databases. "
"We'll always support the canonical [ISO8601](https://en.wikipedia.org/wiki/"
"ISO_8601) format described above."
msgstr ""
"\\[!NOTE\\] 目前 prqlc 不解析或驗證任何日期時間字串，它將按原樣傳遞給資料庫引"
"擎。這在未來可能會改進，以幫助跨資料庫的相容性。我們將始終支援上述規範的 "
"[ISO8601](https://en.wikipedia.org/wiki/ISO_8601) 格式。"

#: src/reference/syntax/literals.md:138
msgid "Roadmap"
msgstr "路線圖"

#: src/reference/syntax/literals.md:140
msgid ""
"Datetimes (as a distinct datatype from the timestamps) are supported by some "
"databases (e.g. MySql, BigQuery). With the addition of type casts, these "
"could be represented by a timestamp cast to a datetime:"
msgstr ""
"日期時間（作為與時間戳記不同的資料型別）受某些資料庫支援（例如 MySql、"
"BigQuery）。通過添加型別轉換，這些可以通過將時間戳記轉換為日期時間來表示："

#: src/reference/syntax/literals.md:148
msgid "These are some examples we can then add:"
msgstr "以下是我們可以添加的一些範例："

#: src/reference/syntax/literals.md:150
msgid "`@2022-12-31T16:54<datetime>` is datetime without timezone"
msgstr ""

#: src/reference/syntax/literals.md:151
msgid "`@2022-12-31<datetime>` is forbidden — datetime must specify time"
msgstr ""

#: src/reference/syntax/literals.md:152
msgid "`@16:54<datetime>` is forbidden — datetime must specify date"
msgstr ""

#: src/reference/syntax/operators.md:1 src/reference/syntax/operators.md:24
msgid "Operators"
msgstr "運算子"

#: src/reference/syntax/operators.md:3
msgid ""
"Expressions can be composed from _function calls_ and _operations_, such as "
"`2 + 3` or `((1 + x) * -y)`. In the example below, note the use of "
"expressions to calculate the alias `circumference` and in the `filter` "
"transform."
msgstr ""
"表達式可以由 _函式呼叫_ 和 _運算_ 組成，例如 `2 + 3` 或 `((1 + x) * -y)`。在"
"下方的範例中，請注意使用表達式計算別名 `circumference` 和在 `filter` 轉換中的"
"用法。"

#: src/reference/syntax/operators.md:7
msgid ""
"```prql\n"
"from foo\n"
"select {\n"
"  circumference = diameter * 3.14159,\n"
"  area = (diameter / 2) ** 2,\n"
"  color,\n"
"}\n"
"filter circumference > 10 && color != \"red\"\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:17
msgid "Operator precedence"
msgstr "運算子優先級"

#: src/reference/syntax/operators.md:19
msgid ""
"This table shows operator precedence. Use parentheses `()` to prioritize "
"operations and for function calls (see the discussion below.)"
msgstr ""
"此表顯示運算子優先級。使用括號 `()` 優先順序排列運算和函式呼叫（參閱下面的討"
"論。）"

#: src/reference/syntax/operators.md:24
msgid "Precedence"
msgstr "優先級"

#: src/reference/syntax/operators.md:24
msgid "Associativity"
msgstr "結合性"

#: src/reference/syntax/operators.md:26
msgid "parentheses"
msgstr "括號"

#: src/reference/syntax/operators.md:26
msgid "0"
msgstr ""

#: src/reference/syntax/operators.md:26
msgid "see below"
msgstr "見下文"

#: src/reference/syntax/operators.md:27
msgid "identifier dot"
msgstr "識別符點"

#: src/reference/syntax/operators.md:27
msgid "`.`"
msgstr ""

#: src/reference/syntax/operators.md:28
msgid "unary"
msgstr "一元"

#: src/reference/syntax/operators.md:28
msgid "`-` `+` `!` `==`"
msgstr ""

#: src/reference/syntax/operators.md:29
msgid "range"
msgstr "範圍"

#: src/reference/syntax/operators.md:29
msgid "`..`"
msgstr ""

#: src/reference/syntax/operators.md:30
msgid "`**`"
msgstr ""

#: src/reference/syntax/operators.md:30
msgid "right-to-left"
msgstr "右至左"

#: src/reference/syntax/operators.md:31
msgid "mul"
msgstr "乘法"

#: src/reference/syntax/operators.md:31
msgid "`*` `/` `//` `%`"
msgstr ""

#: src/reference/syntax/operators.md:31
msgid "5"
msgstr ""

#: src/reference/syntax/operators.md:31 src/reference/syntax/operators.md:32
#: src/reference/syntax/operators.md:33 src/reference/syntax/operators.md:34
#: src/reference/syntax/operators.md:35 src/reference/syntax/operators.md:36
msgid "left-to-right"
msgstr "左至右"

#: src/reference/syntax/operators.md:32
msgid "add"
msgstr "加法"

#: src/reference/syntax/operators.md:32
msgid "`+` `-`"
msgstr ""

#: src/reference/syntax/operators.md:32
msgid "6"
msgstr ""

#: src/reference/syntax/operators.md:33
msgid "compare"
msgstr "比較"

#: src/reference/syntax/operators.md:33
msgid "`==` `!=` `<=` `>=` `<` `>`"
msgstr ""

#: src/reference/syntax/operators.md:34
msgid "coalesce"
msgstr "合併"

#: src/reference/syntax/operators.md:35
msgid "`&&`"
msgstr ""

#: src/reference/syntax/operators.md:36
msgid "or"
msgstr "或"

#: src/reference/syntax/operators.md:36
msgid "<code>\\|\\|</code>"
msgstr "<code>\\|\\</code>"

#: src/reference/syntax/operators.md:36
msgid "10"
msgstr ""

#: src/reference/syntax/operators.md:37
msgid "function call"
msgstr "函式呼叫"

#: src/reference/syntax/operators.md:39
msgid "Division and integer division"
msgstr "除法和整數除法"

#: src/reference/syntax/operators.md:41
msgid ""
"The `/` operator performs division that always returns a float value, while "
"the `//` operator does integer division (truncated division) that always "
"returns an integer value."
msgstr ""
"`/` 運算子執行總是返回浮點值的除法，而 `//` 運算子執行整數除法（截斷除法），"
"總是返回整數值。"

#: src/reference/syntax/operators.md:45
msgid ""
"```prql\n"
"prql target:sql.sqlite\n"
"\n"
"from [\n"
"  {a = 5, b = 2},\n"
"  {a = 5, b = -2},\n"
"]\n"
"select {\n"
"  div_out = a / b,\n"
"  int_div_out = a // b,\n"
"}\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:58
msgid "Coalesce"
msgstr "合併"

#: src/reference/syntax/operators.md:60
msgid ""
"We can coalesce values with an `??` operator. Coalescing takes either the "
"first value or, if that value is null, the second value."
msgstr ""
"我們可以使用 `??` 運算子合併值。合併會取第一個值，或者如果該值為空，則取第二"
"個值。"

#: src/reference/syntax/operators.md:68
msgid "Regex expressions"
msgstr "常規表達式"

#: src/reference/syntax/operators.md:71
msgid "\\[!NOTE\\] This is currently experimental"
msgstr "\\[!注意\\] 這目前是實驗性的"

#: src/reference/syntax/operators.md:74
msgid ""
"To perform a case-sensitive regex search, use the `~=` operator. This "
"generally compiles to `REGEXP`, though differs by dialect. A regex search "
"means that to match an exact value, the start and end need to be anchored "
"with `^foo$`."
msgstr ""
"要執行區分大小寫的常規表達式搜索，請使用 `~=` 運算子。這通常編譯為 `REGEXP`，"
"儘管因方言而異。常規表達式搜索意味著要匹配確切的值，開始和結束需要用 `^foo$` "
"錨定。"

#: src/reference/syntax/operators.md:78
msgid ""
"```prql\n"
"from tracks\n"
"filter (name ~= \"Love\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:83
msgid ""
"```prql\n"
"prql target:sql.duckdb\n"
"\n"
"from artists\n"
"filter (name ~= \"Love.*You\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:90
msgid ""
"```prql\n"
"prql target:sql.bigquery\n"
"\n"
"from tracks\n"
"filter (name ~= \"\\\\bLove\\\\b\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:97
msgid ""
"```prql\n"
"prql target:sql.postgres\n"
"\n"
"from tracks\n"
"filter (name ~= \"\\\\(I Can't Help\\\\) Falling\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:104
msgid ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from tracks\n"
"filter (name ~= \"With You\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:111
msgid ""
"```prql\n"
"prql target:sql.sqlite\n"
"\n"
"from tracks\n"
"filter (name ~= \"But Why Isn't Your Syntax More Similar\\\\?\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:118
msgid "Parentheses"
msgstr "括號"

#: src/reference/syntax/operators.md:120
msgid "PRQL uses parentheses `()` for several purposes:"
msgstr "PRQL 使用括號 `()` 有幾個目的："

#: src/reference/syntax/operators.md:122
msgid ""
"Parentheses group operands to control the order of evaluation, for example: "
"`((1 + x) * y)`"
msgstr "括號對操作數進行分組以控制評估順序，例如：`((1 + x) * y)`"

#: src/reference/syntax/operators.md:125
msgid ""
"Parentheses delimit a minus sign of a function argument, for example: `add "
"(-1) (-3)`"
msgstr "括號用於分隔函式引數的減號，例如：`add (-1) (-3)`"

#: src/reference/syntax/operators.md:128
msgid ""
"Parentheses delimit nested function calls that contain a pipe, either the `|"
"` symbol or a new line. “Nested” means within a transform; i.e. not just the "
"main pipeline, for example: `(column-name | in 0..20)`"
msgstr ""
"\"\"括號用於分隔包含管道的嵌套函式呼叫，可以是 `|` 符號或新行。\"嵌套\"是指在"
"轉換中；即不僅僅是主管道，例如：`(column-name | in 0..20)`"

#: src/reference/syntax/operators.md:132
msgid ""
"Parentheses wrap a function call that is part of a larger expression, for "
"example: `math.round 0 (sum distance)`"
msgstr ""
"括號包裹作為較大表達式一部分的函式呼叫，例如：`math.round 0 (sum distance)`"

#: src/reference/syntax/operators.md:135
msgid ""
"Parentheses are _not_ required for expressions that do not contain function "
"calls, for example: `foo + bar`."
msgstr "括號對於不包含函式呼叫的表達式**不是**必需的，例如：`foo + bar`。"

#: src/reference/syntax/operators.md:138
msgid "Here's a set of examples of these rules:"
msgstr "以下是這些規則的一組範例："

#: src/reference/syntax/operators.md:171
msgid ""
"For example, the snippet below produces an error because the `sum` function "
"call is not in a tuple."
msgstr "例如，下面的代碼片段產生錯誤，因為 `sum` 函式呼叫不在元組中。"

#: src/reference/syntax/operators.md:179
msgid "...while with parentheses, it works at expected:"
msgstr "...而使用括號，它可以按預期工作："

#: src/reference/syntax/operators.md:187
msgid ""
"\\[!NOTE\\] We're continuing to think whether these rules can be more "
"intuitive. We're also planning to make the error messages much better, so "
"the compiler can help out."
msgstr ""
"\\[!注意\\] 我們繼續思考這些規則是否可以更直觀。我們也計畫使錯誤訊息好得多，"
"以便編譯器可以幫助。"

#: src/reference/syntax/operators.md:192
msgid "Wrapping lines"
msgstr "換行"

#: src/reference/syntax/operators.md:194
msgid ""
"Line breaks in PRQL have semantic meaning, so to wrap a single logical line "
"into multiple physical lines, we can use `\\` at the beginning of subsequent "
"physical lines:"
msgstr ""
"PRQL 中的換行有語義含義，所以要將單個邏輯行換行為多個物理行，我們可以在後續物"
"理行的開始處使用 `\\`："

#: src/reference/syntax/operators.md:198
msgid ""
"```prql\n"
"from artists\n"
"select is_europe =\n"
"\\ country == \"DE\"\n"
"\\ || country == \"FR\"\n"
"\\ || country == \"ES\"\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:206
msgid ""
"Wrapping will \"jump over\" empty lines or lines with comments. For example, "
"the `select` here is only one logical line:"
msgstr ""
"換行會\"跳過\"空行或包含註解的行。例如，這裡的 `select` 只是一個邏輯行："

#: src/reference/syntax/operators.md:221
msgid ""
"\\[!NOTE\\] Note that PRQL differs from most languages, which use a `\\` at "
"the _end_ of the preceding line. Because PRQL aims to be friendly for data "
"exploration, we want to make it possible to comment out any line, including "
"the final line, without breaking the query. This requires all lines after "
"the first to be structured similarly, and for the character to be at the "
"start of each following line."
msgstr ""
"\\[!注意\\] 注意 PRQL 與大多數語言不同，大多數語言在前一行的**末尾**使用 "
"`\\`。由於 PRQL 旨在友好地進行數據探索，我們希望可以註解掉任何行，包括最後一"
"行，而不破壞查詢。這要求第一行之後的所有行的結構相似，並且字符位於每個後續行"
"的開始。"

#: src/reference/syntax/operators.md:229
msgid "See [Pipes](./pipes.md) for more details on line breaks."
msgstr "有關換行的更多詳細資訊，請參閱 [Pipes](./pipes.md)。"

#: src/reference/syntax/parameters.md:3
msgid ""
"Parameter is a placeholder for a value provided after the compilation of the "
"query."
msgstr "參數是查詢編譯後提供的值的佔位符。"

#: src/reference/syntax/parameters.md:6
msgid ""
"It uses the following syntax: `$id`, where `id` is an arbitrary alpha "
"numeric string."
msgstr "它使用以下語法：`$id`，其中 `id` 是任意英數字元字串。"

#: src/reference/syntax/parameters.md:9
msgid ""
"Most database engines only support numeric positional parameter ids (i.e "
"`$3`)."
msgstr "大多數資料庫引擎只支援數字位置參數 ID（例如 `$3`）。"

#: src/reference/syntax/pipes.md:1
msgid "Pipes"
msgstr "管道"

#: src/reference/syntax/pipes.md:3
msgid ""
"Pipes are the connection between [transforms](../stdlib/transforms/) that "
"make up a pipeline. The relation produced by a transform before the pipe is "
"used as the input for the transform following the pipe. A pipe can be "
"represented with either a line break or a pipe character (`|`)."
msgstr ""
"管道是組成管道的[轉換](../stdlib/transforms/)之間的連接。管道前的轉換所產生的"
"關聯用作管道後轉換的輸入。管道可以用換行符或管道字元 (`|`) 表示。"

#: src/reference/syntax/pipes.md:8
msgid ""
"For example, here the `filter` transform operates on the result of `from "
"employees` (which is just the `employees` table), and the `select` transform "
"operates on the result of the `filter` transform."
msgstr ""
"例如，這裡 `filter` 轉換對 `from employees`（這只是 `employees` 表格）的結果"
"進行操作，`select` 轉換對 `filter` 轉換的結果進行操作。"

#: src/reference/syntax/pipes.md:12
msgid ""
"```prql\n"
"from employees\n"
"filter department == \"Product\"\n"
"select {first_name, last_name}\n"
"```"
msgstr ""

#: src/reference/syntax/pipes.md:18
msgid ""
"In the place of a line break, it's also possible to use the `|` character to "
"pipe results between transforms, such that this is equivalent:"
msgstr "用 `|` 字元代替換行符號，在轉換之間進行管道化結果，這樣就是等效的："

#: src/reference/syntax/pipes.md:21
msgid ""
"```prql\n"
"from employees | filter department == \"Product\" | select {first_name, "
"last_name}\n"
"```"
msgstr ""

#: src/reference/syntax/pipes.md:25
msgid "\"Ceci n'est pas une pipe\""
msgstr "\"這不是管道\""

#: src/reference/syntax/pipes.md:27
msgid ""
"In almost all situations, a line break acts as a pipe. But there are a few "
"cases where a line break doesn't act as a pipe."
msgstr ""
"在幾乎所有情況下，換行符都起管道作用。但在某些情況下，換行符不起管道作用。"

#: src/reference/syntax/pipes.md:30
msgid "before or after tuple items"
msgstr "在元組項目之前或之後"

#: src/reference/syntax/pipes.md:31
msgid "before or after list items"
msgstr "在列表項目之前或之後"

#: src/reference/syntax/pipes.md:32
msgid "before a new statement, which starts with `let` or `from` (or `func`)"
msgstr "在新陳述句之前，它以 `let` 或 `from`（或 `func`）開頭"

#: src/reference/syntax/pipes.md:33
msgid "within a [line wrap](./operators.md#wrapping-lines)"
msgstr "在[換行](./operators.md#wrapping-lines)中"

#: src/reference/syntax/pipes.md:35
msgid "For example:"
msgstr ""

#: src/reference/syntax/pipes.md:56
msgid "Inner Transforms"
msgstr ""

#: src/reference/syntax/pipes.md:60
msgid ""
"Parentheses are also used for transforms (such as `group` and `window`) that "
"pass their result to an \"inner transform\". The example below applies the "
"`aggregate` pipeline to each group of unique `title` and `country` values:"
msgstr ""

#: src/reference/syntax/ranges.md:1
msgid "Ranges"
msgstr "範圍"

#: src/reference/syntax/ranges.md:3
msgid ""
"Range `start..end` represents as set of values between `start` and `end`, "
"inclusive (greater of equal to `start` and less than or equal to `end`)."
msgstr ""
"範圍 `start..end` 表示 `start` 和 `end` 之間的一組值（含括，大於等於 `start` "
"且小於等於 `end`）。"

#: src/reference/syntax/ranges.md:6
msgid ""
"To express a range that is open on one side, either `start` or `end` can be "
"omitted."
msgstr "若要表示在一側開放的範圍，可以省略 `start` 或 `end`。"

#: src/reference/syntax/ranges.md:9
msgid ""
"Ranges can be used in filters with the `in` function, with any type of "
"literal, including dates:"
msgstr "範圍可以在 `in` 函式的篩選器中使用，具有任何型別的字面值，包括日期："

#: src/reference/syntax/ranges.md:19
msgid "Ranges can also be used in `take`:"
msgstr "範圍也可以在 `take` 中使用："

#: src/reference/syntax/ranges.md:28
msgid ""
"\\[!NOTE\\] Half-open ranges are generally less intuitive to read than a "
"simple `>=` or `<=` operator."
msgstr "\\[!NOTE\\] 半開式範圍通常不如簡單的 `>=` 或 `<=` 運算子那樣直觀易讀。"

#: src/reference/syntax/ranges.md:34
msgid "[take transform](../stdlib/transforms/take.md)"
msgstr "[take 變換](../stdlib/transforms/take.md)"

#: src/reference/syntax/ranges.md:38
msgid ""
"We'd like to use ranges for other types, such as whether an object is in an "
"array or list literal."
msgstr "我們想將範圍用於其他型別，例如物件是否在陣列或列表字面值中。"

#: src/reference/syntax/strings.md:3
msgid ""
"String literals can use any matching odd number of either single or double "
"quotes:"
msgstr "字串字面值可以使用任何匹配的奇數個單引號或雙引號："

#: src/reference/syntax/strings.md:6
msgid ""
"```prql\n"
"from artists\n"
"derive {\n"
"  single        =   'hello world',\n"
"  double        =   \"hello world\",\n"
"  double_triple = \"\"\"hello world\"\"\",\n"
"}\n"
"```"
msgstr ""
"```prql\n"
"from artists\n"
"derive {\n"
"  single        =   'hello world',\n"
"  double        =   \"hello world\",\n"
"  double_triple = \"\"\"hello world\"\"\",\n"
"}\n"
"```"

#: src/reference/syntax/strings.md:15
msgid "Quoting and escape characters"
msgstr "引用和轉義字元"

#: src/reference/syntax/strings.md:17
msgid ""
"To quote a string containing quote characters, use the \"other\" type of "
"quote, or use the escape character `\\`, or use more quotes."
msgstr ""
"要引用包含引號字元的字串，使用「其他」型別的引號，或使用轉義字元 `\\`，或使用"
"更多引號。"

#: src/reference/syntax/strings.md:20
msgid ""
"```prql\n"
"from artists\n"
"select {\n"
"  other   = '\"hello world\"',\n"
"  escaped = \"\\\"hello world\\\"\",\n"
"  triple  = \"\"\"I said \"hello world\"!\"\"\",\n"
"}\n"
"```"
msgstr ""

#: src/reference/syntax/strings.md:29
msgid ""
"Strings can contain any escape character sequences defined by the [JSON "
"standard](https://www.ecma-international.org/publications-and-standards/"
"standards/ecma-404/)."
msgstr ""
"字串可以包含 [JSON 標準](https://www.ecma-international.org/publications-and-"
"standards/standards/ecma-404/)定義的任何轉義字元序列。"

#: src/reference/syntax/strings.md:32
msgid ""
"```prql\n"
"from artists\n"
"derive escapes = \"\\tXYZ\\n \\\\ \"                            # tab (\\t), "
"\"XYZ\", newline (\\n), \" \", \\, \" \"\n"
"derive world = \"\\u{0048}\\u{0065}\\u{006C}\\u{006C}\\u{006F}\" # "
"\"Hello\"\n"
"derive hex = \"\\x48\\x65\\x6C\\x6C\\x6F\"                       # "
"\"Hello\"\n"
"derive turtle = \"\\u{01F422}\"                              # \"🐢\"\n"
"```"
msgstr ""

#: src/reference/syntax/strings.md:40
msgid "Other string formats"
msgstr "其他字串格式"

#: src/reference/syntax/strings.md:42
msgid ""
"[**F-strings**](./f-strings.md) - Build up a new string from a set of "
"columns or values."
msgstr "[**F-字串**](./f-strings.md) - 從一組欄位或值建立新字串。"

#: src/reference/syntax/strings.md:44
msgid ""
"[**R-strings**](./r-strings.md) - Include the raw characters of the string "
"without any form of escaping."
msgstr "[**R-字串**](./r-strings.md) - 不含任何形式轉義的字串的原始字元。"

#: src/reference/syntax/strings.md:46
msgid ""
"[**S-strings**](./s-strings.md) - Insert SQL statements directly into the "
"query. Use when PRQL doesn't have an equivalent facility."
msgstr ""
"[**S-字串**](./s-strings.md) - 將 SQL 陳述句直接插入查詢。在 PRQL 沒有等效工"
"具時使用。"

#: src/reference/syntax/strings.md:51
msgid ""
"\\[!WARNING\\] Currently PRQL allows multiline strings with either a single "
"character or multiple character quotes. This may change for strings using a "
"single character quote in future versions."
msgstr ""
"\\[!WARNING\\] 目前 PRQL 允許使用單一字元或多個字元引號的多行字串。在未來版本"
"中，使用單一字元引號的字串可能會改變。"

#: src/reference/syntax/strings.md:58
msgid ""
"\\[!NOTE\\] These escape rules specify how PRQL interprets escape characters "
"when compiling strings to SQL, not necessarily how the database will "
"interpret the string. Dialects interpret escape characters differently, and "
"PRQL doesn't currently account for these differences. Please open issues "
"with any difficulties in the current implementation."
msgstr ""
"\\[!NOTE\\] 這些轉義規則指定 PRQL 在將字串編譯為 SQL 時如何解釋轉義字元，不一"
"定是資料庫如何解釋字串。方言解釋轉義字元的方式不同，PRQL 目前不考慮這些差異。"
"如對目前實現有任何困難，請提出問題。"

#: src/reference/syntax/strings.md:65
msgid "Escape sequences"
msgstr "轉義序列"

#: src/reference/syntax/strings.md:67
msgid ""
"Unless an `r` prefix is present, escape sequences in string literals are "
"interpreted according to rules similar to those used by Standard C. The "
"recognized escape sequences are:"
msgstr ""
"除非存在 `r` 前綴，否則字串字面值中的轉義序列將按照類似於標準 C 所使用的規則"
"進行解釋。公認的轉義序列是："

#: src/reference/syntax/strings.md:71
msgid "Escape Sequence"
msgstr "轉義序列"

#: src/reference/syntax/strings.md:73
msgid "`\\\\`"
msgstr ""

#: src/reference/syntax/strings.md:73
msgid "Backslash ()"
msgstr "反斜線（）"

#: src/reference/syntax/strings.md:74
msgid "`\\'`"
msgstr ""

#: src/reference/syntax/strings.md:74
msgid "Single quote (')"
msgstr "單引號（'）"

#: src/reference/syntax/strings.md:75
msgid "`\\\"`"
msgstr ""

#: src/reference/syntax/strings.md:75
msgid "Double quote (\")"
msgstr "雙引號（\"）"

#: src/reference/syntax/strings.md:76
msgid "`\\b`"
msgstr ""

#: src/reference/syntax/strings.md:76
msgid "Backspace"
msgstr "退格"

#: src/reference/syntax/strings.md:77
msgid "`\\f`"
msgstr ""

#: src/reference/syntax/strings.md:77
msgid "Formfeed"
msgstr "分頁符"

#: src/reference/syntax/strings.md:78
msgid "`\\n`"
msgstr ""

#: src/reference/syntax/strings.md:78
msgid "ASCII Linefeed (LF)"
msgstr "ASCII 換行符 (LF)"

#: src/reference/syntax/strings.md:79
msgid "`\\r`"
msgstr ""

#: src/reference/syntax/strings.md:79
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII 回車符 (CR)"

#: src/reference/syntax/strings.md:80
msgid "`\\t`"
msgstr ""

#: src/reference/syntax/strings.md:80
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII 水平製表符 (TAB)"

#: src/reference/syntax/strings.md:81
msgid "`\\xhh`"
msgstr ""

#: src/reference/syntax/strings.md:81
msgid "Character with hex value hh"
msgstr "十六進位值為 hh 的字元"

#: src/reference/syntax/strings.md:82
msgid "`\\u{xxxx}`"
msgstr ""

#: src/reference/syntax/strings.md:82
msgid "Character with hex value xxxx"
msgstr "十六進位值為 xxxx 的字元"

#: src/reference/syntax/f-strings.md:1
msgid "F-strings"
msgstr "F-字串"

#: src/reference/syntax/f-strings.md:3
msgid ""
"F-strings are a readable approach to building new strings from existing "
"strings & variables."
msgstr ""

#: src/reference/syntax/f-strings.md:6
msgid ""
"```prql\n"
"from employees\n"
"select full_name = f\"{first_name} {last_name}\"\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"select full_name = f\"{first_name} {last_name}\"\n"
"```"

#: src/reference/syntax/f-strings.md:11
msgid ""
"This can be much easier to read for longer strings, relative to the SQL "
"approach:"
msgstr ""

#: src/reference/syntax/f-strings.md:14
msgid ""
"```prql\n"
"from web\n"
"select url = f\"http{tls}://www.{domain}.{tld}/{page}\"\n"
"```"
msgstr ""
"```prql\n"
"from web\n"
"select url = f\"http{tls}://www.{domain}.{tld}/{page}\"\n"
"```"

#: src/reference/syntax/f-strings.md:19
msgid ""
"Note that currently interpolations can only contain plain variable names and "
"not whole expressions like Python, so this won't work:"
msgstr ""

#: src/reference/syntax/f-strings.md:22
msgid ""
"```prql error no-fmt\n"
"from tracks\n"
"select length_str = f\"{length_seconds / 60} minutes\"\n"
"```"
msgstr ""
"```prql error no-fmt\n"
"from tracks\n"
"select length_str = f\"{length_seconds / 60} minutes\"\n"
"```"

#: src/reference/syntax/f-strings.md:29
msgid ""
"In the future, f-strings may incorporate string formatting such as "
"datetimes, numbers, and padding. If there's a feature that would be helpful, "
"please [post an issue](https://github.com/PRQL/prql/issues/new/)."
msgstr ""

#: src/reference/syntax/r-strings.md:1
msgid "R-strings"
msgstr "R-字串"

#: src/reference/syntax/r-strings.md:3
msgid "R-strings handle escape characters without special treatment:"
msgstr ""

#: src/reference/syntax/r-strings.md:5
msgid ""
"```prql\n"
"from artists\n"
"derive normal_string =  \"\\\\\\t\"   #  two characters - \\ and tab (\\t)\n"
"derive raw_string    = r\"\\\\\\t\"   # four characters - \\, \\, \\, and t\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:1
msgid "S-strings"
msgstr "S-字串"

#: src/reference/syntax/s-strings.md:3
msgid ""
"An s-string inserts SQL directly, as an escape hatch when there's something "
"that PRQL doesn't yet implement. For example, there's a `version()` function "
"in PostgreSQL that returns the PostgreSQL version, so if we want to use "
"that, we use an s-string:"
msgstr ""

#: src/reference/syntax/s-strings.md:8
msgid ""
"```prql\n"
"from my_table\n"
"select db_version = s\"version()\"\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:13
msgid ""
"Embed a column name in an s-string using braces. For example, PRQL's "
"standard library defines the `average` function as:"
msgstr ""

#: src/reference/syntax/s-strings.md:16
msgid ""
"```prql no-eval\n"
"let average = column -> s\"AVG({column})\"\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:20
msgid "So this compiles using the function:"
msgstr ""

#: src/reference/syntax/s-strings.md:28
msgid ""
"\\[!NOTE\\] Because S-string contents are SQL, double-quotes (`\"`) will "
"denote a _column name_. To avoid that, use single-quotes (`'`) around the "
"SQL string, and adjust the quotes of the S-string. For example, instead of "
"`s'CONCAT(\"hello\", \"world\")'` use `s\"CONCAT('hello', 'world')\"`"
msgstr ""

#: src/reference/syntax/s-strings.md:34
msgid "Here's an example of a more involved use of an s-string:"
msgstr ""

#: src/reference/syntax/s-strings.md:36
msgid ""
"```prql\n"
"from de=dept_emp\n"
"join s=salaries side:left (s.emp_no == de.emp_no && s\"\"\"\n"
"  ({s.from_date}, {s.to_date})\n"
"  OVERLAPS\n"
"  ({de.from_date}, {de.to_date})\n"
"\"\"\")\n"
"```"
msgstr ""
"```prql\n"
"from de=dept_emp\n"
"join s=salaries side:left (s.emp_no == de.emp_no && s\"\"\"\n"
"  ({s.from_date}, {s.to_date})\n"
"  OVERLAPS\n"
"  ({de.from_date}, {de.to_date})\n"
"\"\"\")\n"
"```"

#: src/reference/syntax/s-strings.md:45
msgid ""
"For those who have used Python, s-strings are similar to Python's f-strings, "
"but the result is SQL code, rather than a string literal. For example, a "
"Python f-string of `f\"average({col})\"` would produce "
"`\"average(salary)\"`, with quotes; while in PRQL, `s\"average({col})\"` "
"produces `average(salary)`, without quotes."
msgstr ""

#: src/reference/syntax/s-strings.md:50
msgid ""
"Note that interpolations can only contain plain variable names and not whole "
"expression like Python."
msgstr ""

#: src/reference/syntax/s-strings.md:53
msgid "We can also use s-strings to produce a full table:"
msgstr ""

#: src/reference/syntax/s-strings.md:55
msgid ""
"```prql\n"
"from s\"SELECT DISTINCT ON first_name, id, age FROM employees ORDER BY age "
"ASC\"\n"
"join s = s\"SELECT * FROM salaries\" (==id)\n"
"```"
msgstr ""
"```prql\n"
"from s\"SELECT DISTINCT ON first_name, id, age FROM employees ORDER BY age "
"ASC\"\n"
"join s = s\"SELECT * FROM salaries\" (==id)\n"
"```"

#: src/reference/syntax/s-strings.md:61
msgid ""
"\\[!NOTE\\] S-strings in user code are intended as an escape hatch for an "
"unimplemented feature. If we often need s-strings to express something, "
"that's a sign we should implement it in PRQL or PRQL's stdlib. If you often "
"require an s-string, [submit an issue with your use case](https://github.com/"
"PRQL/prql/issues/new/choose)."
msgstr ""

#: src/reference/syntax/s-strings.md:68
msgid "Braces"
msgstr ""

#: src/reference/syntax/s-strings.md:70
msgid "To output braces from an s-string, use double braces:"
msgstr ""

#: src/reference/syntax/s-strings.md:72
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  has_valid_title = s\"regexp_contains(title, '([a-z0-9]*-){{2,}}')\"\n"
"}\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"derive {\n"
"  has_valid_title = s\"regexp_contains(title, '([a-z0-9]*-){{2,}}')\"\n"
"}\n"
"```"

#: src/reference/syntax/s-strings.md:79
msgid "Precedence within s-strings"
msgstr ""

#: src/reference/syntax/s-strings.md:81
msgid ""
"Variables in s-strings are inserted into the SQL source as-is, which means "
"we may get surprising behavior when the variable has multiple terms and the "
"s-string isn't parenthesized."
msgstr ""

#: src/reference/syntax/s-strings.md:85
msgid ""
"In this toy example, the expression `salary + benefits / 365` gets "
"precedence wrong. The generated SQL code is as if we had written `salary + "
"(benefits / 365)`."
msgstr ""

#: src/reference/syntax/s-strings.md:89
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"{gross_salary} / 365\"\n"
"}\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"{gross_salary} / 365\"\n"
"}\n"
"```"

#: src/reference/syntax/s-strings.md:97
msgid "Instead, the numerator `{gross_salary}` must be encased in parentheses:"
msgstr ""

#: src/reference/syntax/s-strings.md:99
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"({gross_salary}) / 365\"\n"
"}\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"({gross_salary}) / 365\"\n"
"}\n"
"```"

#: src/reference/syntax/tuples.md:3
msgid ""
"Tuple is a container type, composed of multiple fields. Each field can have "
"a different type. Number of fields and their types must be known at compile "
"time."
msgstr ""
"值組是一個容器型別，由多個欄位組成。每個欄位可以有不同的型別。欄位的數量和型"
"別必須在編譯時已知。"

#: src/reference/syntax/tuples.md:6
msgid ""
"Tuple is represented by `{}`. It can span multiple lines. Fields can be "
"assigned a name. Fields are separated by commas, trailing trailing comma is "
"optional."
msgstr ""
"值組由 `{}` 表示。它可以跨越多行。欄位可以分配名稱。欄位由逗號分隔，尾部逗號"
"是可選的。"

#: src/reference/syntax/tuples.md:23
msgid ""
"Tuples are the type of a table row, which means that they are expected by "
"many transforms. Most transforms can also take a single field, which will be "
"converted into a tuple. These are equivalent:"
msgstr ""
"值組是表格行的型別，這意味著許多轉換都期望它們。大多數轉換也可以採用單個欄"
"位，該欄位將被轉換為值組。這些是等效的："

#: src/reference/syntax/tuples.md:38
msgid ""
"\\[!NOTE\\] Prior to `0.9.0`, tuples were previously named Lists, and "
"represented with `[]` syntax. There may still be references to the old "
"naming."
msgstr ""
"\\[!NOTE\\] 在 `0.9.0` 之前，值組之前被命名為列表，並用 `[]` 語法表示。可能仍"
"有對舊命名的引用。"

#: src/index.md:1
msgid "PRQL Language Book"
msgstr "PRQL 語言手冊"

#: src/index.md:3
msgid ""
"**P**ipelined **R**elational **Q**uery **L**anguage, pronounced \"Prequel\"."
msgstr ""
"**P**ipelined **R**elational **Q**uery **L**anguage，讀音同「Prequel」。"

#: src/index.md:11
msgid ""
"This book serves as a tutorial and reference guide on the language and the "
"broader project. It currently has three sections, navigated by links on the "
"left:"
msgstr ""
"本書作為語言和更廣泛專案的教學和參考指南。目前有三個部分，通過左側連結進行導"
"航："

#: src/index.md:15
msgid ""
"**Tutorial** — A friendly & accessible guide for learning PRQL. It has a "
"gradual increase of difficulty and requires only basic understanding of "
"programming languages. Knowledge of SQL is beneficial, because of many "
"comparisons to SQL, but not required."
msgstr ""
"**教學** — 一份友善且易於接近的 PRQL 學習指南。難度逐步遞增，只需要基本的編程"
"語言理解。SQL 知識是有益的，因為有很多與 SQL 的比較，但不是必需的。"

#: src/index.md:19
msgid ""
"**Reference** — In-depth information about the PRQL language. Includes "
"justifications for language design decisions and formal specifications for "
"parts of the language."
msgstr ""
"**參考** — 關於 PRQL 語言的深入資訊。包含語言設計決策的理據，以及語言各部分的"
"正式規範。"

#: src/index.md:22
msgid ""
"**Project** — General information about the project, tooling and development."
msgstr "**專案** — 關於專案、工具與開發的一般資訊。"

#: src/index.md:26
msgid ""
"**Examples of PRQL** with a comparison to the generated SQL. PRQL queries "
"can be as simple as:"
msgstr "**PRQL 示例**與生成的 SQL 的比較。PRQL 查詢可以非常簡單，例如："

#: src/index.md:29
msgid ""
"```prql\n"
"from tracks\n"
"filter artist == \"Bob Marley\"  # Each line transforms the previous result\n"
"aggregate {                    # `aggregate` reduces each column to a value\n"
"  plays    = sum plays,\n"
"  longest  = max length,\n"
"  shortest = min length,       # Trailing commas are allowed\n"
"}\n"
"```"
msgstr ""
"```prql\n"
"from tracks\n"
"filter artist == \"Bob Marley\"  # 每行都會變換前面的結果\n"
"aggregate {                    # `aggregate` 將每列縮減為一個值\n"
"  plays    = sum plays,\n"
"  longest  = max length,\n"
"  shortest = min length,       # 允許尾部逗號\n"
"}\n"
"```"

#: src/index.md:39
msgid "...and here's a larger example:"
msgstr "...以下是一個更大的示例："

#: src/index.md:41
msgid ""
"```prql\n"
"from employees\n"
"filter start_date > @2021-01-01            # Clear date syntax\n"
"derive {                                   # `derive` adds columns / "
"variables\n"
"  gross_salary = salary + (tax ?? 0),      # Terse coalesce\n"
"  gross_cost = gross_salary + benefits,    # Variables can use other "
"variables\n"
"}\n"
"filter gross_cost > 0\n"
"group {title, country} (                   # `group` runs a pipeline over "
"each group\n"
"  aggregate {                              # `aggregate` reduces each group "
"to a value\n"
"    average gross_salary,\n"
"    sum_gross_cost = sum gross_cost,       # `=` sets a column name\n"
"  }\n"
")\n"
"filter sum_gross_cost > 100_000            # `filter` replaces both of SQL's "
"`WHERE` & `HAVING`\n"
"derive id = f\"{title}_{country}\"           # F-strings like Python\n"
"derive country_code = s\"LEFT(country, 2)\"  # S-strings permit SQL as an "
"escape hatch\n"
"sort {sum_gross_cost, -country}            # `-country` means descending "
"order\n"
"take 1..20                                 # Range expressions (also valid "
"as `take 20`)\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"filter start_date > @2021-01-01            # 清晰的日期語法\n"
"derive {                                   # `derive` 新增列/變數\n"
"  gross_salary = salary + (tax ?? 0),      # 簡潔的合併\n"
"  gross_cost = gross_salary + benefits,    # 變數可以使用其他變數\n"
"}\n"
"filter gross_cost > 0\n"
"group {title, country} (                   # `group` 在每個群組上執行管道\n"
"  aggregate {                              # `aggregate` 將每個群組縮減為一個"
"值\n"
"    average gross_salary,\n"
"    sum_gross_cost = sum gross_cost,       # `=` 設定列名\n"
"  }\n"
")\n"
"filter sum_gross_cost > 100_000            # `filter` 取代 SQL 的 `WHERE` 和 "
"`HAVING`\n"
"derive id = f\"{title}_{country}\"           # 像 Python 一樣的 F-字串\n"
"derive country_code = s\"LEFT(country, 2)\"  # S-字串允許 SQL 作為逃脫艙口\n"
"sort {sum_gross_cost, -country}            # `-country` 表示遞減順序\n"
"take 1..20                                 # 範圍表達式（也可以寫成 `take "
"20`）\n"
"```"

#: src/SUMMARY.md:3 src/SUMMARY.md:5
msgid "Introduction"
msgstr "介紹"

#: src/SUMMARY.md:7
msgid "Tutorial"
msgstr "教學"

#: src/SUMMARY.md:9
msgid ""
"A friendly & accessible guide for learning PRQL. It has a gradual increase "
"of difficulty and requires only basic understanding of programming "
"languages. Knowledge of SQL is beneficial, because of many comparisons to "
"SQL, but not required."
msgstr ""
"一份友善且易於接近的 PRQL 學習指南。難度逐步遞增，只需要基本的編程語言理解。"
"SQL 知識是有益的，因為有很多與 SQL 的比較，但不是必需的。"

#: src/SUMMARY.md:14
msgid "Relations"
msgstr "關係"

#: src/SUMMARY.md:15
msgid "Filtering"
msgstr "篩選"

#: src/SUMMARY.md:16
msgid "Aggregation"
msgstr "聚合"

#: src/SUMMARY.md:21
msgid "Reference"
msgstr "參考"

#: src/SUMMARY.md:23
msgid ""
"In-depth information about the PRQL language. Includes justifications for "
"language design decisions and formal specifications for parts of the "
"language."
msgstr ""
"關於 PRQL 語言的深入資訊。包含語言設計決策的理據，以及語言各部分的正式規範。"

#: src/SUMMARY.md:46
msgid "Ad-hoc data"
msgstr "臨時資料"

#: src/SUMMARY.md:48
msgid "Declarations"
msgstr "宣告"

#: src/SUMMARY.md:67
msgid "Aggregation functions"
msgstr "聚合函式"

#: src/SUMMARY.md:71
msgid "Removing duplicates"
msgstr "移除重複項"

#: src/SUMMARY.md:79
msgid "Project"
msgstr "專案"

#: src/SUMMARY.md:81
msgid "General information about the project, tooling and development."
msgstr "關於專案、工具與開發的一般資訊。"

#: src/SUMMARY.md:83
msgid "Changelog"
msgstr "變更日誌"

#: src/SUMMARY.md:85
msgid "Target & version"
msgstr "目標與版本"

#: src/SUMMARY.md:88
msgid ".NET"
msgstr ".NET"

#: src/SUMMARY.md:89
msgid "Elixir"
msgstr "Elixir"

#: src/SUMMARY.md:90
msgid "Java"
msgstr "Java"

#: src/SUMMARY.md:91
msgid "JavaScript"
msgstr "JavaScript"

#: src/SUMMARY.md:92
msgid "PHP"
msgstr "PHP"

#: src/SUMMARY.md:93
msgid "Python"
msgstr "Python"

#: src/SUMMARY.md:94
msgid "R"
msgstr "R"

#: src/SUMMARY.md:95
msgid "Rust"
msgstr "Rust"

#: src/SUMMARY.md:98
msgid "`prqlc CLI`"
msgstr "`prqlc CLI`"

#: src/SUMMARY.md:102
msgid "QStudio"
msgstr "QStudio"

#: src/SUMMARY.md:104
msgid "VS Code"
msgstr "VS Code"

#: src/SUMMARY.md:108
msgid "Syntax highlighting"
msgstr "語法標明"

#: src/SUMMARY.md:110
msgid "Contributing to PRQL"
msgstr "對 PRQL 做出貢獻"

#: src/tutorial/aggregation.md:3
msgid ""
"A key feature of analytics is reducing many values down to a summary. This "
"act is called \"aggregation\" and always includes a function — for example, "
"`average` or `sum` — that reduces values in the table to a single row."
msgstr ""
"分析的一個關鍵特性是將許多值歸納為摘要。這種行為稱為「聚合」，始終包括一個函"
"式 — 例如 `average` 或 `sum` — 將表中的值歸納為單一行。"

#: src/tutorial/aggregation.md:7
msgid "`aggregate` transform"
msgstr "`aggregate` 變換"

#: src/tutorial/aggregation.md:9
msgid ""
"The `aggregate` transform takes a tuple to create one or more new columns "
"that \"distill down\" data from all the rows."
msgstr ""
"`aggregate` 變換接受一個元組來建立一個或多個新列，以「歸納」來自所有行的資"
"料。"

#: src/tutorial/aggregation.md:17
msgid ""
"The query above computes the sum of the `total` column of all rows of the "
"`invoices` table to produce a single value."
msgstr "上面的查詢計算 `invoices` 表所有行的 `total` 列的總和，以產生單一值。"

#: src/tutorial/aggregation.md:20
msgid ""
"`aggregate` can produce multiple summaries at once when one or more "
"aggregation expressions are contained in a tuple. `aggregate` discards all "
"columns that are not present in the tuple."
msgstr ""
"當元組中包含一個或多個聚合表達式時，`aggregate` 可以一次產生多個摘要。"
"`aggregate` 會捨棄元組中不存在的所有列。"

#: src/tutorial/aggregation.md:32
msgid ""
"In the example above, the result is a single row with two columns. The "
"`count` function displays the number of rows in the table that was passed "
"in; the `sum` function adds up the values of the `total` column of all rows."
msgstr ""
"在上面的示例中，結果是有兩列的單一行。`count` 函式顯示傳入的表中的行數；"
"`sum` 函式將所有行的 `total` 列的值相加。"

#: src/tutorial/aggregation.md:36
msgid "Grouping"
msgstr "分組"

#: src/tutorial/aggregation.md:38
msgid ""
"Suppose we want to produce summaries of invoices _for each city_ in the "
"table. We could create a query for each city, and aggregate its rows:"
msgstr ""
"假設我們想要產生表中 _每個城市_ 發票的摘要。我們可以為每個城市建立一個查詢，"
"並聚合其行："

#: src/tutorial/aggregation.md:41
msgid ""
"```prql no-eval\n"
"from invoices\n"
"filter billing_city == \"Oslo\"\n"
"aggregate { sum_of_orders = sum total }\n"
"```"
msgstr ""

#: src/tutorial/aggregation.md:47
msgid ""
"But we would need to do it for each city: `London`, `Frankfurt`, etc. Of "
"course this is repetitive (and boring) and error prone (because we would "
"need to type each `billing_city` by hand). Moreover, we would need to create "
"a list of each `billing_city` before we started."
msgstr ""
"但我們需要為每個城市做這種操作：`London`、`Frankfurt` 等。當然這是重複的（且"
"令人厭倦的）且容易出錯（因為我們需要手動輸入每個 `billing_city`）。此外，我們"
"需要在開始前建立每個 `billing_city` 的列表。"

#: src/tutorial/aggregation.md:52
msgid "`group` transform"
msgstr "`group` 變換"

#: src/tutorial/aggregation.md:54
msgid ""
"The `group` transform separates the table into groups (say, those having the "
"same city) using information that's already in the table. It then applies a "
"transform to each group, and combines the results back together:"
msgstr ""
"`group` 變換使用表中已有的資訊將表分成群組（例如，具有相同城市的行）。然後它"
"對每個群組套用變換，並將結果重新組合在一起："

#: src/tutorial/aggregation.md:68
msgid ""
"Those familiar with SQL have probably noticed that we just decoupled "
"aggregation from grouping."
msgstr "熟悉 SQL 的人可能已經注意到，我們剛才將聚合與分組分離了。"

#: src/tutorial/aggregation.md:71
msgid ""
"Although these operations are connected in SQL, PRQL makes it "
"straightforward to use `group` and `aggregate` separate from each other, "
"while combining with other transform functions, such as:"
msgstr ""
"雖然這些操作在 SQL 中是相關的，但 PRQL 使得可以直接將 `group` 和 `aggregate`"
"分開使用，同時與其他變換函式結合，例如："

#: src/tutorial/aggregation.md:82
msgid "This code collects the first two rows for each city's `group`."
msgstr "這段程式碼收集每個城市 `group` 的前兩行。"

#: src/tutorial/filtering.md:1
msgid "Filtering rows"
msgstr "篩選行"

#: src/tutorial/filtering.md:3
msgid ""
"In the previous page we learned how `select`, `derive`, and `join` change "
"the columns of a table."
msgstr "在前一頁，我們學到了 `select`、`derive` 和 `join` 如何改變表的列。"

#: src/tutorial/filtering.md:6
msgid ""
"Now we will explore how to manipulate the rows of a table using `filter` and "
"`take`."
msgstr "現在我們將探索如何使用 `filter` 和 `take` 操作表的行。"

#: src/tutorial/filtering.md:9
msgid "`filter` transform"
msgstr "`filter` 變換"

#: src/tutorial/filtering.md:11
msgid ""
"The `filter` transform picks rows to pass through based on their values:"
msgstr "`filter` 變換根據值選擇要通過的行："

#: src/tutorial/filtering.md:13
msgid ""
"```prql no-eval\n"
"from invoices\n"
"filter billing_city == \"Berlin\"\n"
"```"
msgstr ""

#: src/tutorial/filtering.md:18
msgid "The resulting table contains all the rows that came from Berlin."
msgstr "結果表包含來自柏林的所有行。"

#: src/tutorial/filtering.md:20
msgid ""
"PRQL converts the single `filter` transform to use the appropriate SQL "
"`WHERE` or `HAVING` command, depending on where it appears in the pipeline."
msgstr ""
"PRQL 將單個 `filter` 變換轉換為使用適當的 SQL `WHERE` 或 `HAVING` 命令，取決"
"於它在管道中出現的位置。"

#: src/tutorial/filtering.md:23
msgid "`take` transform"
msgstr "`take` 變換"

#: src/tutorial/filtering.md:25
msgid ""
"The `take` transform picks rows to pass through based on their position "
"within the table. The set of rows picked can be specified in two ways:"
msgstr ""
"`take` 變換根據行在表中的位置選擇要通過的行。所選行的集合可以用兩種方式指定："

#: src/tutorial/filtering.md:28
msgid "a plain number `x`, which will pick the first `x` rows, or"
msgstr "一個純數字 `x`，將選擇前 `x` 行，或"

#: src/tutorial/filtering.md:29
msgid "an inclusive range of rows `start..end`."
msgstr "行的包含範圍 `start..end`。"

#: src/tutorial/filtering.md:41
msgid ""
"Of course, it is possible combine all these transforms into a single "
"pipeline:"
msgstr "當然，可以將所有這些變換組合到一個管道中："

#: src/tutorial/filtering.md:43
msgid ""
"```prql no-eval\n"
"from invoices\n"
"\n"
"# retain only rows for orders from Berlin\n"
"filter billing_city == \"Berlin\"\n"
"\n"
"# skip first 10 rows and take the next 10\n"
"take 11..20\n"
"\n"
"# take only first 3 rows of *that* result\n"
"take 3\n"
"```"
msgstr ""

#: src/tutorial/filtering.md:56
msgid ""
"We did something a bit odd at the end: first we took rows `11..20` and then "
"took the first 3 rows from that result."
msgstr ""
"在最後我們做了一些有點奇怪的事情：首先我們取了行 `11..20`，然後從該結果中取"
"前 3 行。"

#: src/tutorial/filtering.md:60
msgid ""
"\\[!NOTE\\] Note that a single transform `take 11..13` would have produced "
"the same SQL. The example shows how PRQL allows fast data exploration by "
"\"stacking\" transforms in the pipeline. This reduces the cognitive burden: "
"unlike SQL, each new transform interacts _only_ with the results of the "
"previous query."
msgstr ""
"\\[!NOTE\\] 注意，單個變換 `take 11..13` 會產生相同的 SQL。此示例展示了 PRQL "
"如何通過在管道中「堆疊」變換來允許快速資料探索。這減少了認知負擔：與 SQL 不"
"同，每個新的變換只與前一個查詢的結果相互作用。"

#: src/tutorial/relations.md:3
msgid ""
"PRQL is designed on top of _relational algebra_, which is the established "
"data model used by modern SQL databases. A _relation_ has a rigid "
"mathematical definition, which can be simplified to \"a table of data\". For "
"example, the `invoices` table from the Chinook database ([https://github.com/"
"lerocha/chinook-database](https://github.com/lerocha/chinook-database)) "
"looks like this:"
msgstr ""
"PRQL 建立在 _關係代數_ 的基礎上，這是現代 SQL 資料庫使用的既定資料模型。_關係"
"_ 具有嚴格的數學定義，可以簡化為「資料表」。例如，Chinook 資料庫 ([https://"
"github.com/lerocha/chinook-database](https://github.com/lerocha/chinook-"
"database)) 中的 `invoices` 表如下所示："

#: src/tutorial/relations.md:10
msgid "invoice_id"
msgstr ""

#: src/tutorial/relations.md:10
msgid "customer_id"
msgstr ""

#: src/tutorial/relations.md:10
msgid "billing_city"
msgstr ""

#: src/tutorial/relations.md:10
msgid "_other columns_"
msgstr ""

#: src/tutorial/relations.md:10
msgid "total"
msgstr ""

#: src/tutorial/relations.md:12
msgid "Stuttgart"
msgstr ""

#: src/tutorial/relations.md:12 src/tutorial/relations.md:13
#: src/tutorial/relations.md:14 src/tutorial/relations.md:15
#: src/tutorial/relations.md:16 src/tutorial/relations.md:17
msgid "..."
msgstr ""

#: src/tutorial/relations.md:12
msgid "1.98"
msgstr ""

#: src/tutorial/relations.md:13
msgid "Oslo"
msgstr ""

#: src/tutorial/relations.md:13
msgid "3.96"
msgstr ""

#: src/tutorial/relations.md:14
msgid "Brussels"
msgstr ""

#: src/tutorial/relations.md:14
msgid "5.94"
msgstr ""

#: src/tutorial/relations.md:15
msgid "Edmonton"
msgstr ""

#: src/tutorial/relations.md:15
msgid "8.91"
msgstr ""

#: src/tutorial/relations.md:16
msgid "23"
msgstr ""

#: src/tutorial/relations.md:16
msgid "Boston"
msgstr ""

#: src/tutorial/relations.md:16
msgid "13.86"
msgstr ""

#: src/tutorial/relations.md:17
msgid "37"
msgstr ""

#: src/tutorial/relations.md:17
msgid "Frankfurt"
msgstr ""

#: src/tutorial/relations.md:17
msgid "0.99"
msgstr ""

#: src/tutorial/relations.md:19
msgid ""
"A relation is composed of rows. Each row in a relation contains a value for "
"each of the relation's columns. Each column in a relation has a unique name "
"and a designated data type. The table above is a relation, and has columns "
"named `invoice_id`and `customer_id` each with a data type of \"integer "
"number\", a `billing_city` column with a data type of \"text\", several "
"other columns, and a `total` column that contains floating-point numbers."
msgstr ""
"關係由行組成。關係中的每一行都包含該關係每個列的值。關係中的每個列都有唯一的"
"名稱和指定的資料型別。上表是一個關係，有名為 `invoice_id` 和 `customer_id` 的"
"列，每個列的資料型別都是「整數」，有一個資料型別為「文字」的 `billing_city`"
"列，以及其他幾列，還有一個包含浮點數的 `total` 列。"

#: src/tutorial/relations.md:26
msgid "Queries"
msgstr "查詢"

#: src/tutorial/relations.md:28
msgid ""
"The main purpose of PRQL is to build queries that combine and transform data "
"from relations such as the `invoices` table above. Here is the most basic "
"query:"
msgstr ""
"PRQL 的主要目的是建立查詢，以結合和轉換來自關係（如上面的 `invoices` 表）的資"
"料。以下是最基本的查詢："

#: src/tutorial/relations.md:36
msgid ""
"\\[!NOTE\\] Try each of these examples here in the [Playground.](https://"
"prql-lang.org/playground/) Enter the query on the left-hand side, and click "
"the **Query Results** tab on the right-hand side to see the result."
msgstr ""
"\\[!NOTE\\] 嘗試在 [Playground](https://prql-lang.org/playground/) 中的每一個"
"例子。在左側輸入查詢，並點擊右側的 **Query Results** 選項卡來查看結果。"

#: src/tutorial/relations.md:42
msgid ""
"The result of the query above is not terribly interesting, it's just the "
"same relation as before."
msgstr "上面查詢的結果並不特別有趣，它只是與之前相同的關係。"

#: src/tutorial/relations.md:45
msgid "`select` transform"
msgstr "`select` 變換"

#: src/tutorial/relations.md:47
msgid ""
"The `select` function picks the columns to pass through based on a list and "
"discards all others. Formally, that list is a _tuple_ of comma-separated "
"expressions wrapped in `{ ... }`."
msgstr ""
"`select` 函式基於列表選擇要通過的列，並捨棄所有其他列。形式上，該列表是以 "
"`{ ... }` 包裹的逗號分隔表達式的 _元組_。"

#: src/tutorial/relations.md:51
msgid ""
"Suppose we only need the `order_id` and `total` columns. Use `select` to "
"choose the columns to pass through. _(Try it in the [Playground.](https://"
"prql-lang.org/playground/))_"
msgstr ""
"假設我們只需要 `order_id` 和 `total` 列。使用 `select` 來選擇要通過的列。_"
"（在 [Playground](https://prql-lang.org/playground/) 中試試看。）_"

#: src/tutorial/relations.md:60
msgid ""
"We can write the items in the tuple on one or several lines: trailing commas "
"are ignored. In addition, we can assign any of the expressions to a "
"_variable_ that becomes the name of the resulting column in the SQL output."
msgstr ""
"我們可以在一行或多行上寫入元組中的項目：尾部逗號被忽略。此外，我們可以將任何"
"表達式指派給 _變數_，該變數成為 SQL 輸出中結果列的名稱。"

#: src/tutorial/relations.md:72
msgid ""
"This is the same query as above, rewritten on multiple lines, and assigning "
"`OrderID` and `Total` names to the columns."
msgstr ""
"這是與上面相同的查詢，改寫在多行上，並將 `OrderID` 和 `Total` 名稱指派給列。"

#: src/tutorial/relations.md:75
msgid ""
"Once we `select` certain columns, subsequent transforms will have access "
"only to those columns named in the tuple."
msgstr "一旦我們 `select` 某些列，後續變換將只能訪問在元組中命名的那些列。"

#: src/tutorial/relations.md:78
msgid "`derive` transform"
msgstr "`derive` 變換"

#: src/tutorial/relations.md:80
msgid ""
"To add columns to a relation, we can use the `derive` function. Let's define "
"a new column for Value Added Tax, set at 19% of the invoice total."
msgstr ""
"要向關係新增列，我們可以使用 `derive` 函式。讓我們定義一個增值稅新列，設定為"
"發票總額的 19%。"

#: src/tutorial/relations.md:90
msgid ""
"The value of the new column can be a constant (such as a number or a "
"string), or can be computed from the value of an existing column. Note that "
"the value of the new column is assigned the name `VAT`."
msgstr ""
"新列的值可以是常數（例如數字或字串），也可以從現有列的值計算得出。注意新列被"
"指派名稱 `VAT`。"

#: src/tutorial/relations.md:94
msgid "`join` transform"
msgstr "`join` 變換"

#: src/tutorial/relations.md:96
msgid ""
"The `join` transform also adds columns to the relation by combining the rows "
"from two relations \"side by side\". To determine which rows from each "
"relation should be joined, `join` has match criteria, written in `( ... )`."
msgstr ""
"`join` 變換也通過將來自兩個關係的行「並排」組合來向關係新增列。為了確定應該聯"
"接每個關係的哪些行，`join` 有以 `( ... )` 寫出的匹配條件。"

#: src/tutorial/relations.md:105
msgid ""
"This example \"connects\" the customer information from the `customers` "
"relation with the information from the `invoices` relation, using identical "
"values of the `customer_id` column from each relation to match the rows."
msgstr ""
"此示例「連接」來自 `customers` 關係的客戶資訊與來自 `invoices` 關係的資訊，使"
"用來自每個關係的 `customer_id` 列的相同值來匹配行。"

#: src/tutorial/relations.md:109
msgid ""
"It is frequently useful to assign an alias to both relations being joined "
"together so that each relation's columns can be referred to uniquely."
msgstr "為兩個被聯接的關係指派別名通常很有用，以便可以唯一地參考每個關係的列。"

#: src/tutorial/relations.md:117
msgid ""
"In the example above, the alias `inv` represents the `invoices` relation and "
"`cust` represents the `customers` relation. It then becomes possible to "
"refer to `inv.billing_city` and `cust.last_name` unambiguously."
msgstr ""
"在上面的示例中，別名 `inv` 代表 `invoices` 關係，`cust` 代表 `customers` 關"
"係。然後可以明確地參考 `inv.billing_city` 和 `cust.last_name`。"

#: src/tutorial/relations.md:121
msgid "Summary"
msgstr "摘要"

#: src/tutorial/relations.md:123
msgid ""
"PRQL manipulates relations (tables) of data. The `derive`, `select`, and "
"`join` transforms change the number of columns in a table. The first two "
"never affect the number of rows in a table. `join` may change the number of "
"rows, depending on the chosen type of join."
msgstr ""
"PRQL 操作資料的關係（表）。`derive`、`select` 和 `join` 變換改變表中列的數"
"量。前兩者從不影響表中行的數量。`join` 可能會改變行的數量，這取決於選擇的聯接"
"類型。"

#: src/tutorial/relations.md:128
msgid ""
"This final example combines the above into a single query. It illustrates _a "
"pipeline_ - the fundamental basis of PRQL. We simply add new lines "
"(transforms) at the end of the query. Each transform modifies the relation "
"produced by the statement above to produce the desired result."
msgstr ""
"這個最後的示例將上述內容組合成一個單一查詢。它說明了 _管道_ - PRQL 的基礎。我"
"們只是在查詢末尾新增新的行（變換）。每個變換修改由上述語句產生的關係，以產生"
"所需的結果。"
