msgid ""
msgstr ""
"Project-Id-Version: PRQL language book\n"
"POT-Creation-Date: 2026-01-10T16:16:28Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/how-do-i/relation-literals.md:1
msgid "How do I: create ad-hoc relations?"
msgstr ""

#: src/how-do-i/relation-literals.md:3
msgid ""
"It's often useful to make a small inline relation, for example when "
"exploring how a database will evaluate an expression, or for a small lookup "
"table. This can be quite verbose in SQL."
msgstr ""

#: src/how-do-i/relation-literals.md:7
msgid ""
"PRQL offers two approaches — array literals, and a `from_text` transform."
msgstr ""

#: src/how-do-i/relation-literals.md:9
msgid "Array literals"
msgstr ""

#: src/how-do-i/relation-literals.md:11
msgid ""
"Because relations (aka a table) in PRQL are just arrays of tuples, they can "
"be expressed with array and tuple syntax:"
msgstr ""

#: src/how-do-i/relation-literals.md:23
msgid ""
"```prql\n"
"let my_artists = [\n"
"  {artist=\"Miles Davis\"},\n"
"  {artist=\"Marvin Gaye\"},\n"
"  {artist=\"James Brown\"},\n"
"]\n"
"\n"
"from artists\n"
"join my_artists (==artist)\n"
"join albums (==artist_id)\n"
"select {artists.artist_id, albums.title}\n"
"```"
msgstr ""

#: src/how-do-i/relation-literals.md:36
msgid "`from_text`"
msgstr ""

#: src/how-do-i/relation-literals.md:38
msgid ""
"`from_text` takes a string in a common format, and converts it to table. It "
"accepts a few formats:"
msgstr ""

#: src/how-do-i/relation-literals.md:41
msgid "`format:csv` parses CSV (default),"
msgstr ""

#: src/how-do-i/relation-literals.md:43
msgid "`format:json` parses either:"
msgstr ""

#: src/how-do-i/relation-literals.md:45
msgid "an array of objects each of which represents a row, or"
msgstr ""

#: src/how-do-i/relation-literals.md:47
msgid ""
"an object with fields `columns` & `data`, where `columns` take an array of "
"column names and `data` takes an array of arrays."
msgstr ""

#: src/how-do-i/relation-literals.md:50
msgid ""
"```prql\n"
"from_text \"\"\"\n"
"a,b,c\n"
"1,2,3\n"
"4,5,6\n"
"\"\"\"\n"
"derive {\n"
"    d = b + c,\n"
"    answer = 20 * 2 + 2,\n"
"}\n"
"```"
msgstr ""

#: src/how-do-i/relation-literals.md:62
msgid ""
"```prql\n"
"from_text format:json \"\"\"\n"
"[\n"
"    {\"a\": 1, \"m\": \"5\"},\n"
"    {\"a\": 4, \"n\": \"6\"}\n"
"]\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/how-do-i/relation-literals.md:71
msgid ""
"```prql\n"
"from_text format:json \"\"\"\n"
"{\n"
"    \"columns\": [\"a\", \"b\", \"c\"],\n"
"    \"data\": [\n"
"        [1, \"x\", false],\n"
"        [4, \"y\", null]\n"
"    ]\n"
"}\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/how-do-i/relation-literals.md:83
msgid "See also"
msgstr "另請參見"

#: src/how-do-i/relation-literals.md:85
msgid "[How do I: read files?](./read-files.md)"
msgstr ""

#: src/how-do-i/read-files.md:1
msgid "How do I: read files?"
msgstr ""

#: src/how-do-i/read-files.md:3
msgid "There are a couple of functions mainly designed for DuckDB:"
msgstr ""

#: src/how-do-i/read-files.md:5
msgid ""
"```prql\n"
"prql target:sql.duckdb\n"
"\n"
"from (read_parquet \"artists.parquet\")\n"
"join (read_csv \"albums.csv\") (==track_id)\n"
"```"
msgstr ""

#: src/how-do-i/read-files.md:21
msgid ""
"When specifying file names directly in the `FROM` clause without using "
"functions, which is allowed in DuckDB, enclose the file names in backticks "
"``` `` ``` as follows:"
msgstr ""

#: src/how-do-i/read-files.md:31
msgid "[Target and Version](../project/target.md)"
msgstr ""

#: src/how-do-i/read-files.md:32
msgid "[How do I: create ad-hoc relations?](./relation-literals.md)"
msgstr ""

#: src/how-do-i/distinct.md:1
msgid "How do I: remove duplicates?"
msgstr ""

#: src/how-do-i/distinct.md:3
msgid ""
"PRQL doesn't have a specific `distinct` keyword. Instead duplicate tuples in "
"a relation can be removed by using `group` and `take 1`:"
msgstr ""

#: src/how-do-i/distinct.md:14
msgid "This also works with a wildcard:"
msgstr ""

#: src/how-do-i/distinct.md:21
msgid "Remove duplicates from each group?"
msgstr ""

#: src/how-do-i/distinct.md:23
msgid ""
"To [select a single row from each group](https://stackoverflow.com/"
"questions/3800551/select-first-row-in-each-group-by-group) `group` can be "
"combined with `sort` and `take`:"
msgstr ""

#: src/how-do-i/distinct.md:36
msgid ""
"Note that we can't always compile to `DISTINCT`; when the columns in the "
"`group` aren't all the available columns, we need to use a window function:"
msgstr ""

#: src/project/bindings/index.md:1
msgid "Bindings"
msgstr "綁定"

#: src/project/bindings/index.md:3
msgid "PRQL has bindings for many languages. These include:"
msgstr ""

#: src/project/bindings/index.md:5
msgid "We have three tiers of bindings:"
msgstr ""

#: src/project/bindings/index.md:7 src/project/bindings/index.md:11
msgid "Supported"
msgstr ""

#: src/project/bindings/index.md:8 src/project/bindings/index.md:33
msgid "Unsupported"
msgstr ""

#: src/project/bindings/index.md:9 src/project/bindings/index.md:43
msgid "Nascent"
msgstr ""

#: src/project/bindings/index.md:13
msgid "Supported bindings require:"
msgstr ""

#: src/project/bindings/index.md:15
msgid "A maintainer."
msgstr ""

#: src/project/bindings/index.md:16
msgid ""
"Implementations of the [core compile functions](https://docs.rs/prqlc/latest/"
"prqlc/#functions)."
msgstr ""

#: src/project/bindings/index.md:18
msgid "Test coverage for these functions."
msgstr ""

#: src/project/bindings/index.md:19
msgid "A published package to the language's standard package repository."
msgstr ""

#: src/project/bindings/index.md:20
msgid "A script in `Taskfile.yml` to bootstrap a development environment."
msgstr ""

#: src/project/bindings/index.md:21
msgid ""
"Any dev tools, such as a linter & formatter, in pre-commit or MegaLinter."
msgstr ""

#: src/project/bindings/index.md:23
msgid "The currently supported bindings are:"
msgstr ""

#: src/project/bindings/index.md:25
msgid "[JavaScript](./javascript.md)"
msgstr ""

#: src/project/bindings/index.md:26
msgid "[Python](./python.md)"
msgstr "[Python](./python.md)"

#: src/project/bindings/index.md:27
msgid "[R](./r.md)"
msgstr "[R](./r.md)"

#: src/project/bindings/index.md:28
msgid "[Rust](./rust.md)"
msgstr "[Rust](./rust.md)"

#: src/project/bindings/index.md:30
msgid ""
"Most of these are in the main PRQL repo, and we gate any changes to the "
"compiler's API on compatible changes to the bindings."
msgstr ""

#: src/project/bindings/index.md:35
msgid ""
"Unsupported bindings work, but don't fulfil all of the above criteria. We "
"don't gate changes to the compiler's API. If they stop working, we'll demote "
"them to nascent."
msgstr ""

#: src/project/bindings/index.md:39
msgid "[Java](./java.md)"
msgstr "[Java](./java.md)"

#: src/project/bindings/index.md:40
msgid "[Elixir](./elixir.md)"
msgstr "[Elixir](./elixir.md)"

#: src/project/bindings/index.md:41
msgid "`prqlc-c`, the C bindings"
msgstr ""

#: src/project/bindings/index.md:45
msgid "Nascent bindings are in development, and may not yet fully work."
msgstr ""

#: src/project/bindings/index.md:47
msgid "[.NET](./dotnet.md)"
msgstr "[.NET](./dotnet.md)"

#: src/project/bindings/index.md:48
msgid "[PHP](./php.md)"
msgstr "[PHP](./php.md)"

#: src/project/bindings/index.md:50
msgid "Naming"
msgstr ""

#: src/project/bindings/index.md:52
msgid "Over time, we're trying to move to a consistent naming scheme:"
msgstr ""

#: src/project/bindings/index.md:54
msgid "Crates are named `prqlc-$lang`."
msgstr ""

#: src/project/bindings/index.md:55
msgid ""
"Where possible, packages are published to each language's package repository "
"as `prqlc`."
msgstr ""

#: src/project/bindings/elixir.md:1
msgid "PRQL"
msgstr ""

#: src/project/bindings/elixir.md:3
msgid "[PRQL](https://prql-lang.org/) bindings for Elixir."
msgstr ""

#: src/project/bindings/elixir.md:5
msgid "Installation"
msgstr "安裝"

#: src/project/bindings/elixir.md:7
msgid ""
"```elixir\n"
"def deps do\n"
"  [\n"
"    {:prql, \"~> 0.1.0\"}\n"
"  ]\n"
"end\n"
"```"
msgstr ""

#: src/project/bindings/elixir.md:15
msgid "Basic Usage"
msgstr ""

#: src/project/bindings/elixir.md:17
msgid ""
"```elixir\n"
"  iex> PRQL.compile(\"from customers\")\n"
"      {:ok, \"SELECT\\n  *\\nFROM\\n  customers\\n\\n-- Generated by PRQL "
"compiler version 0.3.1 (https://prql-lang.org)\\n\"}\n"
"\n"
"\n"
"  iex> PRQL.compile(\"from customers\\ntake 10\", dialect: :mssql)\n"
"  {:ok, \"SELECT\\n  *\\nFROM\\n  customers\\nORDER BY\\n  (\\n    "
"SELECT\\n      NULL\\n  ) OFFSET 0 ROWS\\nFETCH FIRST\\n  10 ROWS "
"ONLY\\n\\n-- Generated by PRQL compiler version 0.3.1 (https://prql-lang."
"org)\\n\"}\n"
"```"
msgstr ""

#: src/project/bindings/elixir.md:26
msgid "Development"
msgstr "開發"

#: src/project/bindings/elixir.md:28
msgid "We are in the early stages of developing Elixir bindings."
msgstr ""

#: src/project/bindings/elixir.md:30
msgid "We're using `Rustler` to provide Rust bindings for `prqlc`."
msgstr ""

#: src/project/bindings/elixir.md:32
msgid ""
"Currently using the bindings in an Elixir project requires compiling the "
"Rust crate from this repo:"
msgstr ""

#: src/project/bindings/elixir.md:35
msgid "Install dependencies with `mix deps.get`"
msgstr ""

#: src/project/bindings/elixir.md:36
msgid "Compile project `mix compile`"
msgstr ""

#: src/project/bindings/elixir.md:37
msgid "Run tests `mix test`"
msgstr ""

#: src/project/bindings/elixir.md:39
msgid ""
"Future work includes publishing pre-compiled artifacts, so Elixir projects "
"can run PRQL without needing a Rust toolchain."
msgstr ""

#: src/project/bindings/elixir.md:42
msgid "Mac"
msgstr ""

#: src/project/bindings/elixir.md:44
msgid ""
"We currently don't enable compilation for Mac. This is possible to enable, "
"but causes some issues with cargo's compilation cache. Briefly: it requires "
"`RUSTFLAGS` to be set, and because of <https://github.com/rust-lang/cargo/"
"issues/8716> & <https://github.com/rust-lang/cargo/issues/8899>, any "
"compilation of a different target will bust the cache."
msgstr ""

#: src/project/bindings/elixir.md:51
msgid "The possible future workarounds include:"
msgstr ""

#: src/project/bindings/elixir.md:53
msgid ""
"Passing `--target=aarch64-apple-darwin` to every cargo call, which is "
"inconvenient and can be difficult in some situations; e.g. Rust Analyzer. "
"This disables passing `RUSTFLAGS` (I'm actually unclear why `prql-elixir` "
"builds successfully in that case...)"
msgstr ""

#: src/project/bindings/elixir.md:57
msgid ""
"Directing other cargo calls to different paths, such as `/target-ra` for "
"Rust Analyzer and `/target-book` for the book building. But one `cargo "
"build` from the terminal without either the `target` or `target_dir` "
"specified will bust the cache!"
msgstr ""

#: src/project/bindings/elixir.md:61
msgid ""
"Never compiling for other targets. But our standard tests run for `--"
"target=wasm32-unknown-unknown`, so this requires refraining from using them."
msgstr ""

#: src/project/bindings/elixir.md:64
msgid ""
"Removing `prql-elixir` from our workspace, so that `cargo` commands in the "
"PRQL workspace don't require rust flags. This would work well, but means we "
"need separate test coverage for this crate, which adds some weight to the "
"tests."
msgstr ""

#: src/project/bindings/elixir.md:69
msgid ""
"If `prql-elixir` becomes more used (for example, we start publishing to Hex, "
"or Mac developers want to work on it), then we can re-enable and deal with "
"the caching issues. We can also re-enable them if the `cargo` issue is "
"resolved."
msgstr ""

#: src/project/bindings/elixir.md:73
msgid ""
"To test on Mac temporarily — for example if there's an error in GHA and "
"we're on a Mac locally — apply a diff like this, and then run `cargo build` "
"from the `prql-elixir` path, which will enable the local [`.cargo/config."
"toml`](https://github.com/PRQL/prql/blob/main/prqlc/bindings/elixir/native/"
"prql/.cargo/config.toml)). (We could also make a feature like `elixir-mac` "
"which enabled building on Mac)."
msgstr ""

#: src/project/bindings/java.md:1
msgid "prql-java"
msgstr ""

#: src/project/bindings/java.md:3
msgid ""
"`prql-java` offers Java bindings to the `prql-compiler` Rust library. It "
"exposes a Java native method `public static native String toSql(String "
"query)`."
msgstr ""

#: src/project/bindings/java.md:6
msgid ""
"It's still at an early stage, and currently requires compiling locally, and "
"isn't published to Maven. Contributions are welcome."
msgstr ""

#: src/reference/syntax/index.md:11
msgid "Usage"
msgstr "用法"

#: src/project/bindings/java.md:26
msgid "\"from table\""
msgstr ""

#: src/project/bindings/javascript.md:1
msgid "prql-js"
msgstr ""

#: src/project/bindings/javascript.md:3
msgid "JavaScript bindings for [`prqlc`](https://github.com/PRQL/prql/)."
msgstr ""

#: src/project/bindings/javascript.md:13
msgid "Currently these functions are exposed"
msgstr ""

#: src/project/bindings/javascript.md:25
msgid "From Node.js"
msgstr ""

#: src/project/bindings/javascript.md:27
msgid "Direct usage"
msgstr ""

#: src/project/bindings/javascript.md:30 src/project/bindings/javascript.md:51
#: src/project/bindings/javascript.md:61
msgid "\"prql-js\""
msgstr ""

#: src/project/bindings/javascript.md:32
msgid "`from employees | select first_name`"
msgstr ""

#: src/project/bindings/javascript.md:36
msgid "Options"
msgstr "選項"

#: src/project/bindings/javascript.md:40
msgid "\"sql.mssql\""
msgstr ""

#: src/project/bindings/javascript.md:44
msgid "`from employees | take 10`"
msgstr ""

#: src/project/bindings/javascript.md:48
msgid "Template literal"
msgstr ""

#: src/project/bindings/javascript.md:52 src/project/bindings/javascript.md:62
msgid "\"\""
msgstr ""

#: src/project/bindings/javascript.md:54
msgid "prql`from employees | select first_name`"
msgstr ""

#: src/project/bindings/javascript.md:58
msgid "Template literal with newlines"
msgstr ""

#: src/project/bindings/javascript.md:64
msgid ""
"prql`\n"
"    from employees\n"
"    select first_name\n"
"`"
msgstr ""

#: src/project/bindings/javascript.md:71
msgid "From a browser"
msgstr ""

#: src/project/bindings/javascript.md:76
msgid "\"./node_modules/prql-js/dist/web/prql_js.js\""
msgstr ""

#: src/project/bindings/javascript.md:81
msgid "\"./node_modules/prql-js/dist/web/prql_js_bg.wasm\""
msgstr ""

#: src/project/bindings/javascript.md:82
msgid "\"from employees | select first_name\""
msgstr ""

#: src/project/bindings/javascript.md:95
msgid "From a framework or a bundler"
msgstr ""

#: src/project/bindings/javascript.md:97
msgid ""
"```typescript\n"
"import compile from \"prql-js/dist/bundler\";\n"
"\n"
"const sql = compile(`from employees | select first_name`);\n"
"console.log(sql);\n"
"```"
msgstr ""

#: src/project/bindings/javascript.md:104
msgid "Errors"
msgstr ""

#: src/project/bindings/javascript.md:106
msgid "Errors are returned as following object, serialized as a JSON array:"
msgstr ""

#: src/project/bindings/javascript.md:108
msgid ""
"```typescript\n"
"interface ErrorMessage {\n"
"  /// Message kind. Currently only Error is implemented.\n"
"  kind: \"Error\" | \"Warning\" | \"Lint\";\n"
"  /// Machine-readable identifier of the error\n"
"  code: string | null;\n"
"  /// Plain text of the error\n"
"  reason: string;\n"
"  /// A list of suggestions of how to fix the error\n"
"  hint: string | null;\n"
"  /// Character offset of error origin within a source file\n"
"  span: [number, number] | null;\n"
"\n"
"  /// Annotated code, containing cause and hints.\n"
"  display: string | null;\n"
"  /// Line and column number of error origin within a source file\n"
"  location: SourceLocation | null;\n"
"}\n"
"\n"
"/// Location within the source file.\n"
"/// Tuples contain:\n"
"/// - line number (0-based),\n"
"/// - column number within that line (0-based),\n"
"interface SourceLocation {\n"
"  start: [number, number];\n"
"\n"
"  end: [number, number];\n"
"}\n"
"```"
msgstr ""

#: src/project/bindings/javascript.md:138
msgid "These errors can be caught as such:"
msgstr ""

#: src/project/bindings/javascript.md:142
msgid "`from employees | foo first_name`"
msgstr ""

#: src/project/bindings/javascript.md:153
msgid "Build:"
msgstr ""

#: src/project/bindings/javascript.md:159
msgid "This builds Node, bundler and web packages in the `dist` path."
msgstr ""

#: src/project/bindings/javascript.md:161
msgid "Test:"
msgstr "測試："

#: src/project/bindings/javascript.md:167
msgid ""
"By default the `wasm` binaries are optimized on each run, even if the "
"underlying code hasn't changed, which can be slow. For a lower-latency dev "
"loop, pass `--profile=dev` to `npm install` for a faster, less optimized "
"build."
msgstr ""

#: src/project/bindings/javascript.md:175
msgid "Notes"
msgstr ""

#: src/project/bindings/javascript.md:177
msgid ""
"This uses [`wasm-pack`](https://rustwasm.github.io/docs/wasm-pack/) to "
"generate bindings[^1]."
msgstr ""

#: src/project/bindings/javascript.md:179
msgid ""
"We've added an `npm` layer on top of the usual approach of just using `wasm-"
"pack`, so we can distribute a single package with targets of `node`, "
"`bundler` and `no-modules` — somewhat inverting the approach recommended by "
"`wasm-pack`. The build instruction goes in a `build` script, rather than a "
"`pack` script."
msgstr ""

#: src/project/bindings/javascript.md:186
msgid ""
"    Though we would be very open to other approaches, given wasm-pack does "
"not\n"
"    seem maintained, and we're eliding many of its features to build for "
"three\n"
"    targets. See <https://github.com/PRQL/prql/issues/1836> for more "
"details.\n"
"    "
msgstr ""

#: src/project/bindings/dotnet.md:1
msgid "prql-dotnet"
msgstr "prql-dotnet"

#: src/project/bindings/dotnet.md:3
msgid ""
"`prql-net` offers PRQL bindings for .NET bindings as a `netstandard2.0` "
"library."
msgstr ""

#: src/project/bindings/dotnet.md:5
msgid ""
"It provides the `PrqlCompiler` class which contains the `ToJson` and `ToSql` "
"static methods."
msgstr ""

#: src/project/bindings/dotnet.md:8
msgid ""
"It's still at an early stage, and isn't published to NuGet. Contributions "
"are welcome."
msgstr ""

#: src/project/bindings/dotnet.md:13
msgid ""
"Make sure that `libprqlc_c.so` (Linux), `libprqlc_c.dylib` (macOS) or "
"`libprqlc_c.dll` (Windows) is in the project's `bin` directory together with "
"`PrqlCompiler.dll` and the rest of the project's compiled files. I.e. "
"`{your_project}/bin/Debug/net7.0/`."
msgstr ""

#: src/project/bindings/dotnet.md:18
msgid "The `libprqlc_c` library gets dynamically imported at runtime."
msgstr ""

#: src/project/bindings/dotnet.md:22
msgid ""
"```csharp\n"
"using Prql.Compiler;\n"
"\n"
"var options = new PrqlCompilerOptions\n"
"{\n"
"    Format = false,\n"
"    SignatureComment = false,\n"
"};\n"
"var sql = PrqlCompiler.Compile(\"from employees\", options);\n"
"Console.WriteLine(sql);\n"
"```"
msgstr ""

#: src/project/bindings/dotnet.md:34
msgid "TODO"
msgstr ""

#: src/project/bindings/dotnet.md:36
msgid ""
"This is currently at 0.1.0 because we're waiting to update prqlc-c for the "
"latest API. When we've done that, we can match the version here with the "
"broader PRQL version."
msgstr ""

#: src/project/bindings/php.md:1
msgid "prql-php"
msgstr ""

#: src/project/bindings/php.md:3
msgid "`prql-php` offers PHP bindings to `prql-compiler` crate through FFI."
msgstr ""

#: src/project/bindings/php.md:5
msgid ""
"It provides the `Compiler` class which contains `compile`, `prqlToPL`, "
"`plToRQ` and `rqToSQL` functions."
msgstr ""

#: src/project/bindings/php.md:8
msgid ""
"It's still at an early stage, and isn't published to Composer. Contributions "
"are welcome."
msgstr ""

#: src/project/bindings/php.md:13
msgid ""
"The [PHP FFI extension](https://www.php.net/manual/en/book.ffi.php) needs to "
"be enabled. Set `ffi.enable` in your php.ini configuration file to "
"`\"true\"`."
msgstr ""

#: src/project/bindings/php.md:24
msgid "\"from employees\""
msgstr ""

#: src/project/bindings/php.md:31
msgid "Environment"
msgstr ""

#: src/project/bindings/php.md:33
msgid ""
"A way to establish a dev environment with PHP, the ext-ffi extension and "
"Composer is to use a [nix flake](https://github.com/loophp/nix-shell). After "
"installing nix, enable experimental flakes feature:"
msgstr ""

#: src/project/bindings/php.md:37
msgid ""
"```\n"
"mkdir -p ~/.config/nix\n"
"echo \"experimental-features = nix-command flakes\" >> ~/.config/nix/nix."
"conf\n"
"```"
msgstr ""

#: src/project/bindings/php.md:42
msgid "Now you can spawn a shell from `prql-php/`:"
msgstr ""

#: src/project/bindings/php.md:48
msgid ""
"This will pull-in ext-ffi extension, because it's declared in `composer."
"json`."
msgstr ""

#: src/project/bindings/php.md:50
msgid "Building"
msgstr ""

#: src/project/bindings/php.md:52
msgid "There is a `task build-php` script that:"
msgstr ""

#: src/project/bindings/php.md:54
msgid "runs cargo to build `libprqlc_c`,"
msgstr ""

#: src/project/bindings/php.md:55
msgid "copies `libprqlc_c.*` into `lib`,"
msgstr ""

#: src/project/bindings/php.md:56
msgid "copies `prqlc.h` into `lib`."
msgstr ""

#: src/project/bindings/php.md:58
msgid "Tests"
msgstr ""

#: src/project/bindings/php.md:65
msgid "Code style"
msgstr ""

#: src/project/bindings/python.md:1
msgid "Python bindings to `prqlc`"
msgstr ""

#: src/project/bindings/python.md:3
msgid ""
"The `prqlc-python` crate offer Rust bindings to the `prqlc` Rust library, "
"published to a python package named `prqlc`."
msgstr ""

#: src/project/bindings/python.md:6
msgid ""
"The main entry point is a Python method `prqlc.compile(query: str) -> str`."
msgstr ""

#: src/project/bindings/python.md:8
msgid ""
"The package is consumed by [pyprql](https://github.com/prql/pyprql) & [dbt-"
"prql](https://github.com/prql/dbt-prql)."
msgstr ""

#: src/project/bindings/python.md:14
msgid ""
"The crate is not published to crates.io; only to PyPI at <https://pypi.org/"
"project/prql-python/>."
msgstr ""

#: src/project/bindings/python.md:19
msgid "`pip install prqlc`"
msgstr ""

#: src/project/bindings/python.md:26
msgid ""
"\"\"\"\n"
"    from employees\n"
"    join salaries (==emp_id)\n"
"    group {employees.dept_id, employees.gender} (\n"
"      aggregate {\n"
"        avg_salary = average salaries.salary\n"
"      }\n"
"    )\n"
"\"\"\""
msgstr ""

#: src/project/bindings/python.md:37
msgid "\"sql.postgres\""
msgstr ""

#: src/project/bindings/python.md:44
msgid "Relies on [pyo3](https://github.com/PyO3/pyo3) for all the magic."
msgstr ""

#: src/project/bindings/r.md:1
msgid "R (prqlr)"
msgstr ""

#: src/project/bindings/r.md:3
msgid "R bindings for `prqlc`."
msgstr ""

#: src/project/bindings/r.md:5
msgid ""
"`prqlr` also includes `knitr` (R Markdown and Quarto) integration, which "
"allows us to easily create documents with the PRQL conversion results "
"embedded in."
msgstr ""

#: src/project/bindings/r.md:8
msgid "Check out <https://prql.github.io/prqlc-r/> for more context."
msgstr ""

#: src/project/bindings/r.md:10
msgid ""
"```admonish note\n"
"`prqlr` is generously maintained by [@eitsupi](https://github.com/eitsupi) "
"in the\n"
"[PRQL/prqlc-r](https://github.com/PRQL/prqlc-r) repo.\n"
"```"
msgstr ""

#: src/project/bindings/r.md:18
msgid "\"prqlr\""
msgstr ""

#: src/project/bindings/rust.md:1
msgid ""
"Please check the documentation of the [prqlc crate](https://docs.rs/prqlc/"
"latest/prqlc/)."
msgstr ""

#: src/project/changelog.md:1
msgid "PRQL Changelog"
msgstr "PRQL 變更日誌"

#: src/project/changelog.md:3
msgid "0.11.4 — 2023-02-25"
msgstr ""

#: src/project/changelog.md:5
msgid ""
"0.11.4 is a hotfix release, fixing a CI issue that caused the CLI binaries "
"to be built without the `cli` feature."
msgstr ""

#: src/project/changelog.md:8
msgid "0.11.3 — 2023-02-10"
msgstr ""

#: src/project/changelog.md:10
msgid "0.11.3 is a very small release, mostly a rename of the python bindings."
msgstr ""

#: src/project/changelog.md:12
msgid "This release has 13 commits from 4 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:14 src/project/changelog.md:45
#: src/project/changelog.md:126 src/project/changelog.md:314
#: src/project/changelog.md:356 src/project/changelog.md:548
#: src/project/changelog.md:670 src/project/changelog.md:709
#: src/project/changelog.md:812 src/project/changelog.md:897
#: src/project/changelog.md:1127 src/project/changelog.md:1233
#: src/project/changelog.md:1275 src/project/changelog.md:1321
#: src/project/changelog.md:1356 src/project/changelog.md:1376
msgid "**Internal changes**:"
msgstr "**內部變更**："

#: src/project/changelog.md:16
msgid ""
"As part of making our names more consistent, the python bindings are "
"renamed. `prql-python` becomes a package published and importable as "
"`prqlc`. The internal rust crate is named `prqlc-python`."
msgstr ""

#: src/project/changelog.md:20
msgid "0.11.2 — 2023-02-07"
msgstr ""

#: src/project/changelog.md:22
msgid ""
"0.11.2 contains lots of internal changes, lots of syntax highlighting, and "
"the beginning of `lutra`, a query runner."
msgstr ""

#: src/project/changelog.md:25
msgid "This release has 122 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:27 src/project/changelog.md:68
#: src/project/changelog.md:100 src/project/changelog.md:140
#: src/project/changelog.md:183 src/project/changelog.md:329
#: src/project/changelog.md:520 src/project/changelog.md:591
#: src/project/changelog.md:660 src/project/changelog.md:728
#: src/project/changelog.md:875 src/project/changelog.md:910
#: src/project/changelog.md:959 src/project/changelog.md:991
#: src/project/changelog.md:1152 src/project/changelog.md:1215
#: src/project/changelog.md:1258
msgid "**Features**:"
msgstr "**功能**："

#: src/project/changelog.md:29
msgid ""
"Initial implementation of `lutra`, a query runner. (@aljazerzen, #4182, "
"#4174, \\#4134)"
msgstr ""

#: src/project/changelog.md:31
msgid "`prqlc fmt` works on projects with multiple files. (@max-sixty, #4028)"
msgstr ""

#: src/project/changelog.md:33 src/project/changelog.md:76
#: src/project/changelog.md:115 src/project/changelog.md:145
#: src/project/changelog.md:295 src/project/changelog.md:336
#: src/project/changelog.md:539 src/project/changelog.md:691
#: src/project/changelog.md:788 src/project/changelog.md:843
#: src/project/changelog.md:883 src/project/changelog.md:1096
#: src/project/changelog.md:1163 src/project/changelog.md:1222
#: src/project/changelog.md:1263 src/project/changelog.md:1283
#: src/project/changelog.md:1294 src/project/changelog.md:1340
#: src/project/changelog.md:1363
msgid "**Fixes**:"
msgstr ""

#: src/project/changelog.md:35
msgid "Reduce stack memory usage (@aljazerzen, #4103)"
msgstr ""

#: src/project/changelog.md:37 src/project/changelog.md:151
#: src/project/changelog.md:218 src/project/changelog.md:309
#: src/project/changelog.md:350 src/project/changelog.md:544
#: src/project/changelog.md:705 src/project/changelog.md:800
#: src/project/changelog.md:854 src/project/changelog.md:1119
#: src/project/changelog.md:1316 src/project/changelog.md:1351
msgid "**Integrations**:"
msgstr "**整合**："

#: src/project/changelog.md:39
msgid "Add syntax highlight file for GtkSourceView. (@vanillajonathan, #4062)"
msgstr ""

#: src/project/changelog.md:40
msgid "Add syntax highlight file for CotEditor. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:41
msgid "Add syntax highlight file for Sublime Text. (@vanillajonathan, #4127)"
msgstr ""

#: src/project/changelog.md:42
msgid ""
"[sloc](https://github.com/flosse/sloc), a source lines of code counter now "
"has support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:47
msgid ""
"`prql-compiler` has been renamed to `prqlc`, and we've established a more "
"consistent naming scheme. The existing crate will still be published, re-"
"exporting `prqlc`, so no dependencies will break. A future version will add "
"a deprecation warning."
msgstr ""

#: src/project/changelog.md:51
msgid ""
"The `prqlc-clib` crate was renamed to `prqlc-c`, and associated artifacts "
"were renamed. We're trying to make names consistent (ideally for the final "
"time!), and have a plan to rename some other bindings. (@max-sixty, #4077)"
msgstr ""

#: src/project/changelog.md:54
msgid ""
"Add lots of whitespace items to the lexer, in preparation for the completion "
"of `prqlc fmt` (@max-sixty, #4109, #4105)"
msgstr ""

#: src/project/changelog.md:56
msgid "Table declarations (@aljazerzen, #4126)"
msgstr ""

#: src/project/changelog.md:58 src/project/changelog.md:130
#: src/project/changelog.md:250 src/project/changelog.md:318
#: src/project/changelog.md:371 src/project/changelog.md:385
#: src/project/changelog.md:564 src/project/changelog.md:680
#: src/project/changelog.md:820 src/project/changelog.md:832
#: src/project/changelog.md:863 src/project/changelog.md:902
#: src/project/changelog.md:976
msgid "**New Contributors**:"
msgstr ""

#: src/project/changelog.md:60
msgid "@kaspermarstal, with #4124"
msgstr ""

#: src/project/changelog.md:62
msgid "0.11.1 — 2023-12-26"
msgstr ""

#: src/project/changelog.md:64
msgid "0.11.1 fixes a couple of small bugs; it comes a few days after 0.11."
msgstr ""

#: src/project/changelog.md:66
msgid "This release has 16 commits from 6 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:70
msgid ""
"Infer the type of array literals to be the union of types of its items. "
"(@aljazerzen, #3989)"
msgstr ""

#: src/project/changelog.md:72
msgid ""
"`prql` module is added and the `prql_version` function is renamed to the "
"`prql.version` function. The old `prql_version` function is deprecated and "
"will be removed in the future release. (@eitsupi, #4006)"
msgstr ""

#: src/project/changelog.md:78
msgid ""
"Do not compile to `DISTINCT ON` when `take n` is used with `group` for the "
"targets `clickhouse`, `duckdb` and `postgres`. (@PrettyWood, #3988)"
msgstr ""

#: src/project/changelog.md:80
msgid ""
"Fix `take` n rows for `mssql` dialect by switching from TOP to FETCH "
"(@PrettyWood, #3994)"
msgstr ""

#: src/project/changelog.md:83
msgid "0.11.0 — 2023-12-19"
msgstr ""

#: src/project/changelog.md:85
msgid ""
"0.11.0 introduces new `date`, `text` & `math` modules with lots of standard "
"functions, including a new `date.to_text` function. It contains a few bugs "
"fixes, and lots of internal improvements to the compiler."
msgstr ""

#: src/project/changelog.md:89
msgid "This release has 119 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:91 src/project/changelog.md:177
#: src/project/changelog.md:266 src/project/changelog.md:412
msgid "**Language**:"
msgstr "**語言**："

#: src/project/changelog.md:93
msgid ""
"_Breaking_: `group`'s `by` columns are now excluded from the partition. "
"(#3490)"
msgstr ""

#: src/project/changelog.md:95
msgid ""
"_Breaking_: `round` is now in the `math` module and needs to be called via "
"`math.round`. (#3928)"
msgstr ""

#: src/project/changelog.md:97
msgid ""
"_Breaking_: `lower` and `upper` are now in the `text` module and need to be "
"called via `text.lower` and `text.upper`. (#3913, #3973)"
msgstr ""

#: src/project/changelog.md:102
msgid ""
"The `std.in` function now supports a list of values (@PrettyWood, #3883)"
msgstr ""

#: src/project/changelog.md:103
msgid ""
"Most standard mathematical functions are now supported: `abs`, `floor`, "
"`ceil`, `pi`, `exp`, `ln`, `log10`, `log`, `sqrt`, `degrees`, `radians`, "
"`cos`, `acos`, `sin`, `asin`, `tan`, `atan`, `pow` and `round`.  \n"
"Those functions are in the `math` module (@PrettyWood, #3909, #3916 & 3928)"
msgstr ""

#: src/project/changelog.md:107
msgid ""
"Most standard string functions are now supported: `ltrim`, `rtrim`, `trim`, "
"`length`, `extract`, `replace`. Utility functions `starts_with`, `contains` "
"and `ends_with` are also available.  \n"
"Those functions are in the `text` module (@PrettyWood, #3913, #3973)"
msgstr ""

#: src/project/changelog.md:111
msgid ""
"Formatting a date to a text is now available for Clickhouse, DuckDB, MySQL, "
"MSSQL and Postgres. A new `date` module has been added with the `to_text` "
"function (@PrettyWood, #3951, #3954 & #3955)"
msgstr ""

#: src/project/changelog.md:117
msgid "Fix an issue with arithmetic precedence (@max-sixty, #3846)"
msgstr ""

#: src/project/changelog.md:118
msgid "`+` and `-` can be used after a cast (@PrettyWood, #3923)"
msgstr ""

#: src/project/changelog.md:119
msgid ""
"The [Lezer](https://lezer.codemirror.net/) grammar had plenty of "
"improvements and fixes. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:122 src/project/changelog.md:208
#: src/project/changelog.md:305 src/project/changelog.md:344
#: src/project/changelog.md:665 src/project/changelog.md:1114
#: src/project/changelog.md:1312
msgid "**Web**:"
msgstr ""

#: src/project/changelog.md:124
msgid "The Playground now uses [Vite](https://vitejs.dev/). (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:128
msgid "Bump `prql-compiler`'s MSRV to 1.70.0 (@eitsupi, #3876)"
msgstr ""

#: src/project/changelog.md:132
msgid "@PrettyWood, with #3883"
msgstr ""

#: src/project/changelog.md:134
msgid "0.10.1 — 2023-11-14"
msgstr ""

#: src/project/changelog.md:136
msgid ""
"0.10.1 is a small release containing some internal fixes of the compiler."
msgstr ""

#: src/project/changelog.md:138
msgid "This release has 36 commits from 7 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:142
msgid ""
"The `std.sql.read_csv` function and the `std.sql.read_parquet` function "
"supports the `sql.glaredb` target. (@eitsupi, #3749)"
msgstr ""

#: src/project/changelog.md:147
msgid ""
"Fix the bug of compiling to `DISTINCT ON` when `take 1` is used with `group "
"by` for the targets `sql.clickhouse`, `sql.duckdb` and `sql.postgres`. "
"(@aljazerzen, #3792)"
msgstr ""

#: src/project/changelog.md:153
msgid "Enable integration tests for GlareDB. (@eitsupi, #3749)"
msgstr ""

#: src/project/changelog.md:154
msgid ""
"[trapd00r/LS_COLORS](https://github.com/trapd00r/LS_COLORS), a collection of "
"LS_COLORS definitions colorizes `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:156
msgid ""
"[vivid](https://github.com/sharkdp/vivid), a themeable LS_COLORS generator "
"colorizes `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:158
msgid ""
"[colorls](https://github.com/athityakumar/colorls), displays `.prql` files "
"with a database icon. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:160
msgid ""
"[Emoji File Icons](https://marketplace.visualstudio.com/items?"
"itemName=mightbesimon.emoji-icons), a VS Code extension displays `.prql` "
"files with a database emoji icon. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:163
msgid ""
"[eza](https://eza.rocks/), a modern ls replacement colorizes `.prql` files. "
"(@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:165
msgid ""
"[lsd](https://github.com/lsd-rs/lsd), next gen ls command displays `.prql` "
"files with a database icon. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:168
msgid "0.10.0 — 2023-10-26"
msgstr ""

#: src/project/changelog.md:170
msgid ""
"0.10.0 contains lots of small improvements, including support for new types "
"of literal notation, support for `read_*` functions in more dialects, "
"playground improvements, and a better Lezer grammar (which we're planning on "
"using for a Jupyter extension)."
msgstr ""

#: src/project/changelog.md:175
msgid "This release has 155 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:179
msgid ""
"_Breaking:_ Case syntax now uses brackets `[]` rather than braces `{}`. To "
"convert previous PRQL queries to this new syntax simply change `case { ... }"
"` to `case [ ... ]`. (@AaronMoat, #3517)"
msgstr ""

#: src/project/changelog.md:185
msgid ""
"_Breaking_: The `std.sql.read_csv` function is now compiled to `read_csv` by "
"default. Please set the target `sql.duckdb` to use the DuckDB's "
"`read_csv_auto` function as previously. (@eitsupi, #3599)"
msgstr ""

#: src/project/changelog.md:188
msgid ""
"_Breaking_: The `std.every` function is renamed to `std.all` (@aljazerzen, "
"\\#3703)"
msgstr ""

#: src/project/changelog.md:190
msgid ""
"The `std.sql.read_csv` function and the `std.sql.read_parquet` function "
"supports the `sql.clickhouse` target. (@eitsupi, #1533)"
msgstr ""

#: src/project/changelog.md:192
msgid "Add `std.prql_version` function to return PRQL version (@hulxv, #3533)"
msgstr ""

#: src/project/changelog.md:193
msgid "A new type `anytype` is added. (@aljazerzen, #3703)"
msgstr ""

#: src/project/changelog.md:194
msgid ""
"Add support for hex escape sequences in strings. Example `\"Hello \\x51\"`. "
"(@vanillajonathan, #3568)"
msgstr ""

#: src/project/changelog.md:196
msgid ""
"Add support for long Unicode escape sequences. Example `\"Hello "
"\\u{01F422}\"`. (@vanillajonathan, #3569)"
msgstr ""

#: src/project/changelog.md:198
msgid ""
"Add support for binary numerical notation. Example `filter status == "
"0b1111000011110000`. (@vanillajonathan, #3661)"
msgstr ""

#: src/project/changelog.md:200
msgid ""
"Add support for hexadecimal numerical notation. Example `filter status == "
"0xff`. (@vanillajonathan, #3654)"
msgstr ""

#: src/project/changelog.md:202
msgid ""
"Add support for octal numerical notation. Example `filter status == 0o777`. "
"(@vanillajonathan, #3672)"
msgstr ""

#: src/project/changelog.md:204
msgid ""
"New compile target `sql.glaredb` for [GlareDB](https://docs.glaredb.com/) "
"and integration tests for it (However, there is a bug in the test and it is "
"currently not running). (@universalmind303, @scsmithr, @eitsupi, #3669)"
msgstr ""

#: src/project/changelog.md:210
msgid ""
"Allow cmd-/ (Mac) or ctrl-/ (Windows) to toggle comments in the playground "
"editor (@AaronMoat, #3522)"
msgstr ""

#: src/project/changelog.md:213
msgid ""
"Limit maximum height of the playground editor's error panel to avoid taking "
"over whole screen (@AaronMoat, #3524)"
msgstr ""

#: src/project/changelog.md:216
msgid "The playground now uses [Vite](https://vitejs.dev/) (@vanillajonathan)."
msgstr ""

#: src/project/changelog.md:220
msgid ""
"Add a CLI command `prqlc collect` to collect a project's modules into a "
"single file (@aljazerzen, #3739)"
msgstr ""

#: src/project/changelog.md:222
msgid ""
"Add a CLI command `prqlc debug expand-pl` to parse & and expand into PL "
"without resolving (@aljazerzen, #3739)"
msgstr ""

#: src/project/changelog.md:224
msgid "Bump `prqlc`'s MSRV to 1.70.0 (@eitsupi, #3521)"
msgstr ""

#: src/project/changelog.md:225
msgid ""
"[Pygments](https://pygments.org/), a syntax highlighting library now has "
"syntax highlighting for PRQL. (@vanillajonathan, #3564)"
msgstr ""

#: src/project/changelog.md:227
msgid ""
"[chroma](https://github.com/alecthomas/chroma), a syntax highlighting "
"library written in Go and used by the static website generator [Hugo]"
"(https://gohugo.io/). (@vanillajonathan, #3597)"
msgstr ""

#: src/project/changelog.md:230
msgid ""
"[scc](https://github.com/boyter/scc), a source lines of code counter now has "
"support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:232
msgid ""
"[gcloc](https://github.com/JoaoDanielRufino/gcloc) a source lines of code "
"counter now has support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:234
msgid ""
"[cloc](https://github.com/AlDanial/cloc) a source lines of code counter now "
"has support for `.prql` files. (@AlDanial)"
msgstr ""

#: src/project/changelog.md:236
msgid ""
"[gocloc](https://github.com/hhatto/gocloc) a source lines of code counter "
"now has support for `.prql` files. (@vanillajonathan)"
msgstr ""

#: src/project/changelog.md:238
msgid ""
"[The Quarto VS Code extension](https://marketplace.visualstudio.com/items?"
"itemName=quarto.quarto) supports editing PRQL code blocks ([`prqlr`](https://"
"prql-lang.org/book/project/bindings/r.html) is required to render Quarto "
"Markdown with PRQL code blocks). (@jjallaire)"
msgstr ""

#: src/project/changelog.md:243 src/project/changelog.md:1169
msgid "**Internal**:"
msgstr ""

#: src/project/changelog.md:245
msgid ""
"Rename some of the internal crates, and refactored their paths in the repo. "
"(@aljazerzen, #3683)."
msgstr ""

#: src/project/changelog.md:247
msgid ""
"Add a `justfile` for developers who prefer that above our `Taskfile.yml` "
"(@aljazerzen, #3681)"
msgstr ""

#: src/project/changelog.md:252
msgid "@hulxv, with #3533"
msgstr ""

#: src/project/changelog.md:253
msgid "@AaronMoat, with #3522"
msgstr ""

#: src/project/changelog.md:254
msgid "@jangorecki, with #3634"
msgstr ""

#: src/project/changelog.md:256
msgid "0.9.5 — 2023-09-16"
msgstr ""

#: src/project/changelog.md:258
msgid ""
"0.9.5 adds a line-wrapping character, fixes a few bugs, and improves our CI. "
"The release has 77 commits from 8 contributors. Selected changes are below."
msgstr ""

#: src/project/changelog.md:261
msgid ""
"Look out for some conference talks coming up over the next few weeks, "
"including [QCon SF on Oct 2](https://qconsf.com/presentation/oct2023/prql-"
"simple-powerful-pipelined-sql-replacement) and [date2day on Oct 12](https://"
"www.data2day.de/veranstaltung-21353-0-prql-a-modern-language-for-data-"
"transformation.html)."
msgstr ""

#: src/project/changelog.md:268
msgid ""
"A new line-wrapping character, for lines that are long and we want to break "
"up into multiple physical lines. This is slightly different from from many "
"languages — it's on the subsequent line:"
msgstr ""

#: src/project/changelog.md:272
msgid ""
"```prql no-eval\n"
"from artists\n"
"select is_europe =\n"
"\\ country == \"DE\"\n"
"\\ || country == \"FR\"\n"
"\\ || country == \"ES\"\n"
"```"
msgstr ""

#: src/project/changelog.md:280
msgid ""
"This allows for easily commenting out physical lines while maintaining a "
"correct logical line; for example:"
msgstr ""

#: src/project/changelog.md:293
msgid "(@max-sixty, #3408)"
msgstr ""

#: src/project/changelog.md:297
msgid ""
"Fix stack overflow on very long queries in Windows debug builds (@max-sixty, "
"\\#2908)"
msgstr ""

#: src/project/changelog.md:300
msgid ""
"Fix panic when unresolved lineage appears in group or window (@davidot, "
"#3266)"
msgstr ""

#: src/project/changelog.md:302
msgid ""
"Fix a corner-case in handling precedence, and remove unneeded parentheses in "
"some outputs (@max-sixty, #3472)"
msgstr ""

#: src/project/changelog.md:307
msgid "Compiler panics are now printed to the console (@max-sixty, #3446)"
msgstr ""

#: src/project/changelog.md:311
msgid ""
"[Ace](https://ace.c9.io/), the JavaScript code editor now has syntax "
"highlighting for PRQL. (@vanillajonathan, #3493)"
msgstr ""

#: src/project/changelog.md:316
msgid "Simplify & speed up lexer (@max-sixty, #3426, #3418)"
msgstr ""

#: src/project/changelog.md:320
msgid "@davidot, with #3450"
msgstr ""

#: src/project/changelog.md:322
msgid "0.9.4 — 2023-08-24"
msgstr ""

#: src/project/changelog.md:324
msgid ""
"0.9.4 is a small release with some improvements and bug fixes in the "
"compiler and `prqlc`. And, the documentation and CI are continually being "
"improved."
msgstr ""

#: src/project/changelog.md:327
msgid "This release has 110 commits from 9 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:331
msgid ""
"Strings can be delimited with any odd number of quote characters. The logic "
"for lexing quotes is now simpler and slightly faster. Escapes in single-"
"quote-delimited strings escape single-quotes rather than double-quotes. "
"(@max-sixty, #3274)"
msgstr ""

#: src/project/changelog.md:338
msgid "S-strings within double braces now parse correctly (@max-sixty, #3265)"
msgstr ""

#: src/project/changelog.md:340 src/project/changelog.md:699
#: src/project/changelog.md:794 src/project/changelog.md:850
#: src/project/changelog.md:890 src/project/changelog.md:1102
#: src/project/changelog.md:1228 src/project/changelog.md:1269
#: src/project/changelog.md:1307 src/project/changelog.md:1345
#: src/project/changelog.md:1371
msgid "**Documentation**:"
msgstr "**文件**："

#: src/project/changelog.md:342
msgid "New docs for strings (@max-sixty, #3281)"
msgstr ""

#: src/project/changelog.md:346
msgid ""
"Improve syntax highlighting for numbers in the book & website (@max-sixty, "
"\\#3261)"
msgstr ""

#: src/project/changelog.md:348
msgid "Add ClickHouse integration to docs (@max-sixty, #3251)"
msgstr ""

#: src/project/changelog.md:352
msgid ""
"`prqlc` no longer displays a prompt when piping a query into its stdin (@max-"
"sixty, #3248)."
msgstr ""

#: src/project/changelog.md:354
msgid ""
"Add a minimal example for use `prql-lib` with Zig (@vanillajonathan, #3372)"
msgstr ""

#: src/project/changelog.md:358
msgid ""
"Overhaul our CI to run a cohesive set of tests depending on the specific "
"changes in the PR, and elide all others. This cuts CI latency to less than "
"three minutes for most changes, and enables GitHub's auto-merge to wait for "
"all relevant tests. It also reduces the CI time on merging to main, by "
"moving some tests to only run on specific path changes or on our nightly run."
msgstr ""

#: src/project/changelog.md:364
msgid ""
"We now have one label we can add to PRs to run more tests — `pr-nightly`. "
"(@max-sixty, #3317 & others)."
msgstr ""

#: src/project/changelog.md:367
msgid "Auto-merge PRs for backports or pre-commit updates (@max-sixty, #3246)"
msgstr ""

#: src/project/changelog.md:368
msgid ""
"Add a workflow to create an issue when the scheduled nightly workflow fails "
"(@max-sixty, #3304)"
msgstr ""

#: src/project/changelog.md:373
msgid "@FinnRG, with #3292"
msgstr ""

#: src/project/changelog.md:374
msgid "@sitiom, with #3353"
msgstr ""

#: src/project/changelog.md:376
msgid "0.9.3 — 2023-08-02"
msgstr ""

#: src/project/changelog.md:378
msgid ""
"0.9.3 is a small release, with mostly documentation, internal, and CI "
"changes."
msgstr ""

#: src/project/changelog.md:380
msgid "This release has 85 commits from 10 contributors."
msgstr ""

#: src/project/changelog.md:382
msgid ""
"We'd like to welcome @not-my-profile as someone who has helped with lots of "
"internal refactoring in the past couple of weeks."
msgstr ""

#: src/project/changelog.md:387
msgid "@vthriller, with #3171"
msgstr ""

#: src/project/changelog.md:388
msgid "@postmeback, with #3216"
msgstr ""

#: src/project/changelog.md:390
msgid "0.9.2 — 2023-07-25"
msgstr ""

#: src/project/changelog.md:392
msgid ""
"0.9.2 is a hotfix release to fix an issue in the 0.9.0 & 0.9.1 release "
"pipelines."
msgstr ""

#: src/project/changelog.md:395
msgid "0.9.1 — 2023-07-25"
msgstr ""

#: src/project/changelog.md:397
msgid ""
"0.9.1 is a hotfix release to fix an issue in the 0.9.0 release pipeline."
msgstr ""

#: src/project/changelog.md:399
msgid "0.9.0 — 2023-07-24"
msgstr ""

#: src/project/changelog.md:401
msgid ""
"0.9.0 is probably PRQL's biggest ever release. We have dialect-specific "
"standard-libraries, a regex operator, an initial implementation of multiple-"
"file projects & modules, lots of bug fixes, and many many internal changes."
msgstr ""

#: src/project/changelog.md:405
msgid ""
"We've made a few backward incompatible syntax changes. Most queries will "
"work with a simple find/replace; see below for details."
msgstr ""

#: src/project/changelog.md:408
msgid "The release has 421 commits from 12 contributors."
msgstr ""

#: src/project/changelog.md:410 src/project/changelog.md:658
msgid "A small selection of the changes:"
msgstr ""

#: src/project/changelog.md:414
msgid ""
"The major breaking change is a new syntax for lists, which have been renamed "
"to _tuples_, and are now represented with braces `{}` rather than brackets "
"`[]`."
msgstr ""

#: src/project/changelog.md:418
msgid ""
"To convert previous PRQL queries to this new syntax simply change `[ ... ]` "
"to `{ ... }`."
msgstr ""

#: src/project/changelog.md:421
msgid ""
"We made the syntax change to incorporate arrays. Almost every major language "
"uses `[]` for arrays. We are adopting that convention — arrays use `[]`, "
"tuples will use `{}`. (Though we recognize that `{}` for tuples is also rare "
"(Hi, Erlang!), but didn't want to further load parentheses with meaning.)"
msgstr ""

#: src/project/changelog.md:426
msgid ""
"Arrays are conceptually similar to columns — their elements have a single "
"type. Array syntax can't contain assignments."
msgstr ""

#: src/project/changelog.md:429
msgid ""
"As part of this, we've also formalized tuples as containing both individual "
"items (`select {foo, baz}`), and assignments (`select {foo=bar, baz=fuz}`)."
msgstr ""

#: src/project/changelog.md:432
msgid "Some significant changes regarding SQL dialects:"
msgstr ""

#: src/project/changelog.md:434
msgid ""
"Operators and functions can be defined on per-dialect basis. (@aljazerzen, "
"\\#2681)"
msgstr ""

#: src/project/changelog.md:436
msgid ""
"_Breaking_: The `sql.duckdb` target supports DuckDB 0.8 (@eitsupi, #2810)."
msgstr ""

#: src/project/changelog.md:437
msgid "_Breaking_: The `sql.hive` target is removed (@eitsupi, #2837)."
msgstr ""

#: src/project/changelog.md:439
msgid ""
"New arithmetic operators. These compile to different function or operator "
"depending on the target."
msgstr ""

#: src/project/changelog.md:442
msgid ""
"_Breaking_: Operator `/` now always performs floating division (@aljazerzen, "
"\\#2684). See the [Division docs](https://prql-lang.org/book/reference/"
"syntax/operators.html#division-and-integer-division) for details."
msgstr ""

#: src/project/changelog.md:447
msgid ""
"Truncated integer division operator `//` (@aljazerzen, #2684). See the "
"[Division docs](https://prql-lang.org/book/reference/syntax/operators."
"html#division-and-integer-division) for details."
msgstr ""

#: src/project/changelog.md:451
msgid "Regex search operator `~=` (@max-sixty, #2458). An example:"
msgstr ""

#: src/project/changelog.md:453
msgid ""
"```prql no-eval\n"
"from tracks\n"
"filter (name ~= \"Love\")\n"
"```"
msgstr ""

#: src/project/changelog.md:458
msgid "...compiles to;"
msgstr ""

#: src/project/changelog.md:466
msgid "'Love'"
msgstr ""

#: src/project/changelog.md:469
msgid ""
"...though the exact form differs by dialect; see the [Regex docs](https://"
"prql-lang.org/book/reference/syntax/operators.html#regex) for more details."
msgstr ""

#: src/project/changelog.md:473
msgid ""
"New aggregation functions: `every`, `any`, `average`, and `concat_array`. "
"_Breaking:_ Remove `avg` in favor of `average`."
msgstr ""

#: src/project/changelog.md:476
msgid ""
"_Breaking:_ We've changed our function declaration syntax to match other "
"declarations. Functions were one of the first language constructs in PRQL, "
"and since then we've added normal declarations there's no compelling reason "
"for functions to be different."
msgstr ""

#: src/project/changelog.md:485
msgid "Previously, this was:"
msgstr ""

#: src/project/changelog.md:491
msgid ""
"Experimental modules, which allow importing declarations from other files. "
"Docs are forthcoming."
msgstr ""

#: src/project/changelog.md:494
msgid ""
"Relation literals create a relation (a \"table\") as an _array_ of _tuples_. "
"This example demonstrates the new syntax for arrays `[]` and tuples `{}`. "
"(@aljazerzen, #2605)"
msgstr ""

#: src/project/changelog.md:504
msgid ""
"`this` can be used to refer to the current pipeline, for situations where "
"plain column name would be ambiguous:"
msgstr ""

#: src/project/changelog.md:513
msgid ""
"Within a `join` transform, there is also a reference to the right relation: "
"`that`."
msgstr ""

#: src/project/changelog.md:516
msgid ""
"_Breaking:_ functions `count`, `rank` and `row_number` now require an "
"argument of the array to operate on. In most cases you can directly replace "
"`count` with `count this`. The `non_null` argument of `count` has been "
"removed."
msgstr ""

#: src/project/changelog.md:522
msgid "We've changed how we handle colors."
msgstr ""

#: src/project/changelog.md:524
msgid ""
"`Options::color` is deprecated and has no effect. Code which consumes "
"`prql_compiler::compile` should instead accept the output with colors and "
"use a library such as `anstream` to handle the presentation of colors. To "
"ensure minimal disruption, `prql_compiler` will currently strip color codes "
"when a standard environment variable such as `CLI_COLOR=0` is set or when it "
"detects `stderr` is not a TTY."
msgstr ""

#: src/project/changelog.md:531
msgid ""
"We now use the [`anstream`](https://github.com/rust-cli/anstyle) library in "
"`prqlc` & `prql-compiler`."
msgstr ""

#: src/project/changelog.md:534
msgid "(@max-sixty, #2773)"
msgstr ""

#: src/project/changelog.md:536
msgid ""
"`prqlc` can now show backtraces when the standard backtrace env var "
"(`RUST_BACKTRACE`) is active. (@max-sixty, #2751)"
msgstr ""

#: src/project/changelog.md:541
msgid ""
"Numbers expressed with scientific notation — `1e9` — are now handled "
"correctly by the compiler (@max-sixty, #2865)."
msgstr ""

#: src/project/changelog.md:546
msgid "prql-python now provides type hints (@philpep, #2912)"
msgstr ""

#: src/project/changelog.md:550
msgid ""
"Annotations in PRQL. These have limited support but are currently used to "
"specify binding strengths. They're modeled after Rust's annotations, but "
"with `@` syntax, more similar to traditional decorators. (#2729)"
msgstr ""

#: src/project/changelog.md:554
msgid ""
"```prql no-eval\n"
"@{binding_strength=11}\n"
"let mod = l r -> s\"{l} % {r}\"\n"
"```"
msgstr ""

#: src/project/changelog.md:559
msgid ""
"Remove BigQuery's special handling of quoted identifiers, now that our "
"module system handles its semantics (@max-sixty, #2609)."
msgstr ""

#: src/project/changelog.md:562
msgid "ClickHouse is tested in CI (@eitsupi, #2815)."
msgstr ""

#: src/project/changelog.md:566
msgid "@maxmcd, with #2533"
msgstr ""

#: src/project/changelog.md:567
msgid "@khoa165, with #2876"
msgstr ""

#: src/project/changelog.md:568
msgid "@philpep, with #2912"
msgstr ""

#: src/project/changelog.md:569
msgid "@not-my-profile, with #2971"
msgstr ""

#: src/project/changelog.md:571
msgid "0.8.1 — 2023-04-29"
msgstr ""

#: src/project/changelog.md:573
msgid ""
"0.8.1 is a small release with a new `list-targets` command in `prqlc`, some "
"documentation improvements, and some internal improvements."
msgstr ""

#: src/project/changelog.md:576
msgid "This release has 41 commits from 8 contributors."
msgstr ""

#: src/project/changelog.md:578
msgid ""
"From the broader perspective of the project, we're increasing the relative "
"prioritization of it being easy for folks to actually use PRQL — either with "
"existing tools, or a tool we'd build. We'll be thinking about & discussing "
"the best way to do that over the next few weeks."
msgstr ""

#: src/project/changelog.md:583
msgid "0.8.0 — 2023-04-14"
msgstr ""

#: src/project/changelog.md:585
msgid ""
"0.8.0 renames the `and` & `or` operators to `&&` & `||` respectively, "
"reorganizes the Syntax section in the book, and introduces `read_parquet` & "
"`read_csv` functions for reading files with DuckDB."
msgstr ""

#: src/project/changelog.md:589
msgid "This release has 38 commits from 8 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:593
msgid ""
"Rename `and` to `&&` and `or` to `||`. Operators which are symbols are now "
"consistently infix, while \"words\" are now consistently functions "
"(@aljazerzen, \\#2422)."
msgstr ""

#: src/project/changelog.md:597
msgid ""
"New functions `read_parquet` and `read_csv`, which mirror the DuckDB "
"functions, instructing the database to read from files (@max-sixty, #2409)."
msgstr ""

#: src/project/changelog.md:600
msgid "0.7.1 — 2023-04-03"
msgstr ""

#: src/project/changelog.md:602
msgid ""
"0.7.1 is a hotfix release to fix `prql-js`'s `npm install` behavior when "
"being installed as a dependency."
msgstr ""

#: src/project/changelog.md:605
msgid "This release has 17 commits from 4 contributors."
msgstr ""

#: src/project/changelog.md:607
msgid "0.7.0 — 2023-04-01"
msgstr ""

#: src/project/changelog.md:609
msgid ""
"0.7.0 is a fairly small release in terms of new features, with lots of "
"internal improvements, such as integration tests with a whole range of DBs, "
"a blog post on Pi day, RFCs for a type system, and more robust language "
"bindings."
msgstr ""

#: src/project/changelog.md:613
msgid ""
"There's a very small breaking change to the rust API, hence the minor "
"version bump."
msgstr ""

#: src/project/changelog.md:616
msgid ""
"Here's our April 2023 Update, from our [Readme](https://github.com/PRQL/prql/"
"blob/main/README.md):"
msgstr ""

#: src/project/changelog.md:619
msgid "April 2023 update"
msgstr ""

#: src/project/changelog.md:621
msgid ""
"PRQL is being actively developed by a growing community. It's ready to use "
"by the intrepid, either as part of one of our supported extensions, or "
"within your own tools, using one of our supported language bindings."
msgstr ""

#: src/project/changelog.md:625
msgid ""
"PRQL still has some minor bugs and some missing features, and probably is "
"only ready to be rolled out to non-technical teams for fairly simple queries."
msgstr ""

#: src/project/changelog.md:628
msgid ""
"Here's our current [Roadmap](https://prql-lang.org/roadmap/) and our "
"[Milestones.](https://github.com/PRQL/prql/milestones)"
msgstr ""

#: src/project/changelog.md:631
msgid "Our immediate focus for the code is on:"
msgstr ""

#: src/project/changelog.md:633
msgid ""
"Building out the next few big features, including [types](https://github.com/"
"PRQL/prql/pull/1964) and [modules](https://github.com/PRQL/prql/pull/2129)."
msgstr ""

#: src/project/changelog.md:636
msgid ""
"Ensuring our supported features feel extremely robust; resolving any "
"[priority bugs](https://github.com/PRQL/prql/issues?"
"q=is%3Aissue+is%3Aopen+label%3Abug+label%3Apriority)."
msgstr ""

#: src/project/changelog.md:639
msgid "We're also spending time thinking about:"
msgstr ""

#: src/project/changelog.md:641
msgid ""
"Making it really easy to start using PRQL. We're doing that by building "
"integrations with tools that folks already use; for example our VS Code "
"extension & Jupyter integration. If there are tools you're familiar with "
"that you think would be open to integrating with PRQL, please let us know in "
"an issue."
msgstr ""

#: src/project/changelog.md:646
msgid ""
"Making it easier to contribute to the compiler. We have a wide group of "
"contributors to the project, but contributions to the compiler itself are "
"quite concentrated. We're keen to expand this; [\\#1840](https://github.com/"
"PRQL/prql/issues/1840) for feedback."
msgstr ""

#: src/project/changelog.md:653
msgid ""
"The release has 131 commits from 10 contributors. Particular credit goes to "
"to @eitsupi & @jelenkee, who have made significant contributions, and "
"@vanillajonathan, whose prolific contribution include our growing language "
"bindings."
msgstr ""

#: src/project/changelog.md:662
msgid ""
"`prqlc compile` adds `--color` & `--include-signature-comment` options. "
"(@max-sixty, #2267)"
msgstr ""

#: src/project/changelog.md:667
msgid ""
"Added the PRQL snippets from the book to the [Playground](https://prql-lang."
"org/playground/) (@jelenkee, #2197)"
msgstr ""

#: src/project/changelog.md:672
msgid ""
"_Breaking_: The `compile` function's `Options` now includes a `color` "
"member, which determines whether error messages use ANSI color codes. This "
"is technically a breaking change to the API. (@max-sixty, #2251)"
msgstr ""

#: src/project/changelog.md:675
msgid ""
"The `Error` struct now exposes the `MessageKind` enum. (@vanillajonathan, "
"\\#2307)"
msgstr ""

#: src/project/changelog.md:677
msgid ""
"Integration tests run in CI with DuckDB, SQLite, PostgreSQL, MySQL and SQL "
"Server (@jelenkee, #2286)"
msgstr ""

#: src/project/changelog.md:682
msgid "@k-nut, with #2294"
msgstr ""

#: src/project/changelog.md:684
msgid "0.6.1 — 2023-03-12"
msgstr ""

#: src/project/changelog.md:686
msgid ""
"0.6.1 is a small release containing an internal refactoring and improved "
"bindings for C, PHP & .NET."
msgstr ""

#: src/project/changelog.md:689
msgid "This release has 54 commits from 6 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:693
msgid ""
"No longer incorrectly compile to `DISTINCT` when a `take 1` refers to a "
"different set of columns than are in the `group`. (@max-sixty, with thanks "
"to @cottrell, #2109)"
msgstr ""

#: src/project/changelog.md:696
msgid ""
"The version specification of the dependency Chumsky was bumped from `0.9.0` "
"to `0.9.2`. `0.9.0` has a bug that causes an infinite loop. (@eitsupi, #2110)"
msgstr ""

#: src/project/changelog.md:701
msgid ""
"Add a policy for which bindings are supported / unsupported / nascent. See "
"<https://prql-lang.org/book/project/bindings/index.html> for more details "
"(@max-sixty, #2062) (@max-sixty, #2062)"
msgstr ""

#: src/project/changelog.md:707
msgid "\\[prql-lib\\] Added C++ header file. (@vanillajonathan, #2126)"
msgstr ""

#: src/project/changelog.md:711
msgid ""
"Many of the items that were in the root of the repo have been aggregated "
"into `web` & `bindings`, simplifying the repo's structure. There's also "
"`grammars` & `packages` (@max-sixty, #2135, #2117, #2121)."
msgstr ""

#: src/project/changelog.md:715
msgid "0.6.0 — 2023-03-08"
msgstr ""

#: src/project/changelog.md:717
msgid ""
"0.6.0 introduces a rewritten parser, giving us the ability to dramatically "
"improve error messages, renames `switch` to `case` and includes lots of "
"minor improvements and fixes. It also introduces `loop`, which compiles to "
"`WITH RECURSIVE`, as a highly experimental feature."
msgstr ""

#: src/project/changelog.md:722
msgid ""
"There are a few cases of breaking changes, including switching `switch` to "
"`case`, in case that's confusing. There are also some minor parsing changes "
"outlined below."
msgstr ""

#: src/project/changelog.md:726
msgid "This release has 108 commits from 11 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:730
msgid ""
"Add a (highly experimental) `loop` language feature, which translates to "
"`WITH RECURSIVE`. We expect changes and refinements in upcoming releases. "
"(#1642, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:733
msgid ""
"Rename the experimental `switch` function to `case` given it more closely "
"matches the traditional semantics of `case`. (@max-sixty, #2036)"
msgstr ""

#: src/project/changelog.md:735
msgid ""
"Change the `case` syntax to use `=>` instead of `->` to distinguish it from "
"function syntax."
msgstr ""

#: src/project/changelog.md:737
msgid "Convert parser from pest to Chumsky (@aljazerzen, #1818)"
msgstr ""

#: src/project/changelog.md:738
msgid ""
"Improved error messages, and the potential to make even better in the "
"future. Many of these improvements come from error recovery."
msgstr ""

#: src/project/changelog.md:740
msgid "String escapes (`\\n \\t`)."
msgstr ""

#: src/project/changelog.md:741
msgid "Raw strings that don't escape backslashes."
msgstr ""

#: src/project/changelog.md:742
msgid ""
"String interpolations can only contain identifiers and not any expression."
msgstr ""

#: src/project/changelog.md:743
msgid ""
"Operator associativity has been changed from right-to-left to left-to-right "
"to be more similar to other conventional languages."
msgstr ""

#: src/project/changelog.md:745
msgid ""
"`and` now has a higher precedence than `or` (of same reason as the previous "
"point)."
msgstr ""

#: src/project/changelog.md:747
msgid "Dates, times and timestamps have stricter parsing rules."
msgstr ""

#: src/project/changelog.md:748
msgid "`let`, `func`, `prql`, `case` are now treated as keywords."
msgstr ""

#: src/project/changelog.md:749
msgid "Float literals without fraction part are not allowed anymore (`1.`)."
msgstr ""

#: src/project/changelog.md:750
msgid ""
"Add a `--format` option to `prqlc parse` which can return the AST in YAML "
"(@max-sixty, #1962)"
msgstr ""

#: src/project/changelog.md:752
msgid "Add a new subcommand `prqlc jinja`. (@aljazerzen, #1722)"
msgstr ""

#: src/project/changelog.md:753
msgid ""
"_Breaking_: prql-compiler no longer passes text containing `{{` & `}}` "
"through to the output. (@aljazerzen, #1722)"
msgstr ""

#: src/project/changelog.md:756
msgid "For example, the following PRQL query"
msgstr ""

#: src/project/changelog.md:762
msgid ""
"was compiled to the following SQL previously, but now it raises an error."
msgstr ""

#: src/project/changelog.md:771
msgid "This pass-through feature existed for integration with dbt."
msgstr ""

#: src/project/changelog.md:773
msgid ""
"We're again considering how to best integrate with dbt, and this change is "
"based on the idea that the jinja macro should run before the PRQL compiler."
msgstr ""

#: src/project/changelog.md:776
msgid ""
"If you're interested in dbt integration, subscribe or 👍 to <https://github."
"com/dbt-labs/dbt-core/pull/5982>."
msgstr ""

#: src/project/changelog.md:779
msgid ""
"A new compile target `\"sql.any\"`. When `\"sql.any\"` is used as the target "
"of the compile function's option, the target contained in the query header "
"will be used. (@aljazerzen, #1995)"
msgstr ""

#: src/project/changelog.md:782
msgid "Support for SQL parameters with similar syntax (#1957, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:783
msgid ""
"Allow `:` to be elided in timezones, such as `0800` in "
"`@2020-01-01T13:19:55-0800` (@max-sixty, #1991)."
msgstr ""

#: src/project/changelog.md:785
msgid ""
"Add `std.upper` and `std.lower` functions for changing string casing "
"(@Jelenkee, #2019)."
msgstr ""

#: src/project/changelog.md:790
msgid ""
"`prqlc compile` returns a non-zero exit code for invalid queries. (@max-"
"sixty, \\#1924)"
msgstr ""

#: src/project/changelog.md:792
msgid ""
"Identifiers can contain any alphabetic unicode characters (@max-sixty, #2003)"
msgstr ""

#: src/project/changelog.md:796
msgid "Operator precedence (@aljazerzen, #1818)"
msgstr ""

#: src/project/changelog.md:797
msgid ""
"Error messages for invalid queries are displayed in the book (@max-sixty, "
"\\#2015)"
msgstr ""

#: src/project/changelog.md:802
msgid "\\[prql-php\\] Added PHP bindings. (@vanillajonathan, #1860)"
msgstr ""

#: src/project/changelog.md:803
msgid "\\[prql-dotnet\\] Added .NET bindings. (@vanillajonathan, #1917)"
msgstr ""

#: src/project/changelog.md:804
msgid "\\[prql-lib\\] Added C header file. (@vanillajonathan, #1879)"
msgstr ""

#: src/project/changelog.md:805
msgid ""
"Added a workflow building a `.deb` on each release. (Note that it's not yet "
"published on each release). (@vanillajonathan, #1883)"
msgstr ""

#: src/project/changelog.md:807
msgid ""
"Added a workflow building a `.rpm` on each release. (Note that it's not yet "
"published on each release). (@vanillajonathan, #1918)"
msgstr ""

#: src/project/changelog.md:809
msgid ""
"Added a workflow building a Snap package on each release. (@vanillajonathan, "
"\\#1881)"
msgstr ""

#: src/project/changelog.md:814
msgid ""
"Test that the output of our nascent autoformatter can be successfully "
"compiled into SQL. Failing examples are now clearly labeled. (@max-sixty, "
"#2016)"
msgstr ""

#: src/project/changelog.md:816
msgid ""
"Definition files have been added to configure [Dev Containers](https://"
"containers.dev/) for Rust development environment. (@eitsupi, #1893, #2025, "
"#2028)"
msgstr ""

#: src/project/changelog.md:822
msgid "@linux-china, with #1971"
msgstr ""

#: src/project/changelog.md:823
msgid "@Jelenkee, with #2019"
msgstr ""

#: src/project/changelog.md:825
msgid "0.5.2 — 2023-02-18"
msgstr ""

#: src/project/changelog.md:827
msgid ""
"0.5.2 is a tiny release to fix an build issue in yesterday's `prql-js` 0.5.1 "
"release."
msgstr ""

#: src/project/changelog.md:830
msgid "This release has 7 commits from 2 contributors."
msgstr ""

#: src/project/changelog.md:834
msgid "@matthias-Q, with #1873"
msgstr ""

#: src/project/changelog.md:836
msgid "0.5.1 — 2023-02-17"
msgstr ""

#: src/project/changelog.md:838
msgid ""
"0.5.1 contains a few fixes, and another change to how bindings handle "
"default target / dialects."
msgstr ""

#: src/project/changelog.md:841
msgid "This release has 53 commits from 7 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:845
msgid ""
"Delegate dividing literal integers to the DB. Previously integer division "
"was executed during PRQL compilation, which could be confusing given that "
"behavior is different across DBs. Other arithmetic operations are still "
"executed during compilation. (@max-sixty, #1747)"
msgstr ""

#: src/project/changelog.md:852
msgid "Add docs on the `from_text` transform (@max-sixty, #1756)"
msgstr ""

#: src/project/changelog.md:856
msgid ""
"\\[prql-js\\] Default compile target changed from `Sql(Generic)` to "
"`Sql(None)`. (@eitsupi, #1856)"
msgstr ""

#: src/project/changelog.md:858
msgid ""
"\\[prql-python\\] Compilation options can now be specified from Python. "
"(@eitsupi, \\#1807)"
msgstr ""

#: src/project/changelog.md:860
msgid ""
"\\[prql-python\\] Default compile target changed from `Sql(Generic)` to "
"`Sql(None)`. (@eitsupi, #1861)"
msgstr ""

#: src/project/changelog.md:865
msgid "@vanillajonathan, with #1766"
msgstr ""

#: src/project/changelog.md:867
msgid "0.5.0 — 2023-02-08"
msgstr ""

#: src/project/changelog.md:869
msgid ""
"0.5.0 contains a few fixes, some improvements to bindings, lots of docs "
"improvements, and some work on forthcoming features. It contains one "
"breaking change in the compiler's `Options` interface."
msgstr ""

#: src/project/changelog.md:873
msgid "This release has 74 commits from 12 contributors. Selected changes:"
msgstr ""

#: src/project/changelog.md:877
msgid ""
"Change public API to use target instead of dialect in preparation for "
"feature work (@aljazerzen, #1684)"
msgstr ""

#: src/project/changelog.md:880
msgid ""
"`prqlc watch` command which watches filesystem for changes and compiles ."
"prql files to .sql (@aljazerzen, #1708)"
msgstr ""

#: src/project/changelog.md:885
msgid ""
"Support double brackets in s-strings which aren't symmetric (@max-sixty, "
"\\#1650)"
msgstr ""

#: src/project/changelog.md:887
msgid "Support Postgres's Interval syntax (@max-sixty, #1649)"
msgstr ""

#: src/project/changelog.md:888
msgid "Fixed tests for `prql-elixir` with MacOS (@kasvith, #1707)"
msgstr ""

#: src/project/changelog.md:892
msgid ""
"Add a documentation test for prql-compiler, update prql-compiler README, and "
"include the README in the prql book section for Rust bindings. The code "
"examples in the README are included and tested as doctests in the prql-"
"compiler (@nkicg6, #1679)"
msgstr ""

#: src/project/changelog.md:899
msgid ""
"Add tests for all PRQL website examples to prql-python to ensure compiled "
"results match expected SQL (@nkicg6, #1719)"
msgstr ""

#: src/project/changelog.md:904
msgid "@ruslandoga, with #1628"
msgstr ""

#: src/project/changelog.md:905
msgid "@RalfNorthman, with #1632"
msgstr ""

#: src/project/changelog.md:906
msgid "@nicot, with #1662"
msgstr ""

#: src/project/changelog.md:908
msgid "0.4.2 — 2023-01-25"
msgstr ""

#: src/project/changelog.md:912
msgid ""
"New `from_text format-arg string-arg` function that supports JSON and CSV "
"formats. _format-arg_ can be `format:csv` or `format:json`. _string-arg_ can "
"be a string in any format. (@aljazerzen & @snth, #1514)"
msgstr ""

#: src/project/changelog.md:916
msgid ""
"```prql no-eval\n"
"from_text format:csv \"\"\"\n"
"a,b,c\n"
"1,2,3\n"
"4,5,6\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/project/changelog.md:924
msgid ""
"```prql no-eval\n"
"from_text format:json '''\n"
"    [{\"a\": 1, \"b\": \"x\", \"c\": false }, {\"a\": 4, \"b\": \"y\", "
"\"c\": null }]\n"
"'''\n"
"```"
msgstr ""

#: src/project/changelog.md:930
msgid ""
"```prql no-eval\n"
"from_text format:json '''{\n"
"    \"columns\": [\"a\", \"b\", \"c\"],\n"
"    \"data\": [\n"
"        [1, \"x\", false],\n"
"        [4, \"y\", null]\n"
"    ]\n"
"}'''\n"
"```"
msgstr ""

#: src/project/changelog.md:940
msgid "For now, the argument is limited to string constants."
msgstr ""

#: src/project/changelog.md:942
msgid "**Fixes**"
msgstr ""

#: src/project/changelog.md:944
msgid "Export constructor for SQLCompileOptions (@bcho, #1621)"
msgstr ""

#: src/project/changelog.md:945
msgid "Remove backticks in count_distinct (@aljazerzen, #1611)"
msgstr ""

#: src/project/changelog.md:947
msgid "**New Contributors**"
msgstr ""

#: src/project/changelog.md:949
msgid "@1Kinoti, with #1596"
msgstr ""

#: src/project/changelog.md:950
msgid "@veenaamb, with #1614"
msgstr ""

#: src/project/changelog.md:952
msgid "0.4.1 — 2023-01-18"
msgstr ""

#: src/project/changelog.md:954
msgid ""
"0.4.1 comes a few days after 0.4.0, with a couple of features and the "
"release of `prqlc`, the CLI crate."
msgstr ""

#: src/project/changelog.md:957
msgid "0.4.1 has 35 commits from 6 contributors."
msgstr ""

#: src/project/changelog.md:961
msgid "Inferred column names include the relation name (@aljazerzen, #1550):"
msgstr ""

#: src/project/changelog.md:969
msgid ""
"Quoted identifiers such as `dir/*.parquet` are passed through to SQL. (@max-"
"sixty, #1516)."
msgstr ""

#: src/project/changelog.md:972
msgid ""
"The CLI is installed with `cargo install prqlc`. The binary was renamed in "
"0.4.0 but required an additional `--features` flag, which has been removed "
"in favor of this new crate (@max-sixty & @aljazerzen, #1549)."
msgstr ""

#: src/project/changelog.md:978
msgid "@fool1280, with #1554"
msgstr ""

#: src/project/changelog.md:979
msgid "@nkicg6, with #1567"
msgstr ""

#: src/project/changelog.md:981
msgid "0.4.0 — 2023-01-15"
msgstr ""

#: src/project/changelog.md:983
msgid ""
"0.4.0 brings lots of new features including `case`, `select ![]` and numbers "
"with underscores. We have initial (unpublished) bindings to Elixir. And "
"there's the usual improvements to fixes & documentation (only a minority are "
"listed below in this release)."
msgstr ""

#: src/project/changelog.md:988
msgid ""
"0.4.0 also has some breaking changes: `table` is `let`, `dialect` is renamed "
"to `target`, and the compiler's API has changed. Full details below."
msgstr ""

#: src/project/changelog.md:993
msgid ""
"Defining a temporary table is now expressed as `let` rather than `table` "
"(@aljazerzen, #1315). See the [tables docs](https://prql-lang.org/book/"
"reference/declarations/variables.html) for details."
msgstr ""

#: src/project/changelog.md:998
msgid ""
"_Experimental:_ The [`case`](https://prql-lang.org/book/reference/syntax/"
"case.html) function sets a variable to a value based on one of several "
"expressions (@aljazerzen, \\#1278)."
msgstr ""

#: src/project/changelog.md:1003
msgid ""
"```prql no-eval\n"
"derive var = case [\n"
"  score <= 10 -> \"low\",\n"
"  score <= 30 -> \"medium\",\n"
"  score <= 70 -> \"high\",\n"
"  true -> \"very high\",\n"
"]\n"
"```"
msgstr ""

#: src/project/changelog.md:1012
msgid "...compiles to:"
msgstr ""

#: src/project/changelog.md:1018
msgid "'low'"
msgstr ""

#: src/project/changelog.md:1019
msgid "'medium'"
msgstr ""

#: src/project/changelog.md:1020
msgid "'high'"
msgstr ""

#: src/project/changelog.md:1021
msgid "'very high'"
msgstr ""

#: src/project/changelog.md:1027
msgid ""
"Check out the [`case` docs](https://prql-lang.org/book/reference/syntax/case."
"html) for more details."
msgstr ""

#: src/project/changelog.md:1031
msgid ""
"_Experimental:_ Columns can be excluded by name with `select` (@aljazerzen, "
"\\#1329)"
msgstr ""

#: src/project/changelog.md:1039
msgid ""
"_Experimental:_ `append` transform, equivalent to `UNION ALL` in SQL. "
"(@aljazerzen, #894)"
msgstr ""

#: src/project/changelog.md:1047
msgid ""
"Check out the [`append` docs](https://prql-lang.org/book/reference/stdlib/"
"transforms/append.html) for more details."
msgstr ""

#: src/project/changelog.md:1051
msgid ""
"Numbers can contain underscores, which can make reading long numbers easier "
"(@max-sixty, #1467):"
msgstr ""

#: src/project/changelog.md:1062
msgid ""
"The SQL output contains a comment with the PRQL compiler version "
"(@aljazerzen, \\#1322)"
msgstr ""

#: src/project/changelog.md:1064
msgid ""
"`dialect` is renamed to `target`, and its values are prefixed with `sql.` "
"(@max-sixty, #1388); for example:"
msgstr ""

#: src/project/changelog.md:1073
msgid ""
"This gives us the flexibility to target other languages than SQL in the long "
"term."
msgstr ""

#: src/project/changelog.md:1076
msgid ""
"Tables definitions can contain a bare s-string (@max-sixty, #1422), which "
"enables us to include a full CTE of SQL, for example:"
msgstr ""

#: src/project/changelog.md:1079
msgid ""
"```prql no-eval\n"
"let grouping = s\"\"\"\n"
"  SELECT SUM(a)\n"
"  FROM tbl\n"
"  GROUP BY\n"
"    GROUPING SETS\n"
"    ((b, c, d), (d), (b, d))\n"
"\"\"\"\n"
"```"
msgstr ""

#: src/project/changelog.md:1089
msgid "Ranges supplied to `in` can be half-open (@aljazerzen, #1330)."
msgstr ""

#: src/project/changelog.md:1091
msgid ""
"The crate's external API has changed to allow for compiling to intermediate "
"representation. This also affects bindings. See [`prql-compiler` docs]"
"(https://docs.rs/prql-compiler/latest/prql_compiler/) for more details."
msgstr ""

#: src/project/changelog.md:1098
msgid "\\[This release, the changelog only contains a subset of fixes\\]"
msgstr ""

#: src/project/changelog.md:1100
msgid "Allow interpolations in table s-strings (@aljazerzen, #1337)"
msgstr ""

#: src/project/changelog.md:1104
msgid ""
"\\[This release, the changelog only contains a subset of documentation "
"improvements\\]"
msgstr ""

#: src/project/changelog.md:1107
msgid ""
"Add docs on aliases in [Select](https://prql-lang.org/book/reference/stdlib/"
"transforms/select.html)"
msgstr ""

#: src/project/changelog.md:1109
msgid "Add JS template literal and multiline example (@BCsabaEngine, #1432)"
msgstr ""

#: src/project/changelog.md:1110
msgid "JS template literal and multiline example (@BCsabaEngine, #1432)"
msgstr ""

#: src/project/changelog.md:1111
msgid "Improve prql-compiler docs & examples (@aljazerzen, #1515)"
msgstr ""

#: src/project/changelog.md:1112
msgid "Fix string highlighting in book (@max-sixty, #1264)"
msgstr ""

#: src/project/changelog.md:1116
msgid ""
"The playground allows querying some sample data. As before, the result "
"updates on every keystroke. (@aljazerzen, #1305)"
msgstr ""

#: src/project/changelog.md:1121
msgid ""
"\\[This release, the changelog only contains a subset of integration "
"improvements\\]"
msgstr ""

#: src/project/changelog.md:1123
msgid ""
"Added Elixir integration exposing PRQL functions as NIFs (#1500, @kasvith)"
msgstr ""

#: src/project/changelog.md:1124
msgid "Exposed Elixir flavor with exceptions (#1513, @kasvith)"
msgstr ""

#: src/project/changelog.md:1125
msgid "Rename `prql-compiler` binary to `prqlc` (@aljazerzen #1515)"
msgstr ""

#: src/project/changelog.md:1129
msgid ""
"\\[This release, the changelog only contains a subset of internal changes\\]"
msgstr ""

#: src/project/changelog.md:1131
msgid "Add parsing for negative select (@max-sixty, #1317)"
msgstr ""

#: src/project/changelog.md:1132
msgid "Allow for additional builtin functions (@aljazerzen, #1325)"
msgstr ""

#: src/project/changelog.md:1133
msgid "Add an automated check for typos (@max-sixty, #1421)"
msgstr ""

#: src/project/changelog.md:1134
msgid "Add tasks for running playground & book (@max-sixty, #1265)"
msgstr ""

#: src/project/changelog.md:1135
msgid "Add tasks for running tests on every file change (@max-sixty, #1380)"
msgstr ""

#: src/project/changelog.md:1137
msgid "**New contributors**:"
msgstr ""

#: src/project/changelog.md:1139
msgid "@EArazli, with #1359"
msgstr ""

#: src/project/changelog.md:1140
msgid "@boramalper, with #1362"
msgstr ""

#: src/project/changelog.md:1141
msgid "@allurefx, with #1377"
msgstr ""

#: src/project/changelog.md:1142
msgid "@bcho, with #1375"
msgstr ""

#: src/project/changelog.md:1143
msgid "@JettChenT, with #1385"
msgstr ""

#: src/project/changelog.md:1144
msgid "@BlurrechDev, with #1411"
msgstr ""

#: src/project/changelog.md:1145
msgid "@BCsabaEngine, with #1432"
msgstr ""

#: src/project/changelog.md:1146
msgid "@kasvith, with #1500"
msgstr ""

#: src/project/changelog.md:1148
msgid "0.3.1 - 2022-12-03"
msgstr ""

#: src/project/changelog.md:1150
msgid "0.3.1 brings a couple of small improvements and fixes."
msgstr ""

#: src/project/changelog.md:1154
msgid "Support for using s-strings for `from` (#1197, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1156
msgid ""
"```prql no-eval\n"
"from s\"SELECT * FROM employees WHERE foo > 5\"\n"
"```"
msgstr ""

#: src/project/changelog.md:1160
msgid ""
"Helpful error message when referencing a table in an s-string (#1203, "
"@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1165
msgid "Multiple columns with same name created (#1211, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1166
msgid "Renaming via select breaks preceding sorting (#1204, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1167
msgid "Same column gets selected multiple times (#1186, @mklopets)"
msgstr ""

#: src/project/changelog.md:1171
msgid ""
"Update Github Actions and Workflows to current version numbers (and avoid "
"using Node 12)"
msgstr ""

#: src/project/changelog.md:1174
msgid "0.3.0 — 2022-11-29"
msgstr ""

#: src/project/changelog.md:1176
msgid ""
"🎉 0.3.0 is the biggest ever change in PRQL's compiler, rewriting much of "
"the internals: the compiler now has a semantic understanding of expressions, "
"including resolving names & building a DAG of column lineage 🎉."
msgstr ""

#: src/project/changelog.md:1180
msgid ""
"While the immediate changes to the language are modest — some long-running "
"bugs are fixed — this unlocks the development of many of the project's long-"
"term priorities, such as type-checking & auto-complete. And it simplifies "
"the building of our next language features, such as match-case expressions, "
"unions & table expressions."
msgstr ""

#: src/project/changelog.md:1186
msgid ""
"@aljazerzen has (mostly single-handedly) done this work over the past few "
"months. The project owes him immense appreciation."
msgstr ""

#: src/project/changelog.md:1189
msgid "**Breaking changes**:"
msgstr ""

#: src/project/changelog.md:1191
msgid "We've had to make some modest breaking changes for 0.3:"
msgstr ""

#: src/project/changelog.md:1193
msgid ""
"_Pipelines must start with `from`_. For example, a pipeline with only "
"`derive foo = 5`, with no `from` transform, is no longer valid. Depending on "
"demand for this feature, it would be possible to add this back."
msgstr ""

#: src/project/changelog.md:1197
msgid ""
"_Shared column names now require `==` in a join_. The existing approach is "
"ambiguous to the compiler — `id` in the following example could be a boolean "
"column."
msgstr ""

#: src/project/changelog.md:1207
msgid ""
"_Table references containing periods must be surrounded by backticks_. For "
"example, when referencing a schema name:"
msgstr ""

#: src/project/changelog.md:1217
msgid "Change self equality op to `==` (#1176, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1218
msgid "Add logging (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1219
msgid "Add clickhouse dialect (#1090, @max-sixty)"
msgstr ""

#: src/project/changelog.md:1220
msgid "Allow namespaces & tables to contain `.` (#1079, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1224
msgid ""
"Deduplicate column appearing in `SELECT` multiple times (#1186, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1225
msgid "Fix uppercase table names (#1184, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1226
msgid "Omit table name when only one ident in SELECT (#1094, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1230
msgid "Add chapter on semantics' internals (@aljazerzen, #1028)"
msgstr ""

#: src/project/changelog.md:1231
msgid "Add note about nesting variables in s-strings (@max-sixty, #1163)"
msgstr ""

#: src/project/changelog.md:1235
msgid "Flatten group and window (#1120, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1236
msgid "Split ast into expr and stmt (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1237
msgid "Refactor associativity (#1156, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1238
msgid "Rename Ident constructor to `from_name` (#1084, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1239
msgid "Refactor rq folding (#1177, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1240
msgid "Add tests for reported bugs fixes in semantic (#1174, @aljazerzen)"
msgstr ""

#: src/project/changelog.md:1241
msgid "Bump duckdb from 0.5.0 to 0.6.0 (#1132)"
msgstr ""

#: src/project/changelog.md:1242
msgid "Bump once_cell from 1.15.0 to 1.16.0 (#1101)"
msgstr ""

#: src/project/changelog.md:1243
msgid "Bump pest from 2.4.0 to 2.5.0 (#1161)"
msgstr ""

#: src/project/changelog.md:1244
msgid "Bump pest_derive from 2.4.0 to 2.5.0 (#1179)"
msgstr ""

#: src/project/changelog.md:1245
msgid "Bump sqlparser from 0.25.0 to 0.27.0 (#1131)"
msgstr ""

#: src/project/changelog.md:1246
msgid "Bump trash from 2.1.5 to 3.0.0 (#1178)"
msgstr ""

#: src/project/changelog.md:1248
msgid "0.2.11 — 2022-11-20"
msgstr ""

#: src/project/changelog.md:1250
msgid "0.2.11 contains a few helpful fixes."
msgstr ""

#: src/project/changelog.md:1252
msgid ""
"Work continues on our `semantic` refactor — look out for 0.3.0 soon! Many "
"thanks to @aljazerzen for his continued contributions to this."
msgstr ""

#: src/project/changelog.md:1255
msgid ""
"Note: 0.2.10 was skipped due to this maintainer's inability to read his own "
"docs on bumping versions..."
msgstr ""

#: src/project/changelog.md:1260
msgid ""
"Detect when compiler version is behind query version (@MarinPostma, #1058)"
msgstr ""

#: src/project/changelog.md:1261
msgid "Add `__version__` to prql-python package (@max-sixty, #1034)"
msgstr ""

#: src/project/changelog.md:1265
msgid ""
"Fix nesting of expressions with equal binding strength and left "
"associativity, such as `a - (b - c)` (@max-sixty, #1136)"
msgstr ""

#: src/project/changelog.md:1267
msgid "Retain floats without significant digits as floats (@max-sixty, #1141)"
msgstr ""

#: src/project/changelog.md:1271
msgid "Add documentation of `prqlr` bindings (@eitsupi, #1091)"
msgstr ""

#: src/project/changelog.md:1272
msgid "Add a 'Why PRQL' section to the website (@max-sixty, #1098)"
msgstr ""

#: src/project/changelog.md:1273
msgid "Add @snth to core-devs (@max-sixty, #1050)"
msgstr ""

#: src/project/changelog.md:1277
msgid "Use workspace versioning (@max-sixty, #1065)"
msgstr ""

#: src/project/changelog.md:1279
msgid "0.2.9 — 2022-10-14"
msgstr ""

#: src/project/changelog.md:1281
msgid "0.2.9 is a small release containing a bug fix for empty strings."
msgstr ""

#: src/project/changelog.md:1285
msgid "Fix parsing of empty strings (@aljazerzen, #1024)"
msgstr ""

#: src/project/changelog.md:1287
msgid "0.2.8 — 2022-10-10"
msgstr ""

#: src/project/changelog.md:1289
msgid ""
"0.2.8 is another modest release with some fixes, doc improvements, bindings "
"improvements, and lots of internal changes. Note that one of the fixes "
"causes the behavior of `round` and `cast` to change slightly — though it's "
"handled as a fix rather than a breaking change in semantic versioning."
msgstr ""

#: src/project/changelog.md:1296
msgid ""
"Change order of the `round` & `cast` function parameters to have the column "
"last; for example `round 2 foo_col` / `cast int foo`. This is consistent "
"with other functions, and makes piping possible:"
msgstr ""

#: src/project/changelog.md:1309
msgid "Split `DEVELOPMENT.md` from `CONTRIBUTING.md` (@richb-hanover, #1010)"
msgstr ""

#: src/project/changelog.md:1310
msgid "Make s-strings more prominent in website intro (@max-sixty, #982)"
msgstr ""

#: src/project/changelog.md:1314
msgid "Add GitHub star count to website (@max-sixty, #990)"
msgstr ""

#: src/project/changelog.md:1318
msgid ""
"Expose a shortened error message, in particular for the VS Code extension "
"(@aljazerzen, #1005)"
msgstr ""

#: src/project/changelog.md:1323
msgid "Specify 1.60.0 as minimum Rust version (@max-sixty, #1011)"
msgstr ""

#: src/project/changelog.md:1324
msgid "Remove old `wee-alloc` code (@max-sixty, #1013)"
msgstr ""

#: src/project/changelog.md:1325
msgid "Upgrade clap to version 4 (@aj-bagwell, #1004)"
msgstr ""

#: src/project/changelog.md:1326
msgid "Improve book-building script in Taskfile (@max-sixty, #989)"
msgstr ""

#: src/project/changelog.md:1327
msgid ""
"Publish website using an artifact rather than a long-lived branch (@max-"
"sixty, \\#1009)"
msgstr ""

#: src/project/changelog.md:1330
msgid "0.2.7 — 2022-09-17"
msgstr ""

#: src/project/changelog.md:1332
msgid ""
"0.2.7 is a fairly modest release, six weeks after 0.2.6. We have some more "
"significant features, including a `union` operator and an overhaul of our "
"type system, as open PRs which will follow in future releases."
msgstr ""

#: src/project/changelog.md:1336
msgid ""
"We also have new features in the [VS Code extension](https://github.com/PRQL/"
"prql-code), courtesy of @jiripospisil, including a live output panel."
msgstr ""

#: src/project/changelog.md:1342
msgid ""
"`range_of_ranges` checks the Range end is smaller than its start (@shuozeli, "
"\\#946)"
msgstr ""

#: src/project/changelog.md:1347
msgid "Improve various docs (@max-sixty, #974, #971, #972, #970, #925)"
msgstr ""

#: src/project/changelog.md:1348
msgid "Add reference to EdgeDB's blog post in our FAQ (@max-sixty, #922)"
msgstr ""

#: src/project/changelog.md:1349
msgid "Fix typos (@kianmeng, #943)"
msgstr ""

#: src/project/changelog.md:1353
msgid "Add `prql-lib`, enabling language bindings with `go` (@sigxcpu76, #923)"
msgstr ""

#: src/project/changelog.md:1354
msgid "Fix line numbers in JS exceptions (@charlie-sanders, #929)"
msgstr ""

#: src/project/changelog.md:1358
msgid ""
"Lock the version of the rust-toolchain, with auto-updates (@max-sixty, #926, "
"\\#927)"
msgstr ""

#: src/project/changelog.md:1361
msgid "0.2.6 — 2022-08-05"
msgstr ""

#: src/project/changelog.md:1365
msgid "Adjust `fmt` to only escape names when needed (@aljazerzen, #907)"
msgstr ""

#: src/project/changelog.md:1366
msgid "Fix quoting on upper case `table` names (@max-sixty, #893)"
msgstr ""

#: src/project/changelog.md:1367
msgid ""
"Fix scoping of identical column names from multiple tables (@max-sixty, #908)"
msgstr ""

#: src/project/changelog.md:1368
msgid "Fix parse error on newlines in a `table` (@sebastiantoh 🆕, #902)"
msgstr ""

#: src/project/changelog.md:1369
msgid "Fix quoting of upper case table names (@max-sixty, #893)"
msgstr ""

#: src/project/changelog.md:1373
msgid "Add docs on Architecture (@aljazerzen, #904)"
msgstr ""

#: src/project/changelog.md:1374
msgid "Add Changelog (@max-sixty, #890 #891)"
msgstr ""

#: src/project/changelog.md:1378
msgid "Start trial using Conventional Commits (@max-sixty, #889)"
msgstr ""

#: src/project/changelog.md:1379
msgid "Add crates.io release workflow, docs (@max-sixty, #887)"
msgstr ""

#: src/project/changelog.md:1381
msgid "0.2.5 - 2022-07-29"
msgstr ""

#: src/project/changelog.md:1383
msgid "0.2.5 is a very small release following 0.2.4 yesterday. It includes:"
msgstr ""

#: src/project/changelog.md:1385
msgid ""
"Add the ability to represent single brackets in an s-string, with two "
"brackets (#752, @max-sixty)"
msgstr ""

#: src/project/changelog.md:1387
msgid ""
"Fix the \"Copy to Clipboard\" command in the Playground, for Firefox (#880, "
"@mklopets)"
msgstr ""

#: src/project/changelog.md:1390
msgid "0.2.4 - 2022-07-28"
msgstr ""

#: src/project/changelog.md:1392
msgid ""
"0.2.4 is a small release following 0.2.3 a few days ago. The 0.2.4 release "
"includes:"
msgstr ""

#: src/project/changelog.md:1395
msgid ""
"Enrich our CLI, adding commands to get different stages of the compilation "
"process (@aljazerzen , #863)"
msgstr ""

#: src/project/changelog.md:1397
msgid ""
"Fix multiple `take n` statements in a query, leading to duplicate proxy "
"columns in generated SQL (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1399
msgid "Fix BigQuery quoting of identifiers in `SELECT` statements (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1400
msgid ""
"Some internal changes — reorganize top-level functions (@aljazerzen), add a "
"workflow to track our Rust compilation time (@max-sixty), simplify our "
"simple prql-to-sql tests (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1404
msgid ""
"Thanks to @ankane, `prql-compiler` is now available from homebrew core; "
"`brew install prql-compiler`[^1]."
msgstr ""

#: src/project/changelog.md:1408
msgid ""
"    we still need to update docs and add a release workflow for this:\n"
"    <https://github.com/PRQL/prql/issues/866>\n"
"    "
msgstr ""

#: src/project/changelog.md:1411
msgid "0.2.3 - 2022-07-24"
msgstr ""

#: src/project/changelog.md:1413
msgid ""
"A couple of weeks since the 0.2.2 release: we've squashed a few bugs, added "
"some mid-sized features to the language, and made a bunch of internal "
"improvements."
msgstr ""

#: src/project/changelog.md:1416
msgid "The 0.2.3 release includes:"
msgstr ""

#: src/project/changelog.md:1418
msgid ""
"Allow for escaping otherwise-invalid identifiers (@aljazerzen & @max-sixty)"
msgstr ""

#: src/project/changelog.md:1419
msgid "Fix a bug around operator precedence (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1420
msgid "Add a section the book on the language bindings (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1421
msgid ""
"Add tests for our `Display` representation while fixing some existing bugs. "
"This is gradually becoming our code formatter (@arrizalamin)"
msgstr ""

#: src/project/changelog.md:1423
msgid "Add a \"copy to clipboard\" button in the Playground (@mklopets)"
msgstr ""

#: src/project/changelog.md:1424
msgid ""
"Add lots of guidance to our `CONTRIBUTING.md` around our tests and process "
"for merging (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1426
msgid ""
"Add a `prql!` macro for parsing a prql query at compile time (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1427
msgid "Add tests for `prql-js` (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1428
msgid ""
"Add a `from_json` method for transforming json to a PRQL string "
"(@arrizalamin)"
msgstr ""

#: src/project/changelog.md:1429
msgid "Add a workflow to release `prql-java` to Maven (@doki23)"
msgstr ""

#: src/project/changelog.md:1430
msgid ""
"Enable running all tests from a PR by adding a `pr-run-all-tests` label "
"(@max-sixty)"
msgstr ""

#: src/project/changelog.md:1432
msgid "Have `cargo-release` to bump all crate & npm versions (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1433
msgid "Update `prql-js` to use the bundler build of `prql-js` (@mklopets)"
msgstr ""

#: src/project/changelog.md:1435
msgid ""
"As well as those contribution changes, thanks to those who've reported "
"issues, such as @mklopets @huw @mm444 @ajfriend."
msgstr ""

#: src/project/changelog.md:1438
msgid ""
"From here, we're planning to continue squashing bugs (albeit more minor than "
"those in this release), adding some features like `union`, while working on "
"bigger issues such as type-inference."
msgstr ""

#: src/project/changelog.md:1442
msgid ""
"We're also going to document and modularize the compiler further. It's "
"important that we give more people an opportunity to contribute to the guts "
"of PRQL, especially given the number and enthusiasm of contributions to "
"project in general — and it's not that easy to do so at the moment. While "
"this is ongoing if anyone has something they'd like to work on in the more "
"difficult parts of the compiler, let us know on GitHub or Discord, and we'd "
"be happy to work together on it."
msgstr ""

#: src/project/changelog.md:1450
msgid "Thank you!"
msgstr ""

#: src/project/changelog.md:1452
msgid "0.2.2 - 2022-07-10"
msgstr ""

#: src/project/changelog.md:1454
msgid ""
"We're a couple of weeks since our 0.2.0 release. Thanks for the surge in "
"interest and contributions! 0.2.2 has some fixes & some internal "
"improvements:"
msgstr ""

#: src/project/changelog.md:1457
msgid ""
"We now test against SQLite & DuckDB on every commit, to ensure we're "
"producing correct SQL. (@aljazerzen)"
msgstr ""

#: src/project/changelog.md:1459
msgid "We have the beginning of Java bindings! (@doki23)"
msgstr ""

#: src/project/changelog.md:1460
msgid "Idents surrounded by backticks are passed through to SQL (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1461
msgid ""
"More examples on homepage; e.g. `join` & `window`, lots of small docs "
"improvements"
msgstr ""

#: src/project/changelog.md:1463
msgid "Automated releases to homebrew (@roG0d)"
msgstr ""

#: src/project/changelog.md:1464
msgid ""
"[prql-js](https://github.com/PRQL/prql/tree/main/prqlc/bindings/js) is now a "
"single package for Node, browsers & webpack (@charlie-sanders)"
msgstr ""

#: src/project/changelog.md:1466
msgid ""
"Parsing has some fixes, including `>=` and leading underscores in idents "
"(@mklopets)"
msgstr ""

#: src/project/changelog.md:1468
msgid "Ranges receive correct syntax highlighting (@max-sixty)"
msgstr ""

#: src/project/changelog.md:1470
msgid ""
"Thanks to Aljaž Mur Eržen @aljazerzen , George Roldugin @roldugin , Jasper "
"McCulloch @Jaspooky , Jie Han @doki23 , Marko Klopets @mklopets , Maximilian "
"Roos @max-sixty , Rodrigo Garcia @roG0d , Ryan Russell @ryanrussell , Steven "
"Maude @StevenMaude , Charlie Sanders @charlie-sanders ."
msgstr ""

#: src/project/changelog.md:1475
msgid ""
"We're planning to continue collecting bugs & feature requests from users, as "
"well as working on some of the bigger features, like type-inference."
msgstr ""

#: src/project/changelog.md:1478
msgid ""
"For those interesting in joining, we also have a new [Contributing page]"
"(https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md)."
msgstr ""

#: src/project/changelog.md:1481
msgid "0.2.0 - 2022-06-27"
msgstr ""

#: src/project/changelog.md:1483
msgid "🎉 🎉 **After several months of building, PRQL is ready to use!** 🎉 🎉"
msgstr ""

#: src/project/changelog.md:1487
msgid "How we got here:"
msgstr ""

#: src/project/changelog.md:1489
msgid ""
"At the end of January, we published a proposal of a better language for data "
"transformation: PRQL. The reception was better than I could have hoped for — "
"we were no. 2 on HackerNews for a day, and gained 2.5K GitHub stars over the "
"next few days."
msgstr ""

#: src/project/changelog.md:1494
msgid ""
"But man cannot live on GitHub Stars alone — we had to do the work to build "
"it. So over the next several months, during many evenings & weekends, a "
"growing group of us gradually built the compiler, evolved the language, and "
"wrote some integrations."
msgstr ""

#: src/project/changelog.md:1499
msgid ""
"We want to double-down on the community and its roots in open source — it's "
"incredible that a few of us from all over the globe have collaborated on a "
"project without ever having met. We decided early-on that PRQL would always "
"be open-source and would never have a commercial product (despite lots of "
"outside interest to fund a seed round!). Because languages are so deep in "
"the stack, and the data stack has so many players, the best chance of "
"building a great language is to build an open language."
msgstr ""

#: src/project/changelog.md:1509
msgid ""
"We still have a long way to go. While PRQL is usable, it has lots of missing "
"features, and an incredible amount of unfulfilled potential, including a "
"language server, cohesion with databases, and type inference. Over the "
"coming weeks, we'd like to grow the number of intrepid users experimenting "
"PRQL in their projects, prioritize features that will unblock them, and then "
"start fulfilling PRQL's potential by working through our [roadmap](https://"
"prql-lang.org/roadmap/)."
msgstr ""

#: src/project/changelog.md:1517
msgid ""
"The best way to experience PRQL is to try it. Check out our [website]"
"(https://prql-lang.org) and the [Playground](https://prql-lang.org/"
"playground). Start using PRQL for your own projects in [dbt](https://github."
"com/prql/dbt-prql), [Jupyter notebooks](https://pyprql.readthedocs.io/en/"
"latest/magic_readme.html) and Prefect workflows."
msgstr ""

#: src/project/changelog.md:1524
msgid ""
"Keep in touch with PRQL by following the project on [Twitter](https://"
"twitter.com/prql_lang), joining us on [Discord](https://discord.gg/"
"eQcfaCmsNc), starring the [repo](https://github.com/PRQL/prql)."
msgstr ""

#: src/project/changelog.md:1529
msgid ""
"[Contribute](https://github.com/PRQL/prql/blob/main/.github/CONTRIBUTING.md) "
"to the project — we're a really friendly community, whether you're a recent "
"SQL user or an advanced Rust programmer. We need bug reports, documentation "
"tweaks & feature requests — just as much as we need compiler improvements "
"written in Rust."
msgstr ""

#: src/project/changelog.md:1537
msgid ""
"I especially want to give [Aljaž Mur Eržen](https://github.com/aljazerzen) "
"(@aljazerzen) the credit he deserves, who has contributed the majority of "
"the difficult work of building out the compiler. Much credit also goes to "
"[Charlie Sanders](https://github.com/charlie-sanders) (@charlie-sanders), "
"one of PRQL's earliest supporters and the author of pyprql, and [Ryan "
"Patterson-Cross](https://github.com/rbpatt2019) (@rbpatt2019), who built the "
"Jupyter integration among other Python contributions."
msgstr ""

#: src/project/changelog.md:1545
msgid ""
"Other contributors who deserve a special mention include: @roG0d, @snth, "
"@kwigley"
msgstr ""

#: src/project/changelog.md:1550
msgid "Thank you, and we look forward to your feedback!"
msgstr ""

#: src/project/contributing/index.md:1
msgid "Contributing"
msgstr ""

#: src/project/contributing/index.md:3
msgid ""
"If you're interested in joining the community to build a better SQL, here "
"are ways to start:"
msgstr ""

#: src/project/contributing/index.md:6
msgid "Star the [repo](https://github.com/PRQL/prql)."
msgstr "星標收藏[儲存庫](https://github.com/PRQL/prql)。"

#: src/project/contributing/index.md:7
msgid "Send a link to PRQL to a couple of people whose opinion you respect."
msgstr ""

#: src/project/contributing/index.md:8
msgid ""
"Subscribe to [new releases](https://www.jessesquires.com/blog/2020/07/30/"
"github-tip-watching-releases/) for updates."
msgstr ""

#: src/project/contributing/index.md:11
msgid "Follow us on [Twitter](https://twitter.com/prql_lang)."
msgstr "在 [Twitter](https://twitter.com/prql_lang) 上關注我們。"

#: src/project/contributing/index.md:12
msgid "Join our [Discord](https://discord.gg/eQcfaCmsNc)."
msgstr "加入我們的 [Discord](https://discord.gg/eQcfaCmsNc)。"

#: src/project/contributing/index.md:13
msgid ""
"Find an issue labeled [Good First Issue](https://github.com/prql/prql/issues?"
"q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22) and start "
"contributing to the code."
msgstr ""

#: src/project/contributing/index.md:16
msgid ""
"Join our [fortnightly Developer Call](https://github.com/PRQL/prql/"
"issues/1083); ([iCal file](./fortnightly-dev-call.ics))."
msgstr ""

#: src/project/contributing/index.md:20
msgid ""
"PRQL is evolving from a project with lots of excitement into a project that "
"folks are using in their work and integrating into their tools. We're "
"actively looking for collaborators to lead that growth with us."
msgstr ""

#: src/project/contributing/index.md:24
msgid "Areas for larger contributions"
msgstr ""

#: src/project/contributing/index.md:26
msgid "Compiler"
msgstr "編譯器"

#: src/project/contributing/index.md:28
msgid ""
"The compiler is written in Rust, and there's enough to do such that any "
"level of experience with Rust is sufficient."
msgstr ""

#: src/project/contributing/index.md:31
msgid ""
"We try to keep a few onboarding issues on hand under the [\"good first "
"issue\" label](https://github.com/PRQL/prql/labels/good%20first%20issue). "
"These have been screened to have sufficient context to get started (and we "
"very much welcome questions where there's some context missing)."
msgstr ""

#: src/project/contributing/index.md:36
msgid ""
"To get started, check out the docs on [Development](./development.md) and "
"the [Compiler architecture](https://github.com/PRQL/prql/blob/main/prqlc/"
"ARCHITECTURE.md)"
msgstr ""

#: src/project/contributing/index.md:39
msgid ""
"And if you have questions, there are lots of friendly people on the Discord "
"who will patiently help you."
msgstr ""

#: src/project/contributing/index.md:42
msgid "Bindings & integrations"
msgstr ""

#: src/project/contributing/index.md:44
msgid ""
"For PRQL to be successful, it needs to be available for the languages & "
"tools that people already use."
msgstr ""

#: src/project/contributing/index.md:47
msgid ""
"We currently have bindings to the PRQL compiler in a few different "
"languages; many of these can be improved, documented, and packaged in a "
"better way."
msgstr ""

#: src/project/contributing/index.md:49
msgid ""
"If you have experience with packaging in an ecosystem that doesn't currently "
"have bindings, then creating PRQL bindings for that language we don't "
"currently support would be valuable to the project."
msgstr ""

#: src/project/contributing/index.md:52
msgid ""
"If there's a tool that you use yourself to run data queries which you think "
"would benefit from a PRQL integration, suggest one to us or the tool. If "
"it's open-source, build & share a prototype."
msgstr ""

#: src/project/contributing/index.md:56
msgid ""
"Relevant issues are labeled [Integrations](https://github.com/PRQL/prql/"
"labels/integrations)."
msgstr ""

#: src/project/contributing/index.md:59
msgid "Language design"
msgstr "語言設計"

#: src/project/contributing/index.md:61
msgid ""
"We decide on new language features in GitHub issues, usually under "
"[\"language design\" label](https://github.com/PRQL/prql/issues?"
"q=is%3Aopen+label%3Alanguage-design+sort%3Aupdated-desc)."
msgstr ""

#: src/project/contributing/index.md:64
msgid "You can also contribute by:"
msgstr ""

#: src/project/contributing/index.md:66
msgid ""
"Finding instances where the compiler produces incorrect results, and post a "
"bug report — feel free to use the [playground](https://prql-lang.org/"
"playground)."
msgstr ""

#: src/project/contributing/index.md:69
msgid ""
"Opening an issue / append to an existing issue with examples of queries that "
"are difficult to express in PRQL — especially if more difficult than SQL."
msgstr ""

#: src/project/contributing/index.md:72
msgid ""
"With sufficient examples, suggest a change to the language! (Though "
"suggestions _without_ examples are difficult to engage with, so please do "
"anchor suggestions in examples.)"
msgstr ""
"提供充足的範例來建議語言變更！（由於沒有範例的建議很難進行討論，因此請務必將"
"建議建立在具體範例之上。）"

#: src/project/contributing/index.md:76
msgid "Marketing"
msgstr ""

#: src/project/contributing/index.md:78
msgid ""
"Improve our website. We have [a few issues open](https://github.com/PRQL/"
"prql/labels/web) on this front and are looking for anyone with at least some "
"design skills."
msgstr ""

#: src/project/contributing/index.md:81
msgid ""
"Contribute towards the docs. Anything from shaping a whole section of the "
"docs, to simply improving a confusing paragraph or fixing a typo."
msgstr ""

#: src/project/contributing/index.md:83
msgid "Tell people about PRQL."
msgstr ""

#: src/project/contributing/index.md:84
msgid ""
"Find a group of users who would be interested in PRQL, help them get up to "
"speed, help the project understand what they need."
msgstr ""

#: src/project/contributing/index.md:87
msgid "Core team"
msgstr "核心團隊"

#: src/project/contributing/index.md:89
msgid ""
"If you have any questions or feedback and don't receive a response on one of "
"the general channels such as GitHub or Discord, feel free to reach out to:"
msgstr ""
"如果您有任何問題或意見反饋，並且在 GitHub 或 Discord 等公開頻道未收到回覆，歡"
"迎隨時聯繫："

#: src/project/contributing/index.md:92
msgid "[**@aljazerzen**](https://github.com/aljazerzen) — Aljaž Mur Eržen"
msgstr "[**@aljazerzen**](https://github.com/aljazerzen) — Aljaž Mur Eržen"

#: src/project/contributing/index.md:93
msgid "[**@max-sixty**](https://github.com/max-sixty) — Maximilian Roos"
msgstr "[**@max-sixty**](https://github.com/max-sixty) — Maximilian Roos"

#: src/project/contributing/index.md:94
msgid "[**@eitsupi**](https://github.com/eitsupi) — SHIMA Tatsuya"
msgstr "[**@eitsupi**](https://github.com/eitsupi) — SHIMA Tatsuya"

#: src/project/contributing/index.md:95
msgid "[**@snth**](https://github.com/snth) — Tobias Brandt"
msgstr "[**@snth**](https://github.com/snth) — Tobias Brandt"

#: src/project/contributing/index.md:97
msgid "Core team Emeritus"
msgstr "核心團隊榮譽成員"

#: src/project/contributing/index.md:99
msgid "Thank you to those who have previously served on the core team:"
msgstr ""

#: src/project/contributing/index.md:101
msgid ""
"[**@charlie-sanders**](https://github.com/charlie-sanders) — Charlie Sanders"
msgstr ""

#: src/project/contributing/development.md:3
msgid "Setting up an initial dev environment"
msgstr ""

#: src/project/contributing/development.md:5
msgid ""
"We can set up a local development environment sufficient for navigating, "
"editing, and testing PRQL's compiler code in two minutes:"
msgstr ""

#: src/project/contributing/development.md:8
msgid ""
"Install [`rustup` & `cargo`](https://doc.rust-lang.org/cargo/getting-started/"
"installation.html)."
msgstr ""

#: src/project/contributing/development.md:10
msgid ""
"\\[Optional but highly recommended\\] Install `cargo-insta`, our testing "
"framework:"
msgstr ""

#: src/project/contributing/development.md:17
msgid ""
"That's it! Running the unit tests for the `prqlc` crate after cloning the "
"repo should complete successfully:"
msgstr ""

#: src/project/contributing/development.md:24
msgid "...or, to run tests and update the test snapshots:"
msgstr ""

#: src/project/contributing/development.md:30
msgid "There's more context on our tests in [How we test](#how-we-test) below."
msgstr ""

#: src/project/contributing/development.md:32
msgid "That's sufficient for making an initial contribution to the compiler."
msgstr ""

#: src/project/contributing/development.md:36
msgid "Setting up a full dev environment"
msgstr ""

#: src/project/contributing/development.md:46
msgid ""
"For more advanced development; for example compiling for wasm or previewing "
"the website, we have two options:"
msgstr ""

#: src/project/contributing/development.md:49
msgid "Option 1: Use the project's `task`"
msgstr ""

#: src/project/contributing/development.md:56
msgid "[Install Task](https://taskfile.dev/installation/)."
msgstr ""

#: src/project/contributing/development.md:57
msgid ""
"Then run the `setup-dev` task. This runs commands from our [Taskfile.yml]"
"(https://github.com/PRQL/prql/blob/main/Taskfile.yml), installing "
"dependencies with `cargo`, `brew`, `npm` & `pip`, and suggests some VS Code "
"extensions."
msgstr ""

#: src/project/contributing/development.md:66
msgid "Option 2: Install tools individually"
msgstr ""

#: src/project/contributing/development.md:68
msgid "We'll need `cargo-insta`, to update snapshot tests:"
msgstr ""

#: src/project/contributing/development.md:74
msgid ""
"We'll need Python, which most systems will have already. The easiest way to "
"check is to try running the full tests:"
msgstr ""

#: src/project/contributing/development.md:81
msgid ""
"...and if that doesn't complete successfully, ensure we have Python >= 3.7, "
"to compile `prqlc-python`."
msgstr ""

#: src/project/contributing/development.md:84
msgid ""
"For more involved contributions, such as building the website, playground, "
"book, or some release artifacts, we'll need some additional tools. But we "
"won't need those immediately, and the error messages on what's missing "
"should be clear when we attempt those things. When we hit them, the "
"[Taskfile.yml](https://github.com/PRQL/prql/blob/main/Taskfile.yml) will be "
"a good source to copy & paste instructions from."
msgstr ""

#: src/project/contributing/development.md:91
msgid "Option 3: Use a Dev Container"
msgstr "選項 3：使用 Dev Container"

#: src/project/contributing/development.md:93
msgid ""
"This project has a [devcontainer.json file](https://github.com/PRQL/prql/"
"blob/main/.devcontainer/devcontainer.json) and a [pre-built dev container "
"base Docker image](https://github.com/PRQL/prql/pkgs/container/prql-"
"devcontainer-base). Learn more about Dev Containers at [https://containers."
"dev/](https://containers.dev/)"
msgstr ""

#: src/project/contributing/development.md:100
msgid ""
"Currently, the tools for Rust are already installed in the pre-built image, "
"and, Node.js, Python and others are configured to be installed when build "
"the container."
msgstr ""

#: src/project/contributing/development.md:104
msgid ""
"While there are a variety of tools that support Dev Containers, the focus "
"here is on developing with VS Code in a container by [GitHub Codespaces]"
"(https://docs.github.com/en/codespaces/overview) or [VS Code Dev Containers "
"extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-"
"remote.remote-containers)."
msgstr ""

#: src/project/contributing/development.md:109
msgid ""
"To use a Dev Container on a local computer with VS Code, install the [VS "
"Code Dev Containers extension](https://marketplace.visualstudio.com/items?"
"itemName=ms-vscode-remote.remote-containers) and its system requirements. "
"Then refer to the links above to get started."
msgstr ""

#: src/project/contributing/development.md:113
msgid "Option 4: Use nix development environment"
msgstr "選項 4：使用 nix 開發環境"

#: src/project/contributing/development.md:115
msgid ""
"A [nix](https://nixos.org/) flake `flake.nix` provides 3 development "
"environments:"
msgstr ""

#: src/project/contributing/development.md:118
msgid "**default**, for building the compiler"
msgstr ""

#: src/project/contributing/development.md:119
msgid "**web**, for the compiler and the website,"
msgstr ""

#: src/project/contributing/development.md:120
msgid "**full**, for the compiler, the website and the compiler bindings."
msgstr ""

#: src/project/contributing/development.md:122
msgid "To load the shell:"
msgstr ""

#: src/project/contributing/development.md:124
msgid ""
"[Install nix (the package manager)](https://nixos.org/download). (only first "
"time)"
msgstr ""

#: src/project/contributing/development.md:127
msgid ""
"Enable flakes, which are a (pretty stable) experimental feature of nix. "
"(only first time)"
msgstr ""

#: src/project/contributing/development.md:130
msgid "For non-NixOS users:"
msgstr ""

#: src/project/contributing/development.md:134
msgid "'experimental-features = nix-command flakes'"
msgstr "'experimental-features = nix-command flakes'"

#: src/project/contributing/development.md:137
msgid ""
"For NixOs users, follow instructions [here](https://nixos.wiki/wiki/Flakes)."
msgstr ""

#: src/project/contributing/development.md:139
msgid "Run:"
msgstr ""

#: src/project/contributing/development.md:145
msgid "If you want \"web\" or \"full\" shell, run:"
msgstr ""

#: src/project/contributing/development.md:151
msgid ""
"Optionally, you can install [direnv](https://direnv.net/), to automatically "
"load the shell when you enter this repo. The easiest way is to also install "
"[direnv-nix](https://github.com/nix-community/nix-direnv) and configure your "
"`.envrc` with:"
msgstr ""

#: src/project/contributing/development.md:157
msgid "# .envrc\n"
msgstr ""

#: src/project/contributing/development.md:163
msgid "Contribution workflow"
msgstr ""

#: src/project/contributing/development.md:165
msgid ""
"We're similar to most projects on GitHub — open a Pull Request with a "
"suggested change!"
msgstr ""

#: src/project/contributing/development.md:168
msgid "Commits"
msgstr ""

#: src/project/contributing/development.md:170
msgid ""
"If a change is user-facing, please add a line in [**`CHANGELOG.md`**]"
"(https://github.com/PRQL/prql/blob/main/CHANGELOG.md), with `{message}, "
"({@contributor, #X})` where `X` is the PR number."
msgstr ""

#: src/project/contributing/development.md:173
msgid ""
"If there's a missing entry, a follow-up PR containing just the changelog "
"entry is welcome."
msgstr ""

#: src/project/contributing/development.md:175
msgid ""
"We're using [Conventional Commits](https://www.conventionalcommits.org) "
"message format, enforced through [action-semantic-pull-request](https://"
"github.com/amannn/action-semantic-pull-request)."
msgstr ""

#: src/project/contributing/development.md:179
msgid "Merges"
msgstr ""

#: src/project/contributing/development.md:181
msgid "**We merge any code that makes PRQL better**"
msgstr ""

#: src/project/contributing/development.md:182
msgid ""
"A PR doesn't need to be perfect to be merged; it doesn't need to solve a big "
"problem. It needs to:"
msgstr ""

#: src/project/contributing/development.md:184
msgid "be in the right direction,"
msgstr ""

#: src/project/contributing/development.md:185
msgid "make incremental progress,"
msgstr ""

#: src/project/contributing/development.md:186
msgid "be explicit on its current state, so others can continue the progress."
msgstr ""

#: src/project/contributing/development.md:187
msgid ""
"That said, there are a few instances when we need to ensure we have some "
"consensus before merging code — for example non-trivial changes to the "
"language, or large refactorings to the library."
msgstr ""

#: src/project/contributing/development.md:190
msgid ""
"If you have merge permissions, and are reasonably confident that a PR is "
"suitable to merge (whether or not you're the author), feel free to merge."
msgstr ""

#: src/project/contributing/development.md:192
msgid ""
"If you don't have merge permissions and have authored a few PRs, ask and ye "
"shall receive."
msgstr ""

#: src/project/contributing/development.md:194
msgid "The primary way we ratchet the code quality is through automated tests."
msgstr ""

#: src/project/contributing/development.md:195
msgid ""
"This means PRs almost always need a test to demonstrate incremental progress."
msgstr ""

#: src/project/contributing/development.md:197
msgid ""
"If a change breaks functionality without breaking tests, our tests were "
"probably insufficient."
msgstr ""

#: src/project/contributing/development.md:199
msgid ""
"If a change breaks existing tests (for example, changing an external API), "
"that indicates we should be careful about merging a change, including "
"soliciting others' views."
msgstr ""

#: src/project/contributing/development.md:202
msgid ""
"We use PR reviews to give general context, offer specific assistance, and "
"collaborate on larger decisions."
msgstr ""

#: src/project/contributing/development.md:204
msgid ""
"Reviews around 'nits' like code formatting / idioms / etc are very welcome. "
"But the norm is for them to be received as helpful advice, rather than as "
"mandatory tasks to complete. Adding automated tests & lints to automate "
"these suggestions is welcome."
msgstr ""

#: src/project/contributing/development.md:208
msgid ""
"If you have merge permissions and would like a PR to be reviewed before it "
"merges, that's great — ask or assign a reviewer."
msgstr ""

#: src/project/contributing/development.md:210
msgid ""
"If a PR hasn't received attention after a day, please feel free to ping the "
"pull request."
msgstr ""

#: src/project/contributing/development.md:212
msgid ""
"People may review a PR after it's merged. As part of the understanding that "
"we can merge quickly, contributors are expected to incorporate substantive "
"feedback into a future PR."
msgstr ""

#: src/project/contributing/development.md:215
msgid ""
"We should revert quickly if the impact of a PR turns out not to be "
"consistent with our expectations, or there isn't as much consensus on a "
"decision as we had hoped. It's very easy to revert code and then re-revert "
"when we've resolved the issue; it's a sign of moving quickly. Other options "
"which resolve issues immediately are also fine, such as commenting out an "
"incorrect test or adding a quick fix for the underlying issue."
msgstr ""

#: src/project/contributing/development.md:222
msgid "Docs"
msgstr ""

#: src/project/contributing/development.md:224
msgid "We're very keen on contributions to improve our documentation."
msgstr ""

#: src/project/contributing/development.md:226
msgid ""
"This includes our docs in the book, on the website, in our code, or in a "
"Readme. We also appreciate issues pointing out that our documentation was "
"confusing, incorrect, or stale — if it's confusing for you, it's probably "
"confusing for others."
msgstr ""

#: src/project/contributing/development.md:231
msgid "Some principles for ensuring our docs remain maintainable:"
msgstr ""

#: src/project/contributing/development.md:233
msgid ""
"Docs should be as close as possible to the code. Doctests are ideal on this "
"dimension — they're literally very close to the code and they can't drift "
"apart since they're tested on every commit. Or, for example, it's better to "
"add text to a `--help` message, rather than write a paragraph in the Readme "
"explaining the CLI."
msgstr ""

#: src/project/contributing/development.md:238
msgid ""
"We should have some visualization of how to maintain docs when we add them. "
"Docs have a habit of falling out of date — the folks reading them are often "
"different from those writing them, they're sparse from the code, generally "
"not possible to test, and are rarely the by-product of other contributions. "
"Docs that are concise & specific are easier to maintain."
msgstr ""

#: src/project/contributing/development.md:243
msgid ""
"Docs should be specifically relevant to PRQL; anything else we can instead "
"link to."
msgstr ""

#: src/project/contributing/development.md:246
msgid ""
"If something doesn't fit into one of these categories, there are still lots "
"of ways of getting the word out there — a blog post / gist / etc. Let us "
"know and we're happy to link to it / tweet it."
msgstr ""

#: src/project/contributing/development.md:250
msgid "How we test"
msgstr ""

#: src/project/contributing/development.md:252
msgid ""
"We use a pyramid of tests — we have fast, focused tests at the bottom of the "
"pyramid, which give us low latency feedback when developing, and then "
"slower, broader tests which ensure that we don't miss anything as PRQL "
"develops<sup><a name=\"to-footnote-1\">[1](#footnote-1)</a></sup>."
msgstr ""

#: src/project/contributing/development.md:266
msgid "Our tests, from the bottom of the pyramid to the top:"
msgstr ""

#: src/project/contributing/development.md:268
msgid ""
"**[Static checks](https://github.com/PRQL/prql/blob/main/.pre-commit-config."
"yaml)** — we run a few static checks to ensure the code stays healthy and "
"consistent. They're defined in [**`.pre-commit-config.yaml`**](https://"
"github.com/PRQL/prql/blob/main/.pre-commit-config.yaml), using [pre-commit]"
"(https://pre-commit.com). They can be run locally with"
msgstr ""

#: src/project/contributing/development.md:276
#: src/project/contributing/development.md:298
#: src/project/contributing/development.md:350
msgid "# or\n"
msgstr ""

#: src/project/contributing/development.md:280
msgid ""
"The tests fix most of the issues they find themselves. Most of them also run "
"on GitHub on every commit; any changes they make are added onto the branch "
"automatically in an additional commit."
msgstr ""

#: src/project/contributing/development.md:284
msgid ""
"Checking by [MegaLinter](https://megalinter.io/latest/), which includes more "
"Linters, is also done automatically on GitHub. (experimental)"
msgstr ""

#: src/project/contributing/development.md:287
msgid ""
"**Unit tests & inline insta snapshots** — we rely on unit tests to rapidly "
"check that our code basically works. We extensively use [Insta](https://"
"insta.rs/), a snapshot testing tool which writes out the values generated by "
"our code, making it fast & simple to write and modify tests<sup><a name=\"to-"
"footnote-2\">[2](#footnote-2)</a></sup>"
msgstr ""

#: src/project/contributing/development.md:293
msgid ""
"These are the fastest tests which run our code; they're designed to run on "
"every save while you're developing. We include a `task` which does this:"
msgstr ""

#: src/project/contributing/development.md:300
msgid "# or, to run on every change:\n"
msgstr ""

#: src/project/contributing/development.md:334
msgid ""
"**[Documentation](https://github.com/PRQL/prql/tree/main/web/book/tests/"
"documentation)** — we compile all examples from our documentation in the "
"Website, README, and PRQL Book, to test that they produce the SQL we expect, "
"and that changes to our code don't cause any unexpected regressions. These "
"are included in:"
msgstr ""

#: src/project/contributing/development.md:343
msgid ""
"**[Database integration tests](https://github.com/PRQL/prql/tree/main/prqlc/"
"prqlc/tests/integration/dbs)** — we run tests with example queries against "
"databases with actual data to ensure we're producing correct SQL across our "
"supported dialects. The in-process tests can be run locally with:"
msgstr ""

#: src/project/contributing/development.md:354
msgid ""
"More details on running with external databases are in the [Readme](https://"
"github.com/PRQL/prql/tree/main/prqlc/prqlc/tests/integration/dbs)."
msgstr ""

#: src/project/contributing/development.md:357
msgid ""
"```admonish note\n"
"Integration tests use DuckDB, and so require a clang compiler to compile\n"
"[`duckdb-rs`](https://github.com/wangfenjin/duckdb-rs). Most development\n"
"systems will have one, but if the test command fails, install a clang "
"compiler with:\n"
"\n"
"  - On macOS, install xcode with `xcode-select --install`\n"
"  - On Debian Linux, `apt-get update && apt-get install clang`\n"
"  - On Windows, `duckdb-rs` isn't supported, so these tests are excluded\n"
"```"
msgstr ""

#: src/project/contributing/development.md:367
msgid ""
"**[GitHub Actions on every commit](https://github.com/PRQL/prql/blob/main/."
"github/workflows/tests.yaml)** — we run tests relevant to a PR's changes in "
"CI — for example changes to docs will attempt to build docs, changes to a "
"binding will run that binding's tests. The vast majority of changes trigger "
"tests which run in less than five minutes, and we should be reassessing "
"their scope if they take longer than that. Once these pass, a pull request "
"can be merged."
msgstr ""

#: src/project/contributing/development.md:374
msgid ""
"**[GitHub Actions on merge](https://github.com/PRQL/prql/blob/"
"c042eef48709e2c1af577161554fd09f14e67e0f/.github/workflows/pull-request."
"yaml#L124)** — we run a wider set tests on every merge to main. This "
"includes testing across OSs, all our language bindings, a measure of test "
"code coverage, and some performance benchmarks."
msgstr ""

#: src/project/contributing/development.md:379
msgid ""
"If these tests fail after merging, we should revert the commit before fixing "
"the test and then re-reverting."
msgstr ""

#: src/project/contributing/development.md:382
msgid "Most of these will run locally with:"
msgstr ""

#: src/project/contributing/development.md:388
msgid ""
"**[GitHub Actions nightly](https://github.com/PRQL/prql/blob/main/.github/"
"workflows/nightly.yaml)** — every night, we run tests that take longer, are "
"less likely to fail, or are unrelated to code changes — such as security "
"checks, bindings' tests on multiple OSs, or expensive timing benchmarks."
msgstr ""

#: src/project/contributing/development.md:393
msgid ""
"We can run these tests before a merge by adding a label `pr-nightly` to the "
"PR."
msgstr ""

#: src/project/contributing/development.md:396
msgid ""
"The goal of our tests is to allow us to make changes quickly. If they're "
"making it more difficult to make changes, or there are missing tests that "
"would offer the confidence to make changes faster, please raise an issue."
msgstr ""

#: src/project/contributing/development.md:402
msgid "Website"
msgstr "網站"

#: src/project/contributing/development.md:404
msgid ""
"The website is published together with the book and the playground, and is "
"automatically built and released on any push to the `web` branch."
msgstr ""

#: src/project/contributing/development.md:407
msgid ""
"The `web` branch points to the latest release plus any website-specific "
"fixes. That way, the compiler behavior in the playground matches the latest "
"release while allowing us to fix mistakes in the docs with a tighter loop "
"than every release."
msgstr ""

#: src/project/contributing/development.md:412
msgid ""
"Fixes to the playground, book, or website should have a `pr-backport-web` "
"label added to their PR — a bot will then open & merge another PR onto the "
"`web` branch once the initial branch merges."
msgstr ""

#: src/project/contributing/development.md:416
msgid "The website components will run locally with:"
msgstr ""

#: src/project/contributing/development.md:419
msgid "# Run the main website\n"
msgstr ""

#: src/project/contributing/development.md:420
msgid "# Run the PRQL online book\n"
msgstr ""

#: src/project/contributing/development.md:422
msgid "# Run the PRQL playground\n"
msgstr ""

#: src/project/contributing/development.md:429
msgid "Releasing"
msgstr ""

#: src/project/contributing/development.md:431
msgid "Currently we release in a semi-automated way:"
msgstr ""

#: src/project/contributing/development.md:433
msgid ""
"PR & merge an updated [Changelog](https://github.com/PRQL/prql/blob/main/"
"CHANGELOG.md). GitHub will produce a draft version at <https://github.com/"
"PRQL/prql/releases/new>, including \"New Contributors\"."
msgstr ""

#: src/project/contributing/development.md:438
msgid "Use this script to generate a line introducing the enumerated changes:"
msgstr ""

#: src/project/contributing/development.md:441
msgid ""
"\"It has $(git rev-list --count $(git rev-list --tags --max-count=1)..) "
"commits from $(git shortlog --summary $(git rev-list --tags --max-count=1).. "
"| wc -l | tr -d '[:space:]') contributors. Selected changes:\""
msgstr ""

#: src/project/contributing/development.md:444
msgid ""
"If the current version is correct, then skip ahead. But if the version needs "
"to be changed — for example, we had planned on a patch release, but instead "
"require a minor release — then run `cargo release version $version -x && "
"cargo release replace -x` to bump the version and PR the resulting commit."
msgstr ""

#: src/project/contributing/development.md:450
msgid ""
"After merging, go to [Draft a new release](https://github.com/PRQL/prql/"
"releases/new)<sup><a name=\"to-footnote-3\">[3](#footnote-3)</a></sup>, copy "
"the changelog entry into the release description<sup><a name=\"to-"
"footnote-4\">[4](#footnote-4)</a></sup>, enter the tag to be created, and "
"hit \"Publish\"."
msgstr ""

#: src/project/contributing/development.md:455
msgid ""
"From there, both the tag and release is created and all packages are "
"published automatically based on our [release workflow](https://github.com/"
"PRQL/prql/blob/main/.github/workflows/release.yaml)."
msgstr ""

#: src/project/contributing/development.md:459
msgid ""
"Run `cargo release version patch -x --no-confirm && cargo release replace -x "
"--no-confirm` to bump the versions and add a new Changelog section; then PR "
"the resulting commit. Currently we also require running `task test-rust` to "
"update snapshot tests which contain the version."
msgstr ""

#: src/project/contributing/development.md:465
msgid ""
"Check whether there are [milestones](https://github.com/PRQL/prql/"
"milestones) that need to be pushed out."
msgstr ""

#: src/project/contributing/development.md:468
msgid ""
"Review the **Current Status** on the README.md to ensure it reflects the "
"project state."
msgstr ""

#: src/project/contributing/development.md:471
msgid ""
"We may make this more automated in future; e.g. automatic changelog creation."
msgstr ""

#: src/project/contributing/development.md:475
msgid ""
"<a name=\"footnote-1\">[1](#to-footnote-1)</a>: Our approach is very "
"consistent with **[@matklad](https://github.com/matklad)**'s advice, in his "
"excellent blog post [How to Test](https://matklad.github.io//2021/05/31/how-"
"to-test.html)."
msgstr ""

#: src/project/contributing/development.md:480
msgid ""
"<a name=\"footnote-2\">[2](#to-footnote-2)</a>: [Here's an example of an "
"insta test](https://github.com/PRQL/prql/blob/0.2.2/prql-compiler/src/parser."
"rs#L580-L605) — note that only the initial line of each test is written by "
"us; the remainder is filled in by insta."
msgstr ""

#: src/project/contributing/development.md:484
msgid ""
"<a name=\"footnote-3\">[3](#to-footnote-3)</a>: Only maintainers have access "
"to this page."
msgstr ""

#: src/project/contributing/development.md:487
msgid ""
"<a name=\"footnote-4\">[4](#to-footnote-4)</a>: Unfortunately GitHub's "
"markdown parser interprets linebreaks as newlines. I haven't found a better "
"way of editing the markdown to look reasonable than manually editing the "
"text or asking LLM to help."
msgstr ""

#: src/project/contributing/language-design.md:3
msgid ""
"In a way PRQL is just a transpiler to SQL. This can cause its language "
"design to gravitate toward thinking about PRQL features in terms of how they "
"translate to SQL."
msgstr ""

#: src/project/contributing/language-design.md:11
msgid "This is flawed because:"
msgstr ""

#: src/project/contributing/language-design.md:13
msgid "it does not model interactions between features well,"
msgstr ""

#: src/project/contributing/language-design.md:14
msgid ""
"SQL behavior can sometimes be misleading (the order of a subquery will not "
"persist in the parent query) or even differs between dialects (set "
"operations)."
msgstr ""

#: src/project/contributing/language-design.md:18
msgid ""
"Instead, we should think of PRQL features in terms of how they affect PRQL "
"expressions, which in most cases means how they affect relations."
msgstr ""

#: src/project/contributing/language-design.md:34
msgid ""
"Thinking about SQL comes in only at the last step when relation (or rather "
"relational expression) is translated to an SQL expression."
msgstr ""

#: src/project/integrations/index.md:1
msgid "Integrations"
msgstr "整合"

#: src/project/integrations/index.md:3
msgid "PRQL is building integrations with lots of external tools, including:"
msgstr ""

#: src/project/integrations/index.md:5
msgid "[Jupyter](./jupyter.md)"
msgstr "[Jupyter](./jupyter.md)"

#: src/project/integrations/index.md:6
msgid "[ClickHouse](./clickhouse.md)"
msgstr "[ClickHouse](./clickhouse.md)"

#: src/project/integrations/index.md:7
msgid "[DuckDB](./duckdb.md)"
msgstr "[DuckDB](./duckdb.md)"

#: src/project/integrations/index.md:8
msgid "[Prefect](./prefect.md)"
msgstr "[Prefect](./prefect.md)"

#: src/project/integrations/index.md:9
msgid "[VS Code](./vscode.md)"
msgstr "[VS Code](./vscode.md)"

#: src/project/integrations/index.md:10
msgid "[Rill](./rill.md)"
msgstr "[Rill](./rill.md)"

#: src/project/integrations/index.md:11
msgid "[PostgreSQL](./postgresql.md)"
msgstr "[PostgreSQL](./postgresql.md)"

#: src/project/integrations/index.md:13
msgid "We also have a CLI, [`prqlc`](./prqlc-cli.md)"
msgstr ""

#: src/project/integrations/clickhouse.md:1
msgid "ClickHouse"
msgstr "ClickHouse"

#: src/project/integrations/clickhouse.md:3
msgid ""
"PRQL works natively in ClickHouse. Check out the [ClickHouse docs](https://"
"clickhouse.com/docs/en/guides/developer/alternative-query-languages) for "
"more details."
msgstr ""

#: src/project/integrations/duckdb.md:1
msgid "DuckDB"
msgstr "DuckDB"

#: src/project/integrations/duckdb.md:3
msgid ""
"There's an experimental [DuckDB](https://duckdb.org/) extension from "
"**[@ywelsch](https://github.com/ywelsch)** at [ywelsch/duckdb-prql](https://"
"github.com/ywelsch/duckdb-prql)."
msgstr ""

#: src/project/integrations/duckdb.md:7
msgid "Check out the Readme for more details."
msgstr ""

#: src/project/integrations/jupyter.md:1
msgid "Jupyter"
msgstr "Jupyter"

#: src/project/integrations/jupyter.md:3
msgid ""
"[pyprql](https://pypi.org/project/pyprql/) contains `pyprql.magic`, a thin "
"wrapper of [`JupySQL`](https://pypi.org/project/jupysql/)'s SQL IPython "
"magics. This allows us to run PRQL interactively on Jupyter/IPython."
msgstr ""

#: src/project/integrations/jupyter.md:7
msgid "Check out <https://pyprql.readthedocs.io/> for more context."
msgstr ""

#: src/project/integrations/jupyter.md:17
msgid ""
"When installing pyprql, the [duckdb-engine](https://pypi.org/project/duckdb-"
"engine/) package is also installed with it, so we can start using PRQL "
"immediately to query CSV and Parquet files."
msgstr ""

#: src/project/integrations/jupyter.md:22
msgid ""
"For example, running [the example from the JupySQL documentation](https://"
"jupysql.ploomber.io/en/latest/quick-start.html) on IPython:"
msgstr ""

#: src/project/integrations/postgresql.md:1
msgid "PostgreSQL"
msgstr "PostgreSQL"

#: src/project/integrations/postgresql.md:3
msgid ""
"PL/PRQL is a PostgreSQL extension that lets you write functions with PRQL."
msgstr ""

#: src/project/integrations/postgresql.md:5
msgid ""
"PL/PRQL functions serve as intermediaries, compiling the user's PRQL code "
"into SQL statements that PostgreSQL executes. The extension is based on the "
"[pgrx](https://github.com/pgcentralfoundation/pgrx) framework for developing "
"PostgreSQL extensions in Rust. This framework manages the interaction with "
"PostgreSQL's internal APIs, type conversions, and other function hooks "
"necessary to integrate PRQL with PostgreSQL."
msgstr ""

#: src/project/integrations/postgresql.md:8
msgid "Examples"
msgstr "範例"

#: src/project/integrations/postgresql.md:9
msgid "PL/PRQL functions are defined using the `plprql` language specifier:"
msgstr ""

#: src/project/integrations/postgresql.md:27
msgid "---------+----------\n"
msgstr ""

#: src/project/integrations/postgresql.md:34
msgid ""
"You can also run PRQL code directly with the `prql` function which is useful "
"for custom SQL in ORMs:"
msgstr ""

#: src/project/integrations/postgresql.md:37
#: src/project/integrations/postgresql.md:48
msgid "'from matches | filter player == ''Player1'''"
msgstr ""

#: src/project/integrations/postgresql.md:41
msgid "----+----------+-------+---------+-------+--------\n"
msgstr "----+----------+-------+---------+-------+--------\n"

#: src/project/integrations/postgresql.md:46
msgid ""
"-- Same as above without the need for the static types, but returns cursor\n"
msgstr ""

#: src/project/integrations/postgresql.md:48
msgid "'player1_cursor'"
msgstr ""

#: src/project/integrations/postgresql.md:52
msgid "Getting Started"
msgstr "開始使用"

#: src/project/integrations/postgresql.md:53
msgid ""
"For installation instructions and more information on the extension, see the "
"[PL/PRQL repository](https://github.com/kaspermarstal/plprql)."
msgstr ""

#: src/project/integrations/prefect.md:1
msgid "Prefect"
msgstr "Prefect"

#: src/project/integrations/prefect.md:3
msgid ""
"Because [Prefect](https://www.prefect.io/) is in native Python, it's "
"extremely easy to integrate with PRQL."
msgstr ""

#: src/project/integrations/prefect.md:6
msgid "With a Postgres Task, replace:"
msgstr ""

#: src/project/integrations/prefect.md:12
msgid "...with..."
msgstr ""

#: src/project/integrations/prefect.md:18
msgid ""
"We're big fans of Prefect, and if there is anything that would make the "
"integration easier, please open an issue."
msgstr ""

#: src/project/integrations/prqlc-cli.md:1
msgid "PRQL compiler"
msgstr "PRQL 編譯器"

#: src/project/integrations/prqlc-cli.md:3
msgid ""
"`prqlc` is the reference implementation of a compiler from PRQL to SQL, "
"written in Rust. It also serves as the CLI."
msgstr ""

#: src/project/integrations/prqlc-cli.md:6
msgid ""
"For more on PRQL, check out the [PRQL website](https://prql-lang.org) or the "
"[PRQL repo](https://github.com/PRQL/prql)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:9
msgid "CLI"
msgstr ""

#: src/project/integrations/prqlc-cli.md:11
msgid ""
"`prqlc` serves as a CLI for the PRQL compiler. It is a single, dependency-"
"free binary that compiles PRQL into SQL."
msgstr ""
"`prqlc` 是 PRQL 編譯器的 CLI。它是一個無相依項的二進位檔，可以將 PRQL 編譯為 "
"SQL。"

#: src/project/integrations/prqlc-cli.md:16
msgid "`prqlc compile`"
msgstr ""

#: src/project/integrations/prqlc-cli.md:18
msgid ""
"This command works as a filter that compiles a PRQL string into an SQL "
"string."
msgstr ""

#: src/project/integrations/prqlc-cli.md:21
msgid "'from employees | filter has_dog | select salary'"
msgstr ""

#: src/project/integrations/prqlc-cli.md:31
msgid ""
"A PRQL query can be executed with CLI tools compatible with SQL,, such as "
"[DuckDB CLI](https://duckdb.org/docs/api/cli.html)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:36
msgid "'from `albums.csv` | take 3'"
msgstr ""

#: src/project/integrations/prqlc-cli.md:47
msgid ""
"Executing this command without any argument will start interactive mode, "
"allowing a PRQL query to be written interactively. In this mode, after "
"writing PRQL and press `Ctrl-d` (Linux, macOS) or `Ctrl-z` (Windows) to "
"display the compiled SQL."
msgstr ""

#: src/project/integrations/prqlc-cli.md:56
msgid ""
"Just like when using it as a filter, SQL string output can be passed to the "
"DuckDB CLI and similar tools."
msgstr ""

#: src/project/integrations/prqlc-cli.md:77
msgid ""
"[![Packaging status](https://repology.org/badge/vertical-allrepos/prqlc.svg)]"
"(https://repology.org/project/prqlc/versions)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:79
msgid "via Homebrew (macOS, Linux)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:85
msgid "via winget (Windows)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:91
msgid "From GitHub release page"
msgstr ""

#: src/project/integrations/prqlc-cli.md:93
msgid ""
"Precompiled binaries are available for Linux, macOS, and Windows on the "
"[PRQL release page](https://github.com/PRQL/prql/releases)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:96
msgid "From source"
msgstr ""

#: src/project/integrations/prqlc-cli.md:99
msgid "# From crates.io\n"
msgstr ""

#: src/project/integrations/prqlc-cli.md:104
msgid "# From a local PRQL repository\n"
msgstr ""

#: src/project/integrations/prqlc-cli.md:108
msgid "Shell completions"
msgstr ""

#: src/project/integrations/prqlc-cli.md:110
msgid ""
"The `prqlc shell-completion` command prints a shell completion script for "
"supported shells, and saving the printed scripts to files makes for shells "
"to load completions for each session."
msgstr ""

#: src/project/integrations/prqlc-cli.md:114
msgid "Bash"
msgstr ""

#: src/project/integrations/prqlc-cli.md:116
msgid "For Linux:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:122
msgid "For macOS:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:128
msgid "fish"
msgstr ""

#: src/project/integrations/prqlc-cli.md:134
msgid "PowerShell"
msgstr ""

#: src/project/integrations/prqlc-cli.md:142
msgid "zsh"
msgstr ""

#: src/project/integrations/prqlc-cli.md:145
msgid "\"${fpath[1]}/_prqlc\""
msgstr ""

#: src/project/integrations/prqlc-cli.md:148
msgid "Ensure that the following lines are present in `~/.zshrc`:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:155
msgid "Helpers"
msgstr ""

#: src/project/integrations/prqlc-cli.md:157
msgid ""
"Cheat sheets for `prqlc` are available on various websites and with various "
"tools."
msgstr ""

#: src/project/integrations/prqlc-cli.md:160
msgid ""
"[`tldr`](https://tldr.sh/) ([on the web](https://tldr.inbrowser.app/pages/"
"common/prqlc))"
msgstr ""

#: src/project/integrations/prqlc-cli.md:162
msgid "[`eg`](https://github.com/srsudar/eg)"
msgstr ""

#: src/project/integrations/prqlc-cli.md:166
msgid "Library"
msgstr ""

#: src/project/integrations/prqlc-cli.md:168
msgid ""
"For more usage examples and the library documentation, check out the "
"[`prqlc` documentation](https://docs.rs/prqlc/)."
msgstr ""

#: src/project/integrations/prqlc-cli.md:171
msgid "Library installation"
msgstr ""

#: src/project/integrations/prqlc-cli.md:179
msgid "Compile a PRQL string to a SQLite dialect string:"
msgstr ""

#: src/project/integrations/prqlc-cli.md:182
msgid "// In a file src/main.rs\n"
msgstr ""

#: src/project/integrations/prqlc-cli.md:186
msgid "\"from employees | select {name, age}\""
msgstr ""

#: src/project/integrations/prqlc-cli.md:194
msgid "\"SELECT name, age FROM employees\""
msgstr ""

#: src/project/integrations/rill.md:1
msgid "Rill"
msgstr "Rill"

#: src/project/integrations/rill.md:3
msgid ""
"PRQL has had some work to integrate with Rill. See the [Rill ssues](https://"
"github.com/PRQL/prql/issues?q=is%3Aissue+rill) for more details."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:1
msgid "Grammars / syntax highlighting"
msgstr "文法/語法標明"

#: src/project/integrations/syntax-highlighting.md:3
msgid ""
"PRQL contains multiple grammar definitions to enable tools to highlight PRQL "
"code. These are all intended to provide as good an experience as the grammar "
"supports. Please raise any shortcomings in a GitHub issue."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:7
msgid ""
"The definitions are somewhat scattered around the codebase; this page serves "
"as an index."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:10
msgid ""
"[Ace](https://ace.c9.io/) — supported. The grammar is upstream "
"([prql_highlight_rules.js](https://github.com/ajaxorg/ace/blob/master/src/"
"mode/prql_highlight_rules.js)). See the [demo](https://prql-lang.org/demos/"
"ace-demo)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:14
msgid ""
"[chroma](https://github.com/alecthomas/chroma) — Go library used by the "
"static website generator Hugo. The grammar is upstream ([prql.xml](https://"
"github.com/alecthomas/chroma/blob/master/lexers/embedded/prql.xml)). See the "
"[demo](https://swapoff.org/chroma/playground/)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:19
msgid ""
"[Lezer](https://lezer.codemirror.net/) — used by CodeMirror editors. The "
"PRQL file is at [`grammars/prql-lezer/README.md`](https://github.com/PRQL/"
"prql/tree/main/grammars/prql-lezer/README.md)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:23
msgid "[Handlebars](https://handlebarsjs.com/) — currently duplicated:"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:25
msgid ""
"The book: [`book/highlight-prql.js`](https://github.com/PRQL/prql/blob/main/"
"web/book/highlight-prql.js)"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:27
msgid ""
"The website (outside of the book & playground): [`website/themes/prql-theme/"
"static/plugins/highlight/prql.js`](https://github.com/PRQL/prql/blob/main/"
"web/book/highlight-prql.js)"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:30
msgid ""
"Sublime Text — It's in the [`sublime-prql`](https://github.com/PRQL/sublime-"
"prql/) repository."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:32
msgid ""
"[TextMate](https://macromates.com/manual/en/language_grammars) — used by the "
"VS Code extension. It's in the `prql-vscode` repo in [`prql-vscode/syntaxes/"
"prql.tmLanguage.json`](https://github.com/PRQL/prql-vscode/blob/main/"
"syntaxes/prql.tmLanguage.json)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:36
msgid ""
"[Monarch](https://microsoft.github.io/monaco-editor/monarch.html) — used by "
"the Monaco editor, which we use for the Playground. The grammar is at "
"[`playground/src/workbench/prql-syntax.js`](https://github.com/PRQL/prql/"
"blob/main/web/playground/src/workbench/prql-syntax.js)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:40
msgid ""
"[Pygments](https://pygments.org/) — Python library used by Wikipedia, "
"Bitbucket, Sphinx and [more](https://pygments.org/faq/#who-uses-pygments). "
"The grammar is upstream ([prql.py](https://github.com/pygments/pygments/blob/"
"master/pygments/lexers/prql.py)). See the [demo](https://pygments.org/demo/)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:46
msgid ""
"[Tree-Sitter](https://tree-sitter.github.io/tree-sitter) — used by the "
"neovim and helix. The grammar can be found at [https://github.com/PRQL/tree-"
"sitter-prql](https://github.com/PRQL/tree-sitter-prql)."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:52
msgid ""
"Since the [Elm](https://elm-lang.org/) language coincidentally provides "
"syntax highlighting suitable for PRQL, it may look better to mark PRQL code "
"as Elm when the above definition files are not available."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:56
msgid ""
"For example, the following Markdown code block will be nicely highlighted on "
"GitHub, Pandoc, and other Markdown renderers:"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:66
msgid ""
"We hope that in the future these renderers will recognize PRQL code blocks "
"and have syntax highlighting applied, and we are tracking these with several "
"issues."
msgstr ""

#: src/project/integrations/syntax-highlighting.md:69
msgid "GitHub (Linguist): <https://github.com/PRQL/prql/issues/1636>"
msgstr ""

#: src/project/integrations/syntax-highlighting.md:70
msgid "Pandoc (Kate): <https://github.com/PRQL/prql/issues/2213>"
msgstr ""

#: src/project/integrations/vscode.md:1
msgid "Visual Studio Code extension"
msgstr ""

#: src/project/integrations/vscode.md:3
msgid ""
"PRQL has a Visual Studio Code extension that compiles a PRQL query in a VS "
"Code editor and displays the resulting SQL code in a second pane on the "
"side. This is very handy for editing, saving, and reusing PRQL queries in VS "
"Code."
msgstr ""

#: src/project/integrations/vscode.md:7
msgid ""
"To install the VS Code extension, open VS Code and type <kbd>Ctrl</kbd>\\-"
"<kbd>Shift</kbd>\\-<kbd>P</kbd> (<kbd>Cmd</kbd>\\-<kbd>Shift</kbd>\\-<kbd>P</"
"kbd> on a Mac) and type `PRQL`. Install the extension as usual."
msgstr ""

#: src/project/integrations/vscode.md:12
msgid ""
"[Repo for the PRQL VS Code extension](https://github.com/PRQL/prql-vscode)"
msgstr ""

#: src/project/integrations/vscode.md:14
msgid ""
"[Extension on VS Marketplace](https://marketplace.visualstudio.com/items?"
"itemName=PRQL-lang.prql-vscode)"
msgstr ""

#: src/project/target.md:1
msgid "Target & Version"
msgstr ""

#: src/project/target.md:3
msgid "Target dialect"
msgstr ""

#: src/project/target.md:5
msgid ""
"PRQL allows specifying a target dialect at the top of the query, which "
"allows PRQL to compile to a database-specific SQL flavor."
msgstr ""

#: src/project/target.md:26
msgid "Dialects"
msgstr ""

#: src/project/target.md:30
msgid ""
"Supported dialects support all PRQL language features where possible, are "
"tested on every commit, and we'll endeavor to fix bugs."
msgstr ""

#: src/project/target.md:33
msgid "`sql.clickhouse`"
msgstr ""

#: src/project/target.md:34
msgid "`sql.duckdb`"
msgstr ""

#: src/project/target.md:35
msgid "`sql.generic` <sup><a name=\"to-footnote-1\">[1](#footnote-1)</a></sup>"
msgstr ""

#: src/project/target.md:37
msgid "`sql.glaredb`"
msgstr "`sql.glaredb`"

#: src/project/target.md:38
msgid "`sql.mysql`"
msgstr "`sql.mysql`"

#: src/project/target.md:39
msgid "`sql.postgres`"
msgstr "`sql.postgres`"

#: src/project/target.md:40
msgid "`sql.sqlite`"
msgstr "`sql.sqlite`"

#: src/project/target.md:44
msgid ""
"Unsupported dialects have implementations in the compiler, but are tested "
"minimally or not at all, and may have gaps for some features."
msgstr ""

#: src/project/target.md:47
msgid ""
"We're open to contributions to improve our coverage of these, and to adding "
"additional dialects."
msgstr ""

#: src/project/target.md:50
msgid "`sql.mssql`"
msgstr "`sql.mssql`"

#: src/project/target.md:51
msgid "`sql.ansi`"
msgstr "`sql.ansi`"

#: src/project/target.md:52
msgid "`sql.bigquery`"
msgstr "`sql.bigquery`"

#: src/project/target.md:53
msgid "`sql.snowflake`"
msgstr "`sql.snowflake`"

#: src/project/target.md:55
msgid "Priority of targets"
msgstr ""

#: src/project/target.md:57
msgid ""
"The compile target of a query is defined in the query's header or as an "
"argument to the compiler. option. The argument to the compiler takes "
"precedence."
msgstr ""

#: src/project/target.md:60
msgid ""
"For example, the following shell example specifies `sql.generic` in the "
"query and `sql.duckdb` in the `--target` option of the `prqlc compile` "
"command. In this case, `sql.duckdb` takes precedence and the SQL output is "
"based on the DuckDB dialect."
msgstr ""

#: src/project/target.md:66 src/project/target.md:74
msgid ""
"'prql target:sql.generic\n"
"      from foo'"
msgstr ""

#: src/project/target.md:70
msgid ""
"To use the target described in the query, a special target `sql.any` can be "
"specified in the compiler option."
msgstr ""

#: src/project/target.md:78
msgid "Version"
msgstr "版本"

#: src/project/target.md:80
msgid ""
"PRQL allows specifying a version of the language in the PRQL header, like:"
msgstr ""

#: src/project/target.md:82
msgid ""
"```prql\n"
"prql version:\"0.11.3\"\n"
"\n"
"from employees\n"
"```"
msgstr ""

#: src/project/target.md:88
msgid "This has two roles, one of which is implemented:"
msgstr ""

#: src/project/target.md:90
msgid ""
"The compiler will raise an error if the compiler is older than the query "
"version. This prevents confusing errors when queries use newer features of "
"the language but the compiler hasn't yet been upgraded."
msgstr ""

#: src/project/target.md:93
msgid ""
"The compiler will compile for the major version of the query. This allows "
"the language to evolve without breaking existing queries, or forcing "
"multiple installations of the compiler. This isn't yet implemented, but is a "
"gating feature for PRQL 1.0."
msgstr ""

#: src/project/target.md:98
msgid ""
"The version of the compiler currently in use can be called using the special "
"function `std.prql.version` in PRQL."
msgstr ""

#: src/project/target.md:112
msgid ""
"<a name=\"footnote-1\">[1](#to-footnote-1)</a>: while there's no \"generic\" "
"DB to test `sql.generic` against, we still count it as supported."
msgstr ""

#: src/reference/declarations/functions.md:1
msgid "Functions"
msgstr "函式"

#: src/reference/declarations/functions.md:7
msgid "Functions have two types of parameters:"
msgstr ""

#: src/reference/declarations/functions.md:9
msgid "Positional parameters, which require an argument."
msgstr ""

#: src/reference/declarations/functions.md:10
msgid ""
"Named parameters, which optionally take an argument, otherwise using their "
"default value."
msgstr ""

#: src/reference/declarations/functions.md:13
msgid ""
"So this function is named `fahrenheit_to_celsius` and has one parameter "
"`temp`:"
msgstr ""

#: src/reference/declarations/functions.md:22
msgid ""
"This function is named `interp`, and has two positional parameters named "
"`high` and `x`, and one named parameter named `low` which takes a default "
"argument of `0`. It calculates the proportion of the distance that `x` is "
"between `low` and `high`."
msgstr ""

#: src/reference/declarations/functions.md:37
msgid "Other examples"
msgstr "其他範例"

#: src/reference/declarations/functions.md:39
msgid ""
"```prql\n"
"let is_adult = col -> col >= 18\n"
"let writes_code = col -> (col | in [\"PRQL\", \"Rust\"])\n"
"let square = col -> (col | math.pow 2)\n"
"let starts_with_a = col -> (col | text.lower | text.starts_with(\"a\"))\n"
"\n"
"from employees\n"
"select {\n"
"    first_name,\n"
"    last_name,\n"
"    hobby,\n"
"    adult = is_adult age,\n"
"    age_squared = square age,\n"
"}\n"
"filter ((starts_with_a last_name) && (writes_code hobby))\n"
"```"
msgstr ""

#: src/reference/declarations/functions.md:56
msgid "Piping values into functions"
msgstr ""

#: src/reference/declarations/functions.md:58
msgid ""
"Consistent with the principles of PRQL, it's possible to pipe values into "
"functions, which makes composing many functions more readable. When piping a "
"value into a function, the value is passed as an argument to the final "
"positional parameter of the function. Here's the same result as the examples "
"above with an alternative construction:"
msgstr ""

#: src/reference/declarations/functions.md:74
msgid "and"
msgstr "且"

#: src/reference/declarations/functions.md:83
msgid "We can combine a chain of functions, which makes logic more readable:"
msgstr ""

#: src/reference/declarations/functions.md:93
msgid "Late binding"
msgstr ""

#: src/reference/declarations/functions.md:95
msgid ""
"Functions can bind to any variable that is in scope when the function is "
"executed. For example, here `cost_total` refers to the column that's "
"introduced in the `from`."
msgstr ""

#: src/reference/declarations/variables.md:1
msgid "Variables"
msgstr ""

#: src/reference/declarations/variables.md:3
msgid ""
"Variables assign a name — say `x` — to an expression, like in most "
"programming languages. The name can then be used in any expression, acting "
"as a substitute for the expression `x`."
msgstr ""

#: src/reference/declarations/variables.md:7
msgid "Syntactically, variables can take 3 forms."
msgstr ""

#: src/reference/declarations/variables.md:9
msgid "`let` declares the name before the expression."
msgstr ""

#: src/reference/declarations/variables.md:15
msgid ""
"`into` declares the name after the expression. This form is useful for quick "
"pipeline splitting and conforms with the \"flow from top to bottom\" rule of "
"pipelines."
msgstr ""

#: src/reference/declarations/variables.md:24
msgid "The final expression of a pipeline defaults to taking the name `main`."
msgstr ""

#: src/reference/declarations/variables.md:30
msgid "... is equivalent to:"
msgstr ""

#: src/reference/declarations/variables.md:36
msgid ""
"When compiling to SQL, relational variables are compiled to Common Table "
"Expressions (or sub-queries in some cases)."
msgstr ""

#: src/reference/declarations/variables.md:58
msgid ""
"Variables can be assigned an s-string containing the whole SQL query [s-"
"string](../syntax/s-strings.md), enabling us to use features which PRQL "
"doesn't yet support."
msgstr ""

#: src/reference/declarations/variables.md:62
msgid ""
"```prql\n"
"let grouping = s\"\"\"\n"
"  SELECT SUM(a)\n"
"  FROM tbl\n"
"  GROUP BY\n"
"    GROUPING SETS\n"
"    ((b, c, d), (d), (b, d))\n"
"\"\"\"\n"
"\n"
"from grouping\n"
"```"
msgstr ""

#: src/reference/spec/index.md:1
msgid "Specification"
msgstr "規範"

#: src/reference/spec/index.md:3
msgid ""
"This chapter explains PRQL's semantics: how expressions are interpreted and "
"their meaning. It's intended for advanced users and compiler contributors."
msgstr ""
"本章解釋了 PRQL 的語義：表達式如何被解釋及其含義。它適用於進階使用者和編譯器"
"貢獻者。"

#: src/reference/spec/modules.md:1
msgid "Modules"
msgstr "模組"

#: src/reference/spec/modules.md:3
msgid ""
"This is a technical document. For a \"how to use\" or a TLDR; skip to the "
"[Example](#example) section."
msgstr ""

#: src/reference/spec/modules.md:6
msgid "Design goals:"
msgstr ""

#: src/reference/spec/modules.md:8
msgid "Allow importing declarations from other files."
msgstr ""

#: src/reference/spec/modules.md:10
msgid "Have namespaces for things like `std`."
msgstr ""

#: src/reference/spec/modules.md:12
msgid "Have a hierarchical structure so we can represent files in directories."
msgstr ""

#: src/reference/spec/modules.md:14
msgid "Have an unambiguous module structure within a project."
msgstr ""

#: src/reference/spec/modules.md:16
msgid "Definition"
msgstr "定義"

#: src/reference/spec/modules.md:18
msgid ""
"A module is a namespace that contains declarations. A module is itself a "
"declaration, which means that it can contain nested child modules."
msgstr ""

#: src/reference/spec/modules.md:21
msgid ""
"This means that modules form a [tree graph](https://en.wikipedia.org/wiki/"
"Tree_(graph_theory)), which we call \"the module structure\"."
msgstr ""

#: src/reference/spec/modules.md:25
msgid ""
"For the sake of this document, we will express the module structure with "
"`module` keyword and a code block encased in curly braces:"
msgstr ""

#: src/reference/spec/modules.md:38
msgid ""
"The syntax `module name { ...decls... }` is not part of PRQL language, with "
"the objection that it is unnecessary as it only adds more ways of defining "
"modules. If a significant upside of this syntax is found, it may be added in "
"the future."
msgstr ""

#: src/reference/spec/modules.md:43
msgid "Name resolution"
msgstr "名稱解析"

#: src/reference/spec/modules.md:45
msgid ""
"Any declarations within a module can be referenced from the outside of the "
"module:"
msgstr ""

#: src/reference/spec/modules.md:57
msgid "Identifiers are resolved relative to current module."
msgstr ""

#: src/reference/spec/modules.md:70
msgid ""
"If an identifier cannot be resolved relative to the current module, it tries "
"to resolve relative to the parent module. This is repeated, stepping up the "
"module hierarchy until a match is found or root of the module structure is "
"reached."
msgstr ""

#: src/reference/spec/modules.md:90
msgid "Main var declaration"
msgstr ""

#: src/reference/spec/modules.md:92
msgid ""
"The final variable declaration in a module can omit the leading `let main =` "
"and acquire an implicit name main."
msgstr ""

#: src/reference/spec/modules.md:105
msgid ""
"When a module is referenced as a value, the `main` variable is used instead. "
"This is especially useful when referring to a module which is to be compiled "
"to RQ (and later SQL)."
msgstr ""

#: src/reference/spec/modules.md:114
msgid "File importing"
msgstr ""

#: src/reference/spec/modules.md:116
msgid ""
"This section is under discussion. Current implementation plans do not "
"include `module` declarations, but loading of all files under the "
"compilation path."
msgstr ""

#: src/reference/spec/modules.md:119
msgid ""
"To include PRQL source code from other files, we can use the following "
"syntax:"
msgstr ""

#: src/reference/spec/modules.md:125
msgid ""
"This loads either `./my_playlists.prql` (a leaf module) or `./my_playlists/"
"_my_playlists.prql` (a directory module) and uses its contents as module "
"`my_playlists`. If none or both of the files are present, a compilation "
"error is raised."
msgstr ""

#: src/reference/spec/modules.md:130
msgid ""
"Only directory modules can contain module declarations. If a leaf module "
"contains a module declaration, a compilation error is raised, suggesting the "
"leaf module to be converted into a directory module. This is a step toward "
"any module structure having a single \"normalized\" representation in the "
"file system. Such normalization is desired because it restrains the possible "
"file system layouts to a comprehensible and predictable layout, while not "
"sacrificing any functionality."
msgstr ""

#: src/reference/spec/modules.md:138
msgid ""
"Described importing rules don't achieve this \"single normalized "
"representation\" in full, since any leaf modules could be replaced by a "
"directory module with zero submodules, without any semantic changes. "
"Restricting directory modules to have at least one sub-module would not "
"improve approachability enough to justify adding this restriction."
msgstr ""

#: src/reference/spec/modules.md:144
msgid ""
"For example, the following module structure is annotated with files names in "
"which the modules would reside:"
msgstr ""

#: src/reference/spec/modules.md:170
msgid ""
"If module `my_project.sales` wants to add a submodule `util`, it has to be "
"converted to a directory modules. This means that it has to be moved to "
"`sales/_sales.prql`. The new module would reside in `sales/util.prql`."
msgstr ""

#: src/reference/spec/modules.md:174
msgid ""
"The annotated layout is not the only possible layout for this module "
"structure, since any of the modules `sales`, `year_2023` or `year_2024` "
"could be converted into a directory module with zero sub-modules."
msgstr ""

#: src/reference/spec/modules.md:178
msgid ""
"Point 4 of design goals means that each declaration within a project has a "
"single fully-qualified name within this project. This is ensured by strict "
"rules regarding importing files and the fact that the module structure is a "
"tree."
msgstr ""

#: src/reference/spec/modules.md:182
msgid "Declaration order"
msgstr ""

#: src/reference/spec/modules.md:184
msgid ""
"The order of declarations in a module holds no semantic value, except the "
"\"last `main` variable\"."
msgstr ""

#: src/reference/spec/modules.md:187
msgid "References between modules can be cyclic."
msgstr ""

#: src/reference/spec/modules.md:199
msgid "References between variable declarations cannot be cyclic."
msgstr ""

#: src/reference/spec/modules.md:215
msgid "Compiler interface"
msgstr ""

#: src/reference/spec/modules.md:217
msgid "`prqlc` provides two interfaces for compiling files."
msgstr ""

#: src/reference/spec/modules.md:219
msgid "**Multi-file interface** requires three arguments:"
msgstr ""

#: src/reference/spec/modules.md:221
msgid ""
"path to the file containing the module which is the root of the module "
"structure,"
msgstr ""

#: src/reference/spec/modules.md:223
msgid ""
"identifier of the pipeline that should be compiled to RQ (this can also be "
"an identifier of a module that has a `main` pipeline) and,"
msgstr ""

#: src/reference/spec/modules.md:225
msgid "a \"file loader\", which can load files on-demand."
msgstr ""

#: src/reference/spec/modules.md:227
msgid ""
"The path to the root module can be automatically detected by searching for `."
"prql` files starting with `_` in the current working directory."
msgstr ""

#: src/reference/spec/modules.md:230
msgid "Example prqlc usage:"
msgstr ""

#: src/reference/spec/modules.md:237
msgid ""
"**Single-file interface** requires a single argument; the PRQL source. Any "
"attempts to load modules in this mode result in compilation errors. This "
"interface is needed, for example, when integrating the compiler with a "
"database connector (i.e. JDBC) where no other files can be loaded."
msgstr ""

#: src/reference/spec/modules.md:242
msgid "Built-in module structure"
msgstr ""

#: src/reference/spec/modules.md:244
msgid "Work In Progress"
msgstr ""

#: src/reference/spec/modules.md:265
msgid "Example"
msgstr "範例"

#: src/reference/spec/modules.md:267
msgid ""
"This is an example project, where each of code block is a separate file."
msgstr ""

#: src/reference/spec/modules.md:322
msgid "Sources:"
msgstr ""

#: src/reference/spec/modules.md:324
msgid ""
"[Notes On Module System](https://matklad.github.io/2021/11/27/notes-on-"
"module-system.html), by @matklad."
msgstr ""

#: src/reference/spec/name-resolution.md:3
msgid ""
"Because PRQL primarily handles relational data, it has specialized scoping "
"rules for referencing columns."
msgstr ""

#: src/reference/spec/name-resolution.md:6
msgid "Scopes"
msgstr ""

#: src/reference/spec/name-resolution.md:8
msgid ""
"In PRQL's compiler, a scope is the collection of all names one can reference "
"from a specific point in the program."
msgstr ""

#: src/reference/spec/name-resolution.md:11
msgid ""
"In PRQL, names in the scope are composed from namespace and variable name "
"which are separated by a dot, similar to SQL. Namespaces can contain many "
"dots, but variable names cannot."
msgstr ""

#: src/reference/spec/name-resolution.md:21
msgid ""
"When processing a query, a scope is maintained and updated for each point in "
"the query."
msgstr ""

#: src/reference/spec/name-resolution.md:24
msgid ""
"It start with only namespace `std`, which is the standard library. It "
"contains common functions like `sum` or `count`, along with all transform "
"functions such as `derive` and `group`."
msgstr ""

#: src/reference/spec/name-resolution.md:28
msgid ""
"In pipelines (or rather in transform functions), scope is also injected with "
"namespaces of tables which may have been referenced with `from` or `join` "
"transforms. These namespaces contain simply all the columns of the table and "
"possibly a wildcard variable, which matches any variable (see the algorithm "
"below). Within transforms, there is also a special namespace that does not "
"have a name. It is called a _\"frame\"_ and it contains columns of the "
"current table the transform is operating on."
msgstr ""

#: src/reference/spec/name-resolution.md:36
msgid "Resolving"
msgstr ""

#: src/reference/spec/name-resolution.md:38
msgid ""
"For each ident we want to resolve, we search the scope's items in order. One "
"of three things can happen:"
msgstr ""

#: src/reference/spec/name-resolution.md:41
msgid ""
"Scope contains an exact match, e.g. a name that matches in namespace and the "
"variable name."
msgstr ""

#: src/reference/spec/name-resolution.md:44
msgid ""
"Scope does not contain an exact match, but the ident did not specify a "
"namespace, so we can match a namespace that contains a `*` wildcard. If "
"there's a single namespace, the matched namespace is also updated to contain "
"this new variable name."
msgstr ""

#: src/reference/spec/name-resolution.md:49
msgid "Otherwise, the nothing is matched and an error is raised."
msgstr ""

#: src/reference/spec/name-resolution.md:51
msgid "Translating to SQL"
msgstr "翻譯為 SQL"

#: src/reference/spec/name-resolution.md:53
msgid ""
"When translating into an SQL statement which references only one table, "
"there is no need to reference column names with table prefix."
msgstr ""

#: src/reference/spec/name-resolution.md:61
msgid ""
"But when there are multiple tables and we don't have complete knowledge of "
"all table columns, a column without a prefix (i.e. `first_name`) may "
"actually reside in multiple tables. Because of this, we have to use table "
"prefixes for all column names."
msgstr ""

#: src/reference/spec/name-resolution.md:73
msgid ""
"As you can see, `employees.first_name` now needs table prefix, to prevent "
"conflicts with potential column with the same name in `departments` table. "
"Similarly, `d.title` needs the table prefix."
msgstr ""

#: src/SUMMARY.md:67
msgid "Null handling"
msgstr "Null 處理"

#: src/reference/spec/null.md:3
msgid ""
"SQL has an unconventional way of handling `NULL` values, since it treats "
"them as unknown values. As a result, in SQL:"
msgstr ""

#: src/reference/spec/null.md:6
msgid ""
"`NULL` is not a value indicating a missing entry, but a placeholder for "
"anything possible,"
msgstr ""

#: src/reference/spec/null.md:8
msgid ""
"`NULL = NULL` evaluates to `NULL`, since one cannot know if one unknown is "
"equal to another unknown,"
msgstr ""

#: src/reference/spec/null.md:10
msgid "`NULL <> NULL` evaluates to `NULL`, using same logic,"
msgstr ""

#: src/reference/spec/null.md:11
msgid ""
"to check if a value is `NULL`, SQL introduces `IS NULL` and `IS NOT NULL` "
"operators,"
msgstr ""

#: src/reference/spec/null.md:13
msgid "`DISTINCT column` may return multiple `NULL` values."
msgstr ""

#: src/reference/spec/null.md:15
msgid ""
"For more information, check out the [Postgres documentation](https://www."
"postgresql.org/docs/current/functions-comparison.html)."
msgstr ""

#: src/reference/spec/null.md:18
msgid "PRQL, on the other hand, treats `null` as a value, which means that:"
msgstr ""

#: src/reference/spec/null.md:20
msgid "`null == null` evaluates to `true`,"
msgstr ""

#: src/reference/spec/null.md:21
msgid "`null != null` evaluates to `false`,"
msgstr ""

#: src/reference/spec/null.md:22
msgid "distinct column cannot contain multiple `null` values."
msgstr ""

#: src/reference/spec/null.md:30
msgid ""
"Note that PRQL doesn't change how `NULL` is compared between columns, for "
"example in joins. (PRQL compiles to SQL and so can't change the behavior of "
"the database)."
msgstr ""

#: src/reference/spec/null.md:34
msgid ""
"For more context or to provide feedback check out the discussion on [issue "
"#99](https://github.com/PRQL/prql/issues/99)."
msgstr ""

#: src/reference/spec/type-system.md:1
msgid "Type system"
msgstr "型別系統"

#: src/reference/spec/type-system.md:3
msgid "Status: under development"
msgstr ""

#: src/reference/spec/type-system.md:5
msgid "The type system determines the allowed values of a term."
msgstr ""

#: src/reference/spec/type-system.md:7
msgid "Purpose"
msgstr ""

#: src/reference/spec/type-system.md:9
msgid ""
"Each of the SQL DBMSs has their own type system. Thanks to the SQL standard, "
"they are very similar, but have key differences regardless. For example, "
"SQLite does not have a type for date or time or timestamps, but it has "
"functions for handling date and time that take ISO 8601 strings or integers "
"that represent Unix timestamps. So it does support most of what is possible "
"to do with dates in other dialects, even though it stores data with a "
"different physical layout and uses different functions to achieve that."
msgstr ""

#: src/reference/spec/type-system.md:17
msgid ""
"PRQL's task is to define it's own description of _data formats_, just as how "
"it already defines common _data transformations_."
msgstr ""

#: src/reference/spec/type-system.md:20
msgid "This is done in two steps:"
msgstr ""

#: src/reference/spec/type-system.md:22
msgid ""
"Define PRQL's Type System (PTS), following principles we think a relational "
"language should have (and not fixate on what existing SQL DBMSs have)."
msgstr ""

#: src/reference/spec/type-system.md:25
msgid ""
"Define a mapping between SQL Type System (STS) and PTS, for each of the "
"DBMSs. Ideally we'd want that to be a bijection, so each type in PTS would "
"be represented by a single type in STS and vice-versa. Unfortunately this is "
"not entirely possible, as shown below."
msgstr ""

#: src/reference/spec/type-system.md:30
msgid "In practical terms, we want for a user to be able to:"
msgstr ""

#: src/reference/spec/type-system.md:32
msgid ""
"... express types of their database with PRQL (map their STS into PTS). In "
"some cases, we can allow to say \"your database is not representable with "
"PRQL, change it or use only a subset of it\". An example of what we don't "
"want to support are arrays with arbitrary indexes in Postgres (i.e. 2-based "
"index for arrays)."
msgstr ""

#: src/reference/spec/type-system.md:38
msgid ""
"This task of mapping to PTS could be automated by LSP server, by "
"introspecting user's SQL database and generating PRQL source."
msgstr ""

#: src/reference/spec/type-system.md:41
msgid ""
"... express their SQL queries in PRQL. Again, using mapping from STS to PTS, "
"one should be able to express any SQL operation in PRQL."
msgstr ""

#: src/reference/spec/type-system.md:44
msgid ""
"For example, translate MSSQL `DATEDIFF` to subtraction operator `-` in PRQL."
msgstr ""

#: src/reference/spec/type-system.md:46
msgid ""
"For now, this mapping is manual, but should be documented and may be "
"automated."
msgstr ""

#: src/reference/spec/type-system.md:49
msgid ""
"... use any PRQL feature in their database. Here we are mapping from PTS "
"into an arbitrary STS."
msgstr ""

#: src/reference/spec/type-system.md:52
msgid ""
"For example, translate PRQL's datetime operations to use TEXT in SQLite."
msgstr ""

#: src/reference/spec/type-system.md:54
msgid ""
"As of now, prqlc already does a good job of automatically doing this mapping."
msgstr ""

#: src/reference/spec/type-system.md:56
msgid "Example of the mapping between PTS and two STSs:"
msgstr ""

#: src/reference/spec/type-system.md:58
msgid "PTS"
msgstr ""

#: src/reference/spec/type-system.md:58
msgid "STS Postgres"
msgstr ""

#: src/reference/spec/type-system.md:58
msgid "STS SQLite"
msgstr ""

#: src/reference/spec/type-system.md:60
msgid "int32"
msgstr ""

#: src/reference/spec/type-system.md:60
msgid "integer"
msgstr ""

#: src/reference/spec/type-system.md:60 src/reference/spec/type-system.md:61
msgid "INTEGER"
msgstr ""

#: src/reference/spec/type-system.md:61
msgid "int64"
msgstr ""

#: src/reference/spec/type-system.md:61
msgid "bigint"
msgstr ""

#: src/reference/spec/type-system.md:62
msgid "timestamp"
msgstr ""

#: src/reference/spec/type-system.md:62
msgid "TEXT"
msgstr ""

#: src/reference/spec/type-system.md:64
msgid "Principles"
msgstr ""

#: src/reference/spec/type-system.md:66
msgid ""
"**Algebraic types** - have a way of expressing sum and product types. In "
"Rust, sum would be an enum and product would be tuple or a struct. In SQL, "
"product would be a row, since it can contain different types, all at once. "
"Sum would be harder to express, see (this post)\\[https://www.parsonsmatt."
"org/2019/03/19/sum_types_in_sql.html \\]."
msgstr ""

#: src/reference/spec/type-system.md:72
msgid ""
"The value proposition here is that algebraic types give a lot modeling "
"flexibility, all while being conceptually simple."
msgstr ""

#: src/reference/spec/type-system.md:75
msgid ""
"**Composable** - as with transformation, we'd want types to compose together."
msgstr ""

#: src/reference/spec/type-system.md:77
msgid ""
"Using Python, JavaScript, C++ or Rust, one could define many different data "
"structures that would correspond to our idea of \"relation\". Most of them "
"would be an object/struct that has column names and types and then a generic "
"array of arrays for rows."
msgstr ""

#: src/reference/spec/type-system.md:82
msgid ""
"PRQL's type system should also be able to express relations as composed from "
"primitive types, but have only one idiomatic way of doing so."
msgstr ""

#: src/reference/spec/type-system.md:85
msgid ""
"In practice, this means that builtin types include only primitives (int, "
"text, bool, float), tuple (for product), enum (for sum) and array (for "
"repeating). An SQL row translates to a tuple, and a relation translates to "
"an array of tuples."
msgstr ""

#: src/reference/spec/type-system.md:89
msgid ""
"Composability also leads to a minimal type system, which does not "
"differentiate between tuples, objects and structs. A single product type is "
"enough."
msgstr ""

#: src/reference/spec/type-system.md:92
msgid "**No subtyping** - avoid super types and inheritance."
msgstr ""

#: src/reference/spec/type-system.md:94
msgid ""
"Subtyping is a natural extension to a type system, where a type can be a "
"super type of some other type. This is base mechanism for Object Oriented "
"Programming, but is also present in most dynamically types languages. For "
"example, a type `number` might be super type of `int` and `float`."
msgstr ""

#: src/reference/spec/type-system.md:99
msgid ""
"PTS does not have subtyping, because it requires dynamic dispatch and "
"because it adds unnecessary complexity to generic type arguments."
msgstr ""

#: src/reference/spec/type-system.md:102
msgid ""
"Dynamic dispatch, is a mechanism that would be able, for example, to call "
"appropriate `to_string` function for each element of an array of `number`. "
"This array contains both elements of type `int` and type `float`, with "
"different `to_string` implementations."
msgstr ""

#: src/reference/spec/type-system.md:132
msgid ""
"For any undefined terms used in this section, refer to set theory and "
"mathematical definitions in general."
msgstr ""

#: src/reference/spec/type-system.md:135
msgid ""
"A \"type of a variable\" is a \"set of all possible values of that "
"variable\"."
msgstr ""

#: src/reference/spec/type-system.md:137
msgid "Primitives"
msgstr ""

#: src/reference/spec/type-system.md:139
msgid ""
"At the moment of writing, PRQL defines following primitive types: `int`, "
"`float`, `bool`, `text`, `date`, `time` and `timestamp`. New primitive types "
"will be added in the future and some of existing types might be split into "
"smaller subsets (see section \"Splitting primitives\")."
msgstr ""

#: src/reference/spec/type-system.md:144
msgid "Tuples"
msgstr "元組"

#: src/reference/spec/type-system.md:146
msgid "Tuple type is a product type."
msgstr ""

#: src/reference/spec/type-system.md:148
msgid ""
"It contains n ordered fields, where n is known at compile-time. Each field "
"has a type itself and an optional name. Fields are not necessarily of the "
"same type."
msgstr ""

#: src/reference/spec/type-system.md:151
msgid ""
"In other languages, similar constructs are named record, struct, tuple, "
"named tuple or (data)class."
msgstr ""

#: src/reference/spec/type-system.md:158
msgid "Arrays"
msgstr "陣列"

#: src/reference/spec/type-system.md:160
msgid ""
"Array is a container type that contains n ordered fields, where n is not "
"known at compile-time. All fields are of the same type and cannot be named."
msgstr ""

#: src/reference/spec/type-system.md:173
msgid "Union"
msgstr ""

#: src/reference/spec/type-system.md:183
msgid "This is \"a sum type\"."
msgstr ""

#: src/reference/spec/type-system.md:185
msgid "Type annotations"
msgstr ""

#: src/reference/spec/type-system.md:187
msgid ""
"Variable annotations and function parameters may specify type annotations:"
msgstr ""

#: src/reference/spec/type-system.md:193
msgid "The value of `x` (and thus `a`) must be an element of `t`."
msgstr ""

#: src/reference/spec/type-system.md:199
msgid "The value of argument supplied to `x` must be an element of `t`."
msgstr ""

#: src/reference/spec/type-system.md:205
msgid "The value of function body `y` must be an element of `t`."
msgstr ""

#: src/reference/spec/type-system.md:207
msgid "Physical layout"
msgstr ""

#: src/reference/spec/type-system.md:209
msgid ""
"_Logical type_ is user-facing the notion of a type that is the building "
"block of the type system."
msgstr ""

#: src/reference/spec/type-system.md:212
msgid ""
"_Physical layout_ is the underlying memory layout of the data represented by "
"a variable."
msgstr ""

#: src/reference/spec/type-system.md:215
msgid ""
"In many programming languages, physical layout of a logical type is "
"dependent on the target platform. Similarly, physical layout of a PRQL "
"logical type is dependent on representation of that type in the target STS."
msgstr ""

#: src/reference/spec/type-system.md:223
msgid ""
"Note that not all STS types do not have a single physical layout. Postgres "
"has a logical (pseudo)type `anyelement`, which is a super type of any data "
"type. It can be used as a function parameter type, but does not have a "
"single physical layout so it cannot be used in a column declaration."
msgstr ""

#: src/reference/spec/type-system.md:228
msgid ""
"For now, PRQL does not define physical layouts of any type. It is not needed "
"since PRQL is not used for DDL (see section \"Splitting primitives\") or "
"does not support raw access to underlying memory."
msgstr ""

#: src/reference/spec/type-system.md:232
msgid ""
"As a consequence, results of a PRQL query cannot be robustly compared across "
"DBMSs, since the physical layout of the result will vary."
msgstr ""

#: src/reference/spec/type-system.md:235
msgid ""
"In the future, PRQL may define a common physical layout of types, probably "
"using Apache Arrow."
msgstr ""

#: src/reference/spec/type-system.md:261
msgid "Appendix"
msgstr "附錄"

#: src/reference/spec/type-system.md:263
msgid "Splitting primitives"
msgstr ""

#: src/reference/spec/type-system.md:265
msgid ""
"This document mentions `int32` and `int64` as distinct types, but there is "
"no need for that in the initial implementation. The built-in `int` can "
"associate with all operations on integers and translate PRQL to valid SQL "
"regardless of the size of the integer. Later, `int` cam be replaced by "
"`int8`, `int16`, `int32`, `int64`."
msgstr ""

#: src/reference/spec/type-system.md:271
msgid ""
"The general rule for \"when to make a distinction between types\" would be "
"\"as soon as the types carry different information and we find an operation "
"that would be expressed differently\". In this example, that would require "
"some operation on `int32` to have different syntax than same operation over "
"`int64`."
msgstr ""

#: src/reference/spec/type-system.md:276
msgid ""
"We can have such relaxed rule because PRQL is not aiming to be a Data "
"Definition Language and does not have to bother with exact physical layout "
"of types."
msgstr ""

#: src/reference/spec/type-system.md:279
msgid "Type representations"
msgstr ""

#: src/reference/spec/type-system.md:281
msgid ""
"There are cases where a PTS type has multiple possible and valid "
"representations in some STSs."
msgstr ""

#: src/reference/spec/type-system.md:284
msgid ""
"For such cases, we'd want to support the use of alternative representations "
"for storing data, but also application of any function that is defined for "
"the original type."
msgstr ""

#: src/reference/spec/type-system.md:288
msgid ""
"Using SQLite as an example again, users may have some temporal data stored "
"as INTEGER unix timestamp and some as TEXT that contains ISO 8601 without "
"timezone. From the user's perspective, both of these types are `timestamp`s "
"and should be declared as such. But when compiling operations over these "
"types to SQL, the compiler should consider their different representations "
"in STS. For example a difference between two timestamps `timestamp - "
"timestamp` can be translated to a normal int subtraction for INTEGER repr, "
"but must apply SQLite's function `unixepoch` when dealing with TEXT repr."
msgstr ""

#: src/reference/spec/type-system.md:297
msgid ""
"Table declarations should therefore support annotations that give hints "
"about which representation is used:"
msgstr ""

#: src/reference/spec/type-system.md:307
msgid ""
"A similar example is an \"array of strings type\" in PTS that could be "
"represented by a `text[]` (if DBMS supports arrays) or `json` or it's "
"variant `jsonb` in Postgres. Again, the representation would affect "
"operators: in Postgres, arrays would be accessed with `my_array[1]` and json "
"arrays would use `my_json_array -> 1`. This example may not be applicable, "
"if we decide that we want a separate JSON type in PST."
msgstr ""

#: src/reference/spec/type-system.md:314
msgid "RQ functions, targets and reprs"
msgstr ""

#: src/reference/spec/type-system.md:316
msgid ""
"This part is talks about technical implementations, not the language itself"
msgstr ""

#: src/reference/spec/type-system.md:318
msgid "Idea"
msgstr ""

#: src/reference/spec/type-system.md:320
msgid ""
"RQ contains a single node kind for expressing operations and functions: "
"BuiltInFunction (may be renamed in the future)."
msgstr ""

#: src/reference/spec/type-system.md:323
msgid ""
"It is a bottleneck that we can leverage when trying to affect how an "
"operator or a function interacts with different type representations on "
"different targets."
msgstr ""

#: src/reference/spec/type-system.md:326
msgid ""
"Idea is to implement the BuiltInFunction multiple times and annotate it with "
"it intended target and parameter representation. Then we can teach the "
"compiler to pick the appropriate function implementation that suit current "
"repr and compilation target."
msgstr ""

#: src/reference/spec/type-system.md:331
msgid "Specifics"
msgstr ""

#: src/reference/spec/type-system.md:333
msgid ""
"RQ specification is an interface that contains functions, identified by name "
"(i.e. `std.int8.add`). These functions have typed parameters and a return "
"value. If an RQ function call does not match the function declaration in "
"number or in types of the parameters, this is considered an invalid RQ AST."
msgstr ""

#: src/reference/spec/type-system.md:338
msgid ""
"We provide multiple implementations for each RQ function. They are annotated "
"with a target (i.e. `#[target(sql.sqlite)]`) and have their params annotated "
"with type reprs (i.e. `#[repr(int)]`)."
msgstr ""

#: src/reference/spec/type-system.md:342
msgid ""
"```\n"
"# using a made-up syntax\n"
"\n"
"#[target(sql.sqlite)]\n"
"func std.int8.add\n"
"    #[repr(int8)] x\n"
"    #[repr(int8)] y\n"
"    -> s\"{x} + {y}\"\n"
"```"
msgstr ""

#: src/reference/spec/type-system.md:352
msgid ""
"Each RQ type has one canonical repr that serves as the reference "
"implementation for other reprs and indicates the amount of contained data (i."
"e. 1 bit, 8 bits, 64 bits)."
msgstr ""

#: src/reference/spec/type-system.md:358
msgid ""
"Let's say for example, that we'd want to support 8bit integer arithmetic, "
"and that we'd want the result of `127 + 1` to be `-128` (ideally we'd handle "
"this better, but bear with me for the sake of the example). Because some "
"RDBMSs don't support 8bit numbers and do all their integer computation with "
"64bit numbers (SQLite), we need to implement an alternative type "
"representation for that target."
msgstr ""

#: src/reference/spec/type-system.md:365
msgid "The logical type `int8` could have the following two reprs:"
msgstr ""

#: src/reference/spec/type-system.md:367
msgid ""
"canonical `repr_int8` that contains 8 bits in two's complement, covering "
"integer values in range -128 to 127 (inclusive),"
msgstr ""

#: src/reference/spec/type-system.md:369
msgid ""
"`repr_int64` that contains 64 bits of data, but is using only the values "
"that are also covered by `repr_int8`."
msgstr ""

#: src/reference/spec/type-system.md:372
msgid ""
"Now we'd implement function `std.int8.add` for each of the reprs. Let's "
"assume that the `int8` implementation is straightforward and that databases "
"don't just change the data type when a number overflows. The impl for "
"`int64` requires a CASE statement that checks if the value would overflow "
"and subtact 256 in that case."
msgstr ""

#: src/reference/spec/type-system.md:378
msgid ""
"The goal here is that the results of the two impls are equivalent. To "
"validate that, we also need a way to convert between the reprs, or another "
"`to_string` function, implemented for both reprs."
msgstr ""

#: src/reference/stdlib/index.md:1
msgid "Standard library"
msgstr "標準庫"

#: src/reference/stdlib/index.md:3
msgid ""
"The standard library currently contains commonly used functions that are "
"used in SQL. It's not yet as broad as we'd like, and we're very open to "
"expanding it."
msgstr ""
"標準庫目前包含在 SQL 中使用的常用函式。它的覆蓋範圍還不如我們希望的那麼寬，我"
"們非常歡迎擴展它。"

#: src/reference/stdlib/index.md:6
msgid ""
"Currently s-strings are an escape-hatch for any function that isn't in our "
"standard library. If we find ourselves using them for something frequently, "
"raise an issue and we'll add it to the stdlib."
msgstr ""
"目前 s-字串是任何不在我們標準庫中的函式的逃脫艙口。如果我們發現自己經常為某些"
"東西使用它們，請提出問題，我們會將其新增到標準庫中。"

#: src/reference/stdlib/index.md:10
msgid ""
"Here's the source of the current [PRQL `std`](https://github.com/PRQL/prql/"
"blob/main/prqlc/prqlc/src/semantic/std.prql):"
msgstr ""
"以下是當前 [PRQL `std`](https://github.com/PRQL/prql/blob/main/prqlc/prqlc/"
"src/semantic/std.prql) 的源代碼："

#: src/reference/stdlib/index.md:13
msgid ""
"```admonish note\n"
"PRQL 0.9.0 has started supporting different DB implementations for standard "
"library functions.\n"
"The source is the [`std.sql`](https://github.com/PRQL/prql/blob/main/prqlc/"
"prqlc/src/sql/std.sql.prql).\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:18
msgid ""
"````prql no-eval\n"
"# The PRQL standard library defines the following functions and transforms.\n"
"# The definitions are whitespace insensitive, and have this form:\n"
"#\n"
"# ```\n"
"# let my_func = param1 param2 ...  -> <return_type> body_expr\n"
"# ```\n"
"#\n"
"# Where:\n"
"#   * `my_func` is the name of the function\n"
"#   * `param1` is the first parameter optionally followed by a type in "
"\"< ... >\"\n"
"#   * `param2` etc. follow the same pattern as param1\n"
"#   * `<return_type>` is the type of result wrapped in \"< ... >\"\n"
"#   * `body_expr` defines the function body that creates the result.\n"
"#     It can be PRQL code or `internal ...` to indicate internal compiler "
"code.\n"
"\n"
"# Operators\n"
"\n"
"let mul = left right -> <int || float> internal std.mul\n"
"let div_i = left right -> <int || float> internal std.div_i\n"
"let div_f = left right -> <int || float> internal std.div_f\n"
"let mod = left right -> <int || float> internal std.mod\n"
"let add = left right -> <int || float || timestamp || date> internal std."
"add\n"
"let sub = left right -> <int || float || timestamp || date> internal std."
"sub\n"
"let eq = left right -> <bool> internal std.eq\n"
"let ne = left right -> <bool> internal std.ne\n"
"let gt = left right -> <bool> internal std.gt\n"
"let lt = left right -> <bool> internal std.lt\n"
"let gte = left right -> <bool> internal std.gte\n"
"let lte = left right -> <bool> internal std.lte\n"
"let and = left<bool> right<bool> -> <bool> internal std.and\n"
"let or = left<bool> right<bool> -> <bool> internal std.or\n"
"let coalesce = left right -> internal std.coalesce\n"
"let regex_search = text pattern -> <bool> internal std.regex_search\n"
"\n"
"let neg = expr<int || float> -> <int || float> internal std.neg\n"
"let not = expr<bool> -> <bool> internal std.not\n"
"\n"
"# Types\n"
"\n"
"## Type primitives\n"
"type int = int\n"
"type float = float\n"
"type bool = bool\n"
"type text = text\n"
"type date = date\n"
"type time = time\n"
"type timestamp = timestamp\n"
"type `func` = func\n"
"type anytype = anytype\n"
"\n"
"## Generic array\n"
"# TODO: an array of anything, not just nulls\n"
"type array = [anytype]\n"
"\n"
"## Scalar\n"
"type scalar = int || float || bool || text || date || time || timestamp || "
"null\n"
"type tuple = {anytype..}\n"
"\n"
"## Range\n"
"type range = {start = scalar, end = scalar}\n"
"\n"
"## Relation (an array of tuples)\n"
"type relation = [tuple]\n"
"\n"
"## Transform\n"
"type transform = func relation -> relation\n"
"\n"
"# Functions\n"
"\n"
"## Relational transforms\n"
"let from = func\n"
"  `default_db.source` <relation>\n"
"  -> <relation> source\n"
"\n"
"let select = func\n"
"  columns <anytype>\n"
"  tbl <relation>\n"
"  -> <relation> internal select\n"
"\n"
"let filter = func\n"
"  condition <bool>\n"
"  tbl <relation>\n"
"  -> <relation> internal filter\n"
"\n"
"let derive = func\n"
"  columns <anytype>\n"
"  tbl <relation>\n"
"  -> <relation> internal derive\n"
"\n"
"let aggregate = func\n"
"  columns <anytype>\n"
"  tbl <relation>\n"
"  -> <relation> internal aggregate\n"
"\n"
"let sort = func\n"
"  by <anytype>\n"
"  tbl <relation>\n"
"  -> <relation> internal sort\n"
"\n"
"let take = func\n"
"  expr <anytype>\n"
"  tbl <relation>\n"
"  -> <relation> internal take\n"
"\n"
"let join = func\n"
"  `default_db.with` <relation>\n"
"  condition <bool>\n"
"  `noresolve.side`:inner\n"
"  tbl <relation>\n"
"  -> <relation> internal join\n"
"\n"
"let group = func\n"
"  by<scalar || tuple>\n"
"  pipeline <transform>\n"
"  tbl <relation>\n"
"  -> <relation> internal group\n"
"\n"
"let window = func\n"
"  rows:0..0\n"
"  range:0..0\n"
"  expanding <bool>:false\n"
"  rolling <int>:0\n"
"  pipeline <transform>\n"
"  tbl <relation>\n"
"  -> <relation> internal window\n"
"\n"
"let append = `default_db.bottom`<relation> top<relation> -> <relation> "
"internal append\n"
"let intersect = `default_db.bottom`<relation> top<relation> -> <relation> (\n"
"  t = top\n"
"  join (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b.*)))\n"
"  select t.*\n"
")\n"
"let remove = `default_db.bottom`<relation> top<relation> -> <relation> (\n"
"  t = top\n"
"  join side:left (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b."
"*)))\n"
"  filter (tuple_every (tuple_map _is_null b.*))\n"
"  select t.*\n"
")\n"
"let loop = func\n"
"  pipeline <transform>\n"
"  top <relation>\n"
"  -> <relation> internal loop\n"
"\n"
"## Aggregate functions\n"
"# These return either a scalar when used within `aggregate`, or a column "
"when used anywhere else.\n"
"\n"
"let min = column <array> -> <int || float || null> internal std.min\n"
"\n"
"let max = column <array> -> <int || float || null> internal std.max\n"
"\n"
"let sum = column <array> -> <int || float> internal std.sum\n"
"\n"
"let average = column <array> -> <float || null> internal std.average\n"
"\n"
"let stddev = column <array> -> <float || null> internal std.stddev\n"
"\n"
"let all = column <array> -> <bool> internal std.all\n"
"\n"
"let any = column <array> -> <bool> internal std.any\n"
"\n"
"let concat_array = column <array> -> <text> internal std.concat_array\n"
"\n"
"# Counts number of items in the column.\n"
"# Note that the count will include null values.\n"
"let count = column<array> -> <int> internal count\n"
"\n"
"# Deprecated in favour of filterning input to the [std.count] function (not "
"yet implemented).\n"
"@{deprecated}\n"
"let count_distinct = column <array> -> internal std.count_distinct\n"
"\n"
"## Window functions\n"
"let lag =   offset <int>    column <array> -> internal std.lag\n"
"let lead =  offset <int>    column <array> -> internal std.lead\n"
"let first      = column <array> -> internal std.first\n"
"let last       = column <array> -> internal std.last\n"
"let rank       = column <array> -> internal std.rank\n"
"let rank_dense = column <array> -> internal std.rank_dense\n"
"let row_number = column <array> -> internal row_number\n"
"\n"
"# Mathematical functions\n"
"module math {\n"
"  let abs = column -> <int || float> internal std.math.abs\n"
"  let floor = column -> <int> internal std.math.floor\n"
"  let ceil = column -> <int> internal std.math.ceil\n"
"  let pi = -> <float> internal std.math.pi\n"
"  let exp = column -> <int || float> internal std.math.exp\n"
"  let ln = column -> <int || float> internal std.math.ln\n"
"  let log10 = column -> <int || float> internal std.math.log10\n"
"  let log = base<int || float> column -> <int || float> internal std.math."
"log\n"
"  let sqrt = column -> <int || float> internal std.math.sqrt\n"
"  let degrees = column -> <int || float> internal std.math.degrees\n"
"  let radians = column -> <int || float> internal std.math.radians\n"
"  let cos = column -> <int || float> internal std.math.cos\n"
"  let acos = column -> <int || float> internal std.math.acos\n"
"  let sin = column -> <int || float> internal std.math.sin\n"
"  let asin = column -> <int || float> internal std.math.asin\n"
"  let tan = column -> <int || float> internal std.math.tan\n"
"  let atan = column -> <int || float> internal std.math.atan\n"
"  let pow = exponent<int || float> column -> <int || float> internal std."
"math.pow\n"
"  let round = n_digits column -> <scalar> internal std.math.round\n"
"}\n"
"\n"
"## Misc functions\n"
"let as = `noresolve.type` column -> <scalar> internal std.as\n"
"let in = pattern value -> <bool> internal in\n"
"\n"
"## Tuple functions\n"
"let tuple_every = func list -> <bool> internal tuple_every\n"
"let tuple_map = func fn <func> list -> internal tuple_map\n"
"let tuple_zip = func a b -> internal tuple_zip\n"
"let _eq = func a -> internal _eq\n"
"let _is_null = func a -> _param.a == null\n"
"\n"
"## Misc\n"
"let from_text = input<text> `noresolve.format`:csv -> <relation> internal "
"from_text\n"
"\n"
"## Text functions\n"
"module text {\n"
"  let lower = column -> <text> internal std.text.lower\n"
"  let upper = column -> <text> internal std.text.upper\n"
"  let ltrim = column -> <text> internal std.text.ltrim\n"
"  let rtrim = column -> <text> internal std.text.rtrim\n"
"  let trim = column -> <text> internal std.text.trim\n"
"  let length = column -> <int> internal std.text.length\n"
"  let extract = offset<int> length<int> column -> <text> internal std.text."
"extract\n"
"  let replace = pattern<text> replacement<text> column -> <text> internal "
"std.text.replace\n"
"  let starts_with = prefix<text> column -> <bool> internal std.text."
"starts_with\n"
"  let contains = substr<text> column -> <bool> internal std.text.contains\n"
"  let ends_with = suffix<text> column -> <bool> internal std.text.ends_with\n"
"}\n"
"\n"
"## Date functions\n"
"module date {\n"
"  let to_text = format<text> column -> <text> internal std.date.to_text\n"
"}\n"
"\n"
"## File-reading functions, primarily for DuckDB\n"
"let read_parquet = source<text> -> <relation> internal std.read_parquet\n"
"let read_csv = source<text> -> <relation> internal std.read_csv\n"
"\n"
"\n"
"## PRQL compiler functions\n"
"module `prql` {\n"
"  let version = -> <text> internal prql_version\n"
"}\n"
"\n"
"# Deprecated, will be removed in 0.12.0\n"
"let prql_version = -> <text> internal prql_version\n"
"````"
msgstr ""

#: src/reference/stdlib/index.md:269
msgid "And a couple of examples:"
msgstr "以下是幾個示例："

#: src/reference/stdlib/index.md:271
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = (salary + payroll_tax | as int),\n"
"  gross_salary_rounded = (gross_salary | math.round 0),\n"
"  time = s\"NOW()\",  # an s-string, given no `now` function exists in PRQL\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:280
msgid "Example of different implementations of division and integer division:"
msgstr "不同實現的除法和整數除法的示例："

#: src/reference/stdlib/index.md:282
msgid ""
"```prql\n"
"prql target:sql.sqlite\n"
"\n"
"from [{x = 13, y = 5}]\n"
"select {\n"
"  quotient = x / y,\n"
"  int_quotient = x // y,\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:292
msgid ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from [{x = 13, y = 5}]\n"
"select {\n"
"  quotient = x / y,\n"
"  int_quotient = x // y,\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/date.md:1
msgid "Date functions"
msgstr "日期函式"

#: src/reference/stdlib/date.md:3
msgid "These are all the functions defined in the `date` module:"
msgstr ""

#: src/reference/stdlib/date.md:5
msgid "`to_text`"
msgstr ""

#: src/reference/stdlib/date.md:7
msgid ""
"Converts a date into a text.  \n"
"Since there are many possible date representations, `to_text` takes a "
"`format` parameter that describes thanks to [specifiers](#date--time-format-"
"specifiers) how the date or timestamp should be structured."
msgstr ""

#: src/reference/stdlib/date.md:20
msgid ""
"```prql\n"
"prql target:sql.duckdb\n"
"\n"
"from invoices\n"
"select {\n"
"  invoice_date | date.to_text \"%d/%m/%Y\"\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/date.md:29
msgid ""
"```prql\n"
"prql target:sql.postgres\n"
"\n"
"from invoices\n"
"select {\n"
"  invoice_date | date.to_text \"%d/%m/%Y\"\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/date.md:38
msgid ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from invoices\n"
"select {\n"
"  invoice_date | date.to_text \"%d/%m/%Y\"\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/date.md:47
msgid "Date & time format specifiers"
msgstr ""

#: src/reference/stdlib/date.md:49
msgid ""
"PRQL specifiers for date and time formatting is a subset of specifiers used "
"by [`chrono`](https://docs.rs/chrono/latest/chrono/format/strftime/index."
"html)."
msgstr ""

#: src/reference/stdlib/date.md:52
msgid "Here is the list of the specifiers currently supported:"
msgstr ""

#: src/reference/stdlib/date.md:54
msgid "Spec."
msgstr ""

#: src/reference/stdlib/date.md:54
msgid "Description"
msgstr ""

#: src/reference/stdlib/date.md:57
msgid "**DATE SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:58
msgid "`%Y`"
msgstr ""

#: src/reference/stdlib/date.md:58
msgid "`2001`"
msgstr ""

#: src/reference/stdlib/date.md:58
msgid "Year number, zero-padded to 4 digits"
msgstr ""

#: src/reference/stdlib/date.md:59
msgid "`%y`"
msgstr ""

#: src/reference/stdlib/date.md:59
msgid "`01`"
msgstr ""

#: src/reference/stdlib/date.md:59
msgid "Year number, zero-padded to 2 digits"
msgstr ""

#: src/reference/stdlib/date.md:60
msgid "`%m`"
msgstr ""

#: src/reference/stdlib/date.md:60
msgid "`07`"
msgstr ""

#: src/reference/stdlib/date.md:60
msgid "Month number (01–12), zero-padded to 2 digits"
msgstr ""

#: src/reference/stdlib/date.md:61
msgid "`%-m`"
msgstr ""

#: src/reference/stdlib/date.md:61
msgid "`7`"
msgstr ""

#: src/reference/stdlib/date.md:61
msgid "Month number (1-12)"
msgstr ""

#: src/reference/stdlib/date.md:62
msgid "`%b`"
msgstr ""

#: src/reference/stdlib/date.md:62
msgid "`Jul`"
msgstr ""

#: src/reference/stdlib/date.md:62
msgid "Abbreviated month name. Always 3 letters."
msgstr ""

#: src/reference/stdlib/date.md:63
msgid "`%B`"
msgstr ""

#: src/reference/stdlib/date.md:63
msgid "`July`"
msgstr ""

#: src/reference/stdlib/date.md:63
msgid "Full month name"
msgstr "完整月份名稱"

#: src/reference/stdlib/date.md:64
msgid "`%d`"
msgstr ""

#: src/reference/stdlib/date.md:64
msgid "`08`"
msgstr ""

#: src/reference/stdlib/date.md:64
msgid "Day number (01-31), zero-padded to 2 digits"
msgstr ""

#: src/reference/stdlib/date.md:65
msgid "`%-d`"
msgstr ""

#: src/reference/stdlib/date.md:65
msgid "` 8`"
msgstr ""

#: src/reference/stdlib/date.md:65
msgid "Day number (1-31)"
msgstr ""

#: src/reference/stdlib/date.md:66
msgid "`%a`"
msgstr ""

#: src/reference/stdlib/date.md:66
msgid "`Sun`"
msgstr ""

#: src/reference/stdlib/date.md:66
msgid "Abbreviated weekday name. Always 3 letters"
msgstr ""

#: src/reference/stdlib/date.md:67
msgid "`%A`"
msgstr ""

#: src/reference/stdlib/date.md:67
msgid "`Sunday`"
msgstr ""

#: src/reference/stdlib/date.md:67
msgid "Full weekday name"
msgstr ""

#: src/reference/stdlib/date.md:68
msgid "`%D`"
msgstr ""

#: src/reference/stdlib/date.md:68 src/reference/stdlib/date.md:69
msgid "`07/08/01`"
msgstr ""

#: src/reference/stdlib/date.md:68
msgid "Month-day-year format. Same as `%m/%d/%y`"
msgstr ""

#: src/reference/stdlib/date.md:69
msgid "`%x`"
msgstr ""

#: src/reference/stdlib/date.md:69
msgid "Locale's date representation"
msgstr ""

#: src/reference/stdlib/date.md:70
msgid "`%F`"
msgstr ""

#: src/reference/stdlib/date.md:70
msgid "`2001-07-08`"
msgstr ""

#: src/reference/stdlib/date.md:70
msgid "Year-month-day format (ISO 8601). Same as `%Y-%m-%d`"
msgstr ""

#: src/reference/stdlib/date.md:72
msgid "**TIME SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:73
msgid "`%H`"
msgstr ""

#: src/reference/stdlib/date.md:73
msgid "`00`"
msgstr ""

#: src/reference/stdlib/date.md:73
msgid "Hour number (00-23)"
msgstr ""

#: src/reference/stdlib/date.md:74
msgid "`%k`"
msgstr ""

#: src/reference/stdlib/date.md:74
msgid "` 0`"
msgstr ""

#: src/reference/stdlib/date.md:74
msgid "Same as `%H` but space-padded. Same as `%_H`."
msgstr ""

#: src/reference/stdlib/date.md:75
msgid "`%I`"
msgstr ""

#: src/reference/stdlib/date.md:75
msgid "`12`"
msgstr ""

#: src/reference/stdlib/date.md:75
msgid "Hour number in 12-hour clocks (01--12), zero-padded to 2 digits."
msgstr ""

#: src/reference/stdlib/date.md:76
msgid "`%p`"
msgstr ""

#: src/reference/stdlib/date.md:76
msgid "`AM`"
msgstr ""

#: src/reference/stdlib/date.md:76
msgid "`AM` or `PM` in 12-hour clocks."
msgstr ""

#: src/reference/stdlib/date.md:77
msgid "`%M`"
msgstr ""

#: src/reference/stdlib/date.md:77
msgid "`34`"
msgstr ""

#: src/reference/stdlib/date.md:77
msgid "Minute number (00-59), zero-padded to 2 digits."
msgstr ""

#: src/reference/stdlib/date.md:78
msgid "`%S`"
msgstr ""

#: src/reference/stdlib/date.md:78
msgid "`60`"
msgstr ""

#: src/reference/stdlib/date.md:78
msgid "Second number (00-59), zero-padded to 2 digits."
msgstr ""

#: src/reference/stdlib/date.md:79
msgid "`%f`"
msgstr ""

#: src/reference/stdlib/date.md:79
msgid "`264900`"
msgstr ""

#: src/reference/stdlib/date.md:79
msgid "Number of microseconds[^1] since last whole second"
msgstr ""

#: src/reference/stdlib/date.md:80
msgid "`%R`"
msgstr ""

#: src/reference/stdlib/date.md:80
msgid "`00:34`"
msgstr ""

#: src/reference/stdlib/date.md:80
msgid "Hour-minute format. Same as `%H:%M`."
msgstr ""

#: src/reference/stdlib/date.md:81
msgid "`%T`"
msgstr ""

#: src/reference/stdlib/date.md:81 src/reference/stdlib/date.md:82
msgid "`00:34:60`"
msgstr ""

#: src/reference/stdlib/date.md:81
msgid "Hour-minute-second format. Same as `%H:%M:%S`."
msgstr ""

#: src/reference/stdlib/date.md:82
msgid "`%X`"
msgstr ""

#: src/reference/stdlib/date.md:82
msgid "Locale's time representation (e.g., 23:13:48)."
msgstr ""

#: src/reference/stdlib/date.md:83
msgid "`%r`"
msgstr ""

#: src/reference/stdlib/date.md:83
msgid "`12:34:60 AM`"
msgstr ""

#: src/reference/stdlib/date.md:83
msgid "Locale's 12 hour clock time. (e.g., 11:11:04 PM)"
msgstr ""

#: src/reference/stdlib/date.md:85
msgid "**DATE & TIME SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:86
msgid "`%+`"
msgstr ""

#: src/reference/stdlib/date.md:86
msgid "`2001-07-08T00:34:60.026490Z`"
msgstr ""

#: src/reference/stdlib/date.md:86
msgid "ISO 8601 / RFC 3339 date & time format."
msgstr ""

#: src/reference/stdlib/date.md:88
msgid "**SPECIAL SPECIFIERS:**"
msgstr ""

#: src/reference/stdlib/date.md:89
msgid "`%t`"
msgstr ""

#: src/reference/stdlib/date.md:89
msgid "Literal tab (`\\t`)."
msgstr ""

#: src/reference/stdlib/date.md:90
msgid "`%n`"
msgstr ""

#: src/reference/stdlib/date.md:90
msgid "Literal newline (`\\n`)."
msgstr ""

#: src/reference/stdlib/date.md:91
msgid "`%%`"
msgstr ""

#: src/reference/stdlib/date.md:91
msgid "Literal percent sign."
msgstr ""

#: src/reference/stdlib/date.md:93
msgid "This is different from chrono, for which `%f` represents nanoseconds"
msgstr ""

#: src/reference/stdlib/math.md:1
msgid "Mathematical functions"
msgstr "數學函式"

#: src/reference/stdlib/math.md:3
msgid "These are all the functions defined in the `math` module:"
msgstr ""

#: src/reference/stdlib/math.md:5
msgid "function"
msgstr ""

#: src/reference/stdlib/math.md:5
msgid "parameters"
msgstr ""

#: src/reference/stdlib/math.md:5
msgid "description"
msgstr ""

#: src/reference/stdlib/math.md:7
msgid "abs"
msgstr ""

#: src/reference/stdlib/math.md:7 src/reference/stdlib/math.md:8
#: src/reference/stdlib/math.md:9 src/reference/stdlib/math.md:10
#: src/reference/stdlib/math.md:11 src/reference/stdlib/math.md:12
#: src/reference/stdlib/math.md:13 src/reference/stdlib/math.md:14
#: src/reference/stdlib/math.md:15 src/reference/stdlib/math.md:16
#: src/reference/stdlib/math.md:18 src/reference/stdlib/math.md:21
#: src/reference/stdlib/math.md:23 src/reference/stdlib/math.md:24
#: src/reference/stdlib/math.md:25
msgid "`col`"
msgstr ""

#: src/reference/stdlib/math.md:7
msgid "Absolute value of `col`"
msgstr ""

#: src/reference/stdlib/math.md:8
msgid "acos"
msgstr ""

#: src/reference/stdlib/math.md:8
msgid "Arccosine of `col`"
msgstr ""

#: src/reference/stdlib/math.md:9
msgid "asin"
msgstr ""

#: src/reference/stdlib/math.md:9
msgid "Arcsine of `col`"
msgstr ""

#: src/reference/stdlib/math.md:10
msgid "atan"
msgstr ""

#: src/reference/stdlib/math.md:10
msgid "Arctangent of `col`"
msgstr ""

#: src/reference/stdlib/math.md:11
msgid "ceil"
msgstr ""

#: src/reference/stdlib/math.md:11
msgid "Rounds the number up of `col`"
msgstr ""

#: src/reference/stdlib/math.md:12
msgid "cos"
msgstr ""

#: src/reference/stdlib/math.md:12
msgid "Cosine of `col`"
msgstr ""

#: src/reference/stdlib/math.md:13
msgid "degrees"
msgstr ""

#: src/reference/stdlib/math.md:13
msgid "Converts radians to degrees"
msgstr ""

#: src/reference/stdlib/math.md:14
msgid "exp"
msgstr ""

#: src/reference/stdlib/math.md:14
msgid "Exponential of `col`"
msgstr ""

#: src/reference/stdlib/math.md:15
msgid "floor"
msgstr ""

#: src/reference/stdlib/math.md:15
msgid "Rounds the number down"
msgstr ""

#: src/reference/stdlib/math.md:16
msgid "ln"
msgstr ""

#: src/reference/stdlib/math.md:16
msgid "Natural logarithm of `col`"
msgstr ""

#: src/reference/stdlib/math.md:17
msgid "log"
msgstr ""

#: src/reference/stdlib/math.md:17 src/reference/stdlib/math.md:20
msgid "`b` `col`"
msgstr ""

#: src/reference/stdlib/math.md:17
msgid "`b`\\-log of `col`"
msgstr ""

#: src/reference/stdlib/math.md:18
msgid "log10"
msgstr ""

#: src/reference/stdlib/math.md:18
msgid "10-log of `col`"
msgstr ""

#: src/reference/stdlib/math.md:19
msgid "pi"
msgstr ""

#: src/reference/stdlib/math.md:19
msgid "The constant π"
msgstr ""

#: src/reference/stdlib/math.md:20
msgid "pow"
msgstr ""

#: src/reference/stdlib/math.md:20
msgid "Computes `col` to the power `b`"
msgstr ""

#: src/reference/stdlib/math.md:21
msgid "radians"
msgstr ""

#: src/reference/stdlib/math.md:21
msgid "Converts degrees to radians"
msgstr ""

#: src/reference/stdlib/math.md:22
msgid "round"
msgstr ""

#: src/reference/stdlib/math.md:22
msgid "`n` `col`"
msgstr ""

#: src/reference/stdlib/math.md:22
msgid "Rounds `col` to `n` decimal places"
msgstr ""

#: src/reference/stdlib/math.md:23
msgid "sin"
msgstr ""

#: src/reference/stdlib/math.md:23
msgid "Sin of `col`"
msgstr ""

#: src/reference/stdlib/math.md:24
msgid "sqrt"
msgstr ""

#: src/reference/stdlib/math.md:24
msgid "Square root of `col`"
msgstr ""

#: src/reference/stdlib/math.md:25
msgid "tan"
msgstr ""

#: src/reference/stdlib/math.md:25
msgid "Tangent of `col`"
msgstr ""

#: src/reference/stdlib/text.md:1
msgid "Text functions"
msgstr "文字函式"

#: src/reference/stdlib/text.md:3
msgid "These are all the functions defined in the `text` module:"
msgstr ""

#: src/reference/stdlib/text.md:7
msgid "contains"
msgstr ""

#: src/reference/stdlib/text.md:7 src/reference/stdlib/text.md:8
#: src/reference/stdlib/text.md:15
msgid "`sub` `col`"
msgstr ""

#: src/reference/stdlib/text.md:7
msgid "Returns true if `col` contains `sub`"
msgstr ""

#: src/reference/stdlib/text.md:8
msgid "ends_with"
msgstr ""

#: src/reference/stdlib/text.md:8
msgid "Returns true if `col` ends with `sub`"
msgstr ""

#: src/reference/stdlib/text.md:9
msgid "extract"
msgstr ""

#: src/reference/stdlib/text.md:9
msgid "`idx` `len` `col`"
msgstr ""

#: src/reference/stdlib/text.md:9
msgid ""
"Extracts a substring at the index `idx` (starting at 1) with the length `len`"
msgstr ""

#: src/reference/stdlib/text.md:10
msgid "length"
msgstr ""

#: src/reference/stdlib/text.md:10
msgid "Returns the number of characters in `col`"
msgstr ""

#: src/reference/stdlib/text.md:11
msgid "lower"
msgstr ""

#: src/reference/stdlib/text.md:11
msgid "Converts `col` to lower case"
msgstr ""

#: src/reference/stdlib/text.md:12
msgid "ltrim"
msgstr ""

#: src/reference/stdlib/text.md:12
msgid "Removes all the whitespaces from the left side of `col`"
msgstr ""

#: src/reference/stdlib/text.md:13
msgid "replace"
msgstr ""

#: src/reference/stdlib/text.md:13
msgid "`before` `after` `col`"
msgstr ""

#: src/reference/stdlib/text.md:13
msgid "Replaces any occurrences of `before` with `after` in `col`"
msgstr ""

#: src/reference/stdlib/text.md:14
msgid "rtrim"
msgstr ""

#: src/reference/stdlib/text.md:14
msgid "Removes all the whitespaces from the right side of `col`"
msgstr ""

#: src/reference/stdlib/text.md:15
msgid "starts_with"
msgstr ""

#: src/reference/stdlib/text.md:15
msgid "Returns true if `col` starts with `sub`"
msgstr ""

#: src/reference/stdlib/text.md:16
msgid "trim"
msgstr ""

#: src/reference/stdlib/text.md:16
msgid "Removes all the whitespaces from both sides of `col`"
msgstr ""

#: src/reference/stdlib/text.md:17
msgid "upper"
msgstr ""

#: src/reference/stdlib/text.md:17
msgid "Converts `col` to upper case"
msgstr ""

#: src/reference/stdlib/text.md:21
msgid ""
"```prql\n"
"from employees\n"
"select {\n"
"  last_name | text.lower | text.starts_with(\"a\"),\n"
"  title | text.replace \"manager\" \"chief\"\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/index.md:1
msgid "Transforms"
msgstr "變換"

#: src/reference/stdlib/transforms/index.md:3
msgid "Transforms are functions that take a relation and produce a relation."
msgstr ""

#: src/reference/stdlib/transforms/index.md:5
msgid ""
"Usually they are chained together into a pipeline, which resembles an SQL "
"query."
msgstr ""

#: src/reference/stdlib/transforms/index.md:7
msgid ""
"Transforms were designed with a focus on modularity, so each of them is "
"fulfilling a specific purpose and has defined invariants (properties of the "
"relation that are left unaffected). That's often referred to as "
"\"orthogonality\" and its goal is to keep transform functions composable by "
"minimizing interference of their effects. Additionally, it also keeps the "
"number of transforms low."
msgstr ""

#: src/reference/stdlib/transforms/index.md:14
msgid ""
"For example, `select` and `derive` will not change the number of rows, while "
"`filter` and `take` will not change the number of columns."
msgstr ""

#: src/reference/stdlib/transforms/index.md:17
msgid ""
"In SQL, we can see this lack of invariant when an aggregation function is "
"used in the `SELECT` clause. Before, the number of rows was kept constant, "
"but introduction of an aggregation function caused the whole statement to "
"produce only one row (per group)."
msgstr ""

#: src/reference/stdlib/transforms/index.md:22
msgid "These are the currently available transforms:"
msgstr ""

#: src/reference/stdlib/transforms/index.md:24
msgid "Transform"
msgstr ""

#: src/reference/stdlib/transforms/index.md:24
msgid "SQL Equivalent"
msgstr ""

#: src/reference/stdlib/transforms/index.md:26
msgid "`from`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:26
msgid "[Start from a table](./from.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:26
msgid "`FROM`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:27
msgid "`derive`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:27
msgid "[Compute new columns](./derive.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:27
msgid "`SELECT *, ... AS ...`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:28
msgid "`select`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:28
msgid "[Pick & compute columns](./select.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:28
msgid "`SELECT ... AS ...`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:29
msgid "`filter`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:29
msgid "[Pick rows based on their values](./filter.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:29
msgid "`WHERE`, `HAVING`,`QUALIFY`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:30
msgid "`sort`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:30
msgid "[Order rows based on the values of columns](./sort.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:30
msgid "`ORDER BY`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:31
msgid "`join`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:31
msgid ""
"[Add columns from another table, matching rows based on a condition](./join."
"md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:31
msgid "`JOIN`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:32
msgid "`take`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:32
msgid "[Pick rows based on their position](./take.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:32
msgid "`TOP`, `LIMIT`, `OFFSET`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:33
msgid "`group`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:33
msgid ""
"[Partition rows into groups and applies a pipeline to each of them](./group."
"md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:33
msgid "`GROUP BY`, `PARTITION BY`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:34
msgid "`aggregate`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:34
msgid "[Summarize many rows into one row](./aggregate.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:34
msgid "`SELECT foo(...)`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:35
msgid "`window`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:35
msgid "[Apply a pipeline to overlapping segments of rows](./window.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:35
msgid "`OVER`, `ROWS`, `RANGE`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:36
msgid "`loop`"
msgstr ""

#: src/reference/stdlib/transforms/index.md:36
msgid ""
"[Iteratively apply a function to a relation until it's empty](./loop.md)"
msgstr ""

#: src/reference/stdlib/transforms/index.md:36
msgid "`WITH RECURSIVE ...`"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:1
msgid "Aggregate"
msgstr "聚合"

#: src/reference/stdlib/transforms/aggregate.md:3
msgid "Summarizes many rows into one row."
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:5
msgid "When applied:"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:7
msgid "without `group`, it produces one row from the whole table,"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:8
msgid "within a `group` pipeline, it produces one row from each group."
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:40
msgid "Aggregate is required"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:42
msgid ""
"Unlike in SQL, using an aggregation function in `derive` or `select` (or any "
"other transform except `aggregate`) will not trigger aggregation. By "
"default, PRQL will interpret such attempts functions as window functions:"
msgstr ""

#: src/reference/stdlib/transforms/aggregate.md:51
msgid ""
"This ensures that `derive` does not manipulate the number of rows, but only "
"ever adds a column. For more information, see [window transform](./window."
"md)."
msgstr ""

#: src/SUMMARY.md:48
msgid "Append"
msgstr "附加"

#: src/reference/stdlib/transforms/append.md:3
msgid "Concatenates two tables together."
msgstr ""

#: src/reference/stdlib/transforms/append.md:5
msgid ""
"Equivalent to `UNION ALL` in SQL. The number of rows is always the sum of "
"the number of rows from the two input tables. To replicate `UNION DISTINCT`, "
"see [set operations](#set-operations)."
msgstr ""

#: src/reference/stdlib/transforms/append.md:14
msgid "Remove"
msgstr ""

#: src/reference/stdlib/transforms/append.md:16
#: src/reference/stdlib/transforms/append.md:28
#: src/reference/stdlib/transforms/append.md:37
msgid "_experimental_"
msgstr ""

#: src/reference/stdlib/transforms/append.md:18
msgid ""
"Removes rows that appear in another relation, like `EXCEPT ALL`. Duplicate "
"rows are removed one-for-one."
msgstr ""

#: src/reference/stdlib/transforms/append.md:26
msgid "Intersection"
msgstr ""

#: src/reference/stdlib/transforms/append.md:35
msgid "Set operations"
msgstr ""

#: src/reference/stdlib/transforms/append.md:39
msgid ""
"To imitate set operations i.e. (`UNION`, `EXCEPT` and `INTERSECT`), you can "
"use the following functions:"
msgstr ""

#: src/reference/stdlib/transforms/append.md:49
msgid ""
"Don't mind the `default_db.` and `noop`, these are compiler implementation "
"detail for now."
msgstr ""

#: src/reference/stdlib/transforms/derive.md:1
msgid "Derive"
msgstr "衍生"

#: src/reference/stdlib/transforms/derive.md:3
msgid "Computes one or more new columns."
msgstr "計算一個或多個新欄位。"

#: src/reference/stdlib/transforms/filter.md:1
msgid "Filter"
msgstr "篩選"

#: src/reference/stdlib/transforms/filter.md:3
msgid "Picks rows based on their values."
msgstr ""

#: src/reference/stdlib/transforms/filter.md:16
msgid ""
"```prql\n"
"from employees\n"
"filter (age > 25 || department != \"IT\")\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"filter (age > 25 || department != \"IT\")\n"
"```"

#: src/reference/stdlib/transforms/filter.md:21
msgid ""
"```prql\n"
"from employees\n"
"filter (department | in [\"IT\", \"HR\"])\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"filter (department | in [\"IT\", \"HR\"])\n"
"```"

#: src/reference/stdlib/transforms/from.md:1
msgid "From"
msgstr "從"

#: src/reference/stdlib/transforms/from.md:3
msgid "Specifies a data source."
msgstr ""

#: src/reference/stdlib/transforms/from.md:9
msgid "To introduce an alias, use an assign expression:"
msgstr ""

#: src/reference/stdlib/transforms/from.md:16
msgid ""
"Table names containing spaces or special characters [need to be contained "
"within backticks](../../syntax/keywords.md#quoting):"
msgstr ""

#: src/reference/stdlib/transforms/from.md:23
msgid ""
"`default_db.tablename` can be used if the table name matches a function from "
"the standard library."
msgstr ""

#: src/reference/stdlib/transforms/from.md:26
msgid ""
"```admonish note\n"
"We realize this is an awkward workaround. Track & 👍 [#3271](https://github."
"com/PRQL/prql/issues/3271) for resolving this.\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/group.md:1
msgid "Group"
msgstr "群組"

#: src/reference/stdlib/transforms/group.md:3
msgid ""
"Partitions the rows into groups and applies a pipeline to each of the groups."
msgstr ""

#: src/reference/stdlib/transforms/group.md:9
msgid ""
"The partitioning of groups are determined by the `key_column`s (first "
"argument)."
msgstr ""

#: src/reference/stdlib/transforms/group.md:11
msgid "The most conventional use of `group` is with `aggregate`:"
msgstr ""

#: src/reference/stdlib/transforms/group.md:23
msgid ""
"In concept, a transform in context of a `group` does the same transformation "
"to the group as it would to the table — for example finding the employee who "
"joined first across the whole table:"
msgstr ""

#: src/reference/stdlib/transforms/group.md:33
msgid ""
"To find the employee who joined first in each department, it's exactly the "
"same pipeline, but within a `group` expression:"
msgstr ""

#: src/reference/stdlib/transforms/join.md:1
msgid "Join"
msgstr "聯接"

#: src/reference/stdlib/transforms/join.md:3
msgid "Adds columns from another table, matching rows based on a condition."
msgstr ""

#: src/reference/stdlib/transforms/join.md:9
msgid "Parameters"
msgstr "參數"

#: src/reference/stdlib/transforms/join.md:11
msgid "`side` specifies which rows to include, defaulting to `inner`."
msgstr ""

#: src/reference/stdlib/transforms/join.md:12
msgid ""
"_table_ - a reference to a relation, possibly including an alias, e.g. "
"`a=artists`"
msgstr ""

#: src/reference/stdlib/transforms/join.md:14
msgid "_condition_ - a boolean condition"
msgstr ""

#: src/reference/stdlib/transforms/join.md:15
msgid ""
"If the condition evaluates to true for a given row, the row will be joined"
msgstr ""

#: src/reference/stdlib/transforms/join.md:16
msgid ""
"If name is the same from both tables, it can be expressed with only "
"`(==col)`."
msgstr ""

#: src/reference/stdlib/transforms/join.md:39
msgid ""
"[`this` & `that`](../../syntax/keywords.md#this--that) can be used to refer "
"to the current & other table respectively:"
msgstr ""

#: src/reference/stdlib/transforms/join.md:49
msgid "Self equality operator"
msgstr ""

#: src/reference/stdlib/transforms/join.md:51
msgid ""
"If the join conditions are of form `left.x == right.x`, we can use \"self "
"equality operator\":"
msgstr ""

#: src/reference/stdlib/transforms/loop.md:1
msgid "Loop"
msgstr "循環"

#: src/reference/stdlib/transforms/loop.md:3
msgid "_Experimental_"
msgstr ""

#: src/reference/stdlib/transforms/loop.md:9
msgid ""
"Iteratively applies `step` function to `initial` relation until the `step` "
"returns an empty table. Returns a relation that contains rows of initial "
"relation and all intermediate relations."
msgstr ""

#: src/reference/stdlib/transforms/loop.md:13
msgid "This behavior could be expressed with following pseudo-code:"
msgstr ""

#: src/reference/stdlib/transforms/loop.md:38
msgid ""
"```admonish note\n"
"The behavior of `WITH RECURSIVE` may depend on the database configuration in "
"MySQL.\n"
"The compiler assumes the behavior described by\n"
"the [Postgres documentation](https://www.postgresql.org/docs/15/queries-with."
"html#QUERIES-WITH-RECURSIVE)\n"
"and will not produce correct results for\n"
"[alternative configurations of MySQL](https://dev.mysql.com/doc/refman/8.0/"
"en/with.html#common-table-expressions-recursive).\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/select.md:1
msgid "Select"
msgstr "選擇"

#: src/reference/stdlib/transforms/select.md:3
msgid "Picks and computes columns."
msgstr ""

#: src/reference/stdlib/transforms/select.md:17
msgid ""
"```prql\n"
"from employees\n"
"select name = f\"{first_name} {last_name}\"\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/select.md:22
msgid ""
"```prql\n"
"from employees\n"
"select {\n"
"  name = f\"{first_name} {last_name}\",\n"
"  age_eoy = dob - @2022-12-31,\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/select.md:40
msgid "Excluding columns"
msgstr ""

#: src/reference/stdlib/transforms/select.md:42
msgid ""
"We can use `!` to exclude a list of columns. This can operate in two ways:"
msgstr ""

#: src/reference/stdlib/transforms/select.md:44
msgid ""
"We use `SELECT * EXCLUDE` / `SELECT * EXCEPT` for the columns supplied to "
"`select !{}` in dialects which support it."
msgstr ""

#: src/reference/stdlib/transforms/select.md:46
msgid ""
"Otherwise, the columns must have been defined prior in the query (unless all "
"of a table's columns are excluded); for example in another `select` or a "
"`group` transform. In this case, we evaluate and specify the columns that "
"should be included in the output SQL."
msgstr ""

#: src/reference/stdlib/transforms/select.md:51
msgid "Some examples:"
msgstr ""

#: src/reference/stdlib/transforms/select.md:71
msgid ""
"Note that `!` is also the `NOT` operator, so without the tuple it has a "
"different meaning:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:1
msgid "Sort"
msgstr "排序"

#: src/reference/stdlib/transforms/sort.md:3
msgid ""
"Order rows based on the values of one or more expressions (generally "
"columns)."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:11
msgid "One expression or a tuple of expressions to sort by"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:12
msgid "Each expression can be prefixed with:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:13
msgid "`+`, for ascending order, the default"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:14
msgid "`-`, for descending order"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:15
msgid ""
"When using prefixes, even a single expression needs to be in a tuple or "
"parentheses. (Otherwise, `sort -foo` is parsed as a subtraction between "
"`sort` and `foo`.)"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:36
msgid "We can also use expressions:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:38
msgid ""
"```prql\n"
"from employees\n"
"sort {s\"substr({first_name}, 2, 5)\"}\n"
"```"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:43
msgid "Ordering guarantees"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:45
msgid "Ordering is persistent through a pipeline in PRQL. For example:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:53
msgid ""
"Here, PRQL pushes the `sort` down the pipeline, compiling the `ORDER BY` to "
"the _end_ of the query. Consequently, most relation transforms retain the "
"row order."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:56
msgid "The explicit semantics are:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:58
msgid "`sort` introduces a new order,"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:59
msgid "`group` resets the order,"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:60
msgid "`join` retains the order of the left relation,"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:61
msgid "database tables don't have a known order."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:63
msgid ""
"Comparatively, in SQL, relations possess no order, being orderable solely "
"within the context of the query result, `LIMIT` statement, or window "
"function. The lack of inherent order can result in an unexpected reshuffling "
"of a previously ordered relation from a `JOIN` or windowing operation."
msgstr ""

#: src/reference/stdlib/transforms/sort.md:74
msgid "For instance, an SQL query such as:"
msgstr ""

#: src/reference/stdlib/transforms/sort.md:87
msgid ""
"...doesn't guarantee any row order (indeed — even without the `JOIN`, the "
"SQL standard doesn't guarantee an order, although most implementations will "
"respect it)."
msgstr ""

#: src/reference/stdlib/transforms/take.md:1
msgid "Take"
msgstr "取"

#: src/reference/stdlib/transforms/take.md:3
msgid "Picks rows based on their position."
msgstr ""

#: src/reference/stdlib/transforms/take.md:9
msgid ""
"See [Ranges](../../syntax/ranges.md) for more details on how ranges work."
msgstr ""

#: src/reference/stdlib/transforms/window.md:1
msgid "Window"
msgstr "視窗"

#: src/reference/stdlib/transforms/window.md:3
msgid ""
"Applies a pipeline to segments of rows, producing one output value for every "
"input value."
msgstr ""

#: src/reference/stdlib/transforms/window.md:10
msgid ""
"For each row, the segment over which the pipeline is applied is determined "
"by one of:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:13
msgid ""
"`rows`, which takes a range of rows relative to the current row position."
msgstr ""

#: src/reference/stdlib/transforms/window.md:14
msgid "`0` references the current row."
msgstr ""

#: src/reference/stdlib/transforms/window.md:15
msgid "`range`, which takes a range of values relative to current row value."
msgstr ""

#: src/reference/stdlib/transforms/window.md:17
msgid ""
"The bounds of the range are inclusive. If a bound is omitted, the segment "
"will extend until the edge of the table or group."
msgstr ""

#: src/reference/stdlib/transforms/window.md:20
msgid "For ease of use, there are two flags that override `rows` or `range`:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:22
msgid ""
"`expanding:true` is an alias for `rows:..0`. A sum using this window is also "
"known as \"cumulative sum\"."
msgstr ""

#: src/reference/stdlib/transforms/window.md:24
msgid ""
"`rolling:n` is an alias for `rows:(-n+1)..0`, where `n` is an integer. This "
"will include `n` last values, including current row. An average using this "
"window is also knows as a Simple Moving Average."
msgstr ""

#: src/reference/stdlib/transforms/window.md:30
msgid "Expression"
msgstr "表達式"

#: src/reference/syntax/strings.md:70
msgid "Meaning"
msgstr "意義"

#: src/reference/stdlib/transforms/window.md:32
msgid "`rows:0..2`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:32
msgid "current row plus two following"
msgstr ""

#: src/reference/stdlib/transforms/window.md:33
msgid "`rows:-2..0`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:33
msgid "two preceding rows plus current row"
msgstr ""

#: src/reference/stdlib/transforms/window.md:34
msgid "`rolling:3`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:34
#: src/reference/stdlib/transforms/window.md:37
msgid "(same as previous)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:35
msgid "`rows:-2..4`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:35
msgid "two preceding rows plus current row plus four following rows"
msgstr ""

#: src/reference/stdlib/transforms/window.md:36
msgid "`rows:..0`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:36
msgid "all rows from the start of the table up to & including current row"
msgstr ""

#: src/reference/stdlib/transforms/window.md:37
msgid "`expanding:true`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:38
msgid "`rows:0..`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:38
msgid "current row and all following rows until the end of the table"
msgstr ""

#: src/reference/stdlib/transforms/window.md:39
msgid "`rows:..`"
msgstr ""

#: src/reference/stdlib/transforms/window.md:39
msgid "all rows, which same as not having window at all"
msgstr ""

#: src/reference/stdlib/transforms/window.md:67
msgid "Rows vs Range:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "time_id"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "value"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "sma3rows"
msgstr ""

#: src/reference/stdlib/transforms/window.md:88
msgid "sma3range"
msgstr ""

#: src/reference/stdlib/transforms/window.md:90
msgid "1"
msgstr ""

#: src/reference/stdlib/transforms/window.md:90
#: src/reference/stdlib/transforms/window.md:94
msgid "15"
msgstr ""

#: src/reference/stdlib/transforms/window.md:91
msgid "2"
msgstr ""

#: src/reference/stdlib/transforms/window.md:91
msgid "11"
msgstr ""

#: src/reference/stdlib/transforms/window.md:91
msgid "13"
msgstr ""

#: src/reference/stdlib/transforms/window.md:92
msgid "3"
msgstr ""

#: src/reference/stdlib/transforms/window.md:92
msgid "16"
msgstr ""

#: src/reference/stdlib/transforms/window.md:92
msgid "14"
msgstr ""

#: src/reference/stdlib/transforms/window.md:93
msgid "4"
msgstr ""

#: src/reference/stdlib/transforms/window.md:93
msgid "9"
msgstr ""

#: src/reference/stdlib/transforms/window.md:93
msgid "12"
msgstr ""

#: src/reference/stdlib/transforms/window.md:94
msgid "7"
msgstr ""

#: src/reference/stdlib/transforms/window.md:94
msgid "20"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "8"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "22"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "17"
msgstr ""

#: src/reference/stdlib/transforms/window.md:95
msgid "21"
msgstr ""

#: src/reference/stdlib/transforms/window.md:97
msgid ""
"We can see that rows having `time_id` of 5 and 6 are missing in example "
"data; we can say there are gaps in our time series data."
msgstr ""

#: src/reference/stdlib/transforms/window.md:100
msgid "When computing SMA 3 for the fifth row (`time_id==7`) then:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:102
msgid "\"rows\" will compute average on 3 rows (`time_id` in `3, 4, 7`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:103
msgid "\"range\" will compute average on single row only (`time_id==7`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:105
msgid "When computing SMA 3 for the sixth row (`time_id==8`) then:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:107
msgid "\"rows\" will compute average on 3 rows (`time_id` in `4, 7, 8`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:108
msgid "\"range\" will compute average on 2 rows (`time_id` in `7, 8`)"
msgstr ""

#: src/reference/stdlib/transforms/window.md:110
msgid ""
"We can observe that \"rows\" ignores the content of the `time_id`, only uses "
"its order; we can say its window operates on physical rows. On the other "
"hand \"range\" looks at the content of the `time_id` and based on the "
"content decides how many rows fits into window; we can say window operates "
"on logical rows."
msgstr ""

#: src/reference/stdlib/transforms/window.md:115
msgid "Windowing by default"
msgstr ""

#: src/reference/stdlib/transforms/window.md:117
msgid ""
"If you use window functions without `window` transform, they will be applied "
"to the whole table. Unlike in SQL, they will remain window functions and "
"will not trigger aggregation."
msgstr ""

#: src/reference/stdlib/transforms/window.md:127
msgid "You can also only apply `group`:"
msgstr ""

#: src/reference/stdlib/transforms/window.md:137
msgid "Window functions as first class citizens"
msgstr ""

#: src/reference/stdlib/transforms/window.md:139
msgid "There are no limitations on where windowed expressions can be used:"
msgstr ""

#: src/reference/syntax/index.md:1 src/reference/syntax/index.md:11
msgid "Syntax"
msgstr "語法"

#: src/reference/syntax/index.md:3
msgid "A summary of PRQL syntax:"
msgstr "PRQL 語法摘要："

#: src/reference/syntax/index.md:13
msgid "<code>\\|</code>"
msgstr ""

#: src/reference/syntax/index.md:13
msgid "[Pipelines](./function-calls.md)"
msgstr "[管道](./function-calls.md)"

#: src/reference/syntax/index.md:13
msgid "<code>from employees \\| select first_name</code>"
msgstr ""

#: src/reference/syntax/index.md:14
msgid "`=`"
msgstr ""

#: src/reference/syntax/index.md:14
msgid "[Assigns](../declarations/variables.md)"
msgstr "[指派](../declarations/variables.md)"

#: src/reference/syntax/index.md:14
msgid "`from e = employees` <br> `derive total = (sum salary)`"
msgstr ""

#: src/reference/syntax/index.md:15
msgid "`:`"
msgstr ""

#: src/reference/syntax/index.md:15
msgid "[Named args & parameters](../declarations/functions.md)"
msgstr "[具名引數和參數](../declarations/functions.md)"

#: src/reference/syntax/index.md:15
msgid "`interp low:0 1600 sat_score`"
msgstr ""

#: src/reference/syntax/index.md:16
msgid "`{}`"
msgstr ""

#: src/reference/syntax/index.md:16
msgid "[Tuples](./tuples.md)"
msgstr "[值組](./tuples.md)"

#: src/reference/syntax/index.md:16
msgid "`{id, false, total = 3}`"
msgstr ""

#: src/reference/syntax/index.md:17
msgid "`[]`"
msgstr ""

#: src/reference/syntax/index.md:17
msgid "[Arrays](./arrays.md)"
msgstr "[陣列](./arrays.md)"

#: src/reference/syntax/index.md:17
msgid "`[1, 4, 3, 4]`"
msgstr ""

#: src/reference/syntax/index.md:18
msgid "`!`,`&&`,`==`,`+`"
msgstr ""

#: src/reference/syntax/index.md:18
msgid "[Operators](./operators.md)"
msgstr "[運算子](./operators.md)"

#: src/reference/syntax/index.md:18
msgid "<code>filter a == b + c \\|\\| d >= e</code>"
msgstr ""

#: src/reference/syntax/index.md:19
msgid "`()`"
msgstr ""

#: src/reference/syntax/index.md:19
msgid "[Parentheses](./operators.md#parentheses)"
msgstr "[括號](./operators.md#parentheses)"

#: src/reference/syntax/index.md:19
msgid "`derive celsius = (fht - 32) / 1.8`"
msgstr ""

#: src/reference/syntax/index.md:20
msgid "`\\`"
msgstr ""

#: src/reference/syntax/index.md:20
msgid "[Line wrap](./operators.md#wrapping-lines)"
msgstr "[換行](./operators.md#wrapping-lines)"

#: src/reference/syntax/index.md:20
msgid "<code>1 + 2 + 3 +</code><br><code>\\\\ 4 + 5</code>"
msgstr ""

#: src/reference/syntax/index.md:21
msgid "`1`,`100_000`,`5e10`"
msgstr "`1`、`100_000`、`5e10`"

#: src/reference/syntax/index.md:21
msgid "[Numbers](./literals.md#numbers)"
msgstr "[數字](./literals.md#numbers)"

#: src/reference/syntax/index.md:21
msgid "`derive { huge = 5e10 * 10_000 }`"
msgstr ""

#: src/reference/syntax/index.md:22
msgid "`''`,`\"\"`"
msgstr "`''`、`\"\"`"

#: src/reference/syntax/index.md:22
msgid "[Strings](./literals.md#strings)"
msgstr "[字串](./literals.md#strings)"

#: src/reference/syntax/index.md:22
msgid "`derive name = 'Mary'`"
msgstr ""

#: src/reference/syntax/index.md:23
msgid "`true`,`false`"
msgstr "`true`、`false`"

#: src/reference/syntax/index.md:23
msgid "[Booleans](./literals.md#booleans)"
msgstr "[布林值](./literals.md#booleans)"

#: src/reference/syntax/index.md:23
msgid "`derive { Col1 = true }`"
msgstr ""

#: src/reference/syntax/index.md:24
msgid "`null`"
msgstr ""

#: src/reference/syntax/index.md:24
msgid "[Null](./literals.md#null)"
msgstr ""

#: src/reference/syntax/index.md:24
msgid "`filter ( name != null )`"
msgstr ""

#: src/reference/syntax/index.md:25
msgid "`@`"
msgstr ""

#: src/reference/syntax/index.md:25
msgid "[Dates & times](./literals.md#date-and-time)"
msgstr "[日期和時間](./literals.md#date-and-time)"

#: src/reference/syntax/index.md:25
msgid "`@2021-01-01`"
msgstr ""

#: src/reference/syntax/index.md:26
msgid "`` ` ` ``"
msgstr ""

#: src/reference/syntax/index.md:26
msgid "[Quoted identifiers](./keywords.md#quoting)"
msgstr "[引用的識別符號](./keywords.md#quoting)"

#: src/reference/syntax/index.md:26
msgid "``select `first name` ``"
msgstr ""

#: src/reference/syntax/index.md:27
msgid "`#`"
msgstr ""

#: src/reference/syntax/index.md:27
msgid "[Comments](./comments.md)"
msgstr "[註釋](./comments.md)"

#: src/reference/syntax/index.md:27
msgid "`# A comment`"
msgstr ""

#: src/reference/syntax/index.md:28
msgid "`==`"
msgstr ""

#: src/reference/syntax/index.md:28
msgid ""
"[Self-equality in `join`](../stdlib/transforms/join.md#self-equality-"
"operator)"
msgstr ""
"[`join` 中的自相等](../stdlib/transforms/join.md#self-equality-operator)"

#: src/reference/syntax/index.md:28
msgid "`join s=salaries (==id)`"
msgstr ""

#: src/reference/syntax/index.md:29
msgid "`->`"
msgstr ""

#: src/reference/syntax/index.md:29
msgid "[Function definitions](../declarations/functions.md)"
msgstr "[函式定義](../declarations/functions.md)"

#: src/reference/syntax/index.md:29
msgid "`let add = a b -> a + b`"
msgstr ""

#: src/reference/syntax/index.md:30
msgid "`=>`"
msgstr ""

#: src/reference/syntax/index.md:30
msgid "[Case statement](./case.md)"
msgstr "[Case 語句](./case.md)"

#: src/reference/syntax/index.md:30
msgid "`case [a==1 => c, a==2 => d]`"
msgstr ""

#: src/reference/syntax/index.md:31
msgid "`+`,`-`"
msgstr "`+`、`-`"

#: src/reference/syntax/index.md:31
msgid "[Sort order](../stdlib/transforms/sort.md)"
msgstr "[排序順序](../stdlib/transforms/sort.md)"

#: src/reference/syntax/index.md:31
msgid "`sort {-amount, +date}`"
msgstr ""

#: src/reference/syntax/index.md:32
msgid "`??`"
msgstr ""

#: src/reference/syntax/index.md:32
msgid "[Coalesce](./operators.md#coalesce)"
msgstr "[合併](./operators.md#coalesce)"

#: src/reference/syntax/index.md:32
msgid "`amount ?? 0`"
msgstr ""

#: src/reference/syntax/arrays.md:3
msgid ""
"Array is a container type, composed of multiple items. All items must be of "
"the same type. Number of fields can be vary."
msgstr ""
"陣列是一個容器型別，由多個項目組成。所有項目必須是相同型別。欄位數量可以變"
"化。"

#: src/reference/syntax/case.md:1
msgid "Case"
msgstr "情況"

#: src/reference/syntax/case.md:3
msgid ""
"Search for the first condition that evaluates to `true` and return its "
"associated value. If none of the conditions match, `null` is returned."
msgstr ""
"搜尋第一個評估為 `true` 的條件並返回其關聯值。如果沒有條件符合，則返回 "
"`null`。"

#: src/reference/syntax/case.md:6
msgid ""
"```prql\n"
"from employees\n"
"derive distance = case [\n"
"  city == \"Calgary\" => 0,\n"
"  city == \"Edmonton\" => 300,\n"
"]\n"
"```"
msgstr ""

#: src/reference/syntax/case.md:14
msgid "To set a default, a `true` condition can be used:"
msgstr "要設定預設值，可以使用 `true` 條件："

#: src/reference/syntax/case.md:16
msgid ""
"```prql\n"
"from employees\n"
"derive distance = case [\n"
"  city == \"Calgary\" => 0,\n"
"  city == \"Edmonton\" => 300,\n"
"  true => \"Unknown\",\n"
"]\n"
"```"
msgstr ""

#: src/reference/syntax/comments.md:1
msgid "Comments"
msgstr "註釋"

#: src/reference/syntax/comments.md:3
msgid "Character `#` denotes a comment until the end of the line."
msgstr "字元 `#` 表示註釋到行的結尾。"

#: src/reference/syntax/comments.md:11
msgid "There's no distinct multiline comment syntax."
msgstr "沒有明確的多行註釋語法。"

#: src/reference/syntax/function-calls.md:1
msgid "Function calls"
msgstr "函式呼叫"

#: src/reference/syntax/function-calls.md:3
msgid "Simple"
msgstr "簡單"

#: src/reference/syntax/function-calls.md:5
msgid ""
"A distinction between PRQL and most other programming languages is the "
"function call syntax. It consists of the function name followed by arguments "
"separated by whitespace."
msgstr ""
"PRQL 和大多數其他程式語言之間的區別是函式呼叫語法。它由函式名稱組成，後面跟著"
"以空格分隔的引數。"

#: src/reference/syntax/function-calls.md:13
msgid ""
"If one of the arguments is also a function call, it must be encased in "
"parentheses, so we know where arguments of inner function end and the "
"arguments of outer function start."
msgstr ""
"如果其中一個引數也是函式呼叫，它必須用括號括起來，這樣我們才能知道內部函式的"
"引數在哪裡結束，外部函式的引數在哪裡開始。"

#: src/reference/syntax/function-calls.md:21
msgid ""
"The function name must refer to a function variable, which has either [been "
"declared](../declarations/functions.md) in the [standard library](../"
"stdlib/) or some other module."
msgstr ""
"函式名稱必須指向函式變數，該變數要麼在[標準函式庫](../stdlib/)中[已被宣告]"
"(../declarations/functions.md)，要麼在其他某個模組中。"

#: src/reference/syntax/function-calls.md:25
msgid "Function calls can also specify named parameters using `:` notation:"
msgstr "函式呼叫也可以使用 `:` 符號指定具名參數："

#: src/reference/syntax/function-calls.md:31
msgid "Pipeline"
msgstr "管道"

#: src/reference/syntax/function-calls.md:33
msgid ""
"There is a alternative way of calling functions: using a pipeline. "
"Regardless of whether the pipeline is delimited by pipe symbol `|` or a new "
"line, the pipeline is equivalent to applying each of functions as the last "
"argument of the next function."
msgstr ""
"有另一種呼叫函式的方式：使用管道。無論管道是由管道符號 `|` 還是新行分隔，管道"
"相當於將每個函式作為下一個函式的最後一個引數應用。"

#: src/reference/syntax/function-calls.md:42
msgid "... is equivalent to ..."
msgstr "...等價於..."

#: src/reference/syntax/keywords.md:1
msgid "Identifiers & keywords"
msgstr "識別符與關鍵字"

#: src/reference/syntax/keywords.md:3
msgid ""
"Identifiers can contain alphanumeric characters and `_` and must not start "
"with a number. They can be chained together with the `.` indirection "
"operator, used to retrieve a tuple from a field or a variable from a module."
msgstr ""

#: src/reference/syntax/keywords.md:15
msgid "`this` & `that`"
msgstr "`this` 和 `that`"

#: src/reference/syntax/keywords.md:17
msgid "`this` refers to the current relation:"
msgstr "`this` 指的是目前的關聯："

#: src/reference/syntax/keywords.md:26
msgid ""
"Within a [`join`](../stdlib/transforms/join.md), `that` refers to the other "
"table:"
msgstr ""
"在 [`join`](../stdlib/transforms/join.md) 中，`that` 指的是另一個表格："

#: src/reference/syntax/keywords.md:34
msgid ""
"`this` can also be used to remove any column ambiguity. For example, "
"currently using a bare `time` as a column name will fail, because it's also "
"a type:"
msgstr ""
"`this` 也可以用來移除任何欄位歧義。例如，目前使用裸 `time` 作為欄位名稱會失"
"敗，因為它也是一個型別："

#: src/reference/syntax/keywords.md:42
msgid "But with `this.time`, we can remove the ambiguity:"
msgstr "但有了 `this.time`，我們可以移除歧義："

#: src/reference/syntax/keywords.md:49
msgid "Quoting"
msgstr "引述"

#: src/reference/syntax/keywords.md:51
msgid ""
"To use characters that would be otherwise invalid, identifiers can be "
"surrounded by with backticks."
msgstr "為了使用其他方式無效的字元，識別符可以用反引號括起來。"

#: src/reference/syntax/keywords.md:54
msgid ""
"When compiling to SQL, these identifiers will use dialect-specific quotes "
"and quoting rules."
msgstr "編譯為 SQL 時，這些識別符將使用方言特定的引號和引述規則。"

#: src/reference/syntax/keywords.md:76
msgid "Schemas & database names"
msgstr "綱要和資料庫名稱"

#: src/reference/syntax/keywords.md:78
msgid ""
"Identifiers of database tables can be prefixed with schema and databases "
"names."
msgstr "資料庫表格的識別符可以加上綱要和資料庫名稱的前綴。"

#: src/reference/syntax/keywords.md:84
msgid ""
"Note that all of following identifiers will be treated as separate table "
"definitions: `tracks`, `public.tracks`, `my_database.public.tracks`."
msgstr ""
"請注意，以下所有識別符都將被視為單獨的表格定義：`tracks`、`public.tracks`、"
"`my_database.public.tracks`。"

#: src/reference/syntax/keywords.md:87
msgid "Keywords"
msgstr "關鍵字"

#: src/reference/syntax/keywords.md:89
msgid "PRQL uses following keywords:"
msgstr "PRQL 使用了以下關鍵字："

#: src/reference/syntax/keywords.md:91
msgid "**`prql`** - query header [_more..._](../../project/target.md)"
msgstr "**`prql`** - 查詢標頭 [_更多..._](../../project/target.md)"

#: src/reference/syntax/keywords.md:92
msgid ""
"**`let`** - variable definition [_more..._](../declarations/variables.md)"
msgstr "**`let`** - 變數定義 [_更多..._](../declarations/variables.md)"

#: src/reference/syntax/keywords.md:93
msgid ""
"**`into`** - variable definition [_more..._](../declarations/variables.md)"
msgstr "**`into`** - 變數定義 [_更多..._](../declarations/variables.md)"

#: src/reference/syntax/keywords.md:94
msgid "**`case`** - flow control [_more..._](../syntax/case.md)"
msgstr "**`case`** - 流程控制 [_更多..._](../syntax/case.md)"

#: src/reference/syntax/keywords.md:95
msgid "**`type`** - type declaration"
msgstr "**`type`** - 型別宣告"

#: src/reference/syntax/keywords.md:96
msgid ""
"**`func`** - explicit function declaration [_more..._](../declarations/"
"functions.md)"
msgstr "**`func`** - 明確的函式宣告 [_更多..._](../declarations/functions.md)"

#: src/reference/syntax/keywords.md:98
msgid "**`module`** - used internally"
msgstr "**`module`** - 內部使用"

#: src/reference/syntax/keywords.md:99
msgid "**`internal`** - used internally"
msgstr "**`internal`** - 內部使用"

#: src/reference/syntax/keywords.md:100
msgid "**`true`** - boolean [_more..._](./literals.md#booleans)"
msgstr "**`true`** - 布林值 [_更多..._](./literals.md#booleans)"

#: src/reference/syntax/keywords.md:101
msgid "**`false`** - boolean [_more..._](./literals.md#booleans)"
msgstr "**`false`** - 布林值 [_更多..._](./literals.md#booleans)"

#: src/reference/syntax/keywords.md:102
msgid "**`null`** - NULL [_more..._](./literals.md#null)"
msgstr "**`null`** - 空值 [_更多..._](./literals.md#null)"

#: src/reference/syntax/keywords.md:104
msgid ""
"Keywords can be used as identifiers (of columns or variables) when encased "
"in backticks: `` `case` ``."
msgstr "關鍵字可以用作識別符（欄位或變數），當被反引號括起來時：`` `case` ``。"

#: src/reference/syntax/keywords.md:107
msgid ""
"Transforms are normal functions within the `std` namespace, not keywords. "
"That is, `std.from` is the same function as `from`. In the example below, "
"the resulting query is the same as without the `std.` namespace:"
msgstr ""
"轉換是 `std` 命名空間中的普通函式，不是關鍵字。也就是說，`std.from` 與 "
"`from` 是相同的函式。在下面的範例中，產生的查詢與沒有 `std.` 命名空間時相同："

#: src/reference/syntax/literals.md:1
msgid "Literals"
msgstr "字面值"

#: src/reference/syntax/literals.md:3
msgid ""
"A literal is a constant value expression, with special syntax rules for each "
"data type."
msgstr "字面值是一個常數值表達式，每種資料型別都有特殊的語法規則。"

#: src/reference/syntax/literals.md:6
msgid "Numbers"
msgstr "數字"

#: src/reference/syntax/literals.md:8
msgid ""
"Number literals can contain number characters as well as a period, "
"underscores and char `e`."
msgstr "數字字面值可以包含數字字元以及句號、底線和字元 `e`。"

#: src/reference/syntax/literals.md:11
msgid ""
"If a number literal contains a dot or character `e`, it is treated as "
"floating point number (or just _float_), otherwise it is treated as integer "
"number."
msgstr ""
"如果數字字面值包含點或字元 `e`，則將其視為浮點數（或稱為 _float_），否則將其"
"視為整數。"

#: src/reference/syntax/literals.md:14
msgid ""
"Character `e` denotes [\"scientific notation\"](https://en.wikipedia.org/"
"wiki/Scientific_notation), where the number after `e` is the exponent in 10-"
"base."
msgstr ""
"字元 `e` 表示[\"科學記數法\"](https://en.wikipedia.org/wiki/"
"Scientific_notation)，其中 `e` 後面的數字是以 10 為基數的指數。"

#: src/reference/syntax/literals.md:18
msgid ""
"Underscores are ignored, so they can be placed at arbitrary positions, but "
"it is advised to use them as thousand separators."
msgstr "底線被忽略，所以它們可以放在任意位置，但建議將它們用作千位分隔符。"

#: src/reference/syntax/literals.md:21
msgid ""
"Integers can, alternatively, be expressed using hexadecimal, octal or binary "
"notation using these prefixes respectively: `0x`, `0o` or `0b`."
msgstr ""
"整數也可以使用十六進位、八進位或二進位表示法分別用這些前綴表示：`0x`、`0o` "
"或 `0b`。"

#: src/reference/syntax/literals.md:36
msgid "Strings"
msgstr "字串"

#: src/reference/syntax/literals.md:38
msgid ""
"PRQL supports string literals and several other formats of strings. See the "
"[Strings](./strings.md) page for more information."
msgstr ""
"PRQL 支援字串字面值和多種其他字串格式。如需詳細資訊，請參閱[字串](./strings."
"md)頁面。"

#: src/reference/syntax/literals.md:41
msgid "Booleans"
msgstr "布林值"

#: src/reference/syntax/literals.md:43
msgid "Boolean values can be expressed with `true` or `false` keyword."
msgstr "布林值可以用 `true` 或 `false` 關鍵字表示。"

#: src/reference/syntax/literals.md:45
msgid "Null"
msgstr "空值"

#: src/reference/syntax/literals.md:47
msgid ""
"The null value can be expressed with `null` keyword. See also the discussion "
"of how [PRQL handles nulls](../spec/null.md)."
msgstr ""
"空值可以用 `null` 關鍵字表示。另請參閱 [PRQL 如何處理空值](../spec/null.md)的"
"討論。"

#: src/reference/syntax/literals.md:50
msgid "Date and time"
msgstr "日期和時間"

#: src/reference/syntax/literals.md:52
msgid ""
"Date and time literals are expressed with character `@`, followed by a "
"string that encodes the date & time."
msgstr "日期和時間字面值用字元 `@` 表示，後面跟著編碼日期和時間的字串。"

#: src/reference/syntax/literals.md:61
msgid "Dates"
msgstr "日期"

#: src/reference/syntax/literals.md:63
msgid ""
"Dates are represented by `@{yyyy-mm-dd}` — a `@` followed by the date format."
msgstr "日期由 `@{yyyy-mm-dd}` 表示 — `@` 後面跟著日期格式。"

#: src/reference/syntax/literals.md:70
msgid "Times"
msgstr "時間"

#: src/reference/syntax/literals.md:72
msgid ""
"Times are represented by `@{HH:mm:ss.SSS±Z}` with any parts not supplied "
"defaulting to zero. This includes the timezone, which is represented by `+HH:"
"mm`, `-HH:mm` or `Z`. This is consistent with the ISO8601 time format."
msgstr ""
"時間由 `@{HH:mm:ss.SSS±Z}` 表示，任何未提供的部分預設為零。這包括由 `+HH:"
"mm`、`-HH:mm` 或 `Z` 表示的時區。這符合 ISO8601 時間格式。"

#: src/reference/syntax/literals.md:81
msgid "Timestamps"
msgstr "時間戳記"

#: src/reference/syntax/literals.md:83
msgid ""
"Timestamps are represented by `@{yyyy-mm-ddTHH:mm:ss.SSS±Z}` / `@{date}"
"T{time}`, with any time parts not supplied being rounded to zero, including "
"the timezone, which is represented by `+HH:mm`, `-HH:mm` or `Z` (`:` is "
"optional). This is `@` followed by the ISO8601 datetime format, which uses "
"`T` to separate date & time."
msgstr ""
"\"\"時間戳記由 `@{yyyy-mm-ddTHH:mm:ss.SSS±Z}` / `@{date}T{time}` 表示，任何未"
"提供的時間部分被四捨五入為零，包括由 `+HH:mm`、`-HH:mm` 或 `Z`（`:` 是可選"
"的）表示的時區。這是 `@` 後面跟著 ISO8601 日期時間格式，該格式使用 `T` 分隔日"
"期和時間。"

#: src/reference/syntax/literals.md:94
msgid "Durations"
msgstr "持續時間"

#: src/reference/syntax/literals.md:96
msgid ""
"Durations are represented by `{N}{periods}`, such as `2years` or "
"`10minutes`, without a space."
msgstr ""
"持續時間由 `{N}{periods}` 表示，例如 `2years` 或 `10minutes`，中間沒有空格。"

#: src/reference/syntax/literals.md:114
msgid "Here's a larger list of date and time examples:"
msgstr "以下是日期和時間範例的較大列表："

#: src/reference/syntax/literals.md:116
msgid ""
"`@20221231` is invalid — it must contain full punctuation (`-` and `:`),"
msgstr "`@20221231` 無效 — 它必須包含完整的標點符號（`-` 和 `:`），"

#: src/reference/syntax/literals.md:117
msgid "`@2022-12-31` is a date"
msgstr "`@2022-12-31` 是日期"

#: src/reference/syntax/literals.md:118
msgid ""
"`@2022-12` or `@2022` are invalid — SQL can't express a month, only a date"
msgstr "`@2022-12` 或 `@2022` 無效 — SQL 無法表達月份，只能表達日期"

#: src/reference/syntax/literals.md:119
msgid "`@16:54:32.123456` is a time"
msgstr "`@16:54:32.123456` 是時間"

#: src/reference/syntax/literals.md:120
msgid ""
"`@16:54:32`, `@16:54`, `@16` are all allowed, expressing `@16:54:32.000000`, "
"`@16:54:00.000000`, `@16:00:00.000000` respectively"
msgstr ""
"`@16:54:32`、`@16:54`、`@16` 都是允許的，分別表示 `@16:54:32.000000`、"
"`@16:54:00.000000`、`@16:00:00.000000`"

#: src/reference/syntax/literals.md:122
msgid "`@2022-12-31T16:54:32.123456` is a timestamp without timezone"
msgstr "`@2022-12-31T16:54:32.123456` 是沒有時區的時間戳記"

#: src/reference/syntax/literals.md:123
msgid "`@2022-12-31T16:54:32.123456Z` is a timestamp in UTC"
msgstr "`@2022-12-31T16:54:32.123456Z` 是 UTC 時區的時間戳記"

#: src/reference/syntax/literals.md:124
msgid "`@2022-12-31T16:54+02` is timestamp in UTC+2"
msgstr "`@2022-12-31T16:54+02` 是 UTC+2 時區的時間戳記"

#: src/reference/syntax/literals.md:125
msgid ""
"`@2022-12-31T16:54+02:00` and `@2022-12-31T16:54+02` are datetimes in UTC+2"
msgstr ""
"`@2022-12-31T16:54+02:00` 和 `@2022-12-31T16:54+02` 是 UTC+2 時區的日期時間"

#: src/reference/syntax/literals.md:126
msgid ""
"`@16:54+02` is invalid — time is always local, so it cannot have a timezone"
msgstr "`@16:54+02` 無效 — 時間總是本地的，所以它不能有時區"

#: src/reference/syntax/literals.md:127
msgid ""
"`@2022-12-31+02` is invalid — date is always local, so it cannot have a "
"timezone"
msgstr "`@2022-12-31+02` 無效 — 日期總是本地的，所以它不能有時區"

#: src/reference/syntax/literals.md:130
msgid ""
"```admonish note\n"
"Currently prqlc does not parse or validate any of the datetime strings\n"
"and will pass them to the database engine without adjustment. This might be\n"
"refined in the future to aid in compatibility across databases. We'll "
"always\n"
"support the canonical [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) "
"format\n"
"described above.\n"
"```"
msgstr ""

#: src/reference/syntax/literals.md:138
msgid "Roadmap"
msgstr "路線圖"

#: src/reference/syntax/literals.md:140
msgid ""
"Datetimes (as a distinct datatype from the timestamps) are supported by some "
"databases (e.g. MySql, BigQuery). With the addition of type casts, these "
"could be represented by a timestamp cast to a datetime:"
msgstr ""
"日期時間（作為與時間戳記不同的資料型別）受某些資料庫支援（例如 MySql、"
"BigQuery）。通過添加型別轉換，這些可以通過將時間戳記轉換為日期時間來表示："

#: src/reference/syntax/literals.md:148
msgid "These are some examples we can then add:"
msgstr "以下是我們可以添加的一些範例："

#: src/reference/syntax/literals.md:150
msgid "`@2022-12-31T16:54<datetime>` is datetime without timezone"
msgstr ""

#: src/reference/syntax/literals.md:151
msgid "`@2022-12-31<datetime>` is forbidden — datetime must specify time"
msgstr ""

#: src/reference/syntax/literals.md:152
msgid "`@16:54<datetime>` is forbidden — datetime must specify date"
msgstr ""

#: src/reference/syntax/operators.md:1
msgid "Operators"
msgstr "運算子"

#: src/reference/syntax/operators.md:3
msgid ""
"Expressions can be composed from _function calls_ and _operations_, such as "
"`2 + 3` or `((1 + x) * -y)`. In the example below, note the use of "
"expressions to calculate the alias `circumference` and in the `filter` "
"transform."
msgstr ""
"表達式可以由 _函式呼叫_ 和 _運算_ 組成，例如 `2 + 3` 或 `((1 + x) * -y)`。在"
"下方的範例中，請注意使用表達式計算別名 `circumference` 和在 `filter` 轉換中的"
"用法。"

#: src/reference/syntax/operators.md:7
msgid ""
"```prql\n"
"from foo\n"
"select {\n"
"  circumference = diameter * 3.14159,\n"
"  color,\n"
"}\n"
"filter circumference > 10 && color != \"red\"\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:16
msgid "Operator precedence"
msgstr "運算子優先級"

#: src/reference/syntax/operators.md:18
msgid ""
"This table shows operator precedence. Use parentheses `()` to prioritize "
"operations and for function calls (see the discussion below.)"
msgstr ""
"此表顯示運算子優先級。使用括號 `()` 優先順序排列運算和函式呼叫（參閱下面的討"
"論。）"

#: src/reference/syntax/operators.md:23
msgid ""
"\\|          Group | Operators                   | Precedence | "
"Associativity | \\| -------------: | --------------------------- "
"| :--------: | :-----------: | --- | --- | \\|    parentheses | "
"`()`                        |     0      |   see below   | \\| identifier "
"dot | `.`                         |     1      |               | "
"\\|          unary | `-` `+` `!` `==`            |     2      "
"|               | \\|          range | `..`                        |     "
"3      |               | \\|           <!-- | pow                         "
"|    `**`    |       4       |     | --> | \\|            mul | `*` `/` `//` "
"`%`            |     5      | left-to-right | \\|            add | `+` `-"
"`                     |     6      | left-to-right | \\|        compare | "
"`==` `!=` `<=` `>=` `<` `>` |     7      | left-to-right | \\|       "
"coalesce | `??`                        |     8      | left-to-right | "
"\\|            and | `&&`                        |     9      | left-to-"
"right | \\|             or | <code>\\|\\|</code>           |     10     | "
"left-to-right | \\|  function call |                             |     "
"11     |               |"
msgstr ""

#: src/reference/syntax/operators.md:38
msgid "Division and integer division"
msgstr "除法和整數除法"

#: src/reference/syntax/operators.md:40
msgid ""
"The `/` operator performs division that always returns a float value, while "
"the `//` operator does integer division (truncated division) that always "
"returns an integer value."
msgstr ""
"`/` 運算子執行總是返回浮點值的除法，而 `//` 運算子執行整數除法（截斷除法），"
"總是返回整數值。"

#: src/reference/syntax/operators.md:44
msgid ""
"```prql\n"
"prql target:sql.sqlite\n"
"\n"
"from [\n"
"  {a = 5, b = 2},\n"
"  {a = 5, b = -2},\n"
"]\n"
"select {\n"
"  div_out = a / b,\n"
"  int_div_out = a // b,\n"
"}\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:57
msgid "Coalesce"
msgstr "合併"

#: src/reference/syntax/operators.md:59
msgid ""
"We can coalesce values with an `??` operator. Coalescing takes either the "
"first value or, if that value is null, the second value."
msgstr ""
"我們可以使用 `??` 運算子合併值。合併會取第一個值，或者如果該值為空，則取第二"
"個值。"

#: src/reference/syntax/operators.md:67
msgid "Regex expressions"
msgstr "常規表達式"

#: src/reference/syntax/operators.md:73
msgid ""
"To perform a case-sensitive regex search, use the `~=` operator. This "
"generally compiles to `REGEXP`, though differs by dialect. A regex search "
"means that to match an exact value, the start and end need to be anchored "
"with `^foo$`."
msgstr ""
"要執行區分大小寫的常規表達式搜索，請使用 `~=` 運算子。這通常編譯為 `REGEXP`，"
"儘管因方言而異。常規表達式搜索意味著要匹配確切的值，開始和結束需要用 `^foo$` "
"錨定。"

#: src/reference/syntax/operators.md:77
msgid ""
"```prql\n"
"from tracks\n"
"filter (name ~= \"Love\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:82
msgid ""
"```prql\n"
"prql target:sql.duckdb\n"
"\n"
"from artists\n"
"filter (name ~= \"Love.*You\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:89
msgid ""
"```prql\n"
"prql target:sql.bigquery\n"
"\n"
"from tracks\n"
"filter (name ~= \"\\\\bLove\\\\b\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:96
msgid ""
"```prql\n"
"prql target:sql.postgres\n"
"\n"
"from tracks\n"
"filter (name ~= \"\\\\(I Can't Help\\\\) Falling\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:103
msgid ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from tracks\n"
"filter (name ~= \"With You\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:110
msgid ""
"```prql\n"
"prql target:sql.sqlite\n"
"\n"
"from tracks\n"
"filter (name ~= \"But Why Isn't Your Syntax More Similar\\\\?\")\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:117
msgid "Parentheses"
msgstr "括號"

#: src/reference/syntax/operators.md:119
msgid "PRQL uses parentheses `()` for several purposes:"
msgstr "PRQL 使用括號 `()` 有幾個目的："

#: src/reference/syntax/operators.md:121
msgid ""
"Parentheses group operands to control the order of evaluation, for example: "
"`((1 + x) * y)`"
msgstr "括號對操作數進行分組以控制評估順序，例如：`((1 + x) * y)`"

#: src/reference/syntax/operators.md:124
msgid ""
"Parentheses delimit a minus sign of a function argument, for example: `add "
"(-1) (-3)`"
msgstr "括號用於分隔函式引數的減號，例如：`add (-1) (-3)`"

#: src/reference/syntax/operators.md:127
msgid ""
"Parentheses delimit nested function calls that contain a pipe, either the `|"
"` symbol or a new line. “Nested” means within a transform; i.e. not just the "
"main pipeline, for example: `(column-name | in 0..20)`"
msgstr ""
"\"\"括號用於分隔包含管道的嵌套函式呼叫，可以是 `|` 符號或新行。\"嵌套\"是指在"
"轉換中；即不僅僅是主管道，例如：`(column-name | in 0..20)`"

#: src/reference/syntax/operators.md:131
msgid ""
"Parentheses wrap a function call that is part of a larger expression, for "
"example: `math.round 0 (sum distance)`"
msgstr ""
"括號包裹作為較大表達式一部分的函式呼叫，例如：`math.round 0 (sum distance)`"

#: src/reference/syntax/operators.md:134
msgid ""
"Parentheses are _not_ required for expressions that do not contain function "
"calls, for example: `foo + bar`."
msgstr "括號對於不包含函式呼叫的表達式**不是**必需的，例如：`foo + bar`。"

#: src/reference/syntax/operators.md:137
msgid "Here's a set of examples of these rules:"
msgstr "以下是這些規則的一組範例："

#: src/reference/syntax/operators.md:170
msgid ""
"For example, the snippet below produces an error because the `sum` function "
"call is not in a tuple."
msgstr "例如，下面的代碼片段產生錯誤，因為 `sum` 函式呼叫不在元組中。"

#: src/reference/syntax/operators.md:178
msgid "...while with parentheses, it works at expected:"
msgstr "...而使用括號，它可以按預期工作："

#: src/reference/syntax/operators.md:191
msgid "Wrapping lines"
msgstr "換行"

#: src/reference/syntax/operators.md:193
msgid ""
"Line breaks in PRQL have semantic meaning, so to wrap a single logical line "
"into multiple physical lines, we can use `\\` at the beginning of subsequent "
"physical lines:"
msgstr ""
"PRQL 中的換行有語義含義，所以要將單個邏輯行換行為多個物理行，我們可以在後續物"
"理行的開始處使用 `\\`："

#: src/reference/syntax/operators.md:197
msgid ""
"```prql\n"
"from artists\n"
"select is_europe =\n"
"\\ country == \"DE\"\n"
"\\ || country == \"FR\"\n"
"\\ || country == \"ES\"\n"
"```"
msgstr ""

#: src/reference/syntax/operators.md:205
msgid ""
"Wrapping will \"jump over\" empty lines or lines with comments. For example, "
"the `select` here is only one logical line:"
msgstr ""
"換行會\"跳過\"空行或包含註解的行。例如，這裡的 `select` 只是一個邏輯行："

#: src/reference/syntax/operators.md:227
msgid "See [Pipes](./pipes.md) for more details on line breaks."
msgstr "有關換行的更多詳細資訊，請參閱 [Pipes](./pipes.md)。"

#: src/reference/syntax/parameters.md:3
msgid ""
"Parameter is a placeholder for a value provided after the compilation of the "
"query."
msgstr "參數是查詢編譯後提供的值的佔位符。"

#: src/reference/syntax/parameters.md:6
msgid ""
"It uses the following syntax: `$id`, where `id` is an arbitrary alpha "
"numeric string."
msgstr "它使用以下語法：`$id`，其中 `id` 是任意英數字元字串。"

#: src/reference/syntax/parameters.md:9
msgid ""
"Most database engines only support numeric positional parameter ids (i.e "
"`$3`)."
msgstr "大多數資料庫引擎只支援數字位置參數 ID（例如 `$3`）。"

#: src/reference/syntax/pipes.md:1
msgid "Pipes"
msgstr "管道"

#: src/reference/syntax/pipes.md:3
msgid ""
"Pipes are the connection between [transforms](../stdlib/transforms/) that "
"make up a pipeline. The relation produced by a transform before the pipe is "
"used as the input for the transform following the pipe. A pipe can be "
"represented with either a line break or a pipe character (`|`)."
msgstr ""
"管道是組成管道的[轉換](../stdlib/transforms/)之間的連接。管道前的轉換所產生的"
"關聯用作管道後轉換的輸入。管道可以用換行符或管道字元 (`|`) 表示。"

#: src/reference/syntax/pipes.md:8
msgid ""
"For example, here the `filter` transform operates on the result of `from "
"employees` (which is just the `employees` table), and the `select` transform "
"operates on the result of the `filter` transform."
msgstr ""
"例如，這裡 `filter` 轉換對 `from employees`（這只是 `employees` 表格）的結果"
"進行操作，`select` 轉換對 `filter` 轉換的結果進行操作。"

#: src/reference/syntax/pipes.md:12
msgid ""
"```prql\n"
"from employees\n"
"filter department == \"Product\"\n"
"select {first_name, last_name}\n"
"```"
msgstr ""

#: src/reference/syntax/pipes.md:18
msgid ""
"In the place of a line break, it's also possible to use the `|` character to "
"pipe results between transforms, such that this is equivalent:"
msgstr "用 `|` 字元代替換行符號，在轉換之間進行管道化結果，這樣就是等效的："

#: src/reference/syntax/pipes.md:21
msgid ""
"```prql\n"
"from employees | filter department == \"Product\" | select {first_name, "
"last_name}\n"
"```"
msgstr ""

#: src/reference/syntax/pipes.md:25
msgid ""
"In almost all situations, a line break acts as a pipe. But there are a few "
"exceptions where a line break doesn't create a pipeline:"
msgstr ""

#: src/reference/syntax/pipes.md:28
msgid "within a tuple"
msgstr ""

#: src/reference/syntax/pipes.md:29
msgid "within an array"
msgstr ""

#: src/reference/syntax/pipes.md:30
msgid ""
"when the following line is a new statement, which starts with a keyword of "
"`func`, `let` or `from`"
msgstr ""

#: src/reference/syntax/pipes.md:32
msgid "Within a [line wrap](./operators.md#wrapping-lines)"
msgstr ""

#: src/reference/syntax/pipes.md:43
msgid "Inner Transforms"
msgstr ""

#: src/reference/syntax/pipes.md:47
msgid ""
"Parentheses are also used for transforms (such as `group` and `window`) that "
"pass their result to an \"inner transform\". The example below applies the "
"`aggregate` pipeline to each group of unique `title` and `country` values:"
msgstr ""

#: src/reference/syntax/ranges.md:1
msgid "Ranges"
msgstr "範圍"

#: src/reference/syntax/ranges.md:3
msgid ""
"Range `start..end` represents as set of values between `start` and `end`, "
"inclusive (greater of equal to `start` and less than or equal to `end`)."
msgstr ""
"範圍 `start..end` 表示 `start` 和 `end` 之間的一組值（含括，大於等於 `start` "
"且小於等於 `end`）。"

#: src/reference/syntax/ranges.md:6
msgid ""
"To express a range that is open on one side, either `start` or `end` can be "
"omitted."
msgstr "若要表示在一側開放的範圍，可以省略 `start` 或 `end`。"

#: src/reference/syntax/ranges.md:9
msgid ""
"Ranges can be used in filters with the `in` function, with any type of "
"literal, including dates:"
msgstr "範圍可以在 `in` 函式的篩選器中使用，具有任何型別的字面值，包括日期："

#: src/reference/syntax/ranges.md:19
msgid "Ranges can also be used in `take`:"
msgstr "範圍也可以在 `take` 中使用："

#: src/reference/syntax/ranges.md:34
msgid "[take transform](../stdlib/transforms/take.md)"
msgstr "[take 變換](../stdlib/transforms/take.md)"

#: src/reference/syntax/ranges.md:38
msgid ""
"We'd like to use ranges for other types, such as whether an object is in an "
"array or list literal."
msgstr "我們想將範圍用於其他型別，例如物件是否在陣列或列表字面值中。"

#: src/reference/syntax/strings.md:3
msgid ""
"String literals can use any matching odd number of either single or double "
"quotes:"
msgstr "字串字面值可以使用任何匹配的奇數個單引號或雙引號："

#: src/reference/syntax/strings.md:6
msgid ""
"```prql\n"
"from artists\n"
"derive {\n"
"  single        =   'hello world',\n"
"  double        =   \"hello world\",\n"
"  double_triple = \"\"\"hello world\"\"\",\n"
"}\n"
"```"
msgstr ""
"```prql\n"
"from artists\n"
"derive {\n"
"  single        =   'hello world',\n"
"  double        =   \"hello world\",\n"
"  double_triple = \"\"\"hello world\"\"\",\n"
"}\n"
"```"

#: src/reference/syntax/strings.md:15
msgid "Quoting and escape characters"
msgstr "引用和轉義字元"

#: src/reference/syntax/strings.md:17
msgid ""
"To quote a string containing quote characters, use the \"other\" type of "
"quote, or use the escape character `\\`, or use more quotes."
msgstr ""
"要引用包含引號字元的字串，使用「其他」型別的引號，或使用轉義字元 `\\`，或使用"
"更多引號。"

#: src/reference/syntax/strings.md:20
msgid ""
"```prql\n"
"from artists\n"
"select {\n"
"  other   = '\"hello world\"',\n"
"  escaped = \"\\\"hello world\\\"\",\n"
"  triple  = \"\"\"I said \"hello world\"!\"\"\",\n"
"}\n"
"```"
msgstr ""

#: src/reference/syntax/strings.md:29
msgid ""
"Strings can contain any escape character sequences defined by the [JSON "
"standard](https://www.ecma-international.org/publications-and-standards/"
"standards/ecma-404/)."
msgstr ""
"字串可以包含 [JSON 標準](https://www.ecma-international.org/publications-and-"
"standards/standards/ecma-404/)定義的任何轉義字元序列。"

#: src/reference/syntax/strings.md:32
msgid ""
"```prql\n"
"from artists\n"
"derive escapes = \"\\tXYZ\\n \\\\ \"                            # tab (\\t), "
"\"XYZ\", newline (\\n), \" \", \\, \" \"\n"
"derive world = \"\\u{0048}\\u{0065}\\u{006C}\\u{006C}\\u{006F}\" # "
"\"Hello\"\n"
"derive hex = \"\\x48\\x65\\x6C\\x6C\\x6F\"                       # "
"\"Hello\"\n"
"derive turtle = \"\\u{01F422}\"                              # \"🐢\"\n"
"```"
msgstr ""

#: src/reference/syntax/strings.md:40
msgid "Other string formats"
msgstr "其他字串格式"

#: src/reference/syntax/strings.md:42
msgid ""
"[**F-strings**](./f-strings.md) - Build up a new string from a set of "
"columns or values."
msgstr "[**F-字串**](./f-strings.md) - 從一組欄位或值建立新字串。"

#: src/reference/syntax/strings.md:44
msgid ""
"[**R-strings**](./r-strings.md) - Include the raw characters of the string "
"without any form of escaping."
msgstr "[**R-字串**](./r-strings.md) - 不含任何形式轉義的字串的原始字元。"

#: src/reference/syntax/strings.md:46
msgid ""
"[**S-strings**](./s-strings.md) - Insert SQL statements directly into the "
"query. Use when PRQL doesn't have an equivalent facility."
msgstr ""
"[**S-字串**](./s-strings.md) - 將 SQL 陳述句直接插入查詢。在 PRQL 沒有等效工"
"具時使用。"

#: src/reference/syntax/strings.md:64
msgid "Escape sequences"
msgstr "轉義序列"

#: src/reference/syntax/strings.md:66
msgid ""
"Unless an `r` prefix is present, escape sequences in string literals are "
"interpreted according to rules similar to those used by Standard C. The "
"recognized escape sequences are:"
msgstr ""
"除非存在 `r` 前綴，否則字串字面值中的轉義序列將按照類似於標準 C 所使用的規則"
"進行解釋。公認的轉義序列是："

#: src/reference/syntax/strings.md:70
msgid "Escape Sequence"
msgstr "轉義序列"

#: src/reference/syntax/strings.md:72
msgid "`\\\\`"
msgstr ""

#: src/reference/syntax/strings.md:72
msgid "Backslash ()"
msgstr "反斜線（）"

#: src/reference/syntax/strings.md:73
msgid "`\\'`"
msgstr ""

#: src/reference/syntax/strings.md:73
msgid "Single quote (')"
msgstr "單引號（'）"

#: src/reference/syntax/strings.md:74
msgid "`\\\"`"
msgstr ""

#: src/reference/syntax/strings.md:74
msgid "Double quote (\")"
msgstr "雙引號（\"）"

#: src/reference/syntax/strings.md:75
msgid "`\\b`"
msgstr ""

#: src/reference/syntax/strings.md:75
msgid "Backspace"
msgstr "退格"

#: src/reference/syntax/strings.md:76
msgid "`\\f`"
msgstr ""

#: src/reference/syntax/strings.md:76
msgid "Formfeed"
msgstr "分頁符"

#: src/reference/syntax/strings.md:77
msgid "`\\n`"
msgstr ""

#: src/reference/syntax/strings.md:77
msgid "ASCII Linefeed (LF)"
msgstr "ASCII 換行符 (LF)"

#: src/reference/syntax/strings.md:78
msgid "`\\r`"
msgstr ""

#: src/reference/syntax/strings.md:78
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII 回車符 (CR)"

#: src/reference/syntax/strings.md:79
msgid "`\\t`"
msgstr ""

#: src/reference/syntax/strings.md:79
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII 水平製表符 (TAB)"

#: src/reference/syntax/strings.md:80
msgid "`\\xhh`"
msgstr ""

#: src/reference/syntax/strings.md:80
msgid "Character with hex value hh"
msgstr "十六進位值為 hh 的字元"

#: src/reference/syntax/strings.md:81
msgid "`\\u{xxxx}`"
msgstr ""

#: src/reference/syntax/strings.md:81
msgid "Character with hex value xxxx"
msgstr "十六進位值為 xxxx 的字元"

#: src/reference/syntax/f-strings.md:1
msgid "F-strings"
msgstr "F-字串"

#: src/reference/syntax/f-strings.md:3
msgid ""
"F-strings are a readable approach to building new strings from existing "
"strings & variables."
msgstr ""

#: src/reference/syntax/f-strings.md:6
msgid ""
"```prql\n"
"from employees\n"
"select full_name = f\"{first_name} {last_name}\"\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"select full_name = f\"{first_name} {last_name}\"\n"
"```"

#: src/reference/syntax/f-strings.md:11
msgid ""
"This can be much easier to read for longer strings, relative to the SQL "
"approach:"
msgstr ""

#: src/reference/syntax/f-strings.md:14
msgid ""
"```prql\n"
"from web\n"
"select url = f\"http{tls}://www.{domain}.{tld}/{page}\"\n"
"```"
msgstr ""
"```prql\n"
"from web\n"
"select url = f\"http{tls}://www.{domain}.{tld}/{page}\"\n"
"```"

#: src/reference/syntax/f-strings.md:19
msgid ""
"Note that currently interpolations can only contain plain variable names and "
"not whole expressions like Python, so this won't work:"
msgstr ""

#: src/reference/syntax/f-strings.md:22
msgid ""
"```prql error no-fmt\n"
"from tracks\n"
"select length_str = f\"{length_seconds / 60} minutes\"\n"
"```"
msgstr ""
"```prql error no-fmt\n"
"from tracks\n"
"select length_str = f\"{length_seconds / 60} minutes\"\n"
"```"

#: src/reference/syntax/f-strings.md:29
msgid ""
"In the future, f-strings may incorporate string formatting such as "
"datetimes, numbers, and padding. If there's a feature that would be helpful, "
"please [post an issue](https://github.com/PRQL/prql/issues/new/)."
msgstr ""

#: src/reference/syntax/r-strings.md:1
msgid "R-strings"
msgstr "R-字串"

#: src/reference/syntax/r-strings.md:3
msgid "R-strings handle escape characters without special treatment:"
msgstr ""

#: src/reference/syntax/r-strings.md:5
msgid ""
"```prql\n"
"from artists\n"
"derive normal_string =  \"\\\\\\t\"   #  two characters - \\ and tab (\\t)\n"
"derive raw_string    = r\"\\\\\\t\"   # four characters - \\, \\, \\, and t\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:1
msgid "S-strings"
msgstr "S-字串"

#: src/reference/syntax/s-strings.md:3
msgid ""
"An s-string inserts SQL directly, as an escape hatch when there's something "
"that PRQL doesn't yet implement. For example, there's a `version()` function "
"in PostgreSQL that returns the PostgreSQL version, so if we want to use "
"that, we use an s-string:"
msgstr ""

#: src/reference/syntax/s-strings.md:8
msgid ""
"```prql\n"
"from my_table\n"
"select db_version = s\"version()\"\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:13
msgid ""
"Embed a column name in an s-string using braces. For example, PRQL's "
"standard library defines the `average` function as:"
msgstr ""

#: src/reference/syntax/s-strings.md:16
msgid ""
"```prql no-eval\n"
"let average = column -> s\"AVG({column})\"\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:20
msgid "So this compiles using the function:"
msgstr ""

#: src/reference/syntax/s-strings.md:27
msgid ""
"```admonish note\n"
"Because S-string contents are SQL, double-quotes (`\"`) will denote a "
"_column name_.\n"
"To avoid that, use single-quotes (`'`) around the SQL string, and\n"
"adjust the quotes of the S-string. For example, instead of "
"`s'CONCAT(\"hello\", \"world\")'` use `s\"CONCAT('hello', 'world')\"`\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:33
msgid "Here's an example of a more involved use of an s-string:"
msgstr ""

#: src/reference/syntax/s-strings.md:35
msgid ""
"```prql\n"
"from de=dept_emp\n"
"join s=salaries side:left (s.emp_no == de.emp_no && s\"\"\"\n"
"  ({s.from_date}, {s.to_date})\n"
"  OVERLAPS\n"
"  ({de.from_date}, {de.to_date})\n"
"\"\"\")\n"
"```"
msgstr ""
"```prql\n"
"from de=dept_emp\n"
"join s=salaries side:left (s.emp_no == de.emp_no && s\"\"\"\n"
"  ({s.from_date}, {s.to_date})\n"
"  OVERLAPS\n"
"  ({de.from_date}, {de.to_date})\n"
"\"\"\")\n"
"```"

#: src/reference/syntax/s-strings.md:44
msgid ""
"For those who have used Python, s-strings are similar to Python's f-strings, "
"but the result is SQL code, rather than a string literal. For example, a "
"Python f-string of `f\"average({col})\"` would produce "
"`\"average(salary)\"`, with quotes; while in PRQL, `s\"average({col})\"` "
"produces `average(salary)`, without quotes."
msgstr ""

#: src/reference/syntax/s-strings.md:49
msgid ""
"Note that interpolations can only contain plain variable names and not whole "
"expression like Python."
msgstr ""

#: src/reference/syntax/s-strings.md:52
msgid "We can also use s-strings to produce a full table:"
msgstr ""

#: src/reference/syntax/s-strings.md:54
msgid ""
"```prql\n"
"from s\"SELECT DISTINCT ON first_name, id, age FROM employees ORDER BY age "
"ASC\"\n"
"join s = s\"SELECT * FROM salaries\" (==id)\n"
"```"
msgstr ""
"```prql\n"
"from s\"SELECT DISTINCT ON first_name, id, age FROM employees ORDER BY age "
"ASC\"\n"
"join s = s\"SELECT * FROM salaries\" (==id)\n"
"```"

#: src/reference/syntax/s-strings.md:59
msgid ""
"```admonish note\n"
"S-strings in user code are intended as an escape hatch for an unimplemented\n"
"feature. If we often need s-strings to express something, that's a sign we\n"
"should implement it in PRQL or PRQL's stdlib. If you often require an s-"
"string,\n"
"[submit an issue with your use case](https://github.com/PRQL/prql/issues/new/"
"choose).\n"
"```"
msgstr ""

#: src/reference/syntax/s-strings.md:66
msgid "Braces"
msgstr ""

#: src/reference/syntax/s-strings.md:68
msgid "To output braces from an s-string, use double braces:"
msgstr ""

#: src/reference/syntax/s-strings.md:70
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  has_valid_title = s\"regexp_contains(title, '([a-z0-9]*-){{2,}}')\"\n"
"}\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"derive {\n"
"  has_valid_title = s\"regexp_contains(title, '([a-z0-9]*-){{2,}}')\"\n"
"}\n"
"```"

#: src/reference/syntax/s-strings.md:77
msgid "Precedence within s-strings"
msgstr ""

#: src/reference/syntax/s-strings.md:79
msgid ""
"Variables in s-strings are inserted into the SQL source as-is, which means "
"we may get surprising behavior when the variable has multiple terms and the "
"s-string isn't parenthesized."
msgstr ""

#: src/reference/syntax/s-strings.md:83
msgid ""
"In this toy example, the expression `salary + benefits / 365` gets "
"precedence wrong. The generated SQL code is as if we had written `salary + "
"(benefits / 365)`."
msgstr ""

#: src/reference/syntax/s-strings.md:87
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"{gross_salary} / 365\"\n"
"}\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"{gross_salary} / 365\"\n"
"}\n"
"```"

#: src/reference/syntax/s-strings.md:95
msgid "Instead, the numerator `{gross_salary}` must be encased in parentheses:"
msgstr ""

#: src/reference/syntax/s-strings.md:97
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"({gross_salary}) / 365\"\n"
"}\n"
"```"
msgstr ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"({gross_salary}) / 365\"\n"
"}\n"
"```"

#: src/reference/syntax/tuples.md:3
msgid ""
"Tuple is a container type, composed of multiple fields. Each field can have "
"a different type. Number of fields and their types must be known at compile "
"time."
msgstr ""
"值組是一個容器型別，由多個欄位組成。每個欄位可以有不同的型別。欄位的數量和型"
"別必須在編譯時已知。"

#: src/reference/syntax/tuples.md:6
msgid ""
"Tuple is represented by `{}`. It can span multiple lines. Fields can be "
"assigned a name. Fields are separated by commas, trailing trailing comma is "
"optional."
msgstr ""
"值組由 `{}` 表示。它可以跨越多行。欄位可以分配名稱。欄位由逗號分隔，尾部逗號"
"是可選的。"

#: src/reference/syntax/tuples.md:23
msgid ""
"Tuples are the type of a table row, which means that they are expected by "
"many transforms. Most transforms can also take a single field, which will be "
"converted into a tuple. These are equivalent:"
msgstr ""
"值組是表格行的型別，這意味著許多轉換都期望它們。大多數轉換也可以採用單個欄"
"位，該欄位將被轉換為值組。這些是等效的："

#: src/overview.md:1
msgid "Overview"
msgstr ""

#: src/overview.md:3
msgid "PRQL project documentation."
msgstr ""

#: src/overview.md:5
msgid "[Tutorial](./tutorial/relations.md)"
msgstr ""

#: src/overview.md:7
msgid ""
"A friendly & accessible guide for learning PRQL. It has a gradual increase "
"of difficulty and requires only basic understanding of programming "
"languages. Knowledge of SQL is beneficial, because of many comparisons to "
"SQL, but it is not required."
msgstr ""

#: src/overview.md:14
msgid "[Language reference](./reference/syntax/)"
msgstr ""

#: src/overview.md:16
msgid ""
"In-depth information about the PRQL language. Includes justifications for "
"language design decisions and formal specifications for parts of the "
"language."
msgstr ""
"關於 PRQL 語言的深入資訊。包含語言設計決策的理據，以及語言各部分的正式規範。"

#: src/overview.md:19
msgid "[How do I?](./how-do-i/distinct.md)"
msgstr ""

#: src/overview.md:21
msgid "Frequently asked questions and small guides on how to use the language."
msgstr ""

#: src/overview.md:23
msgid "[Project](./project/changelog.md)"
msgstr ""

#: src/overview.md:25
msgid "General information about the project, tooling and development."
msgstr "關於專案、工具與開發的一般資訊。"

#: src/overview.md:27
msgid "[Changelog](./project/changelog.md)"
msgstr ""

#: src/overview.md:28
msgid "[Target & version](./project/target.md)"
msgstr ""

#: src/overview.md:29
msgid "[Bindings](./project/bindings/)"
msgstr ""

#: src/overview.md:30
msgid "[Integrations](./project/integrations/)"
msgstr ""

#: src/overview.md:31
msgid "[Contributing to PRQL](./project/contributing/)"
msgstr ""

#: src/SUMMARY.md:5
msgid "Tutorial"
msgstr "教學"

#: src/SUMMARY.md:7
msgid "Relations"
msgstr "關係"

#: src/SUMMARY.md:8
msgid "Filtering"
msgstr "篩選"

#: src/SUMMARY.md:9
msgid "Aggregation"
msgstr "聚合"

#: src/SUMMARY.md:11
msgid "How do I?"
msgstr ""

#: src/SUMMARY.md:13
msgid "Read files?"
msgstr ""

#: src/SUMMARY.md:14
msgid "Remove duplicates?"
msgstr ""

#: src/SUMMARY.md:15
msgid "Create ad-hoc relations?"
msgstr ""

#: src/SUMMARY.md:17
msgid "Reference"
msgstr "參考"

#: src/SUMMARY.md:37
msgid "Declarations"
msgstr "宣告"

#: src/SUMMARY.md:60
msgid "Aggregation functions"
msgstr "聚合函式"

#: src/SUMMARY.md:72
msgid "Project"
msgstr "專案"

#: src/SUMMARY.md:74
msgid "Changelog"
msgstr "變更日誌"

#: src/SUMMARY.md:76
msgid "Target & version"
msgstr "目標與版本"

#: src/SUMMARY.md:80
msgid ".NET"
msgstr ".NET"

#: src/SUMMARY.md:81
msgid "Elixir"
msgstr "Elixir"

#: src/SUMMARY.md:82
msgid "Java"
msgstr "Java"

#: src/SUMMARY.md:83
msgid "JavaScript"
msgstr "JavaScript"

#: src/SUMMARY.md:84
msgid "PHP"
msgstr "PHP"

#: src/SUMMARY.md:85
msgid "Python"
msgstr "Python"

#: src/SUMMARY.md:86
msgid "R"
msgstr "R"

#: src/SUMMARY.md:87
msgid "Rust"
msgstr "Rust"

#: src/SUMMARY.md:91
msgid "`prqlc CLI`"
msgstr "`prqlc CLI`"

#: src/SUMMARY.md:96
msgid "VS Code"
msgstr "VS Code"

#: src/SUMMARY.md:98
msgid "Syntax highlighting"
msgstr "語法標明"

#: src/SUMMARY.md:101
msgid "Contributing to PRQL"
msgstr "對 PRQL 做出貢獻"

#: src/tutorial/aggregation.md:3
msgid ""
"A key feature of analytics is reducing many values down to some summary. "
"This act is called \"aggregation\" and always includes a function — for "
"example, `average` or `sum` — that reduces values in the table to a single "
"row."
msgstr ""

#: src/tutorial/aggregation.md:7
msgid "`aggregate` transform"
msgstr "`aggregate` 變換"

#: src/tutorial/aggregation.md:9
msgid ""
"The `aggregate` transform takes a tuple to create one or more new columns "
"that \"distill down\" data from all the rows."
msgstr ""
"`aggregate` 變換接受一個元組來建立一個或多個新列，以「歸納」來自所有行的資"
"料。"

#: src/tutorial/aggregation.md:17
msgid ""
"The query above computes the sum of the `total` column of all rows of the "
"`invoices` table to produce a single value."
msgstr "上面的查詢計算 `invoices` 表所有行的 `total` 列的總和，以產生單一值。"

#: src/tutorial/aggregation.md:20
msgid ""
"`aggregate` can produce multiple summaries at once when one or more "
"aggregation expressions are contained in a tuple. `aggregate` discards all "
"columns that are not present in the tuple."
msgstr ""
"當元組中包含一個或多個聚合表達式時，`aggregate` 可以一次產生多個摘要。"
"`aggregate` 會捨棄元組中不存在的所有列。"

#: src/tutorial/aggregation.md:32
msgid ""
"In the example above, the result is a single row with two columns. The "
"`count` function displays the number of rows in the table that was passed "
"in; the `sum` function adds up the values of the `total` column of all rows."
msgstr ""
"在上面的示例中，結果是有兩列的單一行。`count` 函式顯示傳入的表中的行數；"
"`sum` 函式將所有行的 `total` 列的值相加。"

#: src/tutorial/aggregation.md:36
msgid "Grouping"
msgstr "分組"

#: src/tutorial/aggregation.md:38
msgid ""
"Suppose we want to produce summaries of invoices _for each city_ in the "
"table. We could create a query for each city, and aggregate its rows:"
msgstr ""
"假設我們想要產生表中 _每個城市_ 發票的摘要。我們可以為每個城市建立一個查詢，"
"並聚合其行："

#: src/tutorial/aggregation.md:41
msgid ""
"```prql no-eval\n"
"from albums\n"
"filter billing_city == \"Oslo\"\n"
"aggregate { sum_of_orders = sum total }\n"
"```"
msgstr ""

#: src/tutorial/aggregation.md:47
msgid ""
"But we would need to do it for each city: `London`, `Frankfurt`, etc. Of "
"course this is repetitive (and boring) and error prone (because we would "
"need to type each `billing_city` by hand). Moreover, we would need to create "
"a list of each `billing_city` before we started."
msgstr ""
"但我們需要為每個城市做這種操作：`London`、`Frankfurt` 等。當然這是重複的（且"
"令人厭倦的）且容易出錯（因為我們需要手動輸入每個 `billing_city`）。此外，我們"
"需要在開始前建立每個 `billing_city` 的列表。"

#: src/tutorial/aggregation.md:52
msgid "`group` transform"
msgstr "`group` 變換"

#: src/tutorial/aggregation.md:54
msgid ""
"The `group` transform separates the table into groups (say, those having the "
"same city) using information that's already in the table. It then applies a "
"transform to each group, and combines the results back together:"
msgstr ""
"`group` 變換使用表中已有的資訊將表分成群組（例如，具有相同城市的行）。然後它"
"對每個群組套用變換，並將結果重新組合在一起："

#: src/tutorial/aggregation.md:68
msgid ""
"Those familiar with SQL have probably noticed that we just decoupled "
"aggregation from grouping."
msgstr "熟悉 SQL 的人可能已經注意到，我們剛才將聚合與分組分離了。"

#: src/tutorial/aggregation.md:71
msgid ""
"Although these operations are connected in SQL, PRQL makes it "
"straightforward to use `group` and `aggregate` separate from each other, "
"while combining with other transform functions, such as:"
msgstr ""
"雖然這些操作在 SQL 中是相關的，但 PRQL 使得可以直接將 `group` 和 `aggregate`"
"分開使用，同時與其他變換函式結合，例如："

#: src/tutorial/aggregation.md:82
msgid "This code collects the first two rows for each city's `group`."
msgstr "這段程式碼收集每個城市 `group` 的前兩行。"

#: src/tutorial/filtering.md:1
msgid "Filtering rows"
msgstr "篩選行"

#: src/tutorial/filtering.md:3
msgid ""
"In the previous page we learned how `select`, `derive`, and `join` change "
"the columns of a table."
msgstr "在前一頁，我們學到了 `select`、`derive` 和 `join` 如何改變表的列。"

#: src/tutorial/filtering.md:6
msgid ""
"Now we will explore how to manipulate the rows of a table using `filter` and "
"`take`."
msgstr "現在我們將探索如何使用 `filter` 和 `take` 操作表的行。"

#: src/tutorial/filtering.md:9
msgid "`filter` transform"
msgstr "`filter` 變換"

#: src/tutorial/filtering.md:11
msgid ""
"The `filter` transform picks rows to pass through based on their values:"
msgstr "`filter` 變換根據值選擇要通過的行："

#: src/tutorial/filtering.md:13
msgid ""
"```prql no-eval\n"
"from invoices\n"
"filter billing_city == \"Berlin\"\n"
"```"
msgstr ""

#: src/tutorial/filtering.md:18
msgid "The resulting table contains all the rows that came from Berlin."
msgstr "結果表包含來自柏林的所有行。"

#: src/tutorial/filtering.md:20
msgid ""
"PRQL converts the single `filter` transform to use the appropriate SQL "
"`WHERE` or `HAVING` command, depending on where it appears in the pipeline."
msgstr ""
"PRQL 將單個 `filter` 變換轉換為使用適當的 SQL `WHERE` 或 `HAVING` 命令，取決"
"於它在管道中出現的位置。"

#: src/tutorial/filtering.md:23
msgid "`take` transform"
msgstr "`take` 變換"

#: src/tutorial/filtering.md:25
msgid ""
"The `take` transform picks rows to pass through based on their position "
"within the table. The set of rows picked can be specified in two ways:"
msgstr ""
"`take` 變換根據行在表中的位置選擇要通過的行。所選行的集合可以用兩種方式指定："

#: src/tutorial/filtering.md:28
msgid "a plain number `x`, which will pick the first `x` rows, or"
msgstr "一個純數字 `x`，將選擇前 `x` 行，或"

#: src/tutorial/filtering.md:29
msgid "an inclusive range of rows `start..end`."
msgstr "行的包含範圍 `start..end`。"

#: src/tutorial/filtering.md:41
msgid ""
"Of course, it is possible combine all these transforms into a single "
"pipeline:"
msgstr "當然，可以將所有這些變換組合到一個管道中："

#: src/tutorial/filtering.md:43
msgid ""
"```prql no-eval\n"
"from invoices\n"
"\n"
"# retain only rows for orders from Berlin\n"
"filter billing_city == \"Berlin\"\n"
"\n"
"# skip first 10 rows and take the next 10\n"
"take 11..20\n"
"\n"
"# take only first 3 rows of *that* result\n"
"take 3\n"
"```"
msgstr ""

#: src/tutorial/filtering.md:56
msgid ""
"We did something a bit odd at the end: first we took rows `11..20` and then "
"took the first 3 rows from that result."
msgstr ""
"在最後我們做了一些有點奇怪的事情：首先我們取了行 `11..20`，然後從該結果中取"
"前 3 行。"

#: src/tutorial/filtering.md:59
msgid ""
"```admonish note\n"
"Note that a single\n"
"transform `take 11..13` would have produced the same SQL. The example\n"
"serves an example of how PRQL allows fast data exploration by\n"
"\"stacking\" transforms in the pipeline, reducing the cognitive burden of "
"how\n"
"a new transform with the previous query.\n"
"```"
msgstr ""

#: src/tutorial/relations.md:3
msgid ""
"PRQL is designed on top of _relational algebra_, which is the established "
"data model used by modern SQL databases. A _relation_ has a rigid "
"mathematical definition, which can be simplified to \"a table of data\". For "
"example, the `invoices` table from the Chinook database ([https://github.com/"
"lerocha/chinook-database](https://github.com/lerocha/chinook-database)) "
"looks like this:"
msgstr ""
"PRQL 建立在 _關係代數_ 的基礎上，這是現代 SQL 資料庫使用的既定資料模型。_關係"
"_ 具有嚴格的數學定義，可以簡化為「資料表」。例如，Chinook 資料庫 ([https://"
"github.com/lerocha/chinook-database](https://github.com/lerocha/chinook-"
"database)) 中的 `invoices` 表如下所示："

#: src/tutorial/relations.md:10
msgid "invoice_id"
msgstr ""

#: src/tutorial/relations.md:10
msgid "customer_id"
msgstr ""

#: src/tutorial/relations.md:10
msgid "billing_city"
msgstr ""

#: src/tutorial/relations.md:10
msgid "_other columns_"
msgstr ""

#: src/tutorial/relations.md:10
msgid "total"
msgstr ""

#: src/tutorial/relations.md:12
msgid "Stuttgart"
msgstr ""

#: src/tutorial/relations.md:12 src/tutorial/relations.md:13
#: src/tutorial/relations.md:14 src/tutorial/relations.md:15
#: src/tutorial/relations.md:16 src/tutorial/relations.md:17
msgid "..."
msgstr ""

#: src/tutorial/relations.md:12
msgid "1.98"
msgstr ""

#: src/tutorial/relations.md:13
msgid "Oslo"
msgstr ""

#: src/tutorial/relations.md:13
msgid "3.96"
msgstr ""

#: src/tutorial/relations.md:14
msgid "Brussels"
msgstr ""

#: src/tutorial/relations.md:14
msgid "5.94"
msgstr ""

#: src/tutorial/relations.md:15
msgid "Edmonton"
msgstr ""

#: src/tutorial/relations.md:15
msgid "8.91"
msgstr ""

#: src/tutorial/relations.md:16
msgid "5"
msgstr ""

#: src/tutorial/relations.md:16
msgid "23"
msgstr ""

#: src/tutorial/relations.md:16
msgid "Boston"
msgstr ""

#: src/tutorial/relations.md:16
msgid "13.86"
msgstr ""

#: src/tutorial/relations.md:17
msgid "6"
msgstr ""

#: src/tutorial/relations.md:17
msgid "37"
msgstr ""

#: src/tutorial/relations.md:17
msgid "Frankfurt"
msgstr ""

#: src/tutorial/relations.md:17
msgid "0.99"
msgstr ""

#: src/tutorial/relations.md:19
msgid ""
"A relation is composed of rows. Each row in a relation contains a value for "
"each of the relation's columns. Each column in a relation has an unique name "
"and a designated data type. The table above is a relation, and has columns "
"named `invoice_id`and `customer_id` each with a data type of \"integer "
"number\", a `billing_city` column with a data type of \"text\", several "
"other columns, and a `total` column that contains floating-point numbers."
msgstr ""

#: src/tutorial/relations.md:26
msgid "Queries"
msgstr "查詢"

#: src/tutorial/relations.md:28
msgid ""
"The main purpose of PRQL is to build queries that combine and transform data "
"from relations such as the `invoices` table above. Here is the most basic "
"query:"
msgstr ""
"PRQL 的主要目的是建立查詢，以結合和轉換來自關係（如上面的 `invoices` 表）的資"
"料。以下是最基本的查詢："

#: src/tutorial/relations.md:35
msgid ""
"```admonish note\n"
"Try each of these examples here in the\n"
"[Playground.](https://prql-lang.org/playground/) Enter the query on the\n"
"left-hand side, and click **output.arrow** in the right-hand side to see "
"the\n"
"result.\n"
"```"
msgstr ""

#: src/tutorial/relations.md:42
msgid ""
"The result of the query above is not terribly interesting, it's just the "
"same relation as before."
msgstr "上面查詢的結果並不特別有趣，它只是與之前相同的關係。"

#: src/tutorial/relations.md:45
msgid "`select` transform"
msgstr "`select` 變換"

#: src/tutorial/relations.md:47
msgid ""
"The `select` function picks the columns to pass through based on a list and "
"discards all others. Formally, that list is a _tuple_ of comma-separated "
"expressions wrapped in `{ ... }`."
msgstr ""
"`select` 函式基於列表選擇要通過的列，並捨棄所有其他列。形式上，該列表是以 "
"`{ ... }` 包裹的逗號分隔表達式的 _元組_。"

#: src/tutorial/relations.md:51
msgid ""
"Suppose we only need the `order_id` and `total` columns. Use `select` to "
"choose the columns to pass through. _(Try it in the [Playground.](https://"
"prql-lang.org/playground/))_"
msgstr ""
"假設我們只需要 `order_id` 和 `total` 列。使用 `select` 來選擇要通過的列。_"
"（在 [Playground](https://prql-lang.org/playground/) 中試試看。）_"

#: src/tutorial/relations.md:60
msgid ""
"We can write the items in the tuple on one or several lines: trailing commas "
"are ignored. In addition, we can assign any of the expressions to a "
"_variable_ that becomes the name of the resulting column in the SQL output."
msgstr ""
"我們可以在一行或多行上寫入元組中的項目：尾部逗號被忽略。此外，我們可以將任何"
"表達式指派給 _變數_，該變數成為 SQL 輸出中結果列的名稱。"

#: src/tutorial/relations.md:72
msgid ""
"This is the same query as above, rewritten on multiple lines, and assigning "
"`OrderID` and `Total` names to the columns."
msgstr ""
"這是與上面相同的查詢，改寫在多行上，並將 `OrderID` 和 `Total` 名稱指派給列。"

#: src/tutorial/relations.md:75
msgid ""
"Once we `select` certain columns, subsequent transforms will have access "
"only to those columns named in the tuple."
msgstr "一旦我們 `select` 某些列，後續變換將只能訪問在元組中命名的那些列。"

#: src/tutorial/relations.md:78
msgid "`derive` transform"
msgstr "`derive` 變換"

#: src/tutorial/relations.md:80
msgid ""
"To add columns to a relation, we can use `derive` function. Let's define a "
"new column for Value Added Tax, set at 19% of the invoice total."
msgstr ""

#: src/tutorial/relations.md:90
msgid ""
"The value of the new column can be a constant (such as a number or a "
"string), or can be computed from the value of an existing column. Note that "
"the value of the new column is assigned the name `VAT`."
msgstr ""
"新列的值可以是常數（例如數字或字串），也可以從現有列的值計算得出。注意新列被"
"指派名稱 `VAT`。"

#: src/tutorial/relations.md:94
msgid "`join` transform"
msgstr "`join` 變換"

#: src/tutorial/relations.md:96
msgid ""
"The `join` transform also adds columns to the relation by combining the rows "
"from two relations \"side by side\". To determine which rows from each "
"relation should be joined, `join` has match criteria, written in `( ... )`."
msgstr ""
"`join` 變換也通過將來自兩個關係的行「並排」組合來向關係新增列。為了確定應該聯"
"接每個關係的哪些行，`join` 有以 `( ... )` 寫出的匹配條件。"

#: src/tutorial/relations.md:105
msgid ""
"This example \"connects\" the customer information from the `customers` "
"relation with the information from the `invoices` relation, using identical "
"values of the `customer_id` column from each relation to match the rows."
msgstr ""
"此示例「連接」來自 `customers` 關係的客戶資訊與來自 `invoices` 關係的資訊，使"
"用來自每個關係的 `customer_id` 列的相同值來匹配行。"

#: src/tutorial/relations.md:109
msgid ""
"It is frequently useful to assign an alias to both relations being joined "
"together so that each relation's columns can be referred to uniquely."
msgstr "為兩個被聯接的關係指派別名通常很有用，以便可以唯一地參考每個關係的列。"

#: src/tutorial/relations.md:117
msgid ""
"In the example above, the alias `inv` represents the `invoices` relation and "
"`cust` represents the `customers` relation. It then becomes possible to "
"refer to `inv.billing_city` and `cust.last_name` unambiguously."
msgstr ""
"在上面的示例中，別名 `inv` 代表 `invoices` 關係，`cust` 代表 `customers` 關"
"係。然後可以明確地參考 `inv.billing_city` 和 `cust.last_name`。"

#: src/tutorial/relations.md:121
msgid "Summary"
msgstr "摘要"

#: src/tutorial/relations.md:123
msgid ""
"PRQL manipulates relations (tables) of data. The `derive`, `select`, and "
"`join` transforms change the number of columns in a table. The first two "
"never affect the number of rows in a table. `join` may change the number of "
"rows, depending on the variation chosen."
msgstr ""

#: src/tutorial/relations.md:128
msgid ""
"This final example combines the above into a single query. It illustrates _a "
"pipeline_ - the fundamental basis of PRQL. We simply add new lines "
"(transforms) at the end of the query. Each transform modifies the relation "
"produced by the statement above to produce the desired result."
msgstr ""
"這個最後的示例將上述內容組合成一個單一查詢。它說明了 _管道_ - PRQL 的基礎。我"
"們只是在查詢末尾新增新的行（變換）。每個變換修改由上述語句產生的關係，以產生"
"所需的結果。"
