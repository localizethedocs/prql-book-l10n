msgid ""
msgstr ""
"Project-Id-Version: PRQL Language Book\n"
"POT-Creation-Date: 2026-01-10T16:16:24Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/internals/name-resolving.md:1
msgid "Name resolving"
msgstr ""

#: src/internals/name-resolving.md:3
msgid ""
"Because PRQL primarily handles relational data, it has specialized scoping "
"rules for referencing columns."
msgstr ""

#: src/internals/name-resolving.md:5
msgid "Scopes"
msgstr ""

#: src/internals/name-resolving.md:7
msgid ""
"In PRQL's compiler, a scope is the collection of all names one can reference "
"from a specific point in the program."
msgstr ""

#: src/internals/name-resolving.md:9
msgid ""
"In PRQL, names in the scope are composed from namespace and variable name "
"which are separated by a dot, similar to SQL. Namespaces can contain many "
"dots, but variable names cannot."
msgstr ""

#: src/internals/name-resolving.md:18
msgid ""
"When processing a query, a scope is maintained and updated for each point in "
"the query."
msgstr ""

#: src/internals/name-resolving.md:20
msgid ""
"It start with only namespace `std`, which is the standard library. It "
"contains common functions like `sum` or `count`, along with all transform "
"functions such as `derive` and `group`."
msgstr ""

#: src/internals/name-resolving.md:24
msgid ""
"In pipelines (or rather in transform functions), scope is also injected with "
"namespaces of tables which may have been referenced with `from` or `join` "
"transforms. These namespaces contain simply all the columns of the table and "
"possibly a wildcard variable, which matches any variable (see the algorithm "
"below). Within transforms, there is also a special namespace that does not "
"have a name. It is called a _\"frame\"_ and it contains columns of the "
"current table the transform is operating on."
msgstr ""

#: src/internals/name-resolving.md:31
msgid "Resolving"
msgstr ""

#: src/internals/name-resolving.md:33
msgid ""
"For each ident we want to resolve, we search the scope's items in order. One "
"of three things can happen:"
msgstr ""

#: src/internals/name-resolving.md:35
msgid ""
"Scope contains an exact match, e.g. a name that matches in namespace and the "
"variable name."
msgstr ""

#: src/internals/name-resolving.md:37
msgid ""
"Scope does not contain an exact match, but the ident did not specify a "
"namespace, so we can match a namespace that contains a `*` wildcard. If "
"there's a single namespace, the matched namespace is also updated to contain "
"this new variable name."
msgstr ""

#: src/internals/name-resolving.md:41
msgid ""
"In the case that there are multiple namespaces with a wildcard, we don't "
"match with neither of the namespaces, but match as `*.*` name. This is a "
"special feature that allows a column name which may reside in two different "
"tables not to be associated with any of them. Instead, it is translated into "
"the column name only, so database can determine which table it belongs to. "
"Note that this may lead to PRQL passing on ambigous queries to the database, "
"instead of resulting error early."
msgstr ""

#: src/internals/name-resolving.md:49
msgid "Otherwise, the nothing is matched and an error is raised."
msgstr ""

#: src/internals/name-resolving.md:51
msgid "Translating to SQL"
msgstr ""

#: src/internals/name-resolving.md:53
msgid ""
"When translating into a SQL statement which references only one table, there "
"is no need to reference column names with table prefix."
msgstr ""

#: src/internals/name-resolving.md:61
msgid ""
"But when there are multiple tables and we don't have complete knowledge of "
"all table columns, a column without a prefix (i.e. `first_name`) may "
"actually reside in multiple tables. Because of this, we have to use table "
"prefixes for all column names."
msgstr ""

#: src/internals/name-resolving.md:72
msgid ""
"As you can see, `employees.first_name` now needs table prefix, to prevent "
"conficts with potential column with the same name in `departments` table. "
"Similarly, `d.title` needs the table prefix."
msgstr ""

#: src/internals/name-resolving.md:75
msgid ""
"But `created_at` has triggered the special rule and matched `*.*`, because "
"it may reside in any of the two tables. This means that PRQL does not "
"associate it with any table and the column is translated as is."
msgstr ""
