msgid ""
msgstr ""
"Project-Id-Version: PRQL language book\n"
"POT-Creation-Date: 2026-01-10T16:16:29Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/language-features/s-strings.md:1
msgid "S-strings"
msgstr ""

#: src/language-features/s-strings.md:3
msgid ""
"An s-string inserts SQL directly, as an escape hatch when there's something "
"that PRQL doesn't yet implement. For example, there's no `version()` "
"function in SQL that returns the Postgres version, so if we want to use "
"that, we use an s-string:"
msgstr ""

#: src/language-features/s-strings.md:8
msgid ""
"```prql\n"
"from my_table\n"
"select db_version = s\"version()\"\n"
"```"
msgstr ""

#: src/language-features/s-strings.md:13
msgid ""
"Embed a column name in an s-string using braces. For example, PRQL's "
"standard library defines the `average` function as:"
msgstr ""

#: src/language-features/s-strings.md:16
msgid ""
"```prql_no_test\n"
"func average column -> s\"AVG({column})\"\n"
"```"
msgstr ""

#: src/language-features/s-strings.md:20
msgid "So this compiles using the function:"
msgstr ""

#: src/language-features/s-strings.md:27
msgid "Here's an example of a more involved use of an s-string:"
msgstr ""

#: src/language-features/s-strings.md:29
msgid ""
"```prql\n"
"from de=dept_emp\n"
"join s=salaries side:left [\n"
"  (s.emp_no == de.emp_no),\n"
"  s\"\"\"({s.from_date}, {s.to_date})\n"
"  OVERLAPS\n"
"  ({de.from_date}, {de.to_date})\"\"\"\n"
"]\n"
"```"
msgstr ""

#: src/language-features/s-strings.md:39
msgid ""
"For those who have used Python, s-strings are similar to Python's f-strings, "
"but the result is SQL code, rather than a string literal. For example, a "
"Python f-string of `f\"average({col})\"` would produce "
"`\"average(salary)\"`, with quotes; while in PRQL, `s\"average({col})\"` "
"produces `average(salary)`, without quotes."
msgstr ""

#: src/language-features/s-strings.md:44
msgid ""
"Note that interpolations can only contain plain variable names and not whole "
"expression like Python."
msgstr ""

#: src/language-features/s-strings.md:47
msgid "We can also use s-strings to produce a full table:"
msgstr ""

#: src/language-features/s-strings.md:49
msgid ""
"```prql\n"
"from s\"SELECT DISTINCT ON first_name, id, age FROM employees ORDER BY age "
"ASC\"\n"
"join s = s\"SELECT * FROM salaries\" [==id]\n"
"```"
msgstr ""

#: src/language-features/s-strings.md:60
msgid "Braces"
msgstr ""

#: src/language-features/s-strings.md:62
msgid "To output braces from an s-string, use double braces:"
msgstr ""

#: src/language-features/s-strings.md:64
msgid ""
"```prql no-fmt\n"
"from employees\n"
"derive [\n"
"  has_valid_title = s\"regexp_contains(title, '([a-z0-9]*-){{2,}}')\"\n"
"]\n"
"```"
msgstr ""

#: src/language-features/s-strings.md:71
msgid "Precedence"
msgstr ""

#: src/language-features/s-strings.md:73
msgid ""
"The PRQL compiler simply places a literal copy of each variable into the "
"resulting string, which means we may get surprising behavior when the "
"variable is has multiple terms and the s-string isn't parenthesized."
msgstr ""

#: src/language-features/s-strings.md:77
msgid ""
"In this toy example, the `salary + benefits / 365` gets precedence wrong:"
msgstr ""

#: src/language-features/s-strings.md:79
msgid ""
"```prql\n"
"from employees\n"
"derive [\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"{gross_salary} / 365\"\n"
"]\n"
"```"
msgstr ""

#: src/language-features/s-strings.md:87
msgid "Instead, put the denominator `{gross_salary}` in parentheses:"
msgstr ""

#: src/language-features/s-strings.md:89
msgid ""
"```prql\n"
"from employees\n"
"derive [\n"
"  gross_salary = salary + benefits,\n"
"  daily_rate = s\"({gross_salary}) / 365\"\n"
"]\n"
"```"
msgstr ""
