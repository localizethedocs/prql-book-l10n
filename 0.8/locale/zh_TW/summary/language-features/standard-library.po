msgid ""
msgstr ""
"Project-Id-Version: PRQL language book\n"
"POT-Creation-Date: 2026-01-10T16:16:29Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/language-features/standard-library/index.md:1
msgid "Standard library"
msgstr ""

#: src/language-features/standard-library/index.md:3
msgid ""
"The standard library currently contains commonly used functions that are "
"used in SQL. It's not yet as broad as we'd like, and we're very open to "
"expanding it."
msgstr ""

#: src/language-features/standard-library/index.md:6
msgid ""
"Currently s-strings are an escape-hatch for any function that isn't in our "
"standard library. If we find ourselves using them for something frequently, "
"raise an issue and we'll add it to the stdlib."
msgstr ""

#: src/language-features/standard-library/index.md:16
msgid ""
"Here's the source of the current [PRQL `std`](https://github.com/PRQL/prql/"
"blob/main/prql-compiler/src/semantic/std.prql):"
msgstr ""

#: src/language-features/standard-library/index.md:19
msgid ""
"```prql_no_test\n"
"# The PRQL standard library defines the following functions and transforms.\n"
"# The definitions are whitespace insensitive, and have this form:\n"
"#\n"
"# func my_func <return_type> param1 param2 ...  -> body_expr\n"
"# where:\n"
"#   * my_func is the name of the function\n"
"#   * <return_type> is the type of result wrapped in \"< ... >\"\n"
"#   * param1 is the first parameter optionally followed by a type in \"< ... "
">\"\n"
"#   * param2 etc. follow the same pattern as param1\n"
"#   * -> body_expr defines the function body that creates the result.\n"
"#     It can be PRQL code or \"null\" to indicate internal compiler code\n"
"\n"
"# Aggregate functions\n"
"# These return either a scalar when used within `aggregate`, or a column "
"when used anywhere else.\n"
"func min <scalar || column> column -> null\n"
"func max <scalar || column> column -> null\n"
"func sum <scalar || column> column -> null\n"
"func avg <scalar || column> column -> null\n"
"func stddev <scalar || column> column -> null\n"
"func average <scalar || column> column -> null\n"
"func count <scalar || column> non_null:s\"*\" -> null\n"
"# TODO: Possibly make this into `count distinct:true` (or like `distinct:` "
"as an\n"
"# abbreviation of that?)\n"
"func count_distinct <scalar || column> column -> null\n"
"\n"
"# Window functions\n"
"func lag<column> offset column -> null\n"
"func lead<column> offset column -> null\n"
"func first<column> offset column -> null\n"
"func last<column> offset column -> null\n"
"func rank<column> -> null\n"
"func rank_dense<column> -> null\n"
"func row_number<column> -> null\n"
"\n"
"# Other functions\n"
"func round<scalar> n_digits column -> null\n"
"func as<scalar> `noresolve.type` column -> null\n"
"func in<bool> pattern value -> null\n"
"\n"
"# Transform type definitions\n"
"func from<table> `default_db.source`<table> -> null\n"
"func select<table> columns<column> tbl<table> -> null\n"
"func filter<table> condition<bool> tbl<table> -> null\n"
"func derive<table> columns<column> tbl<table> -> null\n"
"func aggregate<table> a<column> tbl<table> -> null\n"
"func sort<table> by tbl<table> -> null\n"
"func take<table> expr tbl<table> -> null\n"
"func join<table> `default_db.with`<table> filter `noresolve.side`:inner "
"tbl<table> -> null\n"
"func group<table> by pipeline tbl<table> -> null\n"
"func window<table> rows:0..0 range:0..0 expanding:false rolling:0 pipeline "
"tbl<table> -> null\n"
"\n"
"func append<table> `default_db.bottom`<table> top<table> -> null\n"
"func intersect<table> `default_db.bottom`<table> top<table> -> (\n"
"    from t = _param.top\n"
"    join b = _param.bottom (all (map _eq (zip t.* b.*)))\n"
"    select t.*\n"
")\n"
"func remove<table> `default_db.bottom`<table> top<table> -> (\n"
"    from t = _param.top\n"
"    join side:left b = _param.bottom (all (map _eq (zip t.* b.*)))\n"
"    filter (all (map _is_null b.*))\n"
"    select t.*\n"
")\n"
"func loop<table> pipeline top<table> -> null\n"
"\n"
"# List functions\n"
"func all<bool> list<list> -> null\n"
"func map<list> fn list<list> -> null\n"
"func zip<list> a<list> b<list> -> null\n"
"func _eq<list> a<list> -> null\n"
"func _is_null a -> _param.a == null\n"
"\n"
"# Misc\n"
"func from_text<table> input<text> `noresolve.format`:csv -> null\n"
"\n"
"# String functions\n"
"func lower <text> column -> null\n"
"func upper <text> column -> null\n"
"\n"
"# type primitives\n"
"type int\n"
"type float\n"
"type bool\n"
"type text\n"
"type date\n"
"type time\n"
"type timestamp\n"
"type table\n"
"type column\n"
"type list\n"
"type scalar\n"
"\n"
"# Source-reading functions, primarily for DuckDB\n"
"func read_parquet<table> source<text> -> s\"SELECT * FROM "
"read_parquet({source})\"\n"
"func read_csv<table> source<text> -> s\"SELECT * FROM "
"read_csv_auto({source})\"\n"
"```"
msgstr ""

#: src/language-features/standard-library/index.md:117
msgid "And a couple of examples:"
msgstr ""

#: src/language-features/standard-library/index.md:119
msgid ""
"```prql\n"
"from employees\n"
"derive [\n"
"  gross_salary = (salary + payroll_tax | as int),\n"
"  gross_salary_rounded = (gross_salary | round 0),\n"
"  time = s\"NOW()\",  # an s-string, given no `now` function exists in PRQL\n"
"]\n"
"```"
msgstr ""
