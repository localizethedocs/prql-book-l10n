msgid ""
msgstr ""
"Project-Id-Version: PRQL language book\n"
"POT-Creation-Date: 2026-01-10T16:16:29Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/reference/stdlib/index.md:1
msgid "Standard library"
msgstr ""

#: src/reference/stdlib/index.md:3
msgid ""
"The standard library currently contains commonly used functions that are "
"used in SQL. It's not yet as broad as we'd like, and we're very open to "
"expanding it."
msgstr ""

#: src/reference/stdlib/index.md:6
msgid ""
"Currently s-strings are an escape-hatch for any function that isn't in our "
"standard library. If we find ourselves using them for something frequently, "
"raise an issue and we'll add it to the stdlib."
msgstr ""

#: src/reference/stdlib/index.md:10
msgid ""
"Here's the source of the current [PRQL `std`](https://github.com/PRQL/prql/"
"blob/main/crates/prql-compiler/src/semantic/std.prql):"
msgstr ""

#: src/reference/stdlib/index.md:13
msgid ""
"```admonish note\n"
"PRQL 0.9.0 has started supporting different DB implementations for standard "
"library functions.\n"
"The source is the [`std.sql`](https://github.com/PRQL/prql/blob/main/crates/"
"prql-compiler/src/sql/std.sql.prql).\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:18
msgid ""
"````prql no-eval\n"
"# The PRQL standard library defines the following functions and transforms.\n"
"# The definitions are whitespace insensitive, and have this form:\n"
"#\n"
"# ```\n"
"# let my_func = param1 param2 ...  -> <return_type> body_expr\n"
"# ```\n"
"#\n"
"# Where:\n"
"#   * `my_func` is the name of the function\n"
"#   * `param1` is the first parameter optionally followed by a type in "
"\"< ... >\"\n"
"#   * `param2` etc. follow the same pattern as param1\n"
"#   * `<return_type>` is the type of result wrapped in \"< ... >\"\n"
"#   * `body_expr` defines the function body that creates the result.\n"
"#     It can be PRQL code or `internal ...` to indicate internal compiler "
"code.\n"
"\n"
"# Operators\n"
"\n"
"let mul = left right -> <int || float> internal std.mul\n"
"let div_i = left right -> <int || float> internal std.div_i\n"
"let div_f = left right -> <int || float> internal std.div_f\n"
"let mod = left right -> <int || float> internal std.mod\n"
"let add = left<int || float || timestamp || date> right<int || float || "
"timestamp || date> -> <int || float || timestamp || date> internal std.add\n"
"let sub = left<int || float || timestamp || date> right<int || float || "
"timestamp || date> -> <int || float || timestamp || date> internal std.sub\n"
"let eq = left right -> <bool> internal std.eq\n"
"let ne = left right -> <bool> internal std.ne\n"
"let gt = left right -> <bool> internal std.gt\n"
"let lt = left right -> <bool> internal std.lt\n"
"let gte = left right -> <bool> internal std.gte\n"
"let lte = left right -> <bool> internal std.lte\n"
"let and = left<bool> right<bool> -> <bool> internal std.and\n"
"let or = left<bool> right<bool> -> <bool> internal std.or\n"
"let coalesce = left right -> internal std.coalesce\n"
"let regex_search = text pattern -> <bool> internal std.regex_search\n"
"\n"
"let neg = expr<int || float> -> <int || float> internal std.neg\n"
"let not = expr<bool> -> <bool> internal std.not\n"
"\n"
"# Types\n"
"\n"
"## Type primitives\n"
"type int\n"
"type float\n"
"type bool\n"
"type text\n"
"type date\n"
"type time\n"
"type timestamp\n"
"type `func`\n"
"\n"
"## Generic array\n"
"# TODO: an array of anything, not just nulls\n"
"type array = [null]\n"
"\n"
"## Scalar\n"
"type scalar = int || float || bool || text || date || time || timestamp || "
"null\n"
"type tuple_of_scalars = {scalar..}\n"
"\n"
"## Relation (an array of tuples)\n"
"type relation = [tuple_of_scalars]\n"
"\n"
"## Transform\n"
"type transform = (func relation -> relation)\n"
"\n"
"# Functions\n"
"\n"
"## Relational transforms\n"
"let from = func\n"
"  `default_db.source` <relation>\n"
"  -> <relation> internal from\n"
"\n"
"let select = func\n"
"  columns <scalar || tuple_of_scalars>\n"
"  tbl <relation>\n"
"  -> <relation> internal select\n"
"\n"
"let filter = func\n"
"  condition <bool>\n"
"  tbl <relation>\n"
"  -> <relation> internal filter\n"
"\n"
"let derive = func\n"
"  columns <scalar || tuple_of_scalars>\n"
"  tbl <relation>\n"
"  -> <relation> internal derive\n"
"\n"
"let aggregate = func\n"
"  columns <scalar || tuple_of_scalars>\n"
"  tbl <relation>\n"
"  -> <relation> internal aggregate\n"
"\n"
"let sort = func\n"
"  by <scalar || tuple_of_scalars>\n"
"  tbl <relation>\n"
"  -> <relation> internal sort\n"
"\n"
"let take = func\n"
"  expr <scalar>\n"
"  tbl <relation>\n"
"  -> <relation> internal take\n"
"\n"
"let join = func\n"
"  `default_db.with` <relation>\n"
"  condition <bool>\n"
"  `noresolve.side`:inner\n"
"  tbl <relation>\n"
"  -> <relation> internal join\n"
"\n"
"let group = func\n"
"  by<scalar || tuple_of_scalars>\n"
"  pipeline <transform>\n"
"  tbl <relation>\n"
"  -> <relation> internal group\n"
"\n"
"let window = func\n"
"  rows:0..0\n"
"  range:0..0\n"
"  expanding <bool>:false\n"
"  rolling <int>:0\n"
"  pipeline <transform>\n"
"  tbl <relation>\n"
"  -> <relation> internal window\n"
"\n"
"let append = `default_db.bottom`<relation> top<relation> -> <relation> "
"internal append\n"
"let intersect = `default_db.bottom`<relation> top<relation> -> <relation> (\n"
"  t = top\n"
"  join (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b.*)))\n"
"  select t.*\n"
")\n"
"let remove = `default_db.bottom`<relation> top<relation> -> <relation> (\n"
"  t = top\n"
"  join side:left (b = bottom) (tuple_every (tuple_map _eq (tuple_zip t.* b."
"*)))\n"
"  filter (tuple_every (tuple_map _is_null b.*))\n"
"  select t.*\n"
")\n"
"let loop = func\n"
"  pipeline <transform>\n"
"  top <relation>\n"
"  -> <relation> internal loop\n"
"\n"
"## Aggregate functions\n"
"# These return either a scalar when used within `aggregate`, or a column "
"when used anywhere else.\n"
"\n"
"let min = column <array> -> <int || float || null> internal std.min\n"
"\n"
"let max = column <array> -> <int || float || null> internal std.max\n"
"\n"
"let sum = column <array> -> <int || float> internal std.sum\n"
"\n"
"let average = column <array> -> <float || null> internal std.average\n"
"\n"
"let stddev = column <array> -> <float || null> internal std.stddev\n"
"\n"
"let every = column <array> -> <bool> internal std.every\n"
"\n"
"let any = column <array> -> <bool> internal std.any\n"
"\n"
"let concat_array = column <array> -> <text> internal std.concat_array\n"
"\n"
"# Counts number of items in the column.\n"
"# Note that the count will include null values.\n"
"let count = column<array> -> <int> internal std.count\n"
"\n"
"# Deprecated in favour of filterning input to the [std.count] function (not "
"yet implemented).\n"
"@{deprecated}\n"
"let count_distinct = column <array> -> internal std.count_distinct\n"
"\n"
"## Window functions\n"
"let lag =   offset <int>    column <array> -> internal std.lag\n"
"let lead =  offset <int>    column <array> -> internal std.lead\n"
"let first      = column <array> -> internal std.first\n"
"let last       = column <array> -> internal std.last\n"
"let rank       = column <array> -> internal std.rank\n"
"let rank_dense = column <array> -> internal std.rank_dense\n"
"let row_number = column <array> -> internal std.row_number\n"
"\n"
"## Misc functions\n"
"let round = n_digits column -> <scalar> internal std.round\n"
"let as = `noresolve.type` column -> <scalar> internal std.as\n"
"let in = pattern value -> <bool> internal in\n"
"\n"
"## Tuple functions\n"
"let tuple_every = func list -> <bool> internal tuple_every\n"
"let tuple_map = func fn <func> list -> internal tuple_map\n"
"let tuple_zip = func a b -> internal tuple_zip\n"
"let _eq = func a -> internal _eq\n"
"let _is_null = func a -> _param.a == null\n"
"\n"
"## Misc\n"
"let from_text = input<text> `noresolve.format`:csv -> <relation> internal "
"from_text\n"
"\n"
"## String functions\n"
"let lower = column -> <text> internal std.lower\n"
"let upper = column -> <text> internal std.upper\n"
"\n"
"## File-reading functions, primarily for DuckDB\n"
"let read_parquet = source<text> -> <relation> internal std.read_parquet\n"
"let read_csv = source<text> -> <relation> internal std.read_csv\n"
"````"
msgstr ""

#: src/reference/stdlib/index.md:218
msgid "And a couple of examples:"
msgstr ""

#: src/reference/stdlib/index.md:220
msgid ""
"```prql\n"
"from employees\n"
"derive {\n"
"  gross_salary = (salary + payroll_tax | as int),\n"
"  gross_salary_rounded = (gross_salary | round 0),\n"
"  time = s\"NOW()\",  # an s-string, given no `now` function exists in PRQL\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:229
msgid "Example of different implementations of division and integer division:"
msgstr ""

#: src/reference/stdlib/index.md:231
msgid ""
"```prql\n"
"prql target:sql.sqlite\n"
"\n"
"from [{x = 13, y = 5}]\n"
"select {\n"
"  quotient = x / y,\n"
"  int_quotient = x // y,\n"
"}\n"
"```"
msgstr ""

#: src/reference/stdlib/index.md:241
msgid ""
"```prql\n"
"prql target:sql.mysql\n"
"\n"
"from [{x = 13, y = 5}]\n"
"select {\n"
"  quotient = x / y,\n"
"  int_quotient = x // y,\n"
"}\n"
"```"
msgstr ""
